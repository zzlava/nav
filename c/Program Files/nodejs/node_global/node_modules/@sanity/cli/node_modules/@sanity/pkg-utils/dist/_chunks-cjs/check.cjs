"use strict";
var path = require("node:path"), esbuild = require("esbuild"), consoleSpy = require("./consoleSpy.cjs"), logger = require("./logger.cjs"), chalk = require("chalk"), treeify = require("treeify"), fs = require("node:fs"), prettyBytes = require("pretty-bytes");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), esbuild__default = /* @__PURE__ */ _interopDefaultCompat(esbuild), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), treeify__default = /* @__PURE__ */ _interopDefaultCompat(treeify), prettyBytes__default = /* @__PURE__ */ _interopDefaultCompat(prettyBytes);
function getFilesize(file) {
  const stats = fs.statSync(file);
  return prettyBytes__default.default(stats.size);
}
function getFileInfo(cwd, filePath) {
  const p = path__default.default.resolve(cwd, filePath), exists = logger.fileExists(p), size = exists ? getFilesize(p) : void 0;
  return { exists, size };
}
function printPackageTree(ctx) {
  const { cwd, exports: exports2, logger: logger2, pkg } = ctx;
  if (!exports2) return;
  logger2.log(`${chalk__default.default.blue(pkg.name)}@${chalk__default.default.green(pkg.version)}`);
  const tree = {};
  pkg.type && (tree.type = chalk__default.default.yellow(pkg.type)), pkg.bin && (tree.bin = Object.fromEntries(
    Object.entries(pkg.bin).map(([name, file]) => [chalk__default.default.cyan(name), fileInfo(file)])
  ));
  function fileInfo(file) {
    const info = getFileInfo(cwd, file);
    return info.size ? `${chalk__default.default.yellow(file)} ${chalk__default.default.gray(info.size)}` : `${chalk__default.default.gray(file)} ${chalk__default.default.red("does not exist")}`;
  }
  tree.exports = Object.fromEntries(
    Object.entries(exports2).filter(([, entry]) => entry._exported).map(([exportPath, entry]) => {
      const exp = {
        source: fileInfo(entry.source),
        browser: void 0,
        require: void 0,
        node: void 0,
        import: void 0,
        default: fileInfo(entry.default)
      };
      return entry.browser ? (exp.browser = { source: fileInfo(entry.browser.source) }, entry.browser.import && (exp.browser.import = fileInfo(entry.browser.import)), entry.browser.require && (exp.browser.require = fileInfo(entry.browser.require))) : delete exp.browser, entry.require ? exp.require = fileInfo(entry.require) : delete exp.require, entry.node ? (exp.node = {}, entry.node.source && (exp.node.source = fileInfo(entry.node.source)), entry.node.import && (exp.node.import = fileInfo(entry.node.import)), entry.node.require && (exp.node.require = fileInfo(entry.node.require))) : delete exp.node, entry.import ? exp.import = fileInfo(entry.import) : delete exp.import, [chalk__default.default.cyan(path__default.default.join(pkg.name, exportPath)), exp];
    })
  ), logger2.log(treeify__default.default.asTree(tree, !0, !0));
}
async function check(options) {
  const { cwd, strict = !1, tsconfig: tsconfigOption } = options, logger$1 = logger.createLogger(), config = await consoleSpy.loadConfig({ cwd }), legacyExports = config?.legacyExports ?? !1, pkg = await consoleSpy.loadPkgWithReporting({ cwd, logger: logger$1, strict, legacyExports }), tsconfig = tsconfigOption || config?.tsconfig || "tsconfig.json", ctx = await consoleSpy.resolveBuildContext({ config, cwd, logger: logger$1, pkg, strict, tsconfig });
  if (printPackageTree(ctx), strict) {
    const missingFiles = [];
    for (const [, exp] of Object.entries(ctx.exports || {}))
      exp.source && !logger.fileExists(path__default.default.resolve(cwd, exp.source)) && missingFiles.push(exp.source), exp.require && !logger.fileExists(path__default.default.resolve(cwd, exp.require)) && missingFiles.push(exp.require), exp.import && !logger.fileExists(path__default.default.resolve(cwd, exp.import)) && missingFiles.push(exp.import);
    ctx.pkg.types && !logger.fileExists(path__default.default.resolve(cwd, ctx.pkg.types)) && missingFiles.push(ctx.pkg.types), missingFiles.length && (logger$1.error(`missing files: ${missingFiles.join(", ")}`), process.exit(1));
    const exportPaths = {
      require: [],
      import: []
    };
    for (const exp of Object.values(ctx.exports || {}))
      exp._exported && (exp.require && exportPaths.require.push(exp.require), exp.import && exportPaths.import.push(exp.import));
    const external = [
      ...Object.keys(pkg.dependencies || {}),
      ...Object.keys(pkg.devDependencies || {})
    ], consoleSpy$1 = consoleSpy.createConsoleSpy();
    exportPaths.import.length && checkExports(exportPaths.import, { cwd, external, format: "esm", logger: logger$1 }), exportPaths.require.length && checkExports(exportPaths.require, { cwd, external, format: "cjs", logger: logger$1 }), consoleSpy$1.restore();
  }
}
async function checkExports(exportPaths, options) {
  const { cwd, external, format, logger: logger2 } = options, code = exportPaths.map((id) => format ? `import('${id}');` : `require('${id}');`).join(`
`);
  try {
    const esbuildResult = await esbuild__default.default.build({
      bundle: !0,
      external,
      format,
      logLevel: "silent",
      // otherwise output maps to stdout as we're using stdin
      outfile: "/dev/null",
      platform: "node",
      stdin: {
        contents: code,
        loader: "js",
        resolveDir: cwd
      }
    });
    if (esbuildResult.errors.length > 0) {
      for (const msg of esbuildResult.errors)
        printEsbuildMessage(logger2.warn, msg), logger2.log();
      process.exit(1);
    }
    const esbuildWarnings = esbuildResult.warnings.filter((msg) => {
      (msg.detail || msg.text).includes("does not affect esbuild's own target setting");
    });
    for (const msg of esbuildWarnings)
      printEsbuildMessage(logger2.warn, msg), logger2.log();
  } catch (err) {
    if (isEsbuildFailure(err)) {
      const { errors } = err;
      for (const msg of errors)
        printEsbuildMessage(logger2.error, msg), logger2.log();
    } else err instanceof Error ? (logger2.error(err.stack || err.message), logger2.log()) : (logger2.error(`${err}`), logger2.log());
    process.exit(1);
  }
}
function printEsbuildMessage(log, msg) {
  msg.location ? log(
    [
      `${msg.detail || msg.text}
`,
      `${msg.location.line} | ${msg.location.lineText}
`,
      `in ./${msg.location.file}:${msg.location.line}:${msg.location.column}`
    ].join("")
  ) : log(msg.detail || msg.text);
}
function isEsbuildFailure(err) {
  return err instanceof Error && "errors" in err && Array.isArray(err.errors) && err.errors.every(isEsbuildMessage) && "warnings" in err && Array.isArray(err.warnings) && err.warnings.every(isEsbuildMessage);
}
function isEsbuildMessage(msg) {
  return typeof msg == "object" && msg !== null && "text" in msg && typeof msg.text == "string" && "location" in msg && (msg.location === null || typeof msg.location == "object");
}
exports.check = check;
//# sourceMappingURL=check.cjs.map
