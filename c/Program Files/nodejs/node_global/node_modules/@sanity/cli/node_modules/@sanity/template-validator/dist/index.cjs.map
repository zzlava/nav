{"version":3,"file":"index.cjs","sources":["../src/validator.ts"],"sourcesContent":["import {parse as parseYaml} from 'yaml'\n\nimport type {ValidationResult} from './types'\n\n/** @public */\nexport const REQUIRED_ENV_VAR = {\n  PROJECT_ID: /SANITY(?:_STUDIO)?_PROJECT_ID/,\n  DATASET: /SANITY(?:_STUDIO)?_DATASET/,\n} as const\n\n/** @public */\nexport const ENV_FILE = {\n  TEMPLATE: '.env.template',\n  EXAMPLE: '.env.example',\n  LOCAL_EXAMPLE: '.env.local.example',\n  LOCAL_TEMPLATE: '.env.local.template',\n} as const\n\n/** @public */\nexport const ENV_TEMPLATE_FILES = [\n  ENV_FILE.TEMPLATE,\n  ENV_FILE.EXAMPLE,\n  ENV_FILE.LOCAL_EXAMPLE,\n  ENV_FILE.LOCAL_TEMPLATE,\n] as const\n\n/** @public */\nexport async function getMonoRepo(\n  baseUrl: string,\n  headers: Record<string, string> = {},\n): Promise<string[] | undefined> {\n  const handlers = {\n    'package.json': {\n      check: (content: string) => {\n        try {\n          const pkg = JSON.parse(content)\n          if (!pkg.workspaces) return undefined\n          return Array.isArray(pkg.workspaces) ? pkg.workspaces : pkg.workspaces.packages\n        } catch {\n          return undefined\n        }\n      },\n    },\n    'pnpm-workspace.yaml': {\n      check: (content: string) => {\n        try {\n          const config = parseYaml(content)\n          return config.packages\n        } catch {\n          return undefined\n        }\n      },\n    },\n    'lerna.json': {\n      check: (content: string) => {\n        try {\n          const config = JSON.parse(content)\n          return config.packages\n        } catch {\n          return undefined\n        }\n      },\n    },\n    'rush.json': {\n      check: (content: string) => {\n        try {\n          const config = JSON.parse(content)\n          return config.projects?.map((p: {packageName: string}) => p.packageName)\n        } catch {\n          return undefined\n        }\n      },\n    },\n  } as const\n\n  const fileChecks = await Promise.all(\n    Object.keys(handlers).map(async (file) => {\n      const response = await fetch(`${baseUrl}/${file}`, {headers})\n      return {file, exists: response.status === 200, content: await response.text()}\n    }),\n  )\n\n  for (const check of fileChecks) {\n    if (!check.exists) continue\n    const result = handlers[check.file as keyof typeof handlers].check(check.content)\n    if (result) return result\n  }\n\n  return undefined\n}\n\nasync function validatePackage(\n  baseUrl: string,\n  packagePath: string,\n  headers: Record<string, string>,\n): Promise<{\n  hasSanityConfig: boolean\n  hasSanityCli: boolean\n  hasEnvFile: boolean\n  hasSanityDep: boolean\n  errors: string[]\n}> {\n  const errors: string[] = []\n  const packageUrl = packagePath ? `${baseUrl}/${packagePath}` : baseUrl\n\n  const requiredFiles = [\n    'package.json',\n    'sanity.config.ts',\n    'sanity.config.js',\n    'sanity.cli.ts',\n    'sanity.cli.js',\n    ...ENV_TEMPLATE_FILES,\n  ]\n\n  const fileChecks = await Promise.all(\n    requiredFiles.map(async (file) => {\n      const response = await fetch(`${packageUrl}/${file}`, {headers})\n      return {file, exists: response.status === 200, content: await response.text()}\n    }),\n  )\n\n  const packageJson = fileChecks.find((f) => f.file === 'package.json')\n  if (!packageJson?.exists) {\n    errors.push(`Package at ${packagePath || 'root'} must include a package.json file`)\n  }\n\n  let hasSanityDep = false\n  if (packageJson?.exists) {\n    try {\n      const pkg = JSON.parse(packageJson.content)\n      hasSanityDep = !!(pkg.dependencies?.sanity || pkg.devDependencies?.sanity)\n    } catch {\n      errors.push(`Invalid package.json file in ${packagePath || 'root'}`)\n    }\n  }\n\n  const hasSanityConfig = fileChecks.some(\n    (f) => f.exists && (f.file === 'sanity.config.ts' || f.file === 'sanity.config.js'),\n  )\n\n  const hasSanityCli = fileChecks.some(\n    (f) => f.exists && (f.file === 'sanity.cli.ts' || f.file === 'sanity.cli.js'),\n  )\n\n  const envFile = fileChecks.find(\n    (f) => f.exists && ENV_TEMPLATE_FILES.includes(f.file as (typeof ENV_TEMPLATE_FILES)[number]),\n  )\n\n  if (envFile) {\n    const envContent = envFile.content\n    const hasProjectId = envContent.match(REQUIRED_ENV_VAR.PROJECT_ID)\n    const hasDataset = envContent.match(REQUIRED_ENV_VAR.DATASET)\n\n    if (!hasProjectId || !hasDataset) {\n      const missing = []\n      if (!hasProjectId) missing.push('SANITY_PROJECT_ID or SANITY_STUDIO_PROJECT_ID')\n      if (!hasDataset) missing.push('SANITY_DATASET or SANITY_STUDIO_DATASET')\n      errors.push(\n        `Environment template in ${\n          packagePath || 'repo'\n        } must include the following variables: ${missing.join(', ')}`,\n      )\n    }\n  }\n\n  return {\n    hasSanityConfig,\n    hasSanityCli,\n    hasEnvFile: Boolean(envFile),\n    hasSanityDep,\n    errors,\n  }\n}\n\n/** @public */\nexport async function validateSanityTemplate(\n  baseUrl: string,\n  packages: string[] = [''],\n  headers: Record<string, string> = {},\n): Promise<ValidationResult> {\n  const errors: string[] = []\n  const validations = await Promise.all(\n    packages.map((pkg) => validatePackage(baseUrl, pkg, headers)),\n  )\n\n  // Collect all package-level errors\n  validations.forEach((v) => errors.push(...v.errors))\n\n  const hasSanityDep = validations.some((v) => v.hasSanityDep)\n  if (!hasSanityDep) {\n    errors.push('At least one package must include \"sanity\" as a dependency in package.json')\n  }\n\n  const hasSanityConfig = validations.some((v) => v.hasSanityConfig)\n  if (!hasSanityConfig) {\n    errors.push('At least one package must include a sanity.config.js or sanity.config.ts file')\n  }\n\n  const hasSanityCli = validations.some((v) => v.hasSanityCli)\n  if (!hasSanityCli) {\n    errors.push('At least one package must include a sanity.cli.js or sanity.cli.ts file')\n  }\n\n  const missingEnvPackages = packages.filter((_, i) => !validations[i].hasEnvFile)\n  if (missingEnvPackages.length > 0) {\n    errors.push(\n      `The following packages are missing .env.template, .env.example, or .env.local.example files: ${missingEnvPackages.join(\n        ', ',\n      )}`,\n    )\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  }\n}\n"],"names":["parseYaml"],"mappings":"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"}