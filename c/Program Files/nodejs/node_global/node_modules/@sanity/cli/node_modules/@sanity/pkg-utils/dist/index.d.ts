import type {ExtractorMessage} from '@microsoft/api-extractor'
import type {IExtractorMessagesConfig} from '@microsoft/api-extractor'
import type {NormalizedOutputOptions} from 'rollup'
import type {Observable} from 'rxjs'
import type {OptimizeLodashOptions} from '@optimize-lodash/rollup-plugin'
import type {PluginItem} from '@babel/core'
import type {Plugin as RollupPlugin} from 'rollup'
import {RollupWatcherEvent} from 'rollup'
import type {TreeshakingOptions} from 'rollup'
import ts from 'typescript'
import {z} from 'zod'

/**
 * Build the distribution files of a npm package.
 *
 * @example
 * ```ts
 * import {build} from '@sanity/pkg-utils'
 *
 * build({
 *   cwd: process.cwd(),
 *   tsconfig: 'tsconfig.dist.json,
 * }).then(() => {
 *   console.log('successfully built')
 * }).catch((err) => {
 *   console.log(`build error: ${err.message}`)
 * })
 * ```
 *
 * @public
 */
export declare function build(options: {
  cwd: string
  emitDeclarationOnly?: boolean
  strict?: boolean
  tsconfig?: string
  clean?: boolean
}): Promise<void>

/** @internal */
export declare interface BuildContext {
  config?: PkgConfigOptions
  cwd: string
  distPath: string
  emitDeclarationOnly: boolean
  exports: PkgExports | undefined
  external: string[]
  bundledPackages: string[]
  files: BuildFile[]
  logger: Logger
  pkg: PackageJSON
  runtime: PkgRuntime
  strict: boolean
  target: Record<PkgRuntime, string[]>
  ts: {
    config?: ts.ParsedCommandLine
    configPath?: string
  }
}

/** @internal */
export declare interface BuildFile {
  type: 'asset' | 'chunk' | 'types'
  path: string
}

/** @internal */
export declare type BuildTask = DtsTask | RollupTask | RollupLegacyTask | RollupReactCompilerTask

/** @internal */
export declare interface BuildTaskHandlers {
  'build:dts': TaskHandler<DtsTask, DtsResult>
  'build:js': TaskHandler<RollupTask>
  'build:react-compiler': TaskHandler<RollupReactCompilerTask>
  'build:legacy': TaskHandler<RollupLegacyTask>
}

/** @internal */
export declare const buildTaskHandlers: BuildTaskHandlers

/** @public */
export declare function check(options: {
  cwd: string
  strict?: boolean
  tsconfig?: string
}): Promise<void>

/** @internal */
export declare function createFromTemplate(options: {
  cwd: string
  logger: Logger
  packagePath: string
  template: PkgTemplate
}): Promise<void>

/** @internal */
export declare function createLogger(): Logger

/** @public */
export declare const DEFAULT_BROWSERSLIST_QUERY: string[]

/** @public */
export declare function defineConfig<const T extends PkgConfigOptions>(configOptions: T): T

/** @public */
export declare function defineTemplateOption<T>(option: PkgTemplateOption<T>): PkgTemplateOption<T>

/** @internal */
export declare interface DtsResult {
  type: 'dts'
  messages: ExtractorMessage[]
  results: {
    sourcePath: string
    filePaths: string[]
  }[]
}

/** @internal */
export declare interface DtsTask {
  type: 'build:dts'
  entries: {
    exportPath: string
    importId: string
    sourcePath: string
    targetPaths: string[]
  }[]
}

/** @internal */
export declare const dtsTask: TaskHandler<DtsTask, DtsResult>

/** @internal */
export declare interface DtsWatchTask {
  type: 'watch:dts'
  entries: {
    exportPath: string
    importId: string
    sourcePath: string
    targetPaths: string[]
  }[]
}

/** @internal */
export declare const dtsWatchTask: TaskHandler<DtsWatchTask, DtsResult>

/** @internal */
export declare function getExtractMessagesConfig(options: {
  rules: NonNullable<PkgConfigOptions['extract']>['rules']
}): IExtractorMessagesConfig

/**
 * @public
 */
export declare type InferredStrictOptions = z.infer<typeof strictOptions>

/** @public */
export declare function init(options: {cwd: string; path: string}): Promise<void>

/** @internal */
export declare function isRecord(value: unknown): value is Record<string, unknown>

/** @internal */
export declare function loadConfig(options: {cwd: string}): Promise<PkgConfigOptions | undefined>

/** @internal */
export declare function loadPkg(options: {cwd: string}): Promise<PackageJSON>

/** @internal */
export declare function loadPkgWithReporting(options: {
  cwd: string
  logger: Logger
  strict: boolean
  legacyExports: boolean
}): Promise<PackageJSON>

/** @internal */
export declare function loadTSConfig(options: {
  cwd: string
  tsconfigPath: string
}): Promise<ts.ParsedCommandLine | undefined>

/** @internal */
export declare interface Logger {
  log: (...args: unknown[]) => void
  info: (...args: unknown[]) => void
  warn: (...args: unknown[]) => void
  error: (...args: unknown[]) => void
  success: (...args: unknown[]) => void
}

/** @internal */
export declare interface PackageJSON {
  type?: 'commonjs' | 'module'
  version: string
  private?: boolean
  author?:
    | string
    | {
        name: string
        email?: string
        url?: string
      }
  name: string
  description?: string
  keywords?: string[]
  bin?: Record<string, string>
  dependencies?: Record<string, string | undefined>
  devDependencies?: Record<string, string | undefined>
  peerDependencies?: Record<string, string | undefined>
  exports?: Record<
    string,
    | `./${string}.json`
    | `./${string}.css`
    | {
        source?: string
        types?: string
        browser?: {
          source: string
          import?: string
          require?: string
        }
        node?: {
          source?: string
          module?: string
          import?: string
          require?: string
        }
        module?: string
        import?: string
        require?: string
        default: string
      }
    | {
        types?: string
        svelte: string
        default?: string
      }
  >
  main?: string
  browser?: Record<string, string>
  source?: string
  module?: string
  types?: string
  files?: string[]
  scripts?: Record<string, string | undefined>
  browserslist?: string | string[]
  sideEffects?: boolean | string[]
  engines?: {
    node?: string
    npm?: string
  }
  repository?:
    | string
    | {
        type: 'git'
        url: string
      }
  bugs?:
    | string
    | {
        url: string
        email?: string
      }
  homepage?: string
  license?: string
}

/** @internal */
export declare function parseExports(options: {
  cwd: string
  pkg: PackageJSON
  strict: boolean
  strictOptions: InferredStrictOptions
  legacyExports: boolean
  logger: Logger
}): (PkgExport & {
  _path: string
})[]

/** @internal */
export declare function parseStrictOptions(input: unknown): InferredStrictOptions

/** @public */
export declare interface PkgBundle {
  source: string
  import?: string
  require?: string
  runtime?: PkgRuntime
}

/** @public */
export declare interface PkgConfigOptions {
  /** @alpha */
  babel?: {
    plugins?: PluginItem[] | null | undefined
    /** @alpha */
    reactCompiler?: boolean
  }
  /**
   * Configure the React Compiler.
   * To enable it, either:
   * - set `babel.reactCompiler` to `true`
   * - add a `react-compiler` export condition,  before any `browser`, `require` or `import` conditions. After any `react-server` and `node` conditions
   * @alpha */
  reactCompilerOptions?: ReactCompilerOptions
  bundles?: PkgBundle[]
  /** @alpha */
  define?: Record<string, string | number | boolean | undefined | null>
  /**
   * Directory of distributed & bundled files.
   */
  dist?: string
  exports?: PkgConfigProperty<PkgExports>
  extract?: {
    /**
     * Packages in `devDependencies` that are not in `external` are automatically added to the `bundledPackages` config.
     * You can exclude a package from being bundled by using a callback:
     * ```
     * bundledPackages: (prev) => prev.filter(package => package !== 'sanity')
     * ```
     */
    bundledPackages?: PkgConfigProperty<string[]>
    customTags?: TSDocCustomTag[]
    rules?: {
      'ae-forgotten-export'?: PkgRuleLevel
      'ae-incompatible-release-tags'?: PkgRuleLevel
      'ae-internal-missing-underscore'?: PkgRuleLevel
      'ae-missing-release-tag'?: PkgRuleLevel
      'tsdoc-link-tag-unescaped-text'?: PkgRuleLevel
      'tsdoc-undefined-tag'?: PkgRuleLevel
      'tsdoc-unsupported-tag'?: PkgRuleLevel
    }
  }
  /**
   * Packages to exclude from bundles.
   * Provide an array to merge with default exclusions, use a function to replace them:
   * ```
   * exclude: (prev) => prev.filter(package => package !== 'foo')
   * ```
   */
  external?: PkgConfigProperty<string[]>
  /**
   * Defaults to `"automatic"`
   */
  jsx?: 'transform' | 'preserve' | 'automatic'
  /**
   * Defaults to `"createElement"`
   */
  jsxFactory?: string
  /**
   * Defaults to `"Fragment"`
   */
  jsxFragment?: string
  /**
   * Defaults to `"react"`
   */
  jsxImportSource?: string
  /**
   * Build package with support for legacy exports (writes root `<export>.js` files)
   */
  legacyExports?: boolean
  minify?: boolean
  /** @alpha */
  rollup?: {
    plugins?: PkgConfigProperty<RollupPlugin[]>
    output?: Partial<NormalizedOutputOptions>
    /**
     * Default options are `preset: 'recommended'` and `propertyReadSideEffects: false`
     * @alpha
     */
    treeshake?: TreeshakingOptions
    /** @alpha */
    experimentalLogSideEffects?: boolean
    /**
     * Adds [hash] to chunk filenames, generally only useful if `@sanity/pkg-utils` is used to deploy a package directly to a CDN.
     * It's not needed when publishing to npm for consumption by other libraries, bundlers and frameworks.
     * @defaultValue false
     */
    hashChunkFileNames?: boolean
    /**
     * Optimizes lodash imports using `@optimize-lodash/rollup-plugin` when set to `true`.
     * It's enabled if `lodash` is found in `dependencies` or `peerDependencies`.
     * It will use `lodash-es` for ESM targets if found in `dependencies` or `peerDependencies`.
     * @defaultValue true
     * @alpha
     */
    optimizeLodash?: boolean | OptimizeLodashOptions
  }
  /**
   * Default runtime of package exports
   */
  runtime?: PkgRuntime
  sourcemap?: boolean
  /**
   * Directory of source files.
   */
  src?: string
  tsconfig?: string
  /**
   * Configure what checks are made when running `--strict` builds and checks
   */
  strictOptions?: StrictOptions
}

/** @public */
export declare type PkgConfigProperty<T> = PkgConfigPropertyResolver<T> | T

/** @public */
export declare type PkgConfigPropertyResolver<T> = (prev: T) => T

/** @public */
export declare interface PkgExport {
  /** @internal */
  '_exported'?: boolean
  'browser'?: {
    source: string
    import?: string
    require?: string
  }
  'react-compiler'?: {
    source?: string
    default: string
  }
  'node'?: {
    source?: string
    import?: string
    require?: string
  }
  'types'?: string
  'source': string
  'import'?: string
  'require'?: string
  'default': string
}

/** @public */
export declare interface PkgExports {
  [path: string]: PkgExport
}

/** @internal */
export declare interface PkgExtMap {
  commonjs: {
    commonjs: string
    esm: string
  }
  module: {
    commonjs: string
    esm: string
  }
  legacy: string
}

/** @internal */
export declare const pkgExtMap: {
  commonjs: {
    commonjs: '.js'
    esm: '.mjs'
  }
  module: {
    commonjs: '.cjs'
    esm: '.js'
  }
  legacy: '.esm.js'
}

/** @public */
export declare type PkgFormat = 'commonjs' | 'esm'

/** @public */
export declare type PkgRuleLevel = 'error' | 'warn' | 'info' | 'off'

/** @public */
export declare type PkgRuntime = '*' | 'browser' | 'node'

/** @public */
export declare type PkgTemplate = PkgTemplateDefinition | PkgTemplateResolver

/** @public */
export declare interface PkgTemplateDefinition {
  options: PkgTemplateStringOption<any>[]
  features: {
    name: string
    optional: boolean
    initial: boolean
  }[]
  getFiles: (
    options: Record<string, any>,
    features: Record<string, boolean>,
  ) => Promise<PkgTemplateFile[]>
}

/** @public */
export declare interface PkgTemplateFile {
  name: string
  contents: string
}

/** @public */
export declare type PkgTemplateOption<T = string> = PkgTemplateStringOption<T>

/** @public */
export declare type PkgTemplateResolver = (options: {
  cwd: string
  /** @internal */
  logger: Logger
  packagePath: string
}) => PkgTemplateDefinition | Promise<PkgTemplateDefinition>

/** @public */
export declare interface PkgTemplateStringOption<T = string> {
  name: string
  type: 'string'
  description: string
  initial?: T | ((options: Record<string, any>) => T)
  parse?: (v: string) => T | null
  validate?: (v: string) => string | true
}

/**
 * @alpha
 */
export declare type ReactCompilerLogger = {
  logEvent: (filename: string | null, event: ReactCompilerLoggerEvent) => void
}

/**
 * @alpha
 * Represents 'events' that may occur during compilation. Events are only
 * recorded when a logger is set (through the config).
 * These are the different types of events:
 * CompileError:
 *   Forget skipped compilation of a function / file due to a known todo,
 *   invalid input, or compiler invariant being broken.
 * CompileSuccess:
 *   Forget successfully compiled a function.
 * PipelineError:
 *   Unexpected errors that occurred during compilation (e.g. failures in
 *   babel or other unhandled exceptions).
 */
export declare type ReactCompilerLoggerEvent =
  | {
      kind: 'CompileError'
      fnLoc: unknown
      detail: unknown
    }
  | {
      kind: 'CompileDiagnostic'
      fnLoc: unknown
      detail: unknown
    }
  | {
      kind: 'CompileSuccess'
      fnLoc: unknown
      fnName: string | null
      memoSlots: number
      memoBlocks: number
      memoValues: number
      prunedMemoBlocks: number
      prunedMemoValues: number
    }
  | {
      kind: 'PipelineError'
      fnLoc: unknown
      data: string
    }

/**
 * Until these types are on npm: https://github.com/facebook/react/blob/0bc30748730063e561d87a24a4617526fdd38349/compiler/packages/babel-plugin-react-compiler/src/Entrypoint/Options.ts#L39-L122
 * @alpha
 */
export declare interface ReactCompilerOptions {
  logger?: ReactCompilerLogger | null
  panicThreshold?: 'ALL_ERRORS' | 'CRITICAL_ERRORS' | 'NONE'
  compilationMode?: 'infer' | 'syntax' | 'annotation' | 'all'
  runtimeModule?: string | null | undefined
  /**
   * By default React Compiler will skip compilation of code that suppresses the default
   * React ESLint rules, since this is a strong indication that the code may be breaking React rules
   * in some way.
   *
   * Use eslintSuppressionRules to pass a custom set of rule names: any code which suppresses the
   * provided rules will skip compilation. To disable this feature (never bailout of compilation
   * even if the default ESLint is suppressed), pass an empty array.
   */
  eslintSuppressionRules?: Array<string> | null | undefined
  sources?: Array<string> | ((filename: string) => boolean) | null
  /**
   * The minimum major version of React that the compiler should emit code for. If the target is 19
   * or higher, the compiler emits direct imports of React runtime APIs needed by the compiler. On
   * versions prior to 19, an extra runtime package react-compiler-runtime is necessary to provide
   * a userspace approximation of runtime APIs.
   */
  target: '17' | '18' | '19'
}

/** @internal */
export declare function resolveBuildTasks(ctx: BuildContext): BuildTask[]

/** @internal */
export declare function resolveConfigProperty<T>(
  prop: PkgConfigProperty<T> | undefined,
  initialValue: T,
): T

/** @internal */
export declare interface RollupLegacyTask {
  type: 'build:legacy'
  buildId: string
  entries: RollupTaskEntry[]
  runtime: PkgRuntime
  format: 'esm'
  target: string[]
}

/** @internal */
export declare const rollupLegacyTask: TaskHandler<RollupLegacyTask>

export {RollupPlugin}

/** @internal */
export declare interface RollupReactCompilerTask {
  type: 'build:react-compiler'
  entries: RollupTaskEntry[]
  runtime: 'browser'
  format: 'esm'
  target: string[]
}

/** @internal */
export declare const rollupReactCompilerTask: TaskHandler<RollupReactCompilerTask>

/** @internal */
export declare interface RollupTask {
  type: 'build:js'
  buildId: string
  entries: RollupTaskEntry[]
  runtime: PkgRuntime
  format: 'commonjs' | 'esm'
  target: string[]
}

/** @internal */
export declare const rollupTask: TaskHandler<RollupTask>

/** @internal */
export declare interface RollupTaskEntry {
  path: string
  source: string
  output: string
}

/** @internal */
export declare interface RollupWatchTask {
  type: 'watch:js'
  buildId: string
  entries: RollupTaskEntry[]
  runtime: PkgRuntime
  format: 'commonjs' | 'esm'
  target: string[]
}

/** @internal */
export declare const rollupWatchTask: TaskHandler<RollupWatchTask, RollupWatcherEvent>

/**
 * @public
 */
export declare interface StrictOptions {
  /**
   * Disallows a top level `typings` field in `package.json` if it is equal to `exports['.'].source`.
   * @defaultValue 'error'
   */
  noPackageJsonTypings?: ToggleType
  /**
   * Requires specifying `sideEffects` in `package.json`.
   * @defaultValue 'warn'
   */
  noImplicitSideEffects?: ToggleType
  /**
   * Requires specifying `browserslist` in `package.json`, instead of relying on it implicitly being:
   * @example
   * ```
   * "browserslist": "extends @sanity/browserslist-config"
   * ```
   * @defaultValue 'warn'
   */
  noImplicitBrowsersList?: ToggleType
  /**
   * If typescript is used then `types` in `package.json` should be specified for npm listings to show the TS icon.
   * @defaultValue 'error'
   */
  alwaysPackageJsonTypes?: ToggleType
  /**
   * A lot of analysis tooling requiers the `main` field to work (like bundlephobia) and so it's best practice to always include it
   * @defaultValue 'error'
   */
  alwaysPackageJsonMain?: ToggleType
  /**
   * Using `.npmignore` is error prone, it's best practice to always declare `files` instead
   * @defaultValue 'error'
   */
  alwaysPackageJsonFiles?: ToggleType
}

/**
 * @public
 */
export declare const strictOptions: z.ZodObject<
  {
    noPackageJsonTypings: z.ZodDefault<
      z.ZodUnion<[z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]>
    >
    noImplicitSideEffects: z.ZodDefault<
      z.ZodUnion<[z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]>
    >
    noImplicitBrowsersList: z.ZodDefault<
      z.ZodUnion<[z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]>
    >
    alwaysPackageJsonTypes: z.ZodDefault<
      z.ZodUnion<[z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]>
    >
    alwaysPackageJsonMain: z.ZodDefault<
      z.ZodUnion<[z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]>
    >
    alwaysPackageJsonFiles: z.ZodDefault<
      z.ZodUnion<[z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]>
    >
  },
  'strict',
  z.ZodTypeAny,
  {
    noPackageJsonTypings: 'error' | 'warn' | 'off'
    noImplicitSideEffects: 'error' | 'warn' | 'off'
    noImplicitBrowsersList: 'error' | 'warn' | 'off'
    alwaysPackageJsonTypes: 'error' | 'warn' | 'off'
    alwaysPackageJsonMain: 'error' | 'warn' | 'off'
    alwaysPackageJsonFiles: 'error' | 'warn' | 'off'
  },
  {
    noPackageJsonTypings?: 'error' | 'warn' | 'off' | undefined
    noImplicitSideEffects?: 'error' | 'warn' | 'off' | undefined
    noImplicitBrowsersList?: 'error' | 'warn' | 'off' | undefined
    alwaysPackageJsonTypes?: 'error' | 'warn' | 'off' | undefined
    alwaysPackageJsonMain?: 'error' | 'warn' | 'off' | undefined
    alwaysPackageJsonFiles?: 'error' | 'warn' | 'off' | undefined
  }
>

/** @internal */
export declare type TaskHandler<Task, Result = void> = {
  name: (ctx: BuildContext, task: Task) => string
  exec: (ctx: BuildContext, task: Task) => Observable<Result>
  complete: (ctx: BuildContext, task: Task, result: Result) => void
  error: (ctx: BuildContext, task: Task, error: unknown) => void
}

/**
 * @public
 */
export declare const toggle: z.ZodUnion<
  [z.ZodLiteral<'error'>, z.ZodLiteral<'warn'>, z.ZodLiteral<'off'>]
>

/**
 * @public
 */
export declare type ToggleType = z.infer<typeof toggle>

/** @public */
export declare interface TSDocCustomTag {
  name: string
  syntaxKind: 'block' | 'modifier'
  allowMultiple?: boolean
}

/** @public */
export declare function watch(options: {
  cwd: string
  strict?: boolean
  tsconfig?: string
}): Promise<void>

/** @internal */
export declare type WatchTask = DtsWatchTask | RollupWatchTask

/** @internal */
export declare interface WatchTaskHandlers {
  'watch:dts': TaskHandler<DtsWatchTask, DtsResult>
  'watch:js': TaskHandler<RollupWatchTask, RollupWatcherEvent>
}

/** @internal */
export declare const watchTaskHandlers: WatchTaskHandlers

export {}
