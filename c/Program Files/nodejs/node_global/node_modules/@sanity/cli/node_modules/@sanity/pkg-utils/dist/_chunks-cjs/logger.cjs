"use strict";
var fs = require("node:fs"), zod = require("zod"), chalk = require("chalk");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk);
function fileExists(filePath) {
  try {
    return fs.statSync(filePath), !0;
  } catch {
    return !1;
  }
}
function isRecord(value) {
  return !!value && !Array.isArray(value) && typeof value == "object";
}
const pkgSchema = zod.z.object({
  type: zod.z.optional(zod.z.enum(["commonjs", "module"])),
  name: zod.z.string(),
  version: zod.z.string(),
  license: zod.z.string(),
  bin: zod.z.optional(zod.z.record(zod.z.string())),
  dependencies: zod.z.optional(zod.z.record(zod.z.string())),
  devDependencies: zod.z.optional(zod.z.record(zod.z.string())),
  peerDependencies: zod.z.optional(zod.z.record(zod.z.string())),
  source: zod.z.optional(zod.z.string()),
  main: zod.z.optional(zod.z.string()),
  browser: zod.z.optional(zod.z.record(zod.z.string())),
  module: zod.z.optional(zod.z.string()),
  types: zod.z.optional(zod.z.string()),
  exports: zod.z.optional(
    zod.z.record(
      zod.z.union([
        zod.z.custom((val) => /^\.\/.*\.json$/.test(val)),
        zod.z.custom((val) => /^\.\/.*\.css$/.test(val)),
        zod.z.object({
          types: zod.z.optional(zod.z.string()),
          source: zod.z.optional(zod.z.string()),
          browser: zod.z.optional(
            zod.z.object({
              source: zod.z.string(),
              import: zod.z.optional(zod.z.string()),
              require: zod.z.optional(zod.z.string())
            })
          ),
          "react-compiler": zod.z.optional(
            // z.union([
            // @TODO add support for a string shortcut
            // z.string(),
            zod.z.object({
              source: zod.z.optional(zod.z.string()),
              default: zod.z.string()
            })
            // ]),
          ),
          node: zod.z.optional(
            zod.z.object({
              source: zod.z.optional(zod.z.string()),
              import: zod.z.optional(zod.z.string()),
              require: zod.z.optional(zod.z.string())
            })
          ),
          import: zod.z.optional(zod.z.string()),
          require: zod.z.optional(zod.z.string()),
          default: zod.z.string()
        }),
        zod.z.object({
          types: zod.z.optional(zod.z.string()),
          svelte: zod.z.string(),
          default: zod.z.optional(zod.z.string())
        })
      ])
    )
  ),
  browserslist: zod.z.optional(zod.z.union([zod.z.string(), zod.z.array(zod.z.string())])),
  sideEffects: zod.z.optional(zod.z.union([zod.z.boolean(), zod.z.array(zod.z.string())])),
  // @TODO type this properly
  typesVersions: zod.z.optional(zod.z.any())
}), typoMap = /* @__PURE__ */ new Map();
for (const key of pkgSchema.keyof()._def.values)
  typoMap.set(key.toUpperCase(), key);
function validatePkg(input) {
  const pkg = pkgSchema.parse(input), invalidKey = Object.keys(input).find((key) => {
    const needle = key.toUpperCase();
    return typoMap.has(needle) ? typoMap.get(needle) !== key : !1;
  });
  if (invalidKey)
    throw new TypeError(
      `
- package.json: "${invalidKey}" is not a valid key. Did you mean "${typoMap.get(invalidKey.toUpperCase())}"?`
    );
  return pkg;
}
function createLogger() {
  return {
    /* eslint-disable no-console */
    log: (...args) => {
      console.log(...args);
    },
    info: (...args) => {
      console.log(chalk__default.default.blue("[info]"), ...args);
    },
    warn: (...args) => {
      console.log(chalk__default.default.yellow("[warning]"), ...args);
    },
    error: (...args) => {
      console.log(chalk__default.default.red("[error]"), ...args);
    },
    success: (...args) => {
      console.log(chalk__default.default.green("[success]"), ...args);
    }
    /* eslint-enable no-console */
  };
}
exports.createLogger = createLogger;
exports.fileExists = fileExists;
exports.isRecord = isRecord;
exports.validatePkg = validatePkg;
//# sourceMappingURL=logger.cjs.map
