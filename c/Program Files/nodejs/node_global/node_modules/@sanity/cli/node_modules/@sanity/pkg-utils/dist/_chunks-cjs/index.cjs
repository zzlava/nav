"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));
var chalk = require("chalk"), rxjs = require("rxjs"), path = require("node:path"), rimraf = require("rimraf"), ts = require("typescript"), fs = require("node:fs/promises"), apiExtractor = require("@microsoft/api-extractor"), mkdirp = require("mkdirp"), prettier = require("prettier"), tsdocConfig = require("@microsoft/tsdoc-config"), jsoncParser = require("jsonc-parser"), recast = require("recast"), typeScriptParser = require("recast/parsers/typescript.js"), rollup = require("rollup"), consoleSpy = require("./consoleSpy.cjs"), rollupPlugin = require("@optimize-lodash/rollup-plugin"), alias = require("@rollup/plugin-alias"), pluginBabel = require("@rollup/plugin-babel"), commonjs = require("@rollup/plugin-commonjs"), json = require("@rollup/plugin-json"), pluginNodeResolve = require("@rollup/plugin-node-resolve"), replace = require("@rollup/plugin-replace"), terser = require("@rollup/plugin-terser"), esbuild = require("rollup-plugin-esbuild");
require("./logger.cjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), path__default = /* @__PURE__ */ _interopDefaultCompat(path), rimraf__default = /* @__PURE__ */ _interopDefaultCompat(rimraf), ts__default = /* @__PURE__ */ _interopDefaultCompat(ts), fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), prettier__default = /* @__PURE__ */ _interopDefaultCompat(prettier), typeScriptParser__default = /* @__PURE__ */ _interopDefaultCompat(typeScriptParser), alias__default = /* @__PURE__ */ _interopDefaultCompat(alias), commonjs__default = /* @__PURE__ */ _interopDefaultCompat(commonjs), json__default = /* @__PURE__ */ _interopDefaultCompat(json), replace__default = /* @__PURE__ */ _interopDefaultCompat(replace), terser__default = /* @__PURE__ */ _interopDefaultCompat(terser), esbuild__default = /* @__PURE__ */ _interopDefaultCompat(esbuild);
function printExtractMessages(ctx, messages) {
  const { cwd, logger } = ctx, warnings = messages.filter((msg) => msg.logLevel === "warning");
  warnings.length && logger.log();
  for (const msg of warnings) {
    const sourceFilePath = msg.sourceFilePath && path__default.default.relative(cwd, msg.sourceFilePath);
    msg.messageId !== "TS6307" && logger.log(
      [
        `${chalk__default.default.cyan(sourceFilePath || "?")}`,
        `:${chalk__default.default.yellow(msg.sourceFileLine)}:${chalk__default.default.yellow(msg.sourceFileColumn)}`,
        ` - ${chalk__default.default.yellow("warning")} ${chalk__default.default.gray(msg.messageId)}
`,
        msg.text,
        `
`
      ].join("")
    );
  }
  const errors = messages.filter((msg) => msg.logLevel === "error");
  !warnings.length && errors.length && logger.log("");
  for (const msg of errors) {
    const sourceFilePath = msg.sourceFilePath && path__default.default.relative(cwd, msg.sourceFilePath);
    logger.log(
      [
        `${chalk__default.default.cyan(sourceFilePath || "?")}`,
        `:${chalk__default.default.yellow(msg.sourceFileLine)}:${chalk__default.default.yellow(msg.sourceFileColumn)}`,
        ` - ${chalk__default.default.red("error")} ${chalk__default.default.gray(msg.messageId)}
`,
        msg.text,
        `
`
      ].join("")
    );
  }
  errors.length && process.exit(1);
}
function printDiagnostic(options) {
  const { cwd, logger, diagnostic } = options;
  if (diagnostic.file && diagnostic.start) {
    const { line, character } = ts__default.default.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start), message = ts__default.default.flattenDiagnosticMessageText(diagnostic.messageText, `
`), file = path__default.default.relative(cwd, diagnostic.file.fileName), output = [
      `${chalk__default.default.yellow(file)}:${chalk__default.default.blue(line + 1)}:${chalk__default.default.blue(character + 1)} - `,
      `${chalk__default.default.gray(`TS${diagnostic.code}:`)} ${message}`
    ].join("");
    diagnostic.category === ts__default.default.DiagnosticCategory.Error && logger.error(output), diagnostic.category === ts__default.default.DiagnosticCategory.Warning && logger.warn(output), diagnostic.category === ts__default.default.DiagnosticCategory.Message && logger.log(output), diagnostic.category === ts__default.default.DiagnosticCategory.Suggestion && logger.log(output);
  } else
    logger.log(ts__default.default.flattenDiagnosticMessageText(diagnostic.messageText, `
`));
}
async function buildTypes(options) {
  const { cwd, logger, outDir, tsconfig, strict = !1 } = options, compilerOptions = {
    ...tsconfig.options,
    declaration: !0,
    declarationDir: outDir,
    emitDeclarationOnly: !0,
    noEmit: !1,
    noEmitOnError: strict ? !0 : tsconfig.options.noEmitOnError ?? !0,
    outDir
  }, program = ts__default.default.createProgram(tsconfig.fileNames, compilerOptions), emitResult = program.emit(), allDiagnostics = ts__default.default.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
  for (const diagnostic of allDiagnostics)
    printDiagnostic({ cwd, logger, diagnostic });
  if (emitResult.emitSkipped && allDiagnostics.filter((diag) => diag.category === ts__default.default.DiagnosticCategory.Error).length)
    throw new Error("failed to compile TypeScript definitions");
}
class DtsError extends Error {
  messages;
  constructor(message, messages) {
    super(message), this.messages = messages;
  }
}
function createApiExtractorConfig(options) {
  const {
    bundledPackages,
    distPath,
    exportPath,
    filePath,
    messages,
    projectFolder,
    mainEntryPointFilePath,
    tsconfig,
    tsconfigPath
  } = options, workaroundModulePreserve = tsconfig.options.module === ts__default.default.ModuleKind.Preserve, workaroundPaths = !!tsconfig.options.paths, overrideTsconfig = {
    extends: tsconfigPath,
    compilerOptions: {}
  };
  return workaroundModulePreserve && Object.assign(overrideTsconfig.compilerOptions, {
    // Set the equivalent options to `module: 'Preserve'`
    // https://github.com/microsoft/TypeScript/pull/56785/files?file-filters%5B%5D=.js&file-filters%5B%5D=.json&file-filters%5B%5D=.symbols&file-filters%5B%5D=.ts&file-filters%5B%5D=.types&show-viewed-files=true#diff-31d3c12bafea26bc9e8c8a77920c41af0c593206442add70c45a06c063767445
    module: "ESNext",
    moduleResolution: "Bundler",
    esModuleInterop: !0,
    resolveJsonModule: !0
  }), workaroundPaths && Object.assign(overrideTsconfig.compilerOptions, {
    // An empty object replaces whatever is in the original tsconfig file
    paths: {}
  }), {
    apiReport: {
      enabled: !1,
      reportFileName: "<unscopedPackageName>.api.md"
    },
    bundledPackages,
    compiler: workaroundModulePreserve || workaroundPaths ? { overrideTsconfig } : { tsconfigFilePath: tsconfigPath },
    docModel: {
      enabled: !1,
      apiJsonFilePath: path__default.default.resolve(distPath, `${exportPath}.api.json`)
    },
    dtsRollup: {
      enabled: !0,
      untrimmedFilePath: path__default.default.resolve(distPath, filePath)
      // betaTrimmedFilePath: path.resolve(distPath, filePath.replace('.d.ts', '-beta.d.ts')),
      // publicTrimmedFilePath: path.resolve(distPath, filePath.replace('.d.ts', '-public.d.ts')),
    },
    tsdocMetadata: {
      enabled: !1
    },
    messages,
    mainEntryPointFilePath,
    projectFolder
  };
}
async function createTSDocConfig(opts) {
  const { customTags } = opts;
  if (customTags.length === 0)
    return;
  const tsDocBaseBuf = await fs.readFile(
    require.resolve("@microsoft/api-extractor/extends/tsdoc-base.json")
  ), tsDocBaseConfig = jsoncParser.parse(tsDocBaseBuf.toString()), tagDefinitions = (tsDocBaseConfig.tagDefinitions || []).concat(
    customTags.map((t) => ({
      tagName: `@${t.name}`,
      syntaxKind: t.syntaxKind,
      allowMultiple: t.allowMultiple
    }))
  ), supportForTags = { ...tsDocBaseConfig.supportForTags };
  for (const customTag of customTags)
    supportForTags[`@${customTag.name}`] = !0;
  return tsdocConfig.TSDocConfigFile.loadFromObject({
    ...tsDocBaseConfig,
    noStandardTags: !1,
    tagDefinitions,
    supportForTags
  });
}
async function extractModuleBlocksFromTypes({
  tsOutDir,
  extractResult
}) {
  const program = extractResult.compilerState.program, moduleBlocks = [], sourceFiles = [...program.getSourceFiles()].filter((sourceFile) => sourceFile.fileName.includes(tsOutDir));
  for (const sourceFile of sourceFiles)
    sourceFile.text.includes("declare module") && moduleBlocks.push(...extractModuleBlocks(sourceFile.text));
  return moduleBlocks;
}
function extractModuleBlocks(fileContent) {
  return recast.parse(fileContent, {
    parser: typeScriptParser__default.default
  }).program.body.filter((node) => node.type === "TSModuleDeclaration").map((node) => recast.print(node).code);
}
const LOG_LEVELS = {
  error: "error",
  info: "info",
  off: "none",
  warn: "warning"
};
function getExtractMessagesConfig(options) {
  const { rules } = options;
  function ruleToLogLevel(key, defaultLevel) {
    const r = rules?.[key];
    return r ? LOG_LEVELS[r] : defaultLevel || "warning";
  }
  return {
    compilerMessageReporting: {
      default: {
        logLevel: "warning"
      }
    },
    extractorMessageReporting: {
      default: {
        logLevel: "warning",
        addToApiReportFile: !1
      },
      "ae-forgotten-export": {
        logLevel: ruleToLogLevel("ae-forgotten-export", "error"),
        addToApiReportFile: !1
      },
      "ae-incompatible-release-tags": {
        logLevel: ruleToLogLevel("ae-incompatible-release-tags", "error"),
        addToApiReportFile: !1
      },
      "ae-internal-missing-underscore": {
        logLevel: ruleToLogLevel("ae-internal-missing-underscore"),
        addToApiReportFile: !1
      },
      "ae-missing-release-tag": {
        logLevel: ruleToLogLevel("ae-missing-release-tag", "error"),
        addToApiReportFile: !1
      },
      "ae-wrong-input-file-type": {
        logLevel: "none",
        addToApiReportFile: !1
      }
    },
    tsdocMessageReporting: {
      default: {
        logLevel: "warning",
        addToApiReportFile: !1
      },
      "tsdoc-link-tag-unescaped-text": {
        logLevel: ruleToLogLevel("tsdoc-link-tag-unescaped-text", "warning"),
        addToApiReportFile: !1
      },
      "tsdoc-undefined-tag": {
        logLevel: ruleToLogLevel("tsdoc-undefined-tag", "error"),
        addToApiReportFile: !1
      },
      "tsdoc-unsupported-tag": {
        logLevel: ruleToLogLevel("tsdoc-unsupported-tag", "none"),
        addToApiReportFile: !1
      }
    }
  };
}
async function extractTypes(options) {
  const {
    bundledPackages,
    customTags,
    distPath,
    exportPath,
    files,
    filePaths,
    projectPath,
    rules,
    sourceTypesPath,
    tmpPath,
    tsconfig,
    tsconfigPath
  } = options, tsdocConfigFile = await createTSDocConfig({
    customTags: customTags || []
  }), filePath = filePaths[0].replace(/\.d\.[mc]ts$/, ".d.ts"), shouldCleanUpDts = !filePaths.includes(filePath), extractorConfig = apiExtractor.ExtractorConfig.prepare({
    configObject: createApiExtractorConfig({
      bundledPackages,
      distPath,
      exportPath,
      filePath,
      messages: getExtractMessagesConfig({ rules }),
      projectFolder: projectPath,
      mainEntryPointFilePath: sourceTypesPath,
      tsconfig,
      tsconfigPath
    }),
    configObjectFullPath: void 0,
    tsdocConfigFile,
    packageJsonFullPath: path__default.default.resolve(projectPath, "package.json")
  }), messages = [], extractorResult = apiExtractor.Extractor.invoke(extractorConfig, {
    // Equivalent to the "--local" command-line parameter
    localBuild: !0,
    // Equivalent to the "--verbose" command-line parameter
    showVerboseMessages: !0,
    // handle messages
    messageCallback(message) {
      messages.push(message), message.handled = !0;
    }
  }), typesPath = path__default.default.resolve(distPath, filePath), typesBuf = await fs__default.default.readFile(typesPath), prettierConfig = await prettier__default.default.resolveConfig(typesPath);
  await mkdirp.mkdirp(path__default.default.dirname(typesPath));
  const moduleBlocks = await extractModuleBlocksFromTypes({
    extractResult: extractorResult,
    tsOutDir: tmpPath
  }), code = [typesBuf.toString(), ...moduleBlocks].join(`

`), prettyCode = await prettier__default.default.format(code, {
    ...prettierConfig,
    filepath: typesPath
  });
  for (const expFilePath of filePaths) {
    const expTypesPath = path__default.default.resolve(distPath, expFilePath);
    await fs__default.default.writeFile(expTypesPath, prettyCode), files.push({
      type: "types",
      path: expTypesPath
    });
  }
  return shouldCleanUpDts && await fs__default.default.unlink(typesPath), { extractorResult, messages };
}
async function doExtract(ctx, task) {
  const { config, cwd, files, logger, strict, ts: ts2, bundledPackages } = ctx;
  if (!ts2.config || !ts2.configPath)
    return { type: "dts", messages: [], results: [] };
  const { outDir, rootDir = cwd } = ts2.config.options;
  if (!outDir)
    throw new Error("tsconfig.json is missing `compilerOptions.outDir`");
  const tmpPath = path__default.default.resolve(outDir, "__tmp__");
  await buildTypes({ cwd, logger, outDir: tmpPath, strict, tsconfig: ts2.config });
  const messages = [], results = [];
  for (const entry of task.entries) {
    const exportPath = entry.exportPath === "." ? "./index" : entry.exportPath, sourceTypesPath = path__default.default.resolve(
      tmpPath,
      path__default.default.relative(rootDir, path__default.default.resolve(cwd, entry.sourcePath)).replace(/\.ts$/, ".d.ts")
    ), targetPaths = entry.targetPaths.map((targetPath) => path__default.default.resolve(cwd, targetPath)), filePaths = targetPaths.map((targetPath) => path__default.default.relative(outDir, targetPath)), result = await extractTypes({
      bundledPackages: bundledPackages || [],
      customTags: config?.extract?.customTags,
      cwd,
      distPath: outDir,
      exportPath,
      files,
      filePaths,
      projectPath: cwd,
      rules: config?.extract?.rules,
      sourceTypesPath,
      tsconfig: ts2.config,
      tmpPath,
      tsconfigPath: path__default.default.resolve(cwd, ts2.configPath || "tsconfig.json")
    });
    messages.push(...result.messages);
    const errors = result.messages.filter((msg) => msg.logLevel === "error");
    if (errors.length > 0)
      throw await rimraf__default.default(tmpPath), new DtsError(`encountered ${errors.length} errors when extracting types`, errors);
    results.push({ sourcePath: path__default.default.resolve(cwd, entry.sourcePath), filePaths: targetPaths });
  }
  return await rimraf__default.default(tmpPath), { type: "dts", messages, results };
}
const dtsTask = {
  name: (_ctx, task) => [
    "Build type definitions...",
    "  entries:",
    ...task.entries.map((entry) => entry.targetPaths.map((targetPath) => [
      `    - ${chalk__default.default.cyan(entry.importId)}: `,
      `${chalk__default.default.yellow(entry.sourcePath)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(targetPath)}`
    ].join("")).join(`
`))
  ].join(`
`),
  exec: (ctx, task) => new rxjs.Observable((observer) => {
    doExtract(ctx, task).then((result) => {
      observer.next(result), observer.complete();
    }).catch((err) => {
      observer.error(err);
    });
  }),
  complete: (ctx, _task, result) => {
    printExtractMessages(ctx, result.messages);
  },
  error: (ctx, _task, err) => {
    const { logger } = ctx;
    err instanceof DtsError ? printExtractMessages(ctx, err.messages) : err instanceof Error && logger.error(err);
  }
}, dtsWatchTask = {
  name: (_ctx, task) => [
    "build type definitions",
    ...task.entries.map((entry) => entry.targetPaths.map((targetPath) => [
      `    - ${chalk__default.default.cyan(entry.importId)}: `,
      `${chalk__default.default.yellow(entry.sourcePath)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(targetPath)}`
    ].join("")))
  ].join(`
`),
  exec: (ctx, task) => {
    const { config, cwd, files, logger, strict, ts: tsContext, bundledPackages } = ctx;
    return new rxjs.Observable((observer) => {
      if (!tsContext.config || !tsContext.configPath) {
        observer.next({ type: "dts", messages: [], results: [] }), observer.complete();
        return;
      }
      const { outDir, rootDir = cwd } = tsContext.config.options;
      if (!outDir) {
        observer.error(new Error("tsconfig.json is missing `compilerOptions.outDir`"));
        return;
      }
      const tmpPath = path__default.default.resolve(outDir, "__tmp__");
      buildTypes({
        cwd,
        logger,
        outDir: tmpPath,
        tsconfig: tsContext.config,
        strict
      }).catch((err) => {
        observer.error(err);
      });
      const host = ts__default.default.createWatchCompilerHost(
        tsContext.configPath,
        {
          ...tsContext.config.options,
          declaration: !0,
          declarationDir: tmpPath,
          emitDeclarationOnly: !0,
          noEmit: !1,
          noEmitOnError: strict ? !0 : tsContext.config.options.noEmitOnError ?? !0,
          outDir: tmpPath
        },
        ts__default.default.sys,
        ts__default.default.createEmitAndSemanticDiagnosticsBuilderProgram,
        (diagnostic) => {
          logger.error(ts__default.default.flattenDiagnosticMessageText(diagnostic.messageText, `
`));
        },
        (diagnostic) => {
          logger.info(ts__default.default.flattenDiagnosticMessageText(diagnostic.messageText, `
`));
        }
      ), origPostProgramCreate = host.afterProgramCreate;
      host.afterProgramCreate = async (program) => {
        origPostProgramCreate?.(program);
        const messages = [], results = [];
        for (const entry of task.entries) {
          const exportPath = entry.exportPath === "." ? "./index" : entry.exportPath, sourceTypesPath = path__default.default.resolve(
            tmpPath,
            path__default.default.relative(rootDir, path__default.default.resolve(cwd, entry.sourcePath)).replace(/\.ts$/, ".d.ts")
          ), targetPaths = entry.targetPaths.map((targetPath) => path__default.default.resolve(cwd, targetPath)), filePaths = targetPaths.map((targetPath) => path__default.default.relative(outDir, targetPath));
          try {
            const result = await extractTypes({
              bundledPackages: bundledPackages || [],
              customTags: config?.extract?.customTags,
              cwd,
              distPath: outDir,
              exportPath,
              files,
              filePaths,
              projectPath: cwd,
              rules: config?.extract?.rules,
              sourceTypesPath,
              tsconfig: tsContext.config,
              tmpPath,
              tsconfigPath: path__default.default.resolve(cwd, tsContext.configPath || "tsconfig.json")
            });
            messages.push(...result.messages), results.push({ sourcePath: path__default.default.resolve(cwd, entry.sourcePath), filePaths: targetPaths });
          } catch (err) {
            if (err instanceof DtsError)
              messages.push(...err.messages);
            else {
              observer.error(err);
              return;
            }
          }
        }
        observer.next({ type: "dts", messages, results });
      };
      const watchProgram = ts__default.default.createWatchProgram(host);
      return () => {
        watchProgram.close(), rimraf__default.default.sync(tmpPath);
      };
    });
  },
  complete: (ctx, task, result) => {
    const { logger } = ctx;
    printExtractMessages(ctx, result.messages), logger.success(
      `build type definitions
       ${task.entries.map(
        (entry) => `    - ${chalk__default.default.cyan(entry.importId)}: ${chalk__default.default.yellow(entry.sourcePath)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(entry.targetPaths.join(", "))}`
      ).join(`
       `)}`
    ), logger.log("");
  },
  error: (ctx, _task, err) => {
    const { logger } = ctx;
    err instanceof DtsError ? printExtractMessages(ctx, err.messages) : err instanceof Error && logger.error(err);
  }
};
function resolveRollupConfig(ctx, buildTask) {
  const { format, runtime, target } = buildTask, { config, cwd, exports: _exports, external, distPath, logger, pkg, ts: ts2 } = ctx, isLegacyExports = buildTask.type === "build:legacy", isReactCompiler = buildTask.type === "build:react-compiler", outputExt = isLegacyExports ? consoleSpy.pkgExtMap.legacy : consoleSpy.pkgExtMap[pkg.type || "commonjs"][format], minify = config?.minify ?? !1, outDir = path__default.default.relative(cwd, distPath), pathAliases = Object.fromEntries(
    Object.entries(ts2.config?.options.paths || {}).map(([key, val]) => [key, path__default.default.resolve(cwd, ts2.config?.options.baseUrl || ".", val[0])])
  ), entries = buildTask.entries.map((entry) => ({
    ...entry,
    name: path__default.default.relative(outDir, entry.output).replace(/\.[^/.]+$/, "")
  }), {}), exportIds = _exports && Object.keys(_exports).map((exportPath) => path__default.default.join(pkg.name, exportPath)), sourcePaths = _exports && Object.values(_exports).map((e) => path__default.default.resolve(cwd, e.source)), replacements = Object.fromEntries(
    Object.entries(config?.define || {}).map(([key, val]) => [key, JSON.stringify(val)])
  ), { optimizeLodash: enableOptimizeLodash = hasDependency(pkg, "lodash") } = config?.rollup || {}, defaultPlugins = [
    replace__default.default({
      preventAssignment: !0,
      values: {
        ...pkg.name === "@sanity/pkg-utils" ? { ...replacements } : {
          "process.env.PKG_FILE_PATH": (arg) => {
            const sourcePath = `./${path__default.default.relative(cwd, arg)}`, entry = entries.find((e) => e.source === sourcePath);
            return entry ? JSON.stringify(
              path__default.default.relative(cwd, path__default.default.resolve(outDir, entry.name + outputExt))
            ) : (console.error(`could not find source entry: ${sourcePath}`), "null");
          },
          "process.env.PKG_FORMAT": JSON.stringify(format),
          "process.env.PKG_RUNTIME": JSON.stringify(runtime),
          "process.env.PKG_VERSION": JSON.stringify(process.env.PKG_VERSION || pkg.version),
          ...replacements
        }
      }
    }),
    alias__default.default({
      entries: { ...pathAliases }
    }),
    pluginNodeResolve.nodeResolve({
      browser: runtime === "browser",
      extensions: [".cjs", ".mjs", ".js", ".jsx", ".json", ".node"],
      preferBuiltins: !0
    }),
    commonjs__default.default(),
    json__default.default(),
    (isReactCompiler || config?.babel?.reactCompiler) && pluginBabel.babel({
      babelrc: !1,
      presets: ["@babel/preset-typescript"],
      babelHelpers: "bundled",
      extensions: [".ts", ".tsx", ".js", ".jsx"],
      plugins: [["babel-plugin-react-compiler", config?.reactCompilerOptions || {}]]
    }),
    esbuild__default.default({
      jsx: config?.jsx ?? "automatic",
      jsxFactory: config?.jsxFactory ?? "createElement",
      jsxFragment: config?.jsxFragment ?? "Fragment",
      jsxImportSource: config?.jsxImportSource ?? "react",
      target,
      tsconfig: ctx.ts.configPath || "tsconfig.json",
      treeShaking: !0,
      minifySyntax: config?.minify !== !1,
      supported: {
        "template-literal": !0
      }
    }),
    Array.isArray(config?.babel?.plugins) && pluginBabel.getBabelOutputPlugin({
      babelrc: !1,
      plugins: config.babel.plugins
    }),
    enableOptimizeLodash && rollupPlugin.optimizeLodashImports({
      useLodashEs: format === "esm" && hasDependency(pkg, "lodash-es") ? !0 : void 0,
      ...typeof config?.rollup?.optimizeLodash == "boolean" ? {} : config?.rollup?.optimizeLodash
    }),
    minify && terser__default.default({
      compress: { directives: !1 },
      output: {
        comments: (_node, comment) => {
          const text = comment.value;
          return comment.type === "comment2" ? /@preserve|@license|@cc_on/i.test(text) : !1;
        }
      }
    })
  ].filter(Boolean), userPlugins = config?.rollup?.plugins, plugins = Array.isArray(userPlugins) ? defaultPlugins.concat(userPlugins) : consoleSpy.resolveConfigProperty(config?.rollup?.plugins, defaultPlugins), hashChunkFileNames = config?.rollup?.hashChunkFileNames ?? !1, chunkFileNames = `${isReactCompiler ? "_compiled" : isLegacyExports ? "_legacy" : hashChunkFileNames ? "_chunks" : "_chunks-[format]"}/${hashChunkFileNames ? "[name]-[hash]" : "[name]"}${outputExt}`, entryFileNames = isLegacyExports ? "[name].js" : `[name]${outputExt}`;
  return {
    inputOptions: {
      context: cwd,
      external: (id, importer) => {
        if (exportIds?.includes(id))
          return !0;
        if (importer && (id.startsWith(".") || id.startsWith("/"))) {
          const idPath = path__default.default.resolve(path__default.default.dirname(importer), id);
          if (sourcePaths?.includes(idPath))
            return logger.warn(
              `detected self-referencing import \u2013 treating as external: ${path__default.default.relative(
                cwd,
                idPath
              )}`
            ), !0;
        }
        const idParts = id.split("/"), name = idParts[0].startsWith("@") ? `${idParts[0]}/${idParts[1]}` : idParts[0];
        return !!(name && external.includes(name));
      },
      input: entries.reduce((acc, entry) => ({ ...acc, [entry.name]: entry.source }), {}),
      watch: {
        chokidar: {
          usePolling: !0
        }
      },
      plugins,
      treeshake: {
        preset: "recommended",
        propertyReadSideEffects: !1,
        moduleSideEffects: "no-external",
        ...config?.rollup?.treeshake
      },
      experimentalLogSideEffects: config?.rollup?.experimentalLogSideEffects
    },
    outputOptions: {
      chunkFileNames,
      compact: minify,
      dir: outDir,
      entryFileNames,
      esModule: !0,
      format,
      interop: "compat",
      sourcemap: config?.sourcemap ?? !0,
      hoistTransitiveImports: !1,
      minifyInternalExports: minify,
      ...config?.rollup?.output
    }
  };
}
function hasDependency(pkg, packageName) {
  return pkg.dependencies ? packageName in pkg.dependencies : pkg.peerDependencies ? packageName in pkg.peerDependencies : !1;
}
const rollupLegacyTask = {
  name: (ctx, task) => {
    const entries = task.entries.filter((e) => !e.path.includes("__$$bundle_")), targetLines = task.target.length ? ["  target:", ...task.target.map((t) => `    - ${chalk__default.default.yellow(t)}`)] : [], entriesLines = entries.length ? [
      "  entries:",
      ...entries.map(
        (e) => [
          "    - ",
          `${chalk__default.default.cyan(path__default.default.join(ctx.pkg.name, e.path))}: `,
          `${chalk__default.default.yellow(e.source)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(e.output)}`
        ].join("")
      )
    ] : [];
    return [
      "Build legacy exports...",
      `  format: ${chalk__default.default.yellow(task.format)}`,
      ...targetLines,
      ...entriesLines
    ].join(`
`);
  },
  exec: (ctx, task) => new rxjs.Observable((observer) => {
    execPromise$2(ctx, task).then((result) => {
      observer.next(result), observer.complete();
    }).catch((err) => observer.error(err));
  }),
  complete: () => {
  },
  error: (_ctx, _task, err) => {
    console.error(err);
  }
};
async function execPromise$2(ctx, task) {
  const { distPath, files, logger } = ctx, outDir = path__default.default.relative(ctx.cwd, distPath), consoleSpy$1 = consoleSpy.createConsoleSpy({
    onRestored: (messages) => {
      for (const msg of messages) {
        const text = String(msg.args[0]);
        msg.code !== "CIRCULAR_DEPENDENCY" && (text.startsWith("Dynamic import can only") || text.startsWith("Sourcemap is likely to be incorrect") || (msg.type === "log" && logger.info(...msg.args), msg.type === "warn" && logger.warn(...msg.args), msg.type === "error" && logger.error(...msg.args)));
      }
    }
  });
  try {
    const { inputOptions, outputOptions } = resolveRollupConfig(ctx, task), bundle = await rollup.rollup({
      ...inputOptions,
      onwarn(warning) {
        consoleSpy$1.messages.push({
          type: "warn",
          code: warning.code,
          args: [warning.message]
        });
      }
    }), { output } = await bundle.generate(outputOptions);
    for (const chunkOrAsset of output)
      chunkOrAsset.type === "asset" ? files.push({
        type: "asset",
        path: path__default.default.resolve(outDir, chunkOrAsset.fileName)
      }) : files.push({
        type: "chunk",
        path: path__default.default.resolve(outDir, chunkOrAsset.fileName)
      });
    await bundle.write(outputOptions), await bundle.close(), consoleSpy$1.restore();
  } catch (err) {
    throw consoleSpy$1.restore(), err;
  }
}
const rollupReactCompilerTask = {
  name: (ctx, task) => {
    const entries = task.entries.filter((e) => !e.path.includes("__$$bundle_")), targetLines = task.target.length ? ["  target:", ...task.target.map((t) => `    - ${chalk__default.default.yellow(t)}`)] : [], entriesLines = entries.length ? [
      "  entries:",
      ...entries.map(
        (e) => [
          "    - ",
          `${chalk__default.default.cyan(path__default.default.join(ctx.pkg.name, e.path))}: `,
          `${chalk__default.default.yellow(e.source)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(e.output)}`
        ].join("")
      )
    ] : [];
    return ["Build react compiler exports...", ...targetLines, ...entriesLines].join(`
`);
  },
  exec: (ctx, task) => new rxjs.Observable((observer) => {
    execPromise$1(ctx, task).then((result) => {
      observer.next(result), observer.complete();
    }).catch((err) => observer.error(err));
  }),
  complete: () => {
  },
  error: (_ctx, _task, err) => {
    console.error(err);
  }
};
async function execPromise$1(ctx, task) {
  const { distPath, files, logger } = ctx, outDir = path__default.default.relative(ctx.cwd, distPath), consoleSpy$1 = consoleSpy.createConsoleSpy({
    onRestored: (messages) => {
      for (const msg of messages) {
        const text = String(msg.args[0]);
        msg.code !== "CIRCULAR_DEPENDENCY" && (text.startsWith("Dynamic import can only") || text.startsWith("Sourcemap is likely to be incorrect") || (msg.type === "log" && logger.info(...msg.args), msg.type === "warn" && logger.warn(...msg.args), msg.type === "error" && logger.error(...msg.args)));
      }
    }
  });
  try {
    const { inputOptions, outputOptions } = resolveRollupConfig(ctx, task), bundle = await rollup.rollup({
      ...inputOptions,
      onwarn(warning) {
        consoleSpy$1.messages.push({
          type: "warn",
          code: warning.code,
          args: [warning.message]
        });
      }
    }), { output } = await bundle.generate(outputOptions);
    for (const chunkOrAsset of output)
      chunkOrAsset.type === "asset" ? files.push({
        type: "asset",
        path: path__default.default.resolve(outDir, chunkOrAsset.fileName)
      }) : files.push({
        type: "chunk",
        path: path__default.default.resolve(outDir, chunkOrAsset.fileName)
      });
    await bundle.write(outputOptions), await bundle.close(), consoleSpy$1.restore();
  } catch (err) {
    throw consoleSpy$1.restore(), err;
  }
}
const rollupTask = {
  name: (ctx, task) => {
    const bundleEntries = task.entries.filter((e) => e.path.includes("__$$bundle_")), entries = task.entries.filter((e) => !e.path.includes("__$$bundle_")), targetLines = task.target.length ? ["  target:", ...task.target.map((t) => `    - ${chalk__default.default.yellow(t)}`)] : [], bundlesLines = bundleEntries.length ? [
      "  bundles:",
      ...bundleEntries.map(
        (e) => [
          "    - ",
          `${chalk__default.default.yellow(e.source)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(e.output)}`
        ].join("")
      )
    ] : [], entriesLines = entries.length ? [
      "  entries:",
      ...entries.map(
        (e) => [
          "    - ",
          `${chalk__default.default.cyan(path__default.default.join(ctx.pkg.name, e.path))}: `,
          `${chalk__default.default.yellow(e.source)} ${chalk__default.default.gray("\u2192")} ${chalk__default.default.yellow(e.output)}`
        ].join("")
      )
    ] : [];
    return [
      "Build javascript files...",
      `  format: ${chalk__default.default.yellow(task.format)}`,
      ...targetLines,
      ...bundlesLines,
      ...entriesLines
    ].join(`
`);
  },
  exec: (ctx, task) => new rxjs.Observable((observer) => {
    execPromise(ctx, task).then((result) => {
      observer.next(result), observer.complete();
    }).catch((err) => observer.error(err));
  }),
  complete: () => {
  },
  error: (_ctx, _task, err) => {
    console.error(err);
  }
};
async function execPromise(ctx, task) {
  const { distPath, files, logger } = ctx, outDir = path__default.default.relative(ctx.cwd, distPath), consoleSpy$1 = consoleSpy.createConsoleSpy({
    onRestored: (messages) => {
      for (const msg of messages) {
        const text = String(msg.args[0]);
        msg.code !== "CIRCULAR_DEPENDENCY" && (text.startsWith("Dynamic import can only") || text.startsWith("Sourcemap is likely to be incorrect") || (msg.type === "log" && logger.info(...msg.args), msg.type === "warn" && logger.warn(...msg.args), msg.type === "error" && logger.error(...msg.args)));
      }
    }
  });
  try {
    const { inputOptions, outputOptions } = resolveRollupConfig(ctx, task), bundle = await rollup.rollup({
      ...inputOptions,
      onwarn(warning) {
        consoleSpy$1.messages.push({
          type: "warn",
          code: warning.code,
          args: [warning.message]
        });
      }
    }), { output } = await bundle.generate(outputOptions);
    for (const chunkOrAsset of output)
      chunkOrAsset.type === "asset" ? files.push({
        type: "asset",
        path: path__default.default.resolve(outDir, chunkOrAsset.fileName)
      }) : files.push({
        type: "chunk",
        path: path__default.default.resolve(outDir, chunkOrAsset.fileName)
      });
    await bundle.write(outputOptions), await bundle.close(), consoleSpy$1.restore();
  } catch (err) {
    throw consoleSpy$1.restore(), err;
  }
}
const rollupWatchTask = {
  name: (ctx, task) => `build javascript files (target ${task.target.join(" + ")}, format ${task.format})
       ${task.entries.map((e) => `${chalk__default.default.blue(path__default.default.join(ctx.pkg.name, e.path))}: ${e.source} -> ${e.output}`).join(`
       `)}`,
  exec: (ctx, task) => {
    const { inputOptions, outputOptions } = resolveRollupConfig(ctx, task);
    return new rxjs.Observable((observer) => {
      const watchOptions = {
        ...inputOptions,
        output: outputOptions
      }, watcher = rollup.watch(watchOptions);
      return watcher.on("event", (event) => {
        observer.next(event);
      }), () => {
        watcher.close();
      };
    });
  },
  complete: (ctx, task, event) => {
    const { logger } = ctx;
    if (event.code === "BUNDLE_END") {
      logger.success(
        `build javascript files (target ${task.target.join(" + ")}, format ${task.format})
       ${task.entries.map((e) => `${chalk__default.default.blue(path__default.default.join(ctx.pkg.name, e.path))}: ${e.source} -> ${e.output}`).join(`
       `)}`
      ), logger.log("");
      return;
    }
    if (event.code !== "BUNDLE_START" && event.code !== "END" && event.code === "ERROR") {
      logger.error(event.code, event);
      return;
    }
  },
  error: (ctx, _task, err) => {
    const { logger } = ctx;
    err instanceof Error && logger.log(err);
  }
}, buildTaskHandlers = {
  "build:dts": dtsTask,
  "build:js": rollupTask,
  "build:legacy": rollupLegacyTask,
  "build:react-compiler": rollupReactCompilerTask
}, watchTaskHandlers = {
  "watch:dts": dtsWatchTask,
  "watch:js": rollupWatchTask
};
exports.buildTaskHandlers = buildTaskHandlers;
exports.dtsTask = dtsTask;
exports.dtsWatchTask = dtsWatchTask;
exports.getExtractMessagesConfig = getExtractMessagesConfig;
exports.rollupLegacyTask = rollupLegacyTask;
exports.rollupReactCompilerTask = rollupReactCompilerTask;
exports.rollupTask = rollupTask;
exports.rollupWatchTask = rollupWatchTask;
exports.watchTaskHandlers = watchTaskHandlers;
//# sourceMappingURL=index.cjs.map
