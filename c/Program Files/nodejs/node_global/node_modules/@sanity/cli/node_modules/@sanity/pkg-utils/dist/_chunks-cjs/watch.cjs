"use strict";
var path = require("node:path"), rxjs = require("rxjs"), consoleSpy = require("./consoleSpy.cjs"), logger = require("./logger.cjs"), fs = require("node:fs"), index = require("./index.cjs"), operators = require("rxjs/operators"), globby = require("globby"), chokidar = require("chokidar");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), globby__default = /* @__PURE__ */ _interopDefaultCompat(globby), chokidar__default = /* @__PURE__ */ _interopDefaultCompat(chokidar);
function resolveWatchTasks(ctx) {
  const { config, cwd, pkg, target } = ctx, tasks = [], exports2 = Object.entries(ctx.exports || {}).map(
    ([_path, exp]) => ({ _path, ...exp })
  ), dtsTask = {
    type: "watch:dts",
    entries: []
  }, rollupTasks = {};
  function addRollupTaskEntry(format, runtime, entry) {
    const buildId = `${format}:${runtime}`;
    rollupTasks[buildId] ? rollupTasks[buildId].entries.push(entry) : rollupTasks[buildId] = {
      type: "watch:js",
      buildId,
      entries: [entry],
      runtime,
      format,
      target: target[runtime]
    };
  }
  for (const exp of exports2) {
    const importId = path__default.default.join(pkg.name, exp._path);
    exp.source?.endsWith(".ts") && dtsTask.entries.push({
      importId,
      exportPath: exp._path,
      sourcePath: exp.source,
      targetPaths: consoleSpy.getTargetPaths(pkg.type, exp)
    }), exp.browser?.source?.endsWith(".ts") && dtsTask.entries.push({
      importId,
      exportPath: exp._path,
      sourcePath: exp.browser.source,
      targetPaths: consoleSpy.getTargetPaths(pkg.type, exp.browser)
    }), exp.node?.source?.endsWith(".ts") && dtsTask.entries.push({
      importId,
      exportPath: exp._path,
      sourcePath: exp.node.source,
      targetPaths: consoleSpy.getTargetPaths(pkg.type, exp.node)
    });
  }
  for (const exp of exports2) {
    const output = exp.require;
    output && addRollupTaskEntry("commonjs", ctx.runtime, {
      path: exp._path,
      source: exp.source,
      output
    });
  }
  for (const exp of exports2) {
    const output = exp.browser?.require;
    output && addRollupTaskEntry("commonjs", "browser", {
      path: exp._path,
      source: exp.browser?.source || exp.source,
      output
    });
  }
  for (const exp of exports2) {
    const output = exp.import;
    output && addRollupTaskEntry("esm", ctx.runtime, {
      path: exp._path,
      source: exp.source,
      output
    });
  }
  for (const exp of exports2) {
    const output = exp.browser?.import;
    output && addRollupTaskEntry("esm", "browser", {
      path: exp._path,
      source: exp.browser?.source || exp.source,
      output
    });
  }
  if (dtsTask.entries.length && tasks.push(dtsTask), tasks.push(...Object.values(rollupTasks)), config?.legacyExports) {
    for (const exp of exports2)
      if (exp._exported && exp._path !== ".") {
        const relativeTargetPath = (exp.browser?.import || exp.import || "").replace(
          /\.[^/.]+$/,
          ""
        );
        relativeTargetPath && fs__default.default.writeFileSync(
          path__default.default.resolve(cwd, `${exp._path}.js`),
          ["// AUTO-GENERATED \u2013 DO NOT EDIT", `export * from '${relativeTargetPath}'`, ""].join(
            `
`
          )
        );
      }
  }
  return tasks;
}
function globFiles(patterns) {
  return globby__default.default(patterns.map((pattern) => pattern.split(path__default.default.sep).join(path__default.default.posix.sep)));
}
function watchFiles(patterns) {
  return new rxjs.Observable((observer) => {
    const watcher = chokidar__default.default.watch(patterns, {
      ignoreInitial: !0
    });
    function handleFileEvent(type, file) {
      type === "error" || file instanceof Error ? observer.error(file) : observer.next({ type, file });
    }
    return watcher.on("all", handleFileEvent), () => {
      watcher.off("all", handleFileEvent), watcher.close();
    };
  });
}
async function watchConfigFiles(options) {
  const { cwd, logger: logger2 } = options, initialFiles = await globFiles([
    path__default.default.resolve(cwd, "package.json"),
    path__default.default.resolve(cwd, "package.config.cjs"),
    path__default.default.resolve(cwd, "package.config.js"),
    path__default.default.resolve(cwd, "package.config.ts")
  ]);
  return watchFiles([
    path__default.default.resolve(cwd, "package.json"),
    path__default.default.resolve(cwd, "package.config.cjs"),
    path__default.default.resolve(cwd, "package.config.js"),
    path__default.default.resolve(cwd, "package.config.ts")
  ]).pipe(
    operators.scan((files, fileEvent) => fileEvent.type === "add" ? files.concat(fileEvent.file) : fileEvent.type === "unlink" ? files.filter((f) => f !== fileEvent.file) : fileEvent.type === "change" ? (logger2.log(
      "--------------------------------------------------------------------------------"
    ), logger2.info(path__default.default.relative(cwd, fileEvent.file), "changed"), logger2.log(""), files.slice(0)) : files, initialFiles),
    operators.startWith(initialFiles),
    operators.distinctUntilChanged()
  );
}
async function watch(options) {
  const { cwd, strict = !1, tsconfig: tsconfigOption } = options, logger$1 = logger.createLogger();
  (await watchConfigFiles({ cwd, logger: logger$1 })).pipe(
    rxjs.switchMap(async (configFiles) => {
      if (!configFiles.map((f) => path__default.default.relative(cwd, f)).find((f) => f === "package.json"))
        throw new Error("missing package.json");
      const config = await consoleSpy.loadConfig({ cwd }), legacyExports = config?.legacyExports ?? !1, pkg = await consoleSpy.loadPkgWithReporting({ cwd, logger: logger$1, strict, legacyExports }), tsconfig = tsconfigOption || config?.tsconfig || "tsconfig.json";
      return consoleSpy.resolveBuildContext({ config, cwd, logger: logger$1, pkg, strict, tsconfig });
    })
  ).subscribe(async (ctx) => {
    const watchTasks = resolveWatchTasks(ctx);
    for (const task of watchTasks) {
      const handler = index.watchTaskHandlers[task.type];
      handler.exec(ctx, task).subscribe({
        error: (err) => {
          ctx.logger.error(err), ctx.logger.log(), process.exit(1);
        },
        next: (result) => {
          handler.complete(ctx, task, result);
        },
        complete: () => {
          ctx.logger.success(handler.name(ctx, task)), ctx.logger.log();
        }
      });
    }
  });
}
exports.watch = watch;
//# sourceMappingURL=watch.cjs.map
