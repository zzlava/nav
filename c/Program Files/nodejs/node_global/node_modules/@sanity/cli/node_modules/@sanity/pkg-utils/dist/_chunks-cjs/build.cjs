"use strict";
var path = require("node:path"), rimraf = require("rimraf"), consoleSpy = require("./consoleSpy.cjs"), logger = require("./logger.cjs"), fs = require("node:fs"), chalk = require("chalk"), index = require("./index.cjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), rimraf__default = /* @__PURE__ */ _interopDefaultCompat(rimraf), fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk);
function resolveBuildTasks(ctx) {
  const { config, cwd, pkg, target } = ctx, bundles = config?.bundles || [], tasks = [], exports2 = Object.entries(ctx.exports || {}).map(
    ([_path, exp]) => ({ _path, ...exp })
  ), dtsTask = {
    type: "build:dts",
    entries: []
  }, rollupTasks = {}, rollupLegacyTasks = {}, rollupReactCompilerTask = {
    type: "build:react-compiler",
    runtime: "browser",
    format: "esm",
    entries: [],
    target: target.browser
  };
  function addRollupTaskEntry(format, runtime, entry) {
    const buildId = `${format}:${runtime}`;
    rollupTasks[buildId] ? rollupTasks[buildId].entries.push(entry) : rollupTasks[buildId] = {
      type: "build:js",
      buildId,
      entries: [entry],
      runtime,
      format,
      target: target[runtime]
    };
  }
  function addRollupLegacyTaskEntry(runtime, entry) {
    const buildId = `esm:${runtime}`;
    rollupLegacyTasks[buildId] ? rollupLegacyTasks[buildId].entries.push(entry) : rollupLegacyTasks[buildId] = {
      type: "build:legacy",
      buildId,
      entries: [entry],
      runtime,
      format: "esm",
      // @TODO set a different target here that is compatible with legacy bundlers and testing tools like brownfield jest
      target: target[runtime]
    };
  }
  function addRollupReactCompilerTaskEntry(entry) {
    rollupReactCompilerTask.entries.push(entry);
  }
  for (const exp of exports2) {
    const importId = path__default.default.join(pkg.name, exp._path);
    exp.source?.endsWith(".ts") && dtsTask.entries.push({
      importId,
      exportPath: exp._path,
      sourcePath: exp.source,
      targetPaths: consoleSpy.getTargetPaths(pkg.type, exp)
    }), exp.browser?.source?.endsWith(".ts") && dtsTask.entries.push({
      importId,
      exportPath: exp._path,
      sourcePath: exp.browser.source,
      targetPaths: consoleSpy.getTargetPaths(pkg.type, exp.browser)
    }), exp.node?.source?.endsWith(".ts") && dtsTask.entries.push({
      importId,
      exportPath: exp._path,
      sourcePath: exp.node.source,
      targetPaths: consoleSpy.getTargetPaths(pkg.type, exp.node)
    });
  }
  for (const bundle of bundles)
    if (bundle.source?.endsWith(".ts")) {
      const exportPath = (bundle.import || bundle.require).replace(/\.[mc]?js$/, ""), importId = path__default.default.join(pkg.name, exportPath);
      dtsTask.entries.push({
        importId,
        exportPath,
        sourcePath: bundle.source,
        targetPaths: consoleSpy.getTargetPaths(pkg.type, bundle)
      });
    }
  if (dtsTask.entries.length && tasks.push(dtsTask), !ctx.emitDeclarationOnly) {
    for (const exp of exports2) {
      const output = exp.require;
      output && addRollupTaskEntry("commonjs", ctx.runtime, {
        path: exp._path,
        source: exp.source,
        output
      });
    }
    for (const exp of exports2) {
      const output = exp.import;
      output && addRollupTaskEntry("esm", ctx.runtime, {
        path: exp._path,
        source: exp.source,
        output
      });
    }
    for (const exp of exports2) {
      const output = exp.browser?.require;
      output && addRollupTaskEntry("commonjs", "browser", {
        path: exp._path,
        source: exp.browser?.source || exp.source,
        output
      });
    }
    for (const exp of exports2) {
      const output = exp.browser?.import;
      output && addRollupTaskEntry("esm", "browser", {
        path: exp._path,
        source: exp.browser?.source || exp.source,
        output
      });
    }
    for (const exp of exports2) {
      const output = exp["react-compiler"]?.default;
      output && addRollupReactCompilerTaskEntry({
        path: exp._path,
        source: exp["react-compiler"]?.source || exp.source,
        output
      });
    }
    if (rollupReactCompilerTask.entries.length && tasks.push(rollupReactCompilerTask), config?.legacyExports)
      for (const exp of exports2) {
        const runtime = exp.browser?.import ? "browser" : ctx.runtime, output = exp.browser?.import || exp.import;
        if (!output) continue;
        const legacyOutput = output.replace(consoleSpy.fileEnding, consoleSpy.legacyEnding);
        addRollupLegacyTaskEntry(runtime, {
          path: exp._path,
          source: exp.browser?.source || exp.source,
          output: legacyOutput
        });
      }
    for (const bundle of bundles) {
      const idx = bundles.indexOf(bundle);
      bundle.require && addRollupTaskEntry("commonjs", bundle.runtime || ctx.runtime, {
        path: `__$$bundle_cjs_${idx}$$__`,
        source: bundle.source,
        output: bundle.require
      }), bundle.import && addRollupTaskEntry("esm", bundle.runtime || ctx.runtime, {
        path: `__$$bundle_esm_${idx}$$__`,
        source: bundle.source,
        output: bundle.import
      });
    }
    if (tasks.push(...Object.values(rollupTasks), ...Object.values(rollupLegacyTasks)), config?.legacyExports) {
      for (const exp of exports2)
        if (exp._exported && exp._path !== ".") {
          const relativeTargetPath = (exp.browser?.import || exp.import || "").replace(consoleSpy.fileEnding, consoleSpy.legacyEnding).replace(/\.[^/.]+$/, "");
          relativeTargetPath && fs__default.default.writeFileSync(
            path__default.default.resolve(cwd, `${exp._path}.js`),
            ["// AUTO-GENERATED \u2013 DO NOT EDIT", `export * from '${relativeTargetPath}'`, ""].join(
              `
`
            )
          );
        }
    }
  }
  return tasks;
}
function createSpinner(msg) {
  const startTime = Date.now();
  return console.log(msg), {
    complete: () => {
      console.log(`${chalk__default.default.green("[success]")} ${chalk__default.default.gray(`${Date.now() - startTime}ms`)}`);
    },
    error: () => {
      console.log(`${chalk__default.default.red("[error]")} ${chalk__default.default.gray(`${Date.now() - startTime}ms`)}`);
    }
  };
}
async function build(options) {
  const {
    cwd,
    emitDeclarationOnly,
    strict = !1,
    tsconfig: tsconfigOption,
    clean = !1
  } = options, logger$1 = logger.createLogger(), config = await consoleSpy.loadConfig({ cwd }), legacyExports = config?.legacyExports ?? !1, pkg = await consoleSpy.loadPkgWithReporting({ cwd, logger: logger$1, strict, legacyExports }), tsconfig = tsconfigOption || config?.tsconfig || "tsconfig.json", ctx = await consoleSpy.resolveBuildContext({
    config,
    cwd,
    emitDeclarationOnly,
    logger: logger$1,
    pkg,
    strict,
    tsconfig
  });
  clean && (logger$1.log(
    `Deleting the \`dist\` folder: './${path__default.default.relative(cwd, ctx.distPath)}' before building...`
  ), await rimraf__default.default(ctx.distPath));
  const buildTasks = resolveBuildTasks(ctx);
  for (const task of buildTasks) {
    const handler = index.buildTaskHandlers[task.type], taskName = handler.name(ctx, task), spinner = createSpinner(taskName);
    try {
      const result = await handler.exec(ctx, task).toPromise();
      spinner.complete(), ctx.logger.log(), handler.complete(ctx, task, result);
    } catch (err) {
      if (spinner.error(), err instanceof Error) {
        const RE_CWD = new RegExp(`${cwd}`, "g");
        ctx.logger.error(err.message.replace(RE_CWD, ".")), ctx.logger.log();
      }
      handler.error(ctx, task, err), process.exit(1);
    }
  }
}
exports.build = build;
exports.resolveBuildTasks = resolveBuildTasks;
//# sourceMappingURL=build.cjs.map
