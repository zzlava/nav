{"version":3,"file":"generateAction.js","sources":["../../src/actions/typegen/generate.telemetry.ts","../../src/actions/typegen/generateAction.ts"],"sourcesContent":["import {defineTrace} from '@sanity/telemetry'\n\ninterface TypesGeneratedTraceAttrubutes {\n  outputSize: number\n  queriesCount: number\n  schemaTypesCount: number\n  queryFilesCount: number\n  filesWithErrors: number\n  typeNodesGenerated: number\n  unknownTypeNodesGenerated: number\n  unknownTypeNodesRatio: number\n  emptyUnionTypeNodesGenerated: number\n  configOverloadClientMethods: boolean\n}\n\nexport const TypesGeneratedTrace = defineTrace<TypesGeneratedTraceAttrubutes>({\n  name: 'Types Generated',\n  version: 0,\n  description: 'Trace emitted when generating TypeScript types for queries',\n})\n","import {constants, mkdir, open, stat} from 'node:fs/promises'\nimport {dirname, join} from 'node:path'\nimport {Worker} from 'node:worker_threads'\n\nimport {readConfig} from '@sanity/codegen'\nimport {format as prettierFormat, resolveConfig as resolvePrettierConfig} from 'prettier'\n\nimport {type CliCommandArguments, type CliCommandContext} from '../../types'\nimport {getCliWorkerPath} from '../../util/cliWorker'\nimport {\n  type TypegenGenerateTypesWorkerData,\n  type TypegenGenerateTypesWorkerMessage,\n} from '../../workers/typegenGenerate'\nimport {TypesGeneratedTrace} from './generate.telemetry'\n\nexport interface TypegenGenerateTypesCommandFlags {\n  'config-path'?: string\n}\n\nconst generatedFileWarning = `/**\n * ---------------------------------------------------------------------------------\n * This file has been generated by Sanity TypeGen.\n * Command: \\`sanity typegen generate\\`\n *\n * Any modifications made directly to this file will be overwritten the next time\n * the TypeScript definitions are generated. Please make changes to the Sanity\n * schema definitions and/or GROQ queries if you need to update these types.\n *\n * For more information on how to use Sanity TypeGen, visit the official documentation:\n * https://www.sanity.io/docs/sanity-typegen\n * ---------------------------------------------------------------------------------\n */\\n\\n`\n\nexport default async function typegenGenerateAction(\n  args: CliCommandArguments<TypegenGenerateTypesCommandFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const flags = args.extOptions\n  const {output, workDir, telemetry} = context\n\n  const trace = telemetry.trace(TypesGeneratedTrace)\n  trace.start()\n\n  const codegenConfig = await readConfig(flags['config-path'] || 'sanity-typegen.json')\n\n  try {\n    const schemaStats = await stat(codegenConfig.schema)\n    if (!schemaStats.isFile()) {\n      throw new Error(`Schema path is not a file: ${codegenConfig.schema}`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // If the user has not provided a specific schema path (eg we're using the default), give some help\n      const hint =\n        codegenConfig.schema === './schema.json' ? ` - did you run \"sanity schema extract\"?` : ''\n      throw new Error(`Schema file not found: ${codegenConfig.schema}${hint}`)\n    }\n    throw err\n  }\n\n  const outputPath = join(process.cwd(), codegenConfig.generates)\n  const outputDir = dirname(outputPath)\n  await mkdir(outputDir, {recursive: true})\n  const workerPath = await getCliWorkerPath('typegenGenerate')\n\n  const spinner = output.spinner({}).start('Generating types')\n\n  const worker = new Worker(workerPath, {\n    workerData: {\n      workDir,\n      schemaPath: codegenConfig.schema,\n      searchPath: codegenConfig.path,\n      overloadClientMethods: codegenConfig.overloadClientMethods,\n    } satisfies TypegenGenerateTypesWorkerData,\n    // eslint-disable-next-line no-process-env\n    env: process.env,\n  })\n\n  const typeFile = await open(\n    outputPath,\n    // eslint-disable-next-line no-bitwise\n    constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY,\n  )\n\n  typeFile.write(generatedFileWarning)\n\n  const stats = {\n    queryFilesCount: 0,\n    errors: 0,\n    queriesCount: 0,\n    schemaTypesCount: 0,\n    unknownTypeNodesGenerated: 0,\n    typeNodesGenerated: 0,\n    emptyUnionTypeNodesGenerated: 0,\n    size: 0,\n  }\n\n  await new Promise<void>((resolve, reject) => {\n    worker.addListener('message', (msg: TypegenGenerateTypesWorkerMessage) => {\n      if (msg.type === 'error') {\n        if (msg.fatal) {\n          trace.error(msg.error)\n          reject(msg.error)\n          return\n        }\n        const errorMessage = msg.filename\n          ? `${msg.error.message} in \"${msg.filename}\"`\n          : msg.error.message\n        spinner.fail(errorMessage)\n        stats.errors++\n        return\n      }\n      if (msg.type === 'complete') {\n        resolve()\n        return\n      }\n\n      if (msg.type === 'typemap') {\n        let typeMapStr = `// Query TypeMap\\n`\n        typeMapStr += msg.typeMap\n        typeFile.write(typeMapStr)\n        stats.size += Buffer.byteLength(typeMapStr)\n        return\n      }\n\n      let fileTypeString = `// Source: ${msg.filename}\\n`\n\n      if (msg.type === 'schema') {\n        stats.schemaTypesCount += msg.length\n        fileTypeString += msg.schema\n        typeFile.write(fileTypeString)\n        return\n      }\n\n      if (msg.type === 'types') {\n        stats.queryFilesCount++\n        for (const {\n          queryName,\n          query,\n          type,\n          typeNodesGenerated,\n          unknownTypeNodesGenerated,\n          emptyUnionTypeNodesGenerated,\n        } of msg.types) {\n          fileTypeString += `// Variable: ${queryName}\\n`\n          fileTypeString += `// Query: ${query.replace(/(\\r\\n|\\n|\\r)/gm, '').trim()}\\n`\n          fileTypeString += type\n          stats.queriesCount++\n          stats.typeNodesGenerated += typeNodesGenerated\n          stats.unknownTypeNodesGenerated += unknownTypeNodesGenerated\n          stats.emptyUnionTypeNodesGenerated += emptyUnionTypeNodesGenerated\n        }\n        typeFile.write(`${fileTypeString}\\n`)\n        stats.size += Buffer.byteLength(fileTypeString)\n      }\n    })\n    worker.addListener('error', reject)\n  })\n\n  await typeFile.close()\n\n  const prettierConfig = codegenConfig.formatGeneratedCode\n    ? await resolvePrettierConfig(outputPath).catch((err) => {\n        output.warn(`Failed to load prettier config: ${err.message}`)\n        return null\n      })\n    : null\n\n  if (prettierConfig) {\n    const formatFile = await open(outputPath, constants.O_RDWR)\n    try {\n      const code = await formatFile.readFile()\n      const formattedCode = await prettierFormat(code.toString(), {\n        ...prettierConfig,\n        parser: 'typescript' as const,\n      })\n      await formatFile.truncate()\n      await formatFile.write(formattedCode, 0)\n\n      spinner.info('Formatted generated types with Prettier')\n    } catch (err) {\n      output.warn(`Failed to format generated types with Prettier: ${err.message}`)\n    } finally {\n      await formatFile.close()\n    }\n  }\n\n  trace.log({\n    outputSize: stats.size,\n    queriesCount: stats.queriesCount,\n    schemaTypesCount: stats.schemaTypesCount,\n    queryFilesCount: stats.queryFilesCount,\n    filesWithErrors: stats.errors,\n    typeNodesGenerated: stats.typeNodesGenerated,\n    unknownTypeNodesGenerated: stats.unknownTypeNodesGenerated,\n    unknownTypeNodesRatio:\n      stats.typeNodesGenerated > 0 ? stats.unknownTypeNodesGenerated / stats.typeNodesGenerated : 0,\n    emptyUnionTypeNodesGenerated: stats.emptyUnionTypeNodesGenerated,\n    configOverloadClientMethods: codegenConfig.overloadClientMethods,\n  })\n\n  trace.complete()\n  if (stats.errors > 0) {\n    spinner.warn(`Encountered errors in ${stats.errors} files while generating types`)\n  }\n\n  spinner.succeed(\n    `Generated TypeScript types for ${stats.schemaTypesCount} schema types and ${stats.queriesCount} GROQ queries in ${stats.queryFilesCount} files into: ${codegenConfig.generates}`,\n  )\n}\n"],"names":["defineTrace","telemetry","readConfig","stat","join","dirname","mkdir","getCliWorkerPath","Worker","open","constants","resolvePrettierConfig","prettierFormat"],"mappings":";;AAeO,MAAM,sBAAsBA,UAAAA,YAA2C;AAAA,EAC5E,MAAM;AAAA,EACN,SAAS;AAAA,EACT,aAAa;AACf,CAAC,GCAK,uBAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcC,eAAA,sBAC5B,MACA,SACe;AACf,QAAM,QAAQ,KAAK,YACb,EAAC,QAAQ,SAAS,WAAAC,WAAS,IAAI,SAE/B,QAAQA,WAAU,MAAM,mBAAmB;AACjD,QAAM,MAAM;AAEZ,QAAM,gBAAgB,MAAMC,QAAA,WAAW,MAAM,aAAa,KAAK,qBAAqB;AAEhF,MAAA;AAEF,QAAI,EADgB,MAAMC,GAAA,KAAK,cAAc,MAAM,GAClC,OAAO;AACtB,YAAM,IAAI,MAAM,8BAA8B,cAAc,MAAM,EAAE;AAAA,WAE/D,KAAK;AACR,QAAA,IAAI,SAAS,UAAU;AAEzB,YAAM,OACJ,cAAc,WAAW,kBAAkB,4CAA4C;AACzF,YAAM,IAAI,MAAM,0BAA0B,cAAc,MAAM,GAAG,IAAI,EAAE;AAAA,IAAA;AAEnE,UAAA;AAAA,EAAA;AAGF,QAAA,aAAaC,KAAAA,KAAK,QAAQ,IAAI,GAAG,cAAc,SAAS,GACxD,YAAYC,KAAA,QAAQ,UAAU;AACpC,QAAMC,GAAM,MAAA,WAAW,EAAC,WAAW,IAAK;AACxC,QAAM,aAAa,MAAMC,UAAA,iBAAiB,iBAAiB,GAErD,UAAU,OAAO,QAAQ,CAAA,CAAE,EAAE,MAAM,kBAAkB,GAErD,SAAS,IAAIC,2BAAO,YAAY;AAAA,IACpC,YAAY;AAAA,MACV;AAAA,MACA,YAAY,cAAc;AAAA,MAC1B,YAAY,cAAc;AAAA,MAC1B,uBAAuB,cAAc;AAAA,IACvC;AAAA;AAAA,IAEA,KAAK,QAAQ;AAAA,EAAA,CACd,GAEK,WAAW,MAAMC,GAAA;AAAA,IACrB;AAAA;AAAA,IAEAC,GAAAA,UAAU,UAAUA,aAAU,UAAUA,GAAAA,UAAU;AAAA,EACpD;AAEA,WAAS,MAAM,oBAAoB;AAEnC,QAAM,QAAQ;AAAA,IACZ,iBAAiB;AAAA,IACjB,QAAQ;AAAA,IACR,cAAc;AAAA,IACd,kBAAkB;AAAA,IAClB,2BAA2B;AAAA,IAC3B,oBAAoB;AAAA,IACpB,8BAA8B;AAAA,IAC9B,MAAM;AAAA,EACR;AAEA,QAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AACpC,WAAA,YAAY,WAAW,CAAC,QAA2C;AACpE,UAAA,IAAI,SAAS,SAAS;AACxB,YAAI,IAAI,OAAO;AACb,gBAAM,MAAM,IAAI,KAAK,GACrB,OAAO,IAAI,KAAK;AAChB;AAAA,QAAA;AAEF,cAAM,eAAe,IAAI,WACrB,GAAG,IAAI,MAAM,OAAO,QAAQ,IAAI,QAAQ,MACxC,IAAI,MAAM;AACN,gBAAA,KAAK,YAAY,GACzB,MAAM;AACN;AAAA,MAAA;AAEE,UAAA,IAAI,SAAS,YAAY;AACnB,gBAAA;AACR;AAAA,MAAA;AAGE,UAAA,IAAI,SAAS,WAAW;AAC1B,YAAI,aAAa;AAAA;AACH,sBAAA,IAAI,SAClB,SAAS,MAAM,UAAU,GACzB,MAAM,QAAQ,OAAO,WAAW,UAAU;AAC1C;AAAA,MAAA;AAGE,UAAA,iBAAiB,cAAc,IAAI,QAAQ;AAAA;AAE3C,UAAA,IAAI,SAAS,UAAU;AACnB,cAAA,oBAAoB,IAAI,QAC9B,kBAAkB,IAAI,QACtB,SAAS,MAAM,cAAc;AAC7B;AAAA,MAAA;AAGE,UAAA,IAAI,SAAS,SAAS;AAClB,cAAA;AACK,mBAAA;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,aACG,IAAI;AACP,4BAAkB,gBAAgB,SAAS;AAAA,GAC3C,kBAAkB,aAAa,MAAM,QAAQ,kBAAkB,EAAE,EAAE,KAAM,CAAA;AAAA,GACzE,kBAAkB,MAClB,MAAM,gBACN,MAAM,sBAAsB,oBAC5B,MAAM,6BAA6B,2BACnC,MAAM,gCAAgC;AAE/B,iBAAA,MAAM,GAAG,cAAc;AAAA,CAAI,GACpC,MAAM,QAAQ,OAAO,WAAW,cAAc;AAAA,MAAA;AAAA,IAEjD,CAAA,GACD,OAAO,YAAY,SAAS,MAAM;AAAA,EAAA,CACnC,GAED,MAAM,SAAS,MAAM;AAErB,QAAM,iBAAiB,cAAc,sBACjC,MAAMC,SAAsB,cAAA,UAAU,EAAE,MAAM,CAAC,SAC7C,OAAO,KAAK,mCAAmC,IAAI,OAAO,EAAE,GACrD,KACR,IACD;AAEJ,MAAI,gBAAgB;AAClB,UAAM,aAAa,MAAMF,GAAAA,KAAK,YAAYC,GAAAA,UAAU,MAAM;AACtD,QAAA;AACI,YAAA,OAAO,MAAM,WAAW,SAAS,GACjC,gBAAgB,MAAME,SAAA,OAAe,KAAK,YAAY;AAAA,QAC1D,GAAG;AAAA,QACH,QAAQ;AAAA,MAAA,CACT;AACK,YAAA,WAAW,YACjB,MAAM,WAAW,MAAM,eAAe,CAAC,GAEvC,QAAQ,KAAK,yCAAyC;AAAA,aAC/C,KAAK;AACZ,aAAO,KAAK,mDAAmD,IAAI,OAAO,EAAE;AAAA,IAAA,UAC5E;AACA,YAAM,WAAW,MAAM;AAAA,IAAA;AAAA,EACzB;AAGF,QAAM,IAAI;AAAA,IACR,YAAY,MAAM;AAAA,IAClB,cAAc,MAAM;AAAA,IACpB,kBAAkB,MAAM;AAAA,IACxB,iBAAiB,MAAM;AAAA,IACvB,iBAAiB,MAAM;AAAA,IACvB,oBAAoB,MAAM;AAAA,IAC1B,2BAA2B,MAAM;AAAA,IACjC,uBACE,MAAM,qBAAqB,IAAI,MAAM,4BAA4B,MAAM,qBAAqB;AAAA,IAC9F,8BAA8B,MAAM;AAAA,IACpC,6BAA6B,cAAc;AAAA,EAAA,CAC5C,GAED,MAAM,SAAA,GACF,MAAM,SAAS,KACjB,QAAQ,KAAK,yBAAyB,MAAM,MAAM,+BAA+B,GAGnF,QAAQ;AAAA,IACN,kCAAkC,MAAM,gBAAgB,qBAAqB,MAAM,YAAY,oBAAoB,MAAM,eAAe,gBAAgB,cAAc,SAAS;AAAA,EACjL;AACF;;"}