"use strict";
var fs$1 = require("node:fs"), os = require("node:os"), path$3 = require("node:path"), chalk = require("chalk"), loadEnv = require("./loadEnv.js"), require$$0$4 = require("path"), require$$1$2 = require("module"), require$$0$5 = require("fs"), telemetry = require("@sanity/telemetry"), childProcess = require("node:child_process"), fs = require("node:fs/promises"), util$4 = require("node:util"), require$$0$6 = require("os"), require$$0$c = require("url"), require$$1$3 = require("get-it"), require$$2$1 = require("get-it/middleware"), require$$0$7 = require("constants"), require$$0$8 = require("stream"), require$$0$a = require("util"), require$$0$9 = require("assert"), require$$0$b = require("events"), require$$6$1 = require("http"), semver = require("semver"), pkgDir = require("pkg-dir"), client$1 = require("@sanity/client"), require$$3$1 = require("crypto"), require$$1$4 = require("child_process"), require$$0$d = require("fs/promises"), require$$0$e = require("buffer"), getCliConfig = require("./getCliConfig.js"), journeyConfig = require("./journeyConfig.js"), Stream = require("node:stream"), promises$1 = require("node:stream/promises"), templateValidator = require("@sanity/template-validator"), require$$2$2 = require("string_decoder"), require$$0$f = require("zlib"), require$$7$1 = require("process"), http = require("node:http"), traverse = require("@babel/traverse"), node_url = require("node:url"), node_events = require("node:events"), node_string_decoder = require("node:string_decoder"), process$2 = require("node:process"), require$$2$3 = require("readline"), require$$0$g = require("tty");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e) return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  return m.forEach(function(e) {
    e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: !0,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }), Object.freeze(n);
}
var fs__namespace = /* @__PURE__ */ _interopNamespaceCompat(fs$1), os__default = /* @__PURE__ */ _interopDefaultCompat(os), path__default = /* @__PURE__ */ _interopDefaultCompat(path$3), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0$4), require$$1__default = /* @__PURE__ */ _interopDefaultCompat(require$$1$2), require$$0__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$0$5), childProcess__default = /* @__PURE__ */ _interopDefaultCompat(childProcess), fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), util__default = /* @__PURE__ */ _interopDefaultCompat(util$4), require$$0__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$0$6), require$$0__default$8 = /* @__PURE__ */ _interopDefaultCompat(require$$0$c), require$$1__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$1$3), require$$2__default = /* @__PURE__ */ _interopDefaultCompat(require$$2$1), require$$0__default$3 = /* @__PURE__ */ _interopDefaultCompat(require$$0$7), require$$0__default$4 = /* @__PURE__ */ _interopDefaultCompat(require$$0$8), require$$0__default$6 = /* @__PURE__ */ _interopDefaultCompat(require$$0$a), require$$0__default$5 = /* @__PURE__ */ _interopDefaultCompat(require$$0$9), require$$0__default$7 = /* @__PURE__ */ _interopDefaultCompat(require$$0$b), require$$6__default = /* @__PURE__ */ _interopDefaultCompat(require$$6$1), semver__default = /* @__PURE__ */ _interopDefaultCompat(semver), pkgDir__default = /* @__PURE__ */ _interopDefaultCompat(pkgDir), require$$3__default = /* @__PURE__ */ _interopDefaultCompat(require$$3$1), require$$1__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$1$4), require$$0__default$9 = /* @__PURE__ */ _interopDefaultCompat(require$$0$d), require$$0__default$a = /* @__PURE__ */ _interopDefaultCompat(require$$0$e), Stream__default = /* @__PURE__ */ _interopDefaultCompat(Stream), require$$2__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$2$2), require$$0__default$b = /* @__PURE__ */ _interopDefaultCompat(require$$0$f), require$$7__default = /* @__PURE__ */ _interopDefaultCompat(require$$7$1), http__default = /* @__PURE__ */ _interopDefaultCompat(http), traverse__default = /* @__PURE__ */ _interopDefaultCompat(traverse), process__default = /* @__PURE__ */ _interopDefaultCompat(process$2), require$$2__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$2$3), require$$0__default$c = /* @__PURE__ */ _interopDefaultCompat(require$$0$g), resolveFrom$1 = { exports: {} }, hasRequiredResolveFrom;
function requireResolveFrom() {
  if (hasRequiredResolveFrom) return resolveFrom$1.exports;
  hasRequiredResolveFrom = 1;
  const path2 = require$$0__default.default, Module = require$$1__default.default, fs2 = require$$0__default$1.default, resolveFrom2 = (fromDirectory, moduleId, silent) => {
    if (typeof fromDirectory != "string")
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    if (typeof moduleId != "string")
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    try {
      fromDirectory = fs2.realpathSync(fromDirectory);
    } catch (error2) {
      if (error2.code === "ENOENT")
        fromDirectory = path2.resolve(fromDirectory);
      else {
        if (silent)
          return;
        throw error2;
      }
    }
    const fromFile = path2.join(fromDirectory, "noop.js"), resolveFileName = () => Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDirectory)
    });
    if (silent)
      try {
        return resolveFileName();
      } catch {
        return;
      }
    return resolveFileName();
  };
  return resolveFrom$1.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId), resolveFrom$1.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, !0), resolveFrom$1.exports;
}
var resolveFromExports = requireResolveFrom(), resolveFrom = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(resolveFromExports);
const CliCommand = telemetry.defineTrace({
  name: "CLI Command Executed",
  version: 1,
  description: "A CLI command was executed"
});
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports, hasRequiredLodash;
function requireLodash() {
  return hasRequiredLodash || (hasRequiredLodash = 1, function(module2, exports2) {
    (function() {
      var undefined$1, VERSION = "4.17.21", LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrimStart = /^\s+/, reWhitespace = /\s/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], templateCounter = -1, typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
      var deburredLetters = {
        // Latin-1 Supplement block.
        \u00C0: "A",
        \u00C1: "A",
        \u00C2: "A",
        \u00C3: "A",
        \u00C4: "A",
        \u00C5: "A",
        \u00E0: "a",
        \u00E1: "a",
        \u00E2: "a",
        \u00E3: "a",
        \u00E4: "a",
        \u00E5: "a",
        \u00C7: "C",
        \u00E7: "c",
        \u00D0: "D",
        \u00F0: "d",
        \u00C8: "E",
        \u00C9: "E",
        \u00CA: "E",
        \u00CB: "E",
        \u00E8: "e",
        \u00E9: "e",
        \u00EA: "e",
        \u00EB: "e",
        \u00CC: "I",
        \u00CD: "I",
        \u00CE: "I",
        \u00CF: "I",
        \u00EC: "i",
        \u00ED: "i",
        \u00EE: "i",
        \u00EF: "i",
        \u00D1: "N",
        \u00F1: "n",
        \u00D2: "O",
        \u00D3: "O",
        \u00D4: "O",
        \u00D5: "O",
        \u00D6: "O",
        \u00D8: "O",
        \u00F2: "o",
        \u00F3: "o",
        \u00F4: "o",
        \u00F5: "o",
        \u00F6: "o",
        \u00F8: "o",
        \u00D9: "U",
        \u00DA: "U",
        \u00DB: "U",
        \u00DC: "U",
        \u00F9: "u",
        \u00FA: "u",
        \u00FB: "u",
        \u00FC: "u",
        \u00DD: "Y",
        \u00FD: "y",
        \u00FF: "y",
        \u00C6: "Ae",
        \u00E6: "ae",
        \u00DE: "Th",
        \u00FE: "th",
        \u00DF: "ss",
        // Latin Extended-A block.
        \u0100: "A",
        \u0102: "A",
        \u0104: "A",
        \u0101: "a",
        \u0103: "a",
        \u0105: "a",
        \u0106: "C",
        \u0108: "C",
        \u010A: "C",
        \u010C: "C",
        \u0107: "c",
        \u0109: "c",
        \u010B: "c",
        \u010D: "c",
        \u010E: "D",
        \u0110: "D",
        \u010F: "d",
        \u0111: "d",
        \u0112: "E",
        \u0114: "E",
        \u0116: "E",
        \u0118: "E",
        \u011A: "E",
        \u0113: "e",
        \u0115: "e",
        \u0117: "e",
        \u0119: "e",
        \u011B: "e",
        \u011C: "G",
        \u011E: "G",
        \u0120: "G",
        \u0122: "G",
        \u011D: "g",
        \u011F: "g",
        \u0121: "g",
        \u0123: "g",
        \u0124: "H",
        \u0126: "H",
        \u0125: "h",
        \u0127: "h",
        \u0128: "I",
        \u012A: "I",
        \u012C: "I",
        \u012E: "I",
        \u0130: "I",
        \u0129: "i",
        \u012B: "i",
        \u012D: "i",
        \u012F: "i",
        \u0131: "i",
        \u0134: "J",
        \u0135: "j",
        \u0136: "K",
        \u0137: "k",
        \u0138: "k",
        \u0139: "L",
        \u013B: "L",
        \u013D: "L",
        \u013F: "L",
        \u0141: "L",
        \u013A: "l",
        \u013C: "l",
        \u013E: "l",
        \u0140: "l",
        \u0142: "l",
        \u0143: "N",
        \u0145: "N",
        \u0147: "N",
        \u014A: "N",
        \u0144: "n",
        \u0146: "n",
        \u0148: "n",
        \u014B: "n",
        \u014C: "O",
        \u014E: "O",
        \u0150: "O",
        \u014D: "o",
        \u014F: "o",
        \u0151: "o",
        \u0154: "R",
        \u0156: "R",
        \u0158: "R",
        \u0155: "r",
        \u0157: "r",
        \u0159: "r",
        \u015A: "S",
        \u015C: "S",
        \u015E: "S",
        \u0160: "S",
        \u015B: "s",
        \u015D: "s",
        \u015F: "s",
        \u0161: "s",
        \u0162: "T",
        \u0164: "T",
        \u0166: "T",
        \u0163: "t",
        \u0165: "t",
        \u0167: "t",
        \u0168: "U",
        \u016A: "U",
        \u016C: "U",
        \u016E: "U",
        \u0170: "U",
        \u0172: "U",
        \u0169: "u",
        \u016B: "u",
        \u016D: "u",
        \u016F: "u",
        \u0171: "u",
        \u0173: "u",
        \u0174: "W",
        \u0175: "w",
        \u0176: "Y",
        \u0177: "y",
        \u0178: "Y",
        \u0179: "Z",
        \u017B: "Z",
        \u017D: "Z",
        \u017A: "z",
        \u017C: "z",
        \u017E: "z",
        \u0132: "IJ",
        \u0133: "ij",
        \u0152: "Oe",
        \u0153: "oe",
        \u0149: "'n",
        \u017F: "s"
      }, htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = typeof loadEnv.commonjsGlobal == "object" && loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.Object === Object && loadEnv.commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root2 = freeGlobal || freeSelf || Function("return this")(), freeExports = exports2 && !exports2.nodeType && exports2, freeModule = freeExports && !0 && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch {
        }
      }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; ) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length && iteratee(array[index], index, array) !== !1; )
          ;
        return array;
      }
      function arrayEachRight(array, iteratee) {
        for (var length = array == null ? 0 : array.length; length-- && iteratee(array[length], length, array) !== !1; )
          ;
        return array;
      }
      function arrayEvery(array, predicate) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
          if (!predicate(array[index], index, array))
            return !1;
        return !0;
      }
      function arrayFilter(array, predicate) {
        for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index];
          predicate(value, index, array) && (result[resIndex++] = value);
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
          if (comparator(value, array[index]))
            return !0;
        return !1;
      }
      function arrayMap(array, iteratee) {
        for (var index = -1, length = array == null ? 0 : array.length, result = Array(length); ++index < length; )
          result[index] = iteratee(array[index], index, array);
        return result;
      }
      function arrayPush(array, values) {
        for (var index = -1, length = values.length, offset = array.length; ++index < length; )
          array[offset + index] = values[index];
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        for (initAccum && length && (accumulator = array[++index]); ++index < length; )
          accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        for (initAccum && length && (accumulator = array[--length]); length--; )
          accumulator = iteratee(accumulator, array[length], length, array);
        return accumulator;
      }
      function arraySome(array, predicate) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
          if (predicate(array[index], index, array))
            return !0;
        return !1;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        return eachFunc(collection, function(value, key2, collection2) {
          if (predicate(value, key2, collection2))
            return result = key2, !1;
        }), result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
          if (predicate(array[index], index, array))
            return index;
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; )
          if (comparator(array[index], value))
            return index;
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key2) {
        return function(object) {
          return object == null ? undefined$1 : object[key2];
        };
      }
      function basePropertyOf(object) {
        return function(key2) {
          return object == null ? undefined$1 : object[key2];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        return eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection2);
        }), accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        for (array.sort(comparer); length--; )
          array[length] = array[length].value;
        return array;
      }
      function baseSum(array, iteratee) {
        for (var result, index = -1, length = array.length; ++index < length; ) {
          var current = iteratee(array[index]);
          current !== undefined$1 && (result = result === undefined$1 ? current : result + current);
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        for (var index = -1, result = Array(n); ++index < n; )
          result[index] = iteratee(index);
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key2) {
          return [key2, object[key2]];
        });
      }
      function baseTrim(string) {
        return string && string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "");
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key2) {
          return object[key2];
        });
      }
      function cacheHas(cache, key2) {
        return cache.has(key2);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
          ;
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
          ;
        return index;
      }
      function countHolders(array, placeholder) {
        for (var length = array.length, result = 0; length--; )
          array[length] === placeholder && ++result;
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key2) {
        return object == null ? undefined$1 : object[key2];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator2) {
        for (var data, result = []; !(data = iterator2.next()).done; )
          result.push(data.value);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        return map2.forEach(function(value, key2) {
          result[++index] = [key2, value];
        }), result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index];
          (value === placeholder || value === PLACEHOLDER) && (array[index] = PLACEHOLDER, result[resIndex++] = index);
        }
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        return set2.forEach(function(value) {
          result[++index] = value;
        }), result;
      }
      function setToPairs(set2) {
        var index = -1, result = Array(set2.size);
        return set2.forEach(function(value) {
          result[++index] = [value, value];
        }), result;
      }
      function strictIndexOf(array, value, fromIndex) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; )
          if (array[index] === value)
            return index;
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        for (var index = fromIndex + 1; index--; )
          if (array[index] === value)
            return index;
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); )
          ;
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); )
          ++result;
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError, arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty2 = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object2), oldDash = root2._, reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1, defineProperty2 = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            return func({}, "", {}), func;
          } catch {
          }
        }(), ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout, nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create"), metaMap = WeakMap2 && new WeakMap2(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper)
              return value;
            if (hasOwnProperty2.call(value, "__wrapped__"))
              return wrapperClone(value);
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto))
              return {};
            if (objectCreate)
              return objectCreate(proto);
            object.prototype = proto;
            var result2 = new object();
            return object.prototype = undefined$1, result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: lodash2
          }
        }, lodash2.prototype = baseLodash.prototype, lodash2.prototype.constructor = lodash2, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          return result2.__actions__ = copyArray(this.__actions__), result2.__dir__ = this.__dir__, result2.__filtered__ = this.__filtered__, result2.__iteratees__ = copyArray(this.__iteratees__), result2.__takeCount__ = this.__takeCount__, result2.__views__ = copyArray(this.__views__), result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1, result2.__filtered__ = !0;
          } else
            result2 = this.clone(), result2.__dir__ *= -1;
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length)
            return baseWrapperValue(array, this.__actions__);
          var result2 = [];
          outer:
            for (; length-- && resIndex < takeCount; ) {
              index += dir;
              for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength; ) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG)
                  value = computed;
                else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG)
                    continue outer;
                  break outer;
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          for (this.clear(); ++index < length; ) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
        }
        function hashDelete(key2) {
          var result2 = this.has(key2) && delete this.__data__[key2];
          return this.size -= result2 ? 1 : 0, result2;
        }
        function hashGet(key2) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key2];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key2) ? data[key2] : undefined$1;
        }
        function hashHas(key2) {
          var data = this.__data__;
          return nativeCreate ? data[key2] !== undefined$1 : hasOwnProperty2.call(data, key2);
        }
        function hashSet(key2, value) {
          var data = this.__data__;
          return this.size += this.has(key2) ? 0 : 1, data[key2] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value, this;
        }
        Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          for (this.clear(); ++index < length; ) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [], this.size = 0;
        }
        function listCacheDelete(key2) {
          var data = this.__data__, index = assocIndexOf(data, key2);
          if (index < 0)
            return !1;
          var lastIndex = data.length - 1;
          return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
        }
        function listCacheGet(key2) {
          var data = this.__data__, index = assocIndexOf(data, key2);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key2) {
          return assocIndexOf(this.__data__, key2) > -1;
        }
        function listCacheSet(key2, value) {
          var data = this.__data__, index = assocIndexOf(data, key2);
          return index < 0 ? (++this.size, data.push([key2, value])) : data[index][1] = value, this;
        }
        ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          for (this.clear(); ++index < length; ) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0, this.__data__ = {
            hash: new Hash(),
            map: new (Map2 || ListCache)(),
            string: new Hash()
          };
        }
        function mapCacheDelete(key2) {
          var result2 = getMapData(this, key2).delete(key2);
          return this.size -= result2 ? 1 : 0, result2;
        }
        function mapCacheGet(key2) {
          return getMapData(this, key2).get(key2);
        }
        function mapCacheHas(key2) {
          return getMapData(this, key2).has(key2);
        }
        function mapCacheSet(key2, value) {
          var data = getMapData(this, key2), size2 = data.size;
          return data.set(key2, value), this.size += data.size == size2 ? 0 : 1, this;
        }
        MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          for (this.__data__ = new MapCache(); ++index < length; )
            this.add(values2[index]);
        }
        function setCacheAdd(value) {
          return this.__data__.set(value, HASH_UNDEFINED), this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache(), this.size = 0;
        }
        function stackDelete(key2) {
          var data = this.__data__, result2 = data.delete(key2);
          return this.size = data.size, result2;
        }
        function stackGet(key2) {
          return this.__data__.get(key2);
        }
        function stackHas(key2) {
          return this.__data__.has(key2);
        }
        function stackSet(key2, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs2 = data.__data__;
            if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1)
              return pairs2.push([key2, value]), this.size = ++data.size, this;
            data = this.__data__ = new MapCache(pairs2);
          }
          return data.set(key2, value), this.size = data.size, this;
        }
        Stack2.prototype.clear = stackClear, Stack2.prototype.delete = stackDelete, Stack2.prototype.get = stackGet, Stack2.prototype.has = stackHas, Stack2.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key2 in value)
            (inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
            isIndex(key2, length))) && result2.push(key2);
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key2, value) {
          (value !== undefined$1 && !eq(object[key2], value) || value === undefined$1 && !(key2 in object)) && baseAssignValue(object, key2, value);
        }
        function assignValue(object, key2, value) {
          var objValue = object[key2];
          (!(hasOwnProperty2.call(object, key2) && eq(objValue, value)) || value === undefined$1 && !(key2 in object)) && baseAssignValue(object, key2, value);
        }
        function assocIndexOf(array, key2) {
          for (var length = array.length; length--; )
            if (eq(array[length][0], key2))
              return length;
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          return baseEach(collection, function(value, key2, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          }), accumulator;
        }
        function baseAssign(object, source2) {
          return object && copyObject(source2, keys(source2), object);
        }
        function baseAssignIn(object, source2) {
          return object && copyObject(source2, keysIn(source2), object);
        }
        function baseAssignValue(object, key2, value) {
          key2 == "__proto__" && defineProperty2 ? defineProperty2(object, key2, {
            configurable: !0,
            enumerable: !0,
            value,
            writable: !0
          }) : object[key2] = value;
        }
        function baseAt(object, paths) {
          for (var index = -1, length = paths.length, result2 = Array2(length), skip2 = object == null; ++index < length; )
            result2[index] = skip2 ? undefined$1 : get(object, paths[index]);
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          return number2 === number2 && (upper !== undefined$1 && (number2 = number2 <= upper ? number2 : upper), lower !== undefined$1 && (number2 = number2 >= lower ? number2 : lower)), number2;
        }
        function baseClone(value, bitmask, customizer, key2, object, stack2) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer && (result2 = object ? customizer(value, key2, object, stack2) : customizer(value)), result2 !== undefined$1)
            return result2;
          if (!isObject2(value))
            return value;
          var isArr = isArray2(value);
          if (isArr) {
            if (result2 = initCloneArray(value), !isDeep)
              return copyArray(value, result2);
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value))
              return cloneBuffer(value, isDeep);
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              if (result2 = isFlat || isFunc ? {} : initCloneObject(value), !isDeep)
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            } else {
              if (!cloneableTags[tag])
                return object ? value : {};
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack2 || (stack2 = new Stack2());
          var stacked = stack2.get(value);
          if (stacked)
            return stacked;
          stack2.set(value, result2), isSet(value) ? value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
          }) : isMap(value) && value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
          });
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined$1 : keysFunc(value);
          return arrayEach(props || value, function(subValue, key3) {
            props && (key3 = subValue, subValue = value[key3]), assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
          }), result2;
        }
        function baseConforms(source2) {
          var props = keys(source2);
          return function(object) {
            return baseConformsTo(object, source2, props);
          };
        }
        function baseConformsTo(object, source2, props) {
          var length = props.length;
          if (object == null)
            return !length;
          for (object = Object2(object); length--; ) {
            var key2 = props[length], predicate = source2[key2], value = object[key2];
            if (value === undefined$1 && !(key2 in object) || !predicate(value))
              return !1;
          }
          return !0;
        }
        function baseDelay(func, wait2, args) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait2);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = !0, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length)
            return result2;
          iteratee2 && (values2 = arrayMap(values2, baseUnary(iteratee2))), comparator ? (includes2 = arrayIncludesWith, isCommon = !1) : values2.length >= LARGE_ARRAY_SIZE && (includes2 = cacheHas, isCommon = !1, values2 = new SetCache(values2));
          outer:
            for (; ++index < length; ) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
                for (var valuesIndex = valuesLength; valuesIndex--; )
                  if (values2[valuesIndex] === computed)
                    continue outer;
                result2.push(value);
              } else includes2(values2, computed, comparator) || result2.push(value);
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0);
        function baseEvery(collection, predicate) {
          var result2 = !0;
          return baseEach(collection, function(value, index, collection2) {
            return result2 = !!predicate(value, index, collection2), result2;
          }), result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          for (var index = -1, length = array.length; ++index < length; ) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed)))
              var computed = current, result2 = value;
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start), end = end === undefined$1 || end > length ? length : toInteger(end), end < 0 && (end += length), end = start > end ? 0 : toLength(end); start < end; )
            array[start++] = value;
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          return baseEach(collection, function(value, index, collection2) {
            predicate(value, index, collection2) && result2.push(value);
          }), result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          for (predicate || (predicate = isFlattenable), result2 || (result2 = []); ++index < length; ) {
            var value = array[index];
            depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result2) : arrayPush(result2, value) : isStrict || (result2[result2.length] = value);
          }
          return result2;
        }
        var baseFor = createBaseFor(), baseForRight = createBaseFor(!0);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key2) {
            return isFunction2(object[key2]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          for (var index = 0, length = path2.length; object != null && index < length; )
            object = object[toKey(path2[index++])];
          return index && index == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          return value == null ? value === undefined$1 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key2) {
          return object != null && hasOwnProperty2.call(object, key2);
        }
        function baseHasIn(object, key2) {
          return object != null && key2 in Object2(object);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          for (var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = 1 / 0, result2 = []; othIndex--; ) {
            var array = arrays[othIndex];
            othIndex && iteratee2 && (array = arrayMap(array, baseUnary(iteratee2))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            for (; ++index < length && result2.length < maxLength; ) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (value = comparator || value !== 0 ? value : 0, !(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                for (othIndex = othLength; --othIndex; ) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator)))
                    continue outer;
                }
                seen && seen.push(computed), result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          return baseForOwn(object, function(value, key2, object2) {
            setter(accumulator, iteratee2(value), key2, object2);
          }), accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object), object = parent(object, path2);
          var func = object == null ? object : object[toKey(last2(path2))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack2) {
          return value === other ? !0 : value == null || other == null || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other))
              return !1;
            objIsArr = !0, objIsObj = !1;
          }
          if (isSameTag && !objIsObj)
            return stack2 || (stack2 = new Stack2()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              return stack2 || (stack2 = new Stack2()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
            }
          }
          return isSameTag ? (stack2 || (stack2 = new Stack2()), equalObjects(object, other, bitmask, customizer, equalFunc, stack2)) : !1;
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source2, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null)
            return !length;
          for (object = Object2(object); index--; ) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))
              return !1;
          }
          for (; ++index < length; ) {
            data = matchData[index];
            var key2 = data[0], objValue = object[key2], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key2 in object))
                return !1;
            } else {
              var stack2 = new Stack2();
              if (customizer)
                var result2 = customizer(objValue, srcValue, key2, object, source2, stack2);
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2))
                return !1;
            }
          }
          return !0;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value))
            return !1;
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          return typeof value == "function" ? value : value == null ? identity2 : typeof value == "object" ? isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object))
            return nativeKeys(object);
          var result2 = [];
          for (var key2 in Object2(object))
            hasOwnProperty2.call(object, key2) && key2 != "constructor" && result2.push(key2);
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object))
            return nativeKeysIn(object);
          var isProto = isPrototype(object), result2 = [];
          for (var key2 in object)
            key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)) || result2.push(key2);
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          return baseEach(collection, function(value, key2, collection2) {
            result2[++index] = iteratee2(value, key2, collection2);
          }), result2;
        }
        function baseMatches(source2) {
          var matchData = getMatchData(source2);
          return matchData.length == 1 && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
            return object === source2 || baseIsMatch(object, source2, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          return isKey(path2) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path2), srcValue) : function(object) {
            var objValue = get(object, path2);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source2, srcIndex, customizer, stack2) {
          object !== source2 && baseFor(source2, function(srcValue, key2) {
            if (stack2 || (stack2 = new Stack2()), isObject2(srcValue))
              baseMergeDeep(object, source2, key2, srcIndex, baseMerge, customizer, stack2);
            else {
              var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source2, stack2) : undefined$1;
              newValue === undefined$1 && (newValue = srcValue), assignMergeValue(object, key2, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source2, key2, srcIndex, mergeFunc, customizer, stack2) {
          var objValue = safeGet(object, key2), srcValue = safeGet(source2, key2), stacked = stack2.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key2, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source2, stack2) : undefined$1, isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue, isArr || isBuff || isTyped ? isArray2(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject2(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject2(objValue) || isFunction2(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
          }
          isCommon && (stack2.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack2), stack2.delete(srcValue)), assignMergeValue(object, key2, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (length)
            return n += n < 0 ? length : 0, isIndex(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          iteratees.length ? iteratees = arrayMap(iteratees, function(iteratee2) {
            return isArray2(iteratee2) ? function(value) {
              return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
            } : iteratee2;
          }) : iteratees = [identity2];
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key2, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { criteria, index: ++index, value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          for (var index = -1, length = paths.length, result2 = {}; ++index < length; ) {
            var path2 = paths[index], value = baseGet(object, path2);
            predicate(value, path2) && baseSet(result2, castPath(path2, object), value);
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          for (array === values2 && (values2 = copyArray(values2)), iteratee2 && (seen = arrayMap(array, baseUnary(iteratee2))); ++index < length; )
            for (var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value; (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1; )
              seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
          return array;
        }
        function basePullAt(array, indexes) {
          for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length); length--; )
            result2[fromRight ? length : ++index] = start, start += step;
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER)
            return result2;
          do
            n % 2 && (result2 += string), n = nativeFloor(n / 2), n && (string += string);
          while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path2, value, customizer) {
          if (!isObject2(object))
            return object;
          path2 = castPath(path2, object);
          for (var index = -1, length = path2.length, lastIndex = length - 1, nested = object; nested != null && ++index < length; ) {
            var key2 = toKey(path2[index]), newValue = value;
            if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype")
              return object;
            if (index != lastIndex) {
              var objValue = nested[key2];
              newValue = customizer ? customizer(objValue, key2, nested) : undefined$1, newValue === undefined$1 && (newValue = isObject2(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {});
            }
            assignValue(nested, key2, newValue), nested = nested[key2];
          }
          return object;
        }
        var baseSetData = metaMap ? function(func, data) {
          return metaMap.set(func, data), func;
        } : identity2, baseSetToString = defineProperty2 ? function(func, string) {
          return defineProperty2(func, "toString", {
            configurable: !0,
            enumerable: !1,
            value: constant(string),
            writable: !0
          });
        } : identity2;
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
          for (var result2 = Array2(length); ++index < length; )
            result2[index] = array[index + start];
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          return baseEach(collection, function(value, index, collection2) {
            return result2 = predicate(value, index, collection2), !result2;
          }), !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            for (; low < high; ) {
              var mid = low + high >>> 1, computed = array[mid];
              computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0)
            return 0;
          value = iteratee2(value);
          for (var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1; low < high; ) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN)
              var setLow = retHighest || othIsReflexive;
            else valIsUndefined ? setLow = othIsReflexive && (retHighest || othIsDefined) : valIsNull ? setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? setLow = !1 : setLow = retHighest ? computed <= value : computed < value;
            setLow ? low = mid + 1 : high = mid;
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          for (var index = -1, length = array.length, resIndex = 0, result2 = []; ++index < length; ) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          return typeof value == "number" ? value : isSymbol(value) ? NAN : +value;
        }
        function baseToString(value) {
          if (typeof value == "string")
            return value;
          if (isArray2(value))
            return arrayMap(value, baseToString) + "";
          if (isSymbol(value))
            return symbolToString ? symbolToString.call(value) : "";
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = !0, result2 = [], seen = result2;
          if (comparator)
            isCommon = !1, includes2 = arrayIncludesWith;
          else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3)
              return setToArray(set3);
            isCommon = !1, includes2 = cacheHas, seen = new SetCache();
          } else
            seen = iteratee2 ? [] : result2;
          outer:
            for (; ++index < length; ) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
                for (var seenIndex = seen.length; seenIndex--; )
                  if (seen[seenIndex] === computed)
                    continue outer;
                iteratee2 && seen.push(computed), result2.push(value);
              } else includes2(seen, computed, comparator) || (seen !== result2 && seen.push(computed), result2.push(value));
            }
          return result2;
        }
        function baseUnset(object, path2) {
          return path2 = castPath(path2, object), object = parent(object, path2), object == null || delete object[toKey(last2(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); )
            ;
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          return result2 instanceof LazyWrapper && (result2 = result2.value()), arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2)
            return length ? baseUniq(arrays[0]) : [];
          for (var index = -1, result2 = Array2(length); ++index < length; )
            for (var array = arrays[index], othIndex = -1; ++othIndex < length; )
              othIndex != index && (result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator));
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          for (var index = -1, length = props.length, valsLength = values2.length, result2 = {}; ++index < length; ) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          return isArray2(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          return end = end === undefined$1 ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep)
            return buffer2.slice();
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          return buffer2.copy(result2), result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          return new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer)), result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp2) {
          var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
          return result2.lastIndex = regexp2.lastIndex, result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
              return 1;
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
              return -1;
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength)
                return result2;
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; )
            result2[leftIndex] = partials[leftIndex];
          for (; ++argsIndex < holdersLength; )
            (isUncurried || argsIndex < argsLength) && (result2[holders[argsIndex]] = args[argsIndex]);
          for (; rangeLength--; )
            result2[leftIndex++] = args[argsIndex++];
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; )
            result2[argsIndex] = args[argsIndex];
          for (var offset = argsIndex; ++rightIndex < rightLength; )
            result2[offset + rightIndex] = partials[rightIndex];
          for (; ++holdersIndex < holdersLength; )
            (isUncurried || argsIndex < argsLength) && (result2[offset + holders[holdersIndex]] = args[argsIndex++]);
          return result2;
        }
        function copyArray(source2, array) {
          var index = -1, length = source2.length;
          for (array || (array = Array2(length)); ++index < length; )
            array[index] = source2[index];
          return array;
        }
        function copyObject(source2, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          for (var index = -1, length = props.length; ++index < length; ) {
            var key2 = props[index], newValue = customizer ? customizer(object[key2], source2[key2], key2, object, source2) : undefined$1;
            newValue === undefined$1 && (newValue = source2[key2]), isNew ? baseAssignValue(object, key2, newValue) : assignValue(object, key2, newValue);
          }
          return object;
        }
        function copySymbols(source2, object) {
          return copyObject(source2, getSymbols(source2), object);
        }
        function copySymbolsIn(source2, object) {
          return copyObject(source2, getSymbolsIn(source2), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined$1 : customizer, length = 1), object = Object2(object); ++index < length; ) {
              var source2 = sources[index];
              source2 && assigner(object, source2, index, customizer);
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null)
              return collection;
            if (!isArrayLike2(collection))
              return eachFunc(collection, iteratee2);
            for (var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection); (fromRight ? index-- : ++index < length) && iteratee2(iterable[index], index, iterable) !== !1; )
              ;
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            for (var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length; length--; ) {
              var key2 = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key2], key2, iterable) === !1)
                break;
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            for (var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper); index--; )
              args[index] = arguments[index];
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            if (length -= holders.length, length < arity)
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection), predicate = function(key2) {
                return iteratee2(iterable[key2], key2, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            for (fromRight && funcs.reverse(); index--; ) {
              var func = funcs[index];
              if (typeof func != "function")
                throw new TypeError2(FUNC_ERROR_TEXT);
              if (prereq && !wrapper && getFuncName(func) == "wrapper")
                var wrapper = new LodashWrapper([], !0);
            }
            for (index = wrapper ? index : length; ++index < length; ) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1 ? wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value))
                return wrapper.plant(value).value();
              for (var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value; ++index2 < length; )
                result2 = funcs[index2].call(this, result2);
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            for (var length = arguments.length, args = Array2(length), index = length; index--; )
              args[index] = arguments[index];
            if (isCurried)
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && ary2 < length && (args.length = ary2), this && this !== root2 && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1)
              return defaultValue;
            if (value !== undefined$1 && (result2 = value), other !== undefined$1) {
              if (result2 === undefined$1)
                return other;
              typeof value == "string" || typeof other == "string" ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2)
            return charsLength ? baseRepeat(chars, length) : chars;
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; )
              args[leftIndex] = partials[leftIndex];
            for (; argsLength--; )
              args[leftIndex++] = arguments[++argsIndex];
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            return step && typeof step != "number" && isIterateeCall(start, end, step) && (end = step = undefined$1), start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            return typeof value == "string" && typeof other == "string" || (value = toNumber(value), other = toNumber(other)), operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ], result2 = wrapFunc.apply(undefined$1, newData);
          return isLaziable(func) && setData(result2, newData), result2.placeholder = placeholder, setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            if (number2 = toNumber(number2), precision = precision == null ? 0 : nativeMin(toInteger(precision), 292), precision && nativeIsFinite(number2)) {
              var pair = (toString(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY ? function(values2) {
          return new Set2(values2);
        } : noop2;
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          var length = partials ? partials.length : 0;
          if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined$1), ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0), arity = arity === undefined$1 ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func), newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), !bitmask || bitmask == WRAP_BIND_FLAG)
            var result2 = createBind(func, bitmask, thisArg);
          else bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? result2 = createCurry(func, bitmask, arity) : (bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length ? result2 = createPartial(func, bitmask, thisArg, partials) : result2 = createHybrid.apply(undefined$1, newData);
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key2, object) {
          return objValue === undefined$1 || eq(objValue, objectProto[key2]) && !hasOwnProperty2.call(object, key2) ? srcValue : objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key2, object, source2, stack2) {
          return isObject2(objValue) && isObject2(srcValue) && (stack2.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2), stack2.delete(srcValue)), objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength))
            return !1;
          var arrStacked = stack2.get(array), othStacked = stack2.get(other);
          if (arrStacked && othStacked)
            return arrStacked == other && othStacked == array;
          var index = -1, result2 = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          for (stack2.set(array, other), stack2.set(other, array); ++index < arrLength; ) {
            var arrValue = array[index], othValue = other[index];
            if (customizer)
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
            if (compared !== undefined$1) {
              if (compared)
                continue;
              result2 = !1;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2)))
                  return seen.push(othIndex);
              })) {
                result2 = !1;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
              result2 = !1;
              break;
            }
          }
          return stack2.delete(array), stack2.delete(other), result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
                return !1;
              object = object.buffer, other = other.buffer;
            case arrayBufferTag:
              return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other)));
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              if (convert || (convert = setToArray), object.size != other.size && !isPartial)
                return !1;
              var stacked = stack2.get(object);
              if (stacked)
                return stacked == other;
              bitmask |= COMPARE_UNORDERED_FLAG, stack2.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
              return stack2.delete(object), result2;
            case symbolTag:
              if (symbolValueOf)
                return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
          return !1;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial)
            return !1;
          for (var index = objLength; index--; ) {
            var key2 = objProps[index];
            if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2)))
              return !1;
          }
          var objStacked = stack2.get(object), othStacked = stack2.get(other);
          if (objStacked && othStacked)
            return objStacked == other && othStacked == object;
          var result2 = !0;
          stack2.set(object, other), stack2.set(other, object);
          for (var skipCtor = isPartial; ++index < objLength; ) {
            key2 = objProps[index];
            var objValue = object[key2], othValue = other[key2];
            if (customizer)
              var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
              result2 = !1;
              break;
            }
            skipCtor || (skipCtor = key2 == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result2 = !1);
          }
          return stack2.delete(object), stack2.delete(other), result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = metaMap ? function(func) {
          return metaMap.get(func);
        } : noop2;
        function getFuncName(func) {
          for (var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0; length--; ) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func)
              return data.name;
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          return result2 = result2 === iteratee ? baseIteratee : result2, arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key2) {
          var data = map3.__data__;
          return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          for (var result2 = keys(object), length = result2.length; length--; ) {
            var key2 = result2[length], value = object[key2];
            result2[length] = [key2, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key2) {
          var value = getValue(object, key2);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = !0;
          } catch {
          }
          var result2 = nativeObjectToString.call(value);
          return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result2;
        }
        var getSymbols = nativeGetSymbols ? function(object) {
          return object == null ? [] : (object = Object2(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          }));
        } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
          for (var result2 = []; object; )
            arrayPush(result2, getSymbols(object)), object = getPrototype(object);
          return result2;
        } : stubArray, getTag = baseGetTag;
        (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) && (getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString)
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          return result2;
        });
        function getView(start, end, transforms) {
          for (var index = -1, length = transforms.length; ++index < length; ) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { start, end };
        }
        function getWrapDetails(source2) {
          var match2 = source2.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          for (var index = -1, length = path2.length, result2 = !1; ++index < length; ) {
            var key2 = toKey(path2[index]);
            if (!(result2 = object != null && hasFunc(object, key2)))
              break;
            object = object[key2];
          }
          return result2 || ++index != length ? result2 : (length = object == null ? 0 : object.length, !!length && isLength(length) && isIndex(key2, length) && (isArray2(object) || isArguments(object)));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          return length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index") && (result2.index = array.index, result2.input = array.input), result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source2, details) {
          var length = details.length;
          if (!length)
            return source2;
          var lastIndex = length - 1;
          return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), source2.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          return length = length ?? MAX_SAFE_INTEGER, !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object))
            return !1;
          var type2 = typeof index;
          return (type2 == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type2 == "string" && index in object) ? eq(object[index], value) : !1;
        }
        function isKey(value, object) {
          if (isArray2(value))
            return !1;
          var type2 = typeof value;
          return type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype))
            return !1;
          if (func === other)
            return !0;
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key2, srcValue) {
          return function(object) {
            return object == null ? !1 : object[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key2) {
            return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key2;
          }), cache = result2.cache;
          return result2;
        }
        function mergeData(data, source2) {
          var bitmask = data[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo))
            return data;
          srcBitmask & WRAP_BIND_FLAG && (data[2] = source2[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
          var value = source2[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source2[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source2[4];
          }
          return value = source2[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source2[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source2[6]), value = source2[7], value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = data[8] == null ? source2[8] : nativeMin(data[8], source2[8])), data[9] == null && (data[9] = source2[9]), data[0] = source2[0], data[1] = newBitmask, data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null)
            for (var key2 in Object2(object))
              result2.push(key2);
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          return start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0), function() {
            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length); ++index < length; )
              array[index] = args[start + index];
            index = -1;
            for (var otherArgs = Array2(start + 1); ++index < start; )
              otherArgs[index] = args[index];
            return otherArgs[start] = transform2(array), apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder(array, indexes) {
          for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key2) {
          if (!(key2 === "constructor" && typeof object[key2] == "function") && key2 != "__proto__")
            return object[key2];
        }
        var setData = shortOut(baseSetData), setTimeout2 = ctxSetTimeout || function(func, wait2) {
          return root2.setTimeout(func, wait2);
        }, setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source2 = reference + "";
          return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            if (lastCalled = stamp, remaining > 0) {
              if (++count2 >= HOT_COUNT)
                return arguments[0];
            } else
              count2 = 0;
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          for (size2 = size2 === undefined$1 ? length : size2; ++index < size2; ) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index], array[index] = value;
          }
          return array.length = size2, array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          return string.charCodeAt(0) === 46 && result2.push(""), string.replace(rePropName, function(match2, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
          }), result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value))
            return value;
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch {
            }
            try {
              return func + "";
            } catch {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          return arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
          }), details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper)
            return wrapper.clone();
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          return result2.__actions__ = copyArray(wrapper.__actions__), result2.__index__ = wrapper.__index__, result2.__values__ = wrapper.__values__, result2;
        }
        function chunk(array, size2, guard) {
          (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) ? size2 = 1 : size2 = nativeMax(toInteger(size2), 0);
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1)
            return [];
          for (var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2)); index < length; )
            result2[resIndex++] = baseSlice(array, index, index += size2);
          return result2;
        }
        function compact(array) {
          for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = []; ++index < length; ) {
            var value = array[index];
            value && (result2[resIndex++] = value);
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length)
            return [];
          for (var args = Array2(length - 1), array = arguments[0], index = length; index--; )
            args[index - 1] = arguments[index];
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0)) : [];
        }), differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last2(values2);
          return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2)) : [];
        }), differenceWith = baseRest(function(array, values2) {
          var comparator = last2(values2);
          return isArrayLikeObject(comparator) && (comparator = undefined$1), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array, n < 0 ? 0 : n, length)) : [];
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array, 0, n < 0 ? 0 : n)) : [];
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          return length ? (start && typeof start != "number" && isIterateeCall(array, value, start) && (start = 0, end = length), baseFill(array, value, start, end)) : [];
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = length - 1;
          return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array, getIteratee(predicate, 3), index, !0);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          return length ? (depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(array, depth)) : [];
        }
        function fromPairs(pairs2) {
          for (var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {}; ++index < length; ) {
            var pair = pairs2[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        }), intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          return iteratee2 === last2(mapped) ? iteratee2 = undefined$1 : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        }), intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          return comparator = typeof comparator == "function" ? comparator : undefined$1, comparator && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator2) {
          return array == null ? "" : nativeJoin.call(array, separator2);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = length;
          return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          return basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending)), result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length))
            return result2;
          var index = -1, indexes = [], length = array.length;
          for (predicate = getIteratee(predicate, 3); ++index < length; ) {
            var value = array[index];
            predicate(value, index, array) && (result2.push(value), indexes.push(index));
          }
          return basePullAt(array, indexes), result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          return length ? (end && typeof end != "number" && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = start == null ? 0 : toInteger(start), end = end === undefined$1 ? length : toInteger(end)), baseSlice(array, start, end)) : [];
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value))
              return index;
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, !0);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), !0);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, !0) - 1;
            if (eq(array[index], value))
              return index;
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take2(array, n, guard) {
          return array && array.length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array, 0, n < 0 ? 0 : n)) : [];
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array, n < 0 ? 0 : n, length)) : [];
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : [];
        }
        function takeWhile2(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
        }), unionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2));
        }), unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          return comparator = typeof comparator == "function" ? comparator : undefined$1, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          return comparator = typeof comparator == "function" ? comparator : undefined$1, array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length))
            return [];
          var length = 0;
          return array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group))
              return length = nativeMax(group.length, length), !0;
          }), baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length))
            return [];
          var result2 = unzip(array);
          return iteratee2 == null ? result2 : arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        }), xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        }), xorBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        }), xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          return comparator = typeof comparator == "function" ? comparator : undefined$1, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        }), zip2 = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          return iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1, unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          return result2.__chain__ = !0, result2;
        }
        function tap2(value, interceptor) {
          return interceptor(value), value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          return length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start) ? this.thru(interceptor) : (value = value.slice(start, +start + (length ? 1 : 0)), value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined$1
          }), new LodashWrapper(value, this.__chain__).thru(function(array) {
            return length && !array.length && array.push(undefined$1), array;
          }));
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          this.__values__ === undefined$1 && (this.__values__ = toArray2(this.value()));
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { done, value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          for (var result2, parent2 = this; parent2 instanceof baseLodash; ) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0, clone2.__values__ = undefined$1, result2 ? previous.__wrapped__ = clone2 : result2 = clone2;
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          return previous.__wrapped__ = value, result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined$1
            }), new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key2) {
          hasOwnProperty2.call(result2, key2) ? ++result2[key2] : baseAssignValue(result2, key2, 1);
        });
        function every2(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex2), findLast = createFind(findLastIndex);
        function flatMap2(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          return depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy2 = createAggregator(function(result2, value, key2) {
          hasOwnProperty2.call(result2, key2) ? result2[key2].push(value) : baseAssignValue(result2, key2, [value]);
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          return baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          }), result2;
        }), keyBy = createAggregator(function(result2, value, key2) {
          baseAssignValue(result2, key2, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          return collection == null ? [] : (isArray2(iteratees) || (iteratees = iteratees == null ? [] : [iteratees]), orders = guard ? undefined$1 : orders, isArray2(orders) || (orders = orders == null ? [] : [orders]), baseOrderBy(collection, iteratees, orders));
        }
        var partition2 = createAggregator(function(result2, value, key2) {
          result2[key2 ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample2(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n);
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null)
            return 0;
          if (isArrayLike2(collection))
            return isString(collection) ? stringSize(collection) : collection.length;
          var tag = getTag(collection);
          return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null)
            return [];
          var length = iteratees.length;
          return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        }), now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return n = toInteger(n), function() {
            if (--n < 1)
              return func.apply(this, arguments);
          };
        }
        function ary(func, n, guard) {
          return n = guard ? undefined$1 : n, n = func && n == null ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return n = toInteger(n), function() {
            return --n > 0 && (result2 = func.apply(this, arguments)), n <= 1 && (func = undefined$1), result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        }), bindKey = baseRest(function(object, key2, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key2, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          return result2.placeholder = curry.placeholder, result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          return result2.placeholder = curryRight.placeholder, result2;
        }
        function debounce2(func, wait2, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          wait2 = toNumber(wait2) || 0, isObject2(options2) && (leading = !!options2.leading, maxing = "maxWait" in options2, maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait2) : maxWait, trailing = "trailing" in options2 ? !!options2.trailing : trailing);
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            return lastArgs = lastThis = undefined$1, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
          }
          function leadingEdge(time) {
            return lastInvokeTime = time, timerId = setTimeout2(timerExpired, wait2), leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time))
              return trailingEdge(time);
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            return timerId = undefined$1, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined$1, result2);
          }
          function cancel() {
            timerId !== undefined$1 && clearTimeout2(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
              if (timerId === undefined$1)
                return leadingEdge(lastCallTime);
              if (maxing)
                return clearTimeout2(timerId), timerId = setTimeout2(timerExpired, wait2), invokeFunc(lastCallTime);
            }
            return timerId === undefined$1 && (timerId = setTimeout2(timerExpired, wait2)), result2;
          }
          return debounced.cancel = cancel, debounced.flush = flush, debounced;
        }
        var defer2 = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        }), delay2 = baseRest(function(func, wait2, args) {
          return baseDelay(func, toNumber(wait2) || 0, args);
        });
        function flip2(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          var memoized = function() {
            var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key2))
              return cache.get(key2);
            var result2 = func.apply(this, args);
            return memoized.cache = cache.set(key2, result2) || cache, result2;
          };
          return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once2(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; )
              args[index] = transforms[index].call(this, args[index]);
            return apply(func, this, args);
          });
        }), partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        }), partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        }), rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return start = start === undefined$1 ? start : toInteger(start), baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return start = start == null ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait2, options2) {
          var leading = !0, trailing = !0;
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return isObject2(options2) && (leading = "leading" in options2 ? !!options2.leading : leading, trailing = "trailing" in options2 ? !!options2.trailing : trailing), debounce2(func, wait2, {
            leading,
            maxWait: wait2,
            trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap2(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length)
            return [];
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source2) {
          return source2 == null || baseConformsTo(object, source2, keys(source2));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
          return value >= other;
        }), isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        }, isArray2 = Array2.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike2(value);
        }
        function isBoolean(value) {
          return value === !0 || value === !1 || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse, isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null)
            return !0;
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value)))
            return !value.length;
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag)
            return !value.size;
          if (isPrototype(value))
            return !baseKeys(value).length;
          for (var key2 in value)
            if (hasOwnProperty2.call(value, key2))
              return !1;
          return !0;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value))
            return !1;
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value))
            return !1;
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source2) {
          return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
        }
        function isMatchWith(object, source2, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, baseIsMatch(object, source2, getMatchData(source2), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value))
            throw new Error2(CORE_ERROR_TEXT);
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag)
            return !1;
          var proto = getPrototype(value);
          if (proto === null)
            return !0;
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value)
            return [];
          if (isArrayLike2(value))
            return isString(value) ? stringToArray(value) : copyArray(value);
          if (symIterator && value[symIterator])
            return iteratorToArray(value[symIterator]());
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value)
            return value === 0 ? value : 0;
          if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number")
            return value;
          if (isSymbol(value))
            return NAN;
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string")
            return value === 0 ? value : +value;
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source2) {
          if (isPrototype(source2) || isArrayLike2(source2)) {
            copyObject(source2, keys(source2), object);
            return;
          }
          for (var key2 in source2)
            hasOwnProperty2.call(source2, key2) && assignValue(object, key2, source2[key2]);
        }), assignIn = createAssigner(function(object, source2) {
          copyObject(source2, keysIn(source2), object);
        }), assignInWith = createAssigner(function(object, source2, srcIndex, customizer) {
          copyObject(source2, keysIn(source2), object, customizer);
        }), assignWith = createAssigner(function(object, source2, srcIndex, customizer) {
          copyObject(source2, keys(source2), object, customizer);
        }), at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1, length = sources.length, guard = length > 2 ? sources[2] : undefined$1;
          for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; )
            for (var source2 = sources[index], props = keysIn(source2), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
              var key2 = props[propsIndex], value = object[key2];
              (value === undefined$1 || eq(value, objectProto[key2]) && !hasOwnProperty2.call(object, key2)) && (object[key2] = source2[key2]);
            }
          return object;
        }), defaultsDeep = baseRest(function(args) {
          return args.push(undefined$1, customDefaultsMerge), apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path2, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path2);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key2) {
          value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), result2[value] = key2;
        }, constant(identity2)), invertBy = createInverter(function(result2, value, key2) {
          value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), hasOwnProperty2.call(result2, value) ? result2[value].push(key2) : result2[value] = [key2];
        }, getIteratee), invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key2, object2) {
            baseAssignValue(result2, iteratee2(value, key2, object2), value);
          }), result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key2, object2) {
            baseAssignValue(result2, key2, iteratee2(value, key2, object2));
          }), result2;
        }
        var merge2 = createAssigner(function(object, source2, srcIndex) {
          baseMerge(object, source2, srcIndex);
        }), mergeWith = createAssigner(function(object, source2, srcIndex, customizer) {
          baseMerge(object, source2, srcIndex, customizer);
        }), omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null)
            return result2;
          var isDeep = !1;
          paths = arrayMap(paths, function(path2) {
            return path2 = castPath(path2, object), isDeep || (isDeep = path2.length > 1), path2;
          }), copyObject(object, getAllKeysIn(object), result2), isDeep && (result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
          for (var length = paths.length; length--; )
            baseUnset(result2, paths[length]);
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null)
            return {};
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index = -1, length = path2.length;
          for (length || (length = 1, object = undefined$1); ++index < length; ) {
            var value = object == null ? undefined$1 : object[toKey(path2[index])];
            value === undefined$1 && (index = length, value = defaultValue), object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path2, value) {
          return object == null ? object : baseSet(object, path2, value);
        }
        function setWith(object, path2, value, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseSet(object, path2, value, customizer);
        }
        var toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          if (iteratee2 = getIteratee(iteratee2, 4), accumulator == null) {
            var Ctor = object && object.constructor;
            isArrLike ? accumulator = isArr ? new Ctor() : [] : isObject2(object) ? accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {} : accumulator = {};
          }
          return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          }), accumulator;
        }
        function unset(object, path2) {
          return object == null ? !0 : baseUnset(object, path2);
        }
        function update2(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number2, lower, upper) {
          return upper === undefined$1 && (upper = lower, lower = undefined$1), upper !== undefined$1 && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined$1 && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          return start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), number2 = toNumber(number2), baseInRange(number2, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating) && (upper = floating = undefined$1), floating === undefined$1 && (typeof upper == "boolean" ? (floating = upper, upper = undefined$1) : typeof lower == "boolean" && (floating = lower, lower = undefined$1)), lower === undefined$1 && upper === undefined$1 ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined$1 ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
            var temp = lower;
            lower = upper, upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          return word = word.toLowerCase(), result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string), target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          return position -= target.length, position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        }), lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        }), lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string), length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length)
            return string;
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string), length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string), length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          return guard || radix == null ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat2(string, n, guard) {
          return (guard ? isIterateeCall(string, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n), baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator2, limit) {
          return limit && typeof limit != "number" && isIterateeCall(string, separator2, limit) && (separator2 = limit = undefined$1), limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0, limit ? (string = toString(string), string && (typeof separator2 == "string" || separator2 != null && !isRegExp(separator2)) && (separator2 = baseToString(separator2), !separator2 && hasUnicode(string)) ? castSlice(stringToArray(string), 0, limit) : string.split(separator2, limit)) : [];
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          return string = toString(string), position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length), target = baseToString(target), string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash2.templateSettings;
          guard && isIterateeCall(string, options2, guard) && (options2 = undefined$1), string = toString(string), options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source2 = "__p += '", reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          ), sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            return interpolateValue || (interpolateValue = esTemplateValue), source2 += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source2 += `' +
__e(` + escapeValue + `) +
'`), evaluateValue && (isEvaluating = !0, source2 += `';
` + evaluateValue + `;
__p += '`), interpolateValue && (source2 += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`), index = offset + match2.length, match2;
          }), source2 += `';
`;
          var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
          if (!variable)
            source2 = `with (obj) {
` + source2 + `
}
`;
          else if (reForbiddenIdentifierChars.test(variable))
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source2 = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + source2 + `return __p
}`;
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$1, importsValues);
          });
          if (result2.source = source2, isError(result2))
            throw result2;
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          if (string = toString(string), string && (guard || chars === undefined$1))
            return baseTrim(string);
          if (!string || !(chars = baseToString(chars)))
            return string;
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          if (string = toString(string), string && (guard || chars === undefined$1))
            return string.slice(0, trimmedEndIndex(string) + 1);
          if (!string || !(chars = baseToString(chars)))
            return string;
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          if (string = toString(string), string && (guard || chars === undefined$1))
            return string.replace(reTrimStart, "");
          if (!string || !(chars = baseToString(chars)))
            return string;
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options2)) {
            var separator2 = "separator" in options2 ? options2.separator : separator2;
            length = "length" in options2 ? toInteger(options2.length) : length, omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength)
            return string;
          var end = length - stringSize(omission);
          if (end < 1)
            return omission;
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator2 === undefined$1)
            return result2 + omission;
          if (strSymbols && (end += result2.length - end), isRegExp(separator2)) {
            if (string.slice(end).search(separator2)) {
              var match2, substring = result2;
              for (separator2.global || (separator2 = RegExp2(separator2.source, toString(reFlags.exec(separator2)) + "g")), separator2.lastIndex = 0; match2 = separator2.exec(substring); )
                var newEnd = match2.index;
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator2), end) != end) {
            var index = result2.lastIndexOf(separator2);
            index > -1 && (result2 = result2.slice(0, index));
          }
          return result2 + omission;
        }
        function unescape2(string) {
          return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        }), upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          return string = toString(string), pattern = guard ? undefined$1 : pattern, pattern === undefined$1 ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        }), bindAll = flatRest(function(object, methodNames) {
          return arrayEach(methodNames, function(key2) {
            key2 = toKey(key2), baseAssignValue(object, key2, bind(object[key2], object));
          }), object;
        });
        function cond(pairs2) {
          var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          return pairs2 = length ? arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function")
              throw new TypeError2(FUNC_ERROR_TEXT);
            return [toIteratee(pair[0]), pair[1]];
          }) : [], baseRest(function(args) {
            for (var index = -1; ++index < length; ) {
              var pair = pairs2[index];
              if (apply(pair[0], this, args))
                return apply(pair[1], this, args);
            }
          });
        }
        function conforms(source2) {
          return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow2 = createFlow(), flowRight = createFlow(!0);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source2) {
          return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        }), methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source2, options2) {
          var props = keys(source2), methodNames = baseFunctions(source2, props);
          options2 == null && !(isObject2(source2) && (methodNames.length || !props.length)) && (options2 = source2, source2 = object, object = this, methodNames = baseFunctions(source2, keys(source2)));
          var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
          return arrayEach(methodNames, function(methodName) {
            var func = source2[methodName];
            object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                return actions.push({ func, args: arguments, thisArg: object }), result2.__chain__ = chainAll, result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            });
          }), object;
        }
        function noConflict() {
          return root2._ === this && (root2._ = oldDash), this;
        }
        function noop2() {
        }
        function nthArg(n) {
          return n = toInteger(n), baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined$1 : baseGet(object, path2);
          };
        }
        var range2 = createRange(), rangeRight = createRange(!0);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return !1;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return !0;
        }
        function times(n, iteratee2) {
          if (n = toInteger(n), n < 1 || n > MAX_SAFE_INTEGER)
            return [];
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2), n -= MAX_ARRAY_LENGTH;
          for (var result2 = baseTimes(length, iteratee2); ++index < n; )
            iteratee2(index);
          return result2;
        }
        function toPath(value) {
          return isArray2(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1), floor = createRound("floor");
        function max2(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min2(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1), round2 = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        return lodash2.after = after, lodash2.ary = ary, lodash2.assign = assign, lodash2.assignIn = assignIn, lodash2.assignInWith = assignInWith, lodash2.assignWith = assignWith, lodash2.at = at, lodash2.before = before, lodash2.bind = bind, lodash2.bindAll = bindAll, lodash2.bindKey = bindKey, lodash2.castArray = castArray, lodash2.chain = chain, lodash2.chunk = chunk, lodash2.compact = compact, lodash2.concat = concat2, lodash2.cond = cond, lodash2.conforms = conforms, lodash2.constant = constant, lodash2.countBy = countBy, lodash2.create = create, lodash2.curry = curry, lodash2.curryRight = curryRight, lodash2.debounce = debounce2, lodash2.defaults = defaults2, lodash2.defaultsDeep = defaultsDeep, lodash2.defer = defer2, lodash2.delay = delay2, lodash2.difference = difference, lodash2.differenceBy = differenceBy, lodash2.differenceWith = differenceWith, lodash2.drop = drop, lodash2.dropRight = dropRight, lodash2.dropRightWhile = dropRightWhile, lodash2.dropWhile = dropWhile, lodash2.fill = fill, lodash2.filter = filter2, lodash2.flatMap = flatMap2, lodash2.flatMapDeep = flatMapDeep, lodash2.flatMapDepth = flatMapDepth, lodash2.flatten = flatten, lodash2.flattenDeep = flattenDeep, lodash2.flattenDepth = flattenDepth, lodash2.flip = flip2, lodash2.flow = flow2, lodash2.flowRight = flowRight, lodash2.fromPairs = fromPairs, lodash2.functions = functions, lodash2.functionsIn = functionsIn, lodash2.groupBy = groupBy2, lodash2.initial = initial, lodash2.intersection = intersection, lodash2.intersectionBy = intersectionBy, lodash2.intersectionWith = intersectionWith, lodash2.invert = invert, lodash2.invertBy = invertBy, lodash2.invokeMap = invokeMap, lodash2.iteratee = iteratee, lodash2.keyBy = keyBy, lodash2.keys = keys, lodash2.keysIn = keysIn, lodash2.map = map2, lodash2.mapKeys = mapKeys, lodash2.mapValues = mapValues, lodash2.matches = matches, lodash2.matchesProperty = matchesProperty, lodash2.memoize = memoize, lodash2.merge = merge2, lodash2.mergeWith = mergeWith, lodash2.method = method, lodash2.methodOf = methodOf, lodash2.mixin = mixin, lodash2.negate = negate, lodash2.nthArg = nthArg, lodash2.omit = omit, lodash2.omitBy = omitBy, lodash2.once = once2, lodash2.orderBy = orderBy, lodash2.over = over, lodash2.overArgs = overArgs, lodash2.overEvery = overEvery, lodash2.overSome = overSome, lodash2.partial = partial, lodash2.partialRight = partialRight, lodash2.partition = partition2, lodash2.pick = pick, lodash2.pickBy = pickBy, lodash2.property = property, lodash2.propertyOf = propertyOf, lodash2.pull = pull, lodash2.pullAll = pullAll, lodash2.pullAllBy = pullAllBy, lodash2.pullAllWith = pullAllWith, lodash2.pullAt = pullAt, lodash2.range = range2, lodash2.rangeRight = rangeRight, lodash2.rearg = rearg, lodash2.reject = reject, lodash2.remove = remove, lodash2.rest = rest, lodash2.reverse = reverse, lodash2.sampleSize = sampleSize, lodash2.set = set2, lodash2.setWith = setWith, lodash2.shuffle = shuffle, lodash2.slice = slice, lodash2.sortBy = sortBy, lodash2.sortedUniq = sortedUniq, lodash2.sortedUniqBy = sortedUniqBy, lodash2.split = split, lodash2.spread = spread, lodash2.tail = tail, lodash2.take = take2, lodash2.takeRight = takeRight, lodash2.takeRightWhile = takeRightWhile, lodash2.takeWhile = takeWhile2, lodash2.tap = tap2, lodash2.throttle = throttle2, lodash2.thru = thru, lodash2.toArray = toArray2, lodash2.toPairs = toPairs, lodash2.toPairsIn = toPairsIn, lodash2.toPath = toPath, lodash2.toPlainObject = toPlainObject, lodash2.transform = transform, lodash2.unary = unary, lodash2.union = union, lodash2.unionBy = unionBy, lodash2.unionWith = unionWith, lodash2.uniq = uniq, lodash2.uniqBy = uniqBy, lodash2.uniqWith = uniqWith, lodash2.unset = unset, lodash2.unzip = unzip, lodash2.unzipWith = unzipWith, lodash2.update = update2, lodash2.updateWith = updateWith, lodash2.values = values, lodash2.valuesIn = valuesIn, lodash2.without = without, lodash2.words = words, lodash2.wrap = wrap2, lodash2.xor = xor, lodash2.xorBy = xorBy, lodash2.xorWith = xorWith, lodash2.zip = zip2, lodash2.zipObject = zipObject, lodash2.zipObjectDeep = zipObjectDeep, lodash2.zipWith = zipWith, lodash2.entries = toPairs, lodash2.entriesIn = toPairsIn, lodash2.extend = assignIn, lodash2.extendWith = assignInWith, mixin(lodash2, lodash2), lodash2.add = add, lodash2.attempt = attempt, lodash2.camelCase = camelCase, lodash2.capitalize = capitalize, lodash2.ceil = ceil, lodash2.clamp = clamp, lodash2.clone = clone, lodash2.cloneDeep = cloneDeep, lodash2.cloneDeepWith = cloneDeepWith, lodash2.cloneWith = cloneWith, lodash2.conformsTo = conformsTo, lodash2.deburr = deburr, lodash2.defaultTo = defaultTo, lodash2.divide = divide, lodash2.endsWith = endsWith, lodash2.eq = eq, lodash2.escape = escape2, lodash2.escapeRegExp = escapeRegExp, lodash2.every = every2, lodash2.find = find2, lodash2.findIndex = findIndex2, lodash2.findKey = findKey, lodash2.findLast = findLast, lodash2.findLastIndex = findLastIndex, lodash2.findLastKey = findLastKey, lodash2.floor = floor, lodash2.forEach = forEach, lodash2.forEachRight = forEachRight, lodash2.forIn = forIn, lodash2.forInRight = forInRight, lodash2.forOwn = forOwn, lodash2.forOwnRight = forOwnRight, lodash2.get = get, lodash2.gt = gt, lodash2.gte = gte, lodash2.has = has, lodash2.hasIn = hasIn, lodash2.head = head, lodash2.identity = identity2, lodash2.includes = includes, lodash2.indexOf = indexOf, lodash2.inRange = inRange, lodash2.invoke = invoke, lodash2.isArguments = isArguments, lodash2.isArray = isArray2, lodash2.isArrayBuffer = isArrayBuffer, lodash2.isArrayLike = isArrayLike2, lodash2.isArrayLikeObject = isArrayLikeObject, lodash2.isBoolean = isBoolean, lodash2.isBuffer = isBuffer, lodash2.isDate = isDate2, lodash2.isElement = isElement, lodash2.isEmpty = isEmpty2, lodash2.isEqual = isEqual, lodash2.isEqualWith = isEqualWith, lodash2.isError = isError, lodash2.isFinite = isFinite2, lodash2.isFunction = isFunction2, lodash2.isInteger = isInteger2, lodash2.isLength = isLength, lodash2.isMap = isMap, lodash2.isMatch = isMatch, lodash2.isMatchWith = isMatchWith, lodash2.isNaN = isNaN2, lodash2.isNative = isNative, lodash2.isNil = isNil, lodash2.isNull = isNull, lodash2.isNumber = isNumber2, lodash2.isObject = isObject2, lodash2.isObjectLike = isObjectLike, lodash2.isPlainObject = isPlainObject2, lodash2.isRegExp = isRegExp, lodash2.isSafeInteger = isSafeInteger, lodash2.isSet = isSet, lodash2.isString = isString, lodash2.isSymbol = isSymbol, lodash2.isTypedArray = isTypedArray, lodash2.isUndefined = isUndefined, lodash2.isWeakMap = isWeakMap, lodash2.isWeakSet = isWeakSet, lodash2.join = join, lodash2.kebabCase = kebabCase, lodash2.last = last2, lodash2.lastIndexOf = lastIndexOf, lodash2.lowerCase = lowerCase, lodash2.lowerFirst = lowerFirst, lodash2.lt = lt, lodash2.lte = lte, lodash2.max = max2, lodash2.maxBy = maxBy, lodash2.mean = mean, lodash2.meanBy = meanBy, lodash2.min = min2, lodash2.minBy = minBy, lodash2.stubArray = stubArray, lodash2.stubFalse = stubFalse, lodash2.stubObject = stubObject, lodash2.stubString = stubString, lodash2.stubTrue = stubTrue, lodash2.multiply = multiply, lodash2.nth = nth, lodash2.noConflict = noConflict, lodash2.noop = noop2, lodash2.now = now, lodash2.pad = pad, lodash2.padEnd = padEnd, lodash2.padStart = padStart, lodash2.parseInt = parseInt2, lodash2.random = random, lodash2.reduce = reduce2, lodash2.reduceRight = reduceRight, lodash2.repeat = repeat2, lodash2.replace = replace, lodash2.result = result, lodash2.round = round2, lodash2.runInContext = runInContext2, lodash2.sample = sample2, lodash2.size = size, lodash2.snakeCase = snakeCase, lodash2.some = some, lodash2.sortedIndex = sortedIndex, lodash2.sortedIndexBy = sortedIndexBy, lodash2.sortedIndexOf = sortedIndexOf, lodash2.sortedLastIndex = sortedLastIndex, lodash2.sortedLastIndexBy = sortedLastIndexBy, lodash2.sortedLastIndexOf = sortedLastIndexOf, lodash2.startCase = startCase, lodash2.startsWith = startsWith, lodash2.subtract = subtract, lodash2.sum = sum, lodash2.sumBy = sumBy, lodash2.template = template, lodash2.times = times, lodash2.toFinite = toFinite, lodash2.toInteger = toInteger, lodash2.toLength = toLength, lodash2.toLower = toLower, lodash2.toNumber = toNumber, lodash2.toSafeInteger = toSafeInteger, lodash2.toString = toString, lodash2.toUpper = toUpper, lodash2.trim = trim, lodash2.trimEnd = trimEnd, lodash2.trimStart = trimStart, lodash2.truncate = truncate, lodash2.unescape = unescape2, lodash2.uniqueId = uniqueId, lodash2.upperCase = upperCase, lodash2.upperFirst = upperFirst, lodash2.each = forEach, lodash2.eachRight = forEachRight, lodash2.first = head, mixin(lodash2, function() {
          var source2 = {};
          return baseForOwn(lodash2, function(func, methodName) {
            hasOwnProperty2.call(lodash2.prototype, methodName) || (source2[methodName] = func);
          }), source2;
        }(), { chain: !1 }), lodash2.VERSION = VERSION, arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        }), arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            return result2.__filtered__ ? result2.__takeCount__ = nativeMin(n, result2.__takeCount__) : result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            }), result2;
          }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        }), arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            return result2.__iteratees__.push({
              iteratee: getIteratee(iteratee2, 3),
              type: type2
            }), result2.__filtered__ = result2.__filtered__ || isFilter, result2;
          };
        }), arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        }), arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        }), LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        }, LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        }, LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        }, LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          return typeof path2 == "function" ? new LazyWrapper(this) : this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        }), LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        }, LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          return result2.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result2) : (start < 0 ? result2 = result2.takeRight(-start) : start && (result2 = result2.drop(start)), end !== undefined$1 && (end = toInteger(end), result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start)), result2);
        }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        }, LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          lodashFunc && (lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value), interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1 && (isLazy = useLazy = !1);
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              return result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined$1 }), new LodashWrapper(result2, chainAll);
            }
            return isUnwrapped && onlyLazy ? func.apply(this, args) : (result2 = this.thru(interceptor), isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2);
          });
        }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key2 = lodashFunc.name + "";
            hasOwnProperty2.call(realNames, key2) || (realNames[key2] = []), realNames[key2].push({ name: methodName, func: lodashFunc });
          }
        }), realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          name: "wrapper",
          func: undefined$1
        }], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, LazyWrapper.prototype.value = lazyValue, lodash2.prototype.at = wrapperAt, lodash2.prototype.chain = wrapperChain, lodash2.prototype.commit = wrapperCommit, lodash2.prototype.next = wrapperNext, lodash2.prototype.plant = wrapperPlant, lodash2.prototype.reverse = wrapperReverse, lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue, lodash2.prototype.first = lodash2.prototype.head, symIterator && (lodash2.prototype[symIterator] = wrapperToIterator), lodash2;
      }, _ = runInContext();
      freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root2._ = _;
    }).call(lodash);
  }(lodash$1, lodash$1.exports)), lodash$1.exports;
}
var lodashExports = requireLodash();
const purpose$2 = "Transform `sanity/desk` imports to `sanity/structure`", description$3 = `
Modifies all code paths that are found to import  from 'sanity/desk' to instead import from
'sanity/structure', and renames any renamed members.

from: import {deskTool} from 'sanity/desk'
  to: import {structureTool} from 'sanity/structure'

from: import {StructureBuilder} from 'sanity/desk'
  to: import {StructureBuilder} from 'sanity/structure'
`.trim(), deskRename = {
  purpose: purpose$2,
  description: description$3,
  filename: "deskRename.js"
}, purpose$1 = "Add parts types directive to all ts/tsx files that has one or more part imports", description$2 = `
Adds a '///<reference types="@sanity/types/parts" />' header to all source files that has one or more part imports.
For example:

Before:
---- somefile.ts
import client from 'part:@sanity/base/client'
//\u2026
----

After:
---- somefile.ts
///<reference types="@sanity/types/parts" />
import client from 'part:@sanity/base/client'
//\u2026
----


`.trim(), partsTypeDirective = {
  purpose: purpose$1,
  description: description$2,
  filename: "partsTypeDirective.js"
};
var semverCompare$1, hasRequiredSemverCompare;
function requireSemverCompare() {
  return hasRequiredSemverCompare || (hasRequiredSemverCompare = 1, semverCompare$1 = function(a, b) {
    for (var pa = a.split("."), pb = b.split("."), i = 0; i < 3; i++) {
      var na = Number(pa[i]), nb = Number(pb[i]);
      if (na > nb) return 1;
      if (nb > na) return -1;
      if (!isNaN(na) && isNaN(nb)) return 1;
      if (isNaN(na) && !isNaN(nb)) return -1;
    }
    return 0;
  }), semverCompare$1;
}
var semverCompareExports = requireSemverCompare(), semverCompare = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(semverCompareExports);
async function readJson(filePath) {
  const content = await fs.readFile(filePath, "utf8");
  return JSON.parse(content);
}
const purpose = "Transform react-icons v2 imports to v3 form", description$1 = `
Modifies all found react-icons import and require statements from their v2 form
to the path structure used in react-icons v3. For instance:

from: import {MdPerson} from 'react-icons/lib/md'
  to: import {MdPerson} from 'react-icons/md'

from: import PersonIcon from 'react-icons/lib/md/person'
  to: import {MdPerson as PersonIcon} from 'react-icons/md'
`.trim(), reactIconsV3 = {
  purpose,
  description: description$1,
  filename: "reactIconsV3.js",
  verify: async (context) => {
    const { workDir } = context, studioPkg = await maybeReadJson(path__default.default.join(workDir, "package.json")), dependencyVersion = ((studioPkg && studioPkg.dependencies || {})["react-icons"] || "").replace(/^[\^~]/, "");
    if (!dependencyVersion)
      throw new Error("Could not find react-icons declared as dependency in package.json");
    if (semverCompare(dependencyVersion, "3.0.0") < 0)
      throw new Error("react-icons declared in package.json dependencies is lower than 3.0.0");
    const iconPkgPath = resolveFrom.silent(workDir, "react-icons/package.json"), iconPkg = iconPkgPath && await maybeReadJson(iconPkgPath);
    if (iconPkg && semverCompare(iconPkg.version, "3.0.0") < 0)
      throw new Error("The installed version of react-icon seems to be < 3.0.0");
  }
};
async function maybeReadJson(jsonPath) {
  try {
    return await readJson(jsonPath);
  } catch {
    return null;
  }
}
var mods = {
  reactIconsV3,
  partsTypeDirective,
  deskRename
};
const codemodAction = async function(args, context) {
  const { output, cliRoot, workDir } = context, [name] = args.argsWithoutOptions, cliFlags = args.extOptions;
  if (!name) {
    printMods(output);
    return;
  }
  const normalizedMods = {};
  for (const [originalName, mod2] of Object.entries(mods))
    normalizedMods[originalName.toLowerCase()] = mod2;
  const mod = normalizedMods[name.toLowerCase()];
  if (!mod)
    throw new Error(`Codemod with name "${name}" not found`);
  typeof mod.verify == "function" && cliFlags.verify !== !1 && await mod.verify(context);
  const exts = cliFlags.extensions ? cliFlags.extensions.split(",").map((ext2) => ext2.trim().replace(/^\./, "")) : ["js", "ts", "tsx"], dryRun = !!(!(typeof cliFlags.dry > "u") && cliFlags.dry);
  ensureNpx();
  const hasGitIgnore = fs__namespace.default.existsSync(path__default.default.join(workDir, ".gitignore")), modPath = path__default.default.resolve(path__default.default.join(cliRoot, "codemods", mod.filename)), cmdArgs = [
    "jscodeshift",
    "--ignore-pattern",
    "node_modules",
    "--ignore-pattern",
    "dist",
    hasGitIgnore && "--ignore-config",
    hasGitIgnore && ".gitignore",
    "-t",
    modPath,
    "--extensions",
    exts.join(","),
    dryRun && "--dry",
    workDir
  ].filter((item) => typeof item == "string"), child = childProcess__default.default.spawn("npx", cmdArgs, {
    stdio: "inherit"
  });
  process.on("SIGINT", () => {
    child.kill(2);
  }), child.on("close", (code) => {
    process.exit(code || void 0);
  });
};
function printMods(output) {
  output.print(`Available code modifications:
`);
  for (const [modName, mod] of Object.entries(mods))
    output.print(`${modName} - ${mod.purpose}`);
}
function ensureNpx() {
  try {
    if (!childProcess__default.default.execSync("npx --help", { encoding: "utf8" }).includes("npm"))
      throw new Error("Not the npx we expected");
  } catch {
    throw new Error(
      'Failed to run "npx" - required to run codemods. Do you have a recent version of npm installed?'
    );
  }
}
const helpText$9 = `
Runs a given code modification script on the current studio folder.
Running the command without a specified codemod name will list available transformations.

Options
  --dry Dry run (no changes are made to files)
  --extensions=EXT Transform files with these file extensions (comma separated list)
                   (default: js,ts,tsx)
  --no-verify Skips verification steps before running codemod

Examples
  # Show available code mods
  sanity codemod

  # Run codemod to transform react-icons imports from v2 style to v3 style,
  # but only as a dry-run (do not write the files)
  sanity codemod reactIconsV3 --dry

`, codemodCommand = {
  name: "codemod",
  signature: "[CODEMOD_NAME]",
  description: "Updates Sanity Studio codebase with a code modification script",
  helpText: helpText$9,
  action: codemodAction
};
var lodash_isplainobject, hasRequiredLodash_isplainobject;
function requireLodash_isplainobject() {
  if (hasRequiredLodash_isplainobject) return lodash_isplainobject;
  hasRequiredLodash_isplainobject = 1;
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = !1;
    if (value != null && typeof value.toString != "function")
      try {
        result = !!(value + "");
      } catch {
      }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty2 = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString = objectProto.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value))
      return !1;
    var proto = getPrototype(value);
    if (proto === null)
      return !0;
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  return lodash_isplainobject = isPlainObject2, lodash_isplainobject;
}
var promisePropsRecursive_1, hasRequiredPromisePropsRecursive;
function requirePromisePropsRecursive() {
  if (hasRequiredPromisePropsRecursive) return promisePropsRecursive_1;
  hasRequiredPromisePropsRecursive = 1;
  const isPlainObject2 = requireLodash_isplainobject();
  function isPromiseLike(obj) {
    return obj && typeof obj == "object" && typeof obj.then == "function";
  }
  function promiseProps2(obj) {
    const keys = Object.keys(obj), values = keys.map((key2) => obj[key2]);
    return promiseArray(values).then((results) => {
      const result = {};
      for (let i = 0; i < keys.length; i++)
        result[keys[i]] = results[i];
      return result;
    });
  }
  function promiseArray(arr) {
    return Promise.all(arr.map(promisePropsRecursive));
  }
  function promisePropsRecursive(obj) {
    return isPromiseLike(obj) ? obj.then(promisePropsRecursive) : isPlainObject2(obj) ? promiseProps2(obj) : Array.isArray(obj) ? promiseArray(obj) : Promise.resolve(obj);
  }
  return promisePropsRecursive_1 = promisePropsRecursive, promisePropsRecursive_1;
}
var promisePropsRecursiveExports = requirePromisePropsRecursive(), promiseProps = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(promisePropsRecursiveExports), xdgBasedir$1 = {}, hasRequiredXdgBasedir;
function requireXdgBasedir() {
  return hasRequiredXdgBasedir || (hasRequiredXdgBasedir = 1, function(exports2) {
    const os2 = require$$0__default$2.default, path2 = require$$0__default.default, homeDirectory = os2.homedir(), { env } = process;
    exports2.data = env.XDG_DATA_HOME || (homeDirectory ? path2.join(homeDirectory, ".local", "share") : void 0), exports2.config = env.XDG_CONFIG_HOME || (homeDirectory ? path2.join(homeDirectory, ".config") : void 0), exports2.cache = env.XDG_CACHE_HOME || (homeDirectory ? path2.join(homeDirectory, ".cache") : void 0), exports2.runtime = env.XDG_RUNTIME_DIR || void 0, exports2.dataDirs = (env.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":"), exports2.data && exports2.dataDirs.unshift(exports2.data), exports2.configDirs = (env.XDG_CONFIG_DIRS || "/etc/xdg").split(":"), exports2.config && exports2.configDirs.unshift(exports2.config);
  }(xdgBasedir$1)), xdgBasedir$1;
}
var xdgBasedirExports = requireXdgBasedir(), xdgBasedir = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(xdgBasedirExports), registryUrl = { exports: {} }, utils$3 = {}, ini$1 = {}, hasRequiredIni$1;
function requireIni$1() {
  if (hasRequiredIni$1) return ini$1;
  hasRequiredIni$1 = 1, ini$1.parse = ini$1.decode = decode, ini$1.stringify = ini$1.encode = encode, ini$1.safe = safe, ini$1.unsafe = unsafe;
  var eol = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
  function encode(obj, opt) {
    var children = [], out = "";
    typeof opt == "string" ? opt = {
      section: opt,
      whitespace: !1
    } : (opt = opt || {}, opt.whitespace = opt.whitespace === !0);
    var separator2 = opt.whitespace ? " = " : "=";
    return Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      val && Array.isArray(val) ? val.forEach(function(item) {
        out += safe(k + "[]") + separator2 + safe(item) + `
`;
      }) : val && typeof val == "object" ? children.push(k) : out += safe(k) + separator2 + safe(val) + eol;
    }), opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out), children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, child = encode(obj[k], {
        section,
        whitespace: opt.whitespace
      });
      out.length && child.length && (out += eol), out += child;
    }), out;
  }
  function dotSplit(str2) {
    return str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function decode(str2) {
    var out = {}, p = out, section = null, re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines2 = str2.split(/[\r\n]+/g);
    return lines2.forEach(function(line3, _, __) {
      if (!(!line3 || line3.match(/^\s*[;#]/))) {
        var match2 = line3.match(re);
        if (match2) {
          if (match2[1] !== void 0) {
            if (section = unsafe(match2[1]), section === "__proto__") {
              p = {};
              return;
            }
            p = out[section] = out[section] || {};
            return;
          }
          var key2 = unsafe(match2[2]);
          if (key2 !== "__proto__") {
            var value = match2[3] ? unsafe(match2[4]) : !0;
            switch (value) {
              case "true":
              case "false":
              case "null":
                value = JSON.parse(value);
            }
            if (key2.length > 2 && key2.slice(-2) === "[]") {
              if (key2 = key2.substring(0, key2.length - 2), key2 === "__proto__")
                return;
              p[key2] ? Array.isArray(p[key2]) || (p[key2] = [p[key2]]) : p[key2] = [];
            }
            Array.isArray(p[key2]) ? p[key2].push(value) : p[key2] = value;
          }
        }
      }
    }), Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] != "object" || Array.isArray(out[k]))
        return !1;
      var parts = dotSplit(k), p2 = out, l = parts.pop(), nl = l.replace(/\\\./g, ".");
      return parts.forEach(function(part, _2, __2) {
        part !== "__proto__" && ((!p2[part] || typeof p2[part] != "object") && (p2[part] = {}), p2 = p2[part]);
      }), p2 === out && nl === l ? !1 : (p2[nl] = out[k], !0);
    }).forEach(function(del, _, __) {
      delete out[del];
    }), out;
  }
  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }
  function safe(val) {
    return typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function unsafe(val, doUnesc) {
    if (val = (val || "").trim(), isQuoted(val)) {
      val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
      try {
        val = JSON.parse(val);
      } catch {
      }
    } else {
      for (var esc = !1, unesc = "", i = 0, l = val.length; i < l; i++) {
        var c2 = val.charAt(i);
        if (esc)
          "\\;#".indexOf(c2) !== -1 ? unesc += c2 : unesc += "\\" + c2, esc = !1;
        else {
          if (";#".indexOf(c2) !== -1)
            break;
          c2 === "\\" ? esc = !0 : unesc += c2;
        }
      }
      return esc && (unesc += "\\"), unesc.trim();
    }
    return val;
  }
  return ini$1;
}
var stripJsonComments, hasRequiredStripJsonComments;
function requireStripJsonComments() {
  if (hasRequiredStripJsonComments) return stripJsonComments;
  hasRequiredStripJsonComments = 1;
  var singleComment = 1, multiComment = 2;
  function stripWithoutWhitespace() {
    return "";
  }
  function stripWithWhitespace(str2, start, end) {
    return str2.slice(start, end).replace(/\S/g, " ");
  }
  return stripJsonComments = function(str2, opts) {
    opts = opts || {};
    for (var currentChar, nextChar, insideString = !1, insideComment = !1, offset = 0, ret = "", strip = opts.whitespace === !1 ? stripWithoutWhitespace : stripWithWhitespace, i = 0; i < str2.length; i++) {
      if (currentChar = str2[i], nextChar = str2[i + 1], !insideComment && currentChar === '"') {
        var escaped = str2[i - 1] === "\\" && str2[i - 2] !== "\\";
        escaped || (insideString = !insideString);
      }
      if (!insideString) {
        if (!insideComment && currentChar + nextChar === "//")
          ret += str2.slice(offset, i), offset = i, insideComment = singleComment, i++;
        else if (insideComment === singleComment && currentChar + nextChar === `\r
`) {
          i++, insideComment = !1, ret += strip(str2, offset, i), offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === `
`)
          insideComment = !1, ret += strip(str2, offset, i), offset = i;
        else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str2.slice(offset, i), offset = i, insideComment = multiComment, i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++, insideComment = !1, ret += strip(str2, offset, i + 1), offset = i + 1;
          continue;
        }
      }
    }
    return ret + (insideComment ? strip(str2.substr(offset)) : str2.substr(offset));
  }, stripJsonComments;
}
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  var fs2 = require$$0__default$1.default, ini2 = requireIni$1(), path2 = require$$0__default.default, stripJsonComments2 = requireStripJsonComments(), parse3 = utils$3.parse = function(content) {
    return /^\s*{/.test(content) ? JSON.parse(stripJsonComments2(content)) : ini2.parse(content);
  }, file = utils$3.file = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    });
    for (var i in args)
      if (typeof args[i] != "string")
        return;
    var file2 = path2.join.apply(null, args);
    try {
      return fs2.readFileSync(file2, "utf-8");
    } catch {
      return;
    }
  };
  return utils$3.json = function() {
    var content = file.apply(null, arguments);
    return content ? parse3(content) : null;
  }, utils$3.env = function(prefix, env) {
    env = env || process.env;
    var obj = {}, l = prefix.length;
    for (var k in env)
      if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
        for (var keypath = k.substring(l).split("__"), _emptyStringIndex; (_emptyStringIndex = keypath.indexOf("")) > -1; )
          keypath.splice(_emptyStringIndex, 1);
        var cursor = obj;
        keypath.forEach(function(_subkey, i) {
          !_subkey || typeof cursor != "object" || (i === keypath.length - 1 && (cursor[_subkey] = env[k]), cursor[_subkey] === void 0 && (cursor[_subkey] = {}), cursor = cursor[_subkey]);
        });
      }
    return obj;
  }, utils$3.find = function() {
    var rel = path2.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file2 = path2.join(start, rel2);
      try {
        return fs2.statSync(file2), file2;
      } catch {
        if (path2.dirname(start) !== start)
          return find2(path2.dirname(start), rel2);
      }
    }
    return find2(process.cwd(), rel);
  }, utils$3;
}
var deepExtend = { exports: {} };
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var hasRequiredDeepExtend;
function requireDeepExtend() {
  if (hasRequiredDeepExtend) return deepExtend.exports;
  hasRequiredDeepExtend = 1;
  function isSpecificValue(val) {
    return val instanceof Buffer || val instanceof Date || val instanceof RegExp;
  }
  function cloneSpecificValue(val) {
    if (val instanceof Buffer) {
      var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
      return val.copy(x), x;
    } else {
      if (val instanceof Date)
        return new Date(val.getTime());
      if (val instanceof RegExp)
        return new RegExp(val);
      throw new Error("Unexpected situation");
    }
  }
  function deepCloneArray(arr) {
    var clone = [];
    return arr.forEach(function(item, index) {
      typeof item == "object" && item !== null ? Array.isArray(item) ? clone[index] = deepCloneArray(item) : isSpecificValue(item) ? clone[index] = cloneSpecificValue(item) : clone[index] = deepExtend$1({}, item) : clone[index] = item;
    }), clone;
  }
  function safeGetProperty(object, property) {
    return property === "__proto__" ? void 0 : object[property];
  }
  var deepExtend$1 = deepExtend.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] != "object")
      return !1;
    if (arguments.length < 2)
      return arguments[0];
    var target = arguments[0], args = Array.prototype.slice.call(arguments, 1), val, src2;
    return args.forEach(function(obj) {
      typeof obj != "object" || obj === null || Array.isArray(obj) || Object.keys(obj).forEach(function(key2) {
        if (src2 = safeGetProperty(target, key2), val = safeGetProperty(obj, key2), val !== target)
          if (typeof val != "object" || val === null) {
            target[key2] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key2] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key2] = cloneSpecificValue(val);
            return;
          } else if (typeof src2 != "object" || src2 === null || Array.isArray(src2)) {
            target[key2] = deepExtend$1({}, val);
            return;
          } else {
            target[key2] = deepExtend$1(src2, val);
            return;
          }
      });
    }), target;
  };
  return deepExtend.exports;
}
var minimist$1, hasRequiredMinimist;
function requireMinimist() {
  if (hasRequiredMinimist) return minimist$1;
  hasRequiredMinimist = 1;
  function hasKey2(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key3) {
      o = o[key3] || {};
    });
    var key2 = keys[keys.length - 1];
    return key2 in o;
  }
  function isNumber2(x) {
    return typeof x == "number" || /^0x[0-9a-f]+$/i.test(x) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
  function isConstructorOrProto(obj, key2) {
    return key2 === "constructor" && typeof obj[key2] == "function" || key2 === "__proto__";
  }
  return minimist$1 = function(args, opts) {
    opts || (opts = {});
    var flags = {
      bools: {},
      strings: {},
      unknownFn: null
    };
    typeof opts.unknown == "function" && (flags.unknownFn = opts.unknown), typeof opts.boolean == "boolean" && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach(function(key3) {
      flags.bools[key3] = !0;
    });
    var aliases = {};
    function aliasIsBoolean(key3) {
      return aliases[key3].some(function(x) {
        return flags.bools[x];
      });
    }
    Object.keys(opts.alias || {}).forEach(function(key3) {
      aliases[key3] = [].concat(opts.alias[key3]), aliases[key3].forEach(function(x) {
        aliases[x] = [key3].concat(aliases[key3].filter(function(y) {
          return x !== y;
        }));
      });
    }), [].concat(opts.string).filter(Boolean).forEach(function(key3) {
      flags.strings[key3] = !0, aliases[key3] && [].concat(aliases[key3]).forEach(function(k) {
        flags.strings[k] = !0;
      });
    });
    var defaults2 = opts.default || {}, argv = { _: [] };
    function argDefined(key3, arg2) {
      return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key3] || flags.bools[key3] || aliases[key3];
    }
    function setKey(obj, keys, value2) {
      for (var o = obj, i2 = 0; i2 < keys.length - 1; i2++) {
        var key3 = keys[i2];
        if (isConstructorOrProto(o, key3))
          return;
        o[key3] === void 0 && (o[key3] = {}), (o[key3] === Object.prototype || o[key3] === Number.prototype || o[key3] === String.prototype) && (o[key3] = {}), o[key3] === Array.prototype && (o[key3] = []), o = o[key3];
      }
      var lastKey = keys[keys.length - 1];
      isConstructorOrProto(o, lastKey) || ((o === Object.prototype || o === Number.prototype || o === String.prototype) && (o = {}), o === Array.prototype && (o = []), o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] == "boolean" ? o[lastKey] = value2 : Array.isArray(o[lastKey]) ? o[lastKey].push(value2) : o[lastKey] = [o[lastKey], value2]);
    }
    function setArg(key3, val, arg2) {
      if (!(arg2 && flags.unknownFn && !argDefined(key3, arg2) && flags.unknownFn(arg2) === !1)) {
        var value2 = !flags.strings[key3] && isNumber2(val) ? Number(val) : val;
        setKey(argv, key3.split("."), value2), (aliases[key3] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
    }
    Object.keys(flags.bools).forEach(function(key3) {
      setArg(key3, defaults2[key3] === void 0 ? !1 : defaults2[key3]);
    });
    var notFlags = [];
    args.indexOf("--") !== -1 && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
    for (var i = 0; i < args.length; i++) {
      var arg = args[i], key2, next;
      if (/^--.+=/.test(arg)) {
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        key2 = m[1];
        var value = m[2];
        flags.bools[key2] && (value = value !== "false"), setArg(key2, value, arg);
      } else if (/^--no-.+/.test(arg))
        key2 = arg.match(/^--no-(.+)/)[1], setArg(key2, !1, arg);
      else if (/^--.+/.test(arg))
        key2 = arg.match(/^--(.+)/)[1], next = args[i + 1], next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key2] && !flags.allBools && (!aliases[key2] || !aliasIsBoolean(key2)) ? (setArg(key2, next, arg), i += 1) : /^(true|false)$/.test(next) ? (setArg(key2, next === "true", arg), i += 1) : setArg(key2, flags.strings[key2] ? "" : !0, arg);
      else if (/^-[^-]+/.test(arg)) {
        for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) {
          if (next = arg.slice(j + 2), next === "-") {
            setArg(letters[j], next, arg);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
            setArg(letters[j], next.slice(1), arg), broken = !0;
            break;
          }
          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg), broken = !0;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
            break;
          } else
            setArg(letters[j], flags.strings[letters[j]] ? "" : !0, arg);
        }
        key2 = arg.slice(-1)[0], !broken && key2 !== "-" && (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key2] && (!aliases[key2] || !aliasIsBoolean(key2)) ? (setArg(key2, args[i + 1], arg), i += 1) : args[i + 1] && /^(true|false)$/.test(args[i + 1]) ? (setArg(key2, args[i + 1] === "true", arg), i += 1) : setArg(key2, flags.strings[key2] ? "" : !0, arg));
      } else if ((!flags.unknownFn || flags.unknownFn(arg) !== !1) && argv._.push(flags.strings._ || !isNumber2(arg) ? arg : Number(arg)), opts.stopEarly) {
        argv._.push.apply(argv._, args.slice(i + 1));
        break;
      }
    }
    return Object.keys(defaults2).forEach(function(k) {
      hasKey2(argv, k.split(".")) || (setKey(argv, k.split("."), defaults2[k]), (aliases[k] || []).forEach(function(x) {
        setKey(argv, x.split("."), defaults2[k]);
      }));
    }), opts["--"] ? argv["--"] = notFlags.slice() : notFlags.forEach(function(k) {
      argv._.push(k);
    }), argv;
  }, minimist$1;
}
var rc, hasRequiredRc;
function requireRc() {
  if (hasRequiredRc) return rc;
  hasRequiredRc = 1;
  var cc = requireUtils$3(), join = require$$0__default.default.join, deepExtend2 = requireDeepExtend(), etc = "/etc", win = process.platform === "win32", home = win ? process.env.USERPROFILE : process.env.HOME;
  return rc = function(name, defaults2, argv, parse3) {
    if (typeof name != "string")
      throw new Error("rc(name): name *must* be string");
    argv || (argv = requireMinimist()(process.argv.slice(2))), defaults2 = (typeof defaults2 == "string" ? cc.json(defaults2) : defaults2) || {}, parse3 = parse3 || cc.parse;
    var env = cc.env(name + "_"), configs = [defaults2], configFiles = [];
    function addConfigFile(file) {
      if (!(configFiles.indexOf(file) >= 0)) {
        var fileConfig = cc.file(file);
        fileConfig && (configs.push(parse3(fileConfig)), configFiles.push(file));
      }
    }
    return win || [
      join(etc, name, "config"),
      join(etc, name + "rc")
    ].forEach(addConfigFile), home && [
      join(home, ".config", name, "config"),
      join(home, ".config", name),
      join(home, "." + name, "config"),
      join(home, "." + name + "rc")
    ].forEach(addConfigFile), addConfigFile(cc.find("." + name + "rc")), env.config && addConfigFile(env.config), argv.config && addConfigFile(argv.config), deepExtend2.apply(null, configs.concat([
      env,
      argv,
      configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
    ]));
  }, rc;
}
var hasRequiredRegistryUrl;
function requireRegistryUrl() {
  if (hasRequiredRegistryUrl) return registryUrl.exports;
  hasRequiredRegistryUrl = 1;
  const rc2 = requireRc(), registryUrl$1 = (scope2) => {
    const result = rc2("npm", { registry: "https://registry.npmjs.org/" }), url = result[`${scope2}:registry`] || result.config_registry || result.registry;
    return url.slice(-1) === "/" ? url : `${url}/`;
  };
  return registryUrl.exports = registryUrl$1, registryUrl.exports.default = registryUrl$1, registryUrl.exports;
}
var npmConf = { exports: {} }, dist$4 = {}, caFile = {}, polyfills$1, hasRequiredPolyfills$1;
function requirePolyfills$1() {
  if (hasRequiredPolyfills$1) return polyfills$1;
  hasRequiredPolyfills$1 = 1;
  var constants2 = require$$0__default$3.default, origCwd = process.cwd, cwd = null, platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return cwd || (cwd = origCwd.call(process)), cwd;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills$1 = patch;
  function patch(fs2) {
    constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs2), fs2.lutimes || patchLutimes(fs2), fs2.chown = chownFix(fs2.chown), fs2.fchown = chownFix(fs2.fchown), fs2.lchown = chownFix(fs2.lchown), fs2.chmod = chmodFix(fs2.chmod), fs2.fchmod = chmodFix(fs2.fchmod), fs2.lchmod = chmodFix(fs2.lchmod), fs2.chownSync = chownFixSync(fs2.chownSync), fs2.fchownSync = chownFixSync(fs2.fchownSync), fs2.lchownSync = chownFixSync(fs2.lchownSync), fs2.chmodSync = chmodFixSync(fs2.chmodSync), fs2.fchmodSync = chmodFixSync(fs2.fchmodSync), fs2.lchmodSync = chmodFixSync(fs2.lchmodSync), fs2.stat = statFix(fs2.stat), fs2.fstat = statFix(fs2.fstat), fs2.lstat = statFix(fs2.lstat), fs2.statSync = statFixSync(fs2.statSync), fs2.fstatSync = statFixSync(fs2.fstatSync), fs2.lstatSync = statFixSync(fs2.lstatSync), fs2.chmod && !fs2.lchmod && (fs2.lchmod = function(path2, mode2, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchmodSync = function() {
    }), fs2.chown && !fs2.lchown && (fs2.lchown = function(path2, uid, gid, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchownSync = function() {
    }), platform2 === "win32" && (fs2.rename = typeof fs2.rename != "function" ? fs2.rename : function(fs$rename) {
      function rename2(from2, to, cb) {
        var start = Date.now(), backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                stater && stater.code === "ENOENT" ? fs$rename(from2, to, CB) : cb(er);
              });
            }, backoff), backoff < 100 && (backoff += 10);
            return;
          }
          cb && cb(er);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(rename2, fs$rename), rename2;
    }(fs2.rename)), fs2.read = typeof fs2.read != "function" ? fs2.read : function(fs$read) {
      function read2(fd, buffer2, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ == "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10)
              return eagCounter++, fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(read2, fs$read), read2;
    }(fs2.read), fs2.readSync = typeof fs2.readSync != "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer2, offset, length, position) {
        for (var eagCounter = 0; ; )
          try {
            return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path2, mode2, callback) {
        fs3.open(
          path2,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode2,
          function(err, fd) {
            if (err) {
              callback && callback(err);
              return;
            }
            fs3.fchmod(fd, mode2, function(err2) {
              fs3.close(fd, function(err22) {
                callback && callback(err2 || err22);
              });
            });
          }
        );
      }, fs3.lchmodSync = function(path2, mode2) {
        var fd = fs3.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode2), threw = !0, ret;
        try {
          ret = fs3.fchmodSync(fd, mode2), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      constants2.hasOwnProperty("O_SYMLINK") && fs3.futimes ? (fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants2.O_SYMLINK, function(er, fd) {
          if (er) {
            cb && cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              cb && cb(er2 || er22);
            });
          });
        });
      }, fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants2.O_SYMLINK), ret, threw = !0;
        try {
          ret = fs3.futimesSync(fd, at, mt), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      }) : fs3.futimes && (fs3.lutimes = function(_a, _b, _c, cb) {
        cb && process.nextTick(cb);
      }, fs3.lutimesSync = function() {
      });
    }
    function chmodFix(orig) {
      return orig && function(target, mode2, cb) {
        return orig.call(fs2, target, mode2, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      return orig && function(target, mode2) {
        try {
          return orig.call(fs2, target, mode2);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      return orig && function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      return orig && function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      return orig && function(target, options2, cb) {
        typeof options2 == "function" && (cb = options2, options2 = null);
        function callback(er, stats) {
          stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
        }
        return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      return orig && function(target, options2) {
        var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
        return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
      };
    }
    function chownErOk(er) {
      if (!er || er.code === "ENOSYS")
        return !0;
      var nonroot = !process.getuid || process.getuid() !== 0;
      return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
    }
  }
  return polyfills$1;
}
var legacyStreams$1, hasRequiredLegacyStreams$1;
function requireLegacyStreams$1() {
  if (hasRequiredLegacyStreams$1) return legacyStreams$1;
  hasRequiredLegacyStreams$1 = 1;
  var Stream2 = require$$0__default$4.default.Stream;
  legacyStreams$1 = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options2) {
      if (!(this instanceof ReadStream)) return new ReadStream(path2, options2);
      Stream2.call(this);
      var self2 = this;
      this.path = path2, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err), self2.readable = !1;
          return;
        }
        self2.fd = fd, self2.emit("open", fd), self2._read();
      });
    }
    function WriteStream(path2, options2) {
      if (!(this instanceof WriteStream)) return new WriteStream(path2, options2);
      Stream2.call(this), this.path = path2, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = fs2.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return legacyStreams$1;
}
var clone_1$1, hasRequiredClone$1;
function requireClone$1() {
  if (hasRequiredClone$1) return clone_1$1;
  hasRequiredClone$1 = 1, clone_1$1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj != "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(obj).forEach(function(key2) {
      Object.defineProperty(copy2, key2, Object.getOwnPropertyDescriptor(obj, key2));
    }), copy2;
  }
  return clone_1$1;
}
var gracefulFs$1, hasRequiredGracefulFs$1;
function requireGracefulFs$1() {
  if (hasRequiredGracefulFs$1) return gracefulFs$1;
  hasRequiredGracefulFs$1 = 1;
  var fs2 = require$$0__default$1.default, polyfills2 = requirePolyfills$1(), legacy = requireLegacyStreams$1(), clone = requireClone$1(), util2 = require$$0__default$6.default, gracefulQueue, previousSymbol;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
  function noop2() {
  }
  function publishQueue(context, queue3) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue3;
      }
    });
  }
  var debug2 = noop2;
  if (util2.debuglog ? debug2 = util2.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug2 = function() {
    var m = util2.format.apply(util2, arguments);
    m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
  }), !fs2[gracefulQueue]) {
    var queue2 = loadEnv.commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue2), fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs2.close), fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs2.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug2(fs2[gracefulQueue]), require$$0__default$5.default.equal(fs2[gracefulQueue].length, 0);
    });
  }
  loadEnv.commonjsGlobal[gracefulQueue] || publishQueue(loadEnv.commonjsGlobal, fs2[gracefulQueue]), gracefulFs$1 = patch(clone(fs2)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched && (gracefulFs$1 = patch(fs2), fs2.__patched = !0);
  function patch(fs3) {
    polyfills2(fs3), fs3.gracefulify = patch, fs3.createReadStream = createReadStream, fs3.createWriteStream = createWriteStream;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile;
    function readFile(path2, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$readFile(path2, options2, cb);
      function go$readFile(path3, options3, cb2, startTime) {
        return fs$readFile(path3, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile;
    function writeFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$writeFile(path2, data, options2, cb);
      function go$writeFile(path3, data2, options3, cb2, startTime) {
        return fs$writeFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    fs$appendFile && (fs3.appendFile = appendFile);
    function appendFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$appendFile(path2, data, options2, cb);
      function go$appendFile(path3, data2, options3, cb2, startTime) {
        return fs$appendFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    fs$copyFile && (fs3.copyFile = copyFile);
    function copyFile(src2, dest, flags, cb) {
      return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src3, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src3, dest2, flags2, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir2;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir2(path2, options2, cb) {
      typeof options2 == "function" && (cb = options2, options2 = null);
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      } : function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, options3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      };
      return go$readdir(path2, options2, cb);
      function fs$readdirCallback(path3, options3, cb2, startTime) {
        return function(err, files) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
            go$readdir,
            [path3, options3, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs3);
      ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
    var fs$WriteStream = fs3.WriteStream;
    fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    function ReadStream(path2, options2) {
      return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
      });
    }
    function WriteStream(path2, options2) {
      return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
      });
    }
    function createReadStream(path2, options2) {
      return new fs3.ReadStream(path2, options2);
    }
    function createWriteStream(path2, options2) {
      return new fs3.WriteStream(path2, options2);
    }
    var fs$open = fs3.open;
    fs3.open = open2;
    function open2(path2, flags, mode2, cb) {
      return typeof mode2 == "function" && (cb = mode2, mode2 = null), go$open(path2, flags, mode2, cb);
      function go$open(path3, flags2, mode3, cb2, startTime) {
        return fs$open(path3, flags2, mode3, function(err, fd) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path3, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug2("ENQUEUE", elem[0].name, elem[1]), fs2[gracefulQueue].push(elem), retry2();
  }
  var retryTimer;
  function resetQueue() {
    for (var now = Date.now(), i = 0; i < fs2[gracefulQueue].length; ++i)
      fs2[gracefulQueue][i].length > 2 && (fs2[gracefulQueue][i][3] = now, fs2[gracefulQueue][i][4] = now);
    retry2();
  }
  function retry2() {
    if (clearTimeout(retryTimer), retryTimer = void 0, fs2[gracefulQueue].length !== 0) {
      var elem = fs2[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
      if (startTime === void 0)
        debug2("RETRY", fn.name, args), fn.apply(null, args);
      else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        typeof cb == "function" && cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
        sinceAttempt >= desiredDelay ? (debug2("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs2[gracefulQueue].push(elem);
      }
      retryTimer === void 0 && (retryTimer = setTimeout(retry2, 0));
    }
  }
  return gracefulFs$1;
}
var hasRequiredCaFile;
function requireCaFile() {
  if (hasRequiredCaFile) return caFile;
  hasRequiredCaFile = 1;
  var __importDefault2 = caFile && caFile.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(caFile, "__esModule", { value: !0 }), caFile.readCAFileSync = void 0;
  const graceful_fs_1 = __importDefault2(requireGracefulFs$1());
  function readCAFileSync(filePath) {
    try {
      const contents = graceful_fs_1.default.readFileSync(filePath, "utf8"), delim = "-----END CERTIFICATE-----";
      return contents.split(delim).filter((ca) => !!ca.trim()).map((ca) => `${ca.trimLeft()}${delim}`);
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
  }
  return caFile.readCAFileSync = readCAFileSync, caFile;
}
var hasRequiredDist$3;
function requireDist$3() {
  return hasRequiredDist$3 || (hasRequiredDist$3 = 1, function(exports2) {
    var __createBinding2 = dist$4 && dist$4.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = dist$4 && dist$4.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), __exportStar2(requireCaFile(), exports2);
  }(dist$4)), dist$4;
}
var configChain = { exports: {} }, protoList, hasRequiredProtoList;
function requireProtoList() {
  if (hasRequiredProtoList) return protoList;
  hasRequiredProtoList = 1, protoList = ProtoList;
  function setProto(obj, proto) {
    if (typeof Object.setPrototypeOf == "function")
      return Object.setPrototypeOf(obj, proto);
    obj.__proto__ = proto;
  }
  function ProtoList() {
    this.list = [];
    var root2 = null;
    Object.defineProperty(this, "root", {
      get: function() {
        return root2;
      },
      set: function(r) {
        root2 = r, this.list.length && setProto(this.list[this.list.length - 1], r);
      },
      enumerable: !0,
      configurable: !0
    });
  }
  return ProtoList.prototype = {
    get length() {
      return this.list.length;
    },
    get keys() {
      var k = [];
      for (var i in this.list[0]) k.push(i);
      return k;
    },
    get snapshot() {
      var o = {};
      return this.keys.forEach(function(k) {
        o[k] = this.get(k);
      }, this), o;
    },
    get store() {
      return this.list[0];
    },
    push: function(obj) {
      return typeof obj != "object" && (obj = { valueOf: obj }), this.list.length >= 1 && setProto(this.list[this.list.length - 1], obj), setProto(obj, this.root), this.list.push(obj);
    },
    pop: function() {
      return this.list.length >= 2 && setProto(this.list[this.list.length - 2], this.root), this.list.pop();
    },
    unshift: function(obj) {
      return setProto(obj, this.list[0] || this.root), this.list.unshift(obj);
    },
    shift: function() {
      return this.list.length === 1 && setProto(this.list[0], this.root), this.list.shift();
    },
    get: function(key2) {
      return this.list[0][key2];
    },
    set: function(key2, val, save) {
      return this.length || this.push({}), save && this.list[0].hasOwnProperty(key2) && this.push({}), this.list[0][key2] = val;
    },
    forEach: function(fn, thisp) {
      for (var key2 in this.list[0]) fn.call(thisp, key2, this.list[0][key2]);
    },
    slice: function() {
      return this.list.slice.apply(this.list, arguments);
    },
    splice: function() {
      for (var ret = this.list.splice.apply(this.list, arguments), i = 0, l = this.list.length; i < l; i++)
        setProto(this.list[i], this.list[i + 1] || this.root);
      return ret;
    }
  }, protoList;
}
var hasRequiredConfigChain;
function requireConfigChain() {
  if (hasRequiredConfigChain) return configChain.exports;
  hasRequiredConfigChain = 1;
  var ProtoList = requireProtoList(), path2 = require$$0__default.default, fs2 = require$$0__default$1.default, ini2 = requireIni$1(), EE = require$$0__default$7.default.EventEmitter, url = require$$0__default$8.default, http2 = require$$6__default.default, exports2 = configChain.exports = function() {
    for (var args = [].slice.call(arguments), conf2 = new ConfigChain(); args.length; ) {
      var a = args.shift();
      a && conf2.push(typeof a == "string" ? json2(a) : a);
    }
    return conf2;
  };
  exports2.find = function() {
    var rel = path2.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file = path2.join(start, rel2);
      try {
        return fs2.statSync(file), file;
      } catch {
        if (path2.dirname(start) !== start)
          return find2(path2.dirname(start), rel2);
      }
    }
    return find2(__dirname, rel);
  };
  var parse3 = exports2.parse = function(content, file, type2) {
    if (content = "" + content, type2)
      if (type2 === "json")
        if (this.emit)
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit("error", er);
          }
        else
          return JSON.parse(content);
      else
        return ini2.parse(content);
    else try {
      return JSON.parse(content);
    } catch {
      return ini2.parse(content);
    }
  }, json2 = exports2.json = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    }), file = path2.join.apply(null, args), content;
    try {
      content = fs2.readFileSync(file, "utf-8");
    } catch {
      return;
    }
    return parse3(content, file, "json");
  };
  exports2.env = function(prefix, env) {
    env = env || process.env;
    var obj = {}, l = prefix.length;
    for (var k in env)
      k.indexOf(prefix) === 0 && (obj[k.substring(l)] = env[k]);
    return obj;
  }, exports2.ConfigChain = ConfigChain;
  function ConfigChain() {
    EE.apply(this), ProtoList.apply(this, arguments), this._awaiting = 0, this._saving = 0, this.sources = {};
  }
  var extras = {
    constructor: { value: ConfigChain }
  };
  return Object.keys(EE.prototype).forEach(function(k) {
    extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
  }), ConfigChain.prototype = Object.create(ProtoList.prototype, extras), ConfigChain.prototype.del = function(key2, where) {
    if (where) {
      var target = this.sources[where];
      if (target = target && target.data, !target)
        return this.emit("error", new Error("not found " + where));
      delete target[key2];
    } else
      for (var i = 0, l = this.list.length; i < l; i++)
        delete this.list[i][key2];
    return this;
  }, ConfigChain.prototype.set = function(key2, value, where) {
    var target;
    if (where) {
      if (target = this.sources[where], target = target && target.data, !target)
        return this.emit("error", new Error("not found " + where));
    } else if (target = this.list[0], !target)
      return this.emit("error", new Error("cannot set, no confs!"));
    return target[key2] = value, this;
  }, ConfigChain.prototype.get = function(key2, where) {
    return where ? (where = this.sources[where], where && (where = where.data), where && Object.hasOwnProperty.call(where, key2) ? where[key2] : void 0) : this.list[0][key2];
  }, ConfigChain.prototype.save = function(where, type2, cb) {
    typeof type2 == "function" && (cb = type2, type2 = null);
    var target = this.sources[where];
    if (!target || !(target.path || target.source) || !target.data)
      return this.emit("error", new Error("bad save target: " + where));
    if (target.source) {
      var pref = target.prefix || "";
      return Object.keys(target.data).forEach(function(k) {
        target.source[pref + k] = target.data[k];
      }), this;
    }
    var type2 = type2 || target.type, data = target.data;
    return target.type === "json" ? data = JSON.stringify(data) : data = ini2.stringify(data), this._saving++, fs2.writeFile(target.path, data, "utf8", function(er) {
      if (this._saving--, er)
        return cb ? cb(er) : this.emit("error", er);
      this._saving === 0 && (cb && cb(), this.emit("save"));
    }.bind(this)), this;
  }, ConfigChain.prototype.addFile = function(file, type2, name) {
    name = name || file;
    var marker = { __source__: name };
    return this.sources[name] = { path: file, type: type2 }, this.push(marker), this._await(), fs2.readFile(file, "utf8", function(er, data) {
      er && this.emit("error", er), this.addString(data, file, type2, marker);
    }.bind(this)), this;
  }, ConfigChain.prototype.addEnv = function(prefix, env, name) {
    name = name || "env";
    var data = exports2.env(prefix, env);
    return this.sources[name] = { data, source: env, prefix }, this.add(data, name);
  }, ConfigChain.prototype.addUrl = function(req, type2, name) {
    this._await();
    var href = url.format(req);
    name = name || href;
    var marker = { __source__: name };
    return this.sources[name] = { href, type: type2 }, this.push(marker), http2.request(req, function(res) {
      var c2 = [], ct = res.headers["content-type"];
      type2 || (type2 = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null, marker.type = type2), res.on("data", c2.push.bind(c2)).on("end", function() {
        this.addString(Buffer.concat(c2), href, type2, marker);
      }.bind(this)).on("error", this.emit.bind(this, "error"));
    }.bind(this)).on("error", this.emit.bind(this, "error")).end(), this;
  }, ConfigChain.prototype.addString = function(data, file, type2, marker) {
    return data = this.parse(data, file, type2), this.add(data, marker), this;
  }, ConfigChain.prototype.add = function(data, marker) {
    if (marker && typeof marker == "object") {
      var i = this.list.indexOf(marker);
      if (i === -1)
        return this.emit("error", new Error("bad marker"));
      this.splice(i, 1, data), marker = marker.__source__, this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data, this._resolve();
    } else
      typeof marker == "string" && (this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data), this._await(), this.push(data), process.nextTick(this._resolve.bind(this));
    return this;
  }, ConfigChain.prototype.parse = exports2.parse, ConfigChain.prototype._await = function() {
    this._awaiting++;
  }, ConfigChain.prototype._resolve = function() {
    this._awaiting--, this._awaiting === 0 && this.emit("load", this);
  }, configChain.exports;
}
var envKeyToSetting, hasRequiredEnvKeyToSetting;
function requireEnvKeyToSetting() {
  if (hasRequiredEnvKeyToSetting) return envKeyToSetting;
  hasRequiredEnvKeyToSetting = 1, envKeyToSetting = function(x) {
    const colonIndex = x.indexOf(":");
    if (colonIndex === -1)
      return normalize2(x);
    const firstPart = x.substr(0, colonIndex), secondPart = x.substr(colonIndex + 1);
    return `${normalize2(firstPart)}:${normalize2(secondPart)}`;
  };
  function normalize2(s) {
    if (s = s.toLowerCase(), s === "_authtoken") return "_authToken";
    let r = s[0];
    for (let i = 1; i < s.length; i++)
      r += s[i] === "_" ? "-" : s[i];
    return r;
  }
  return envKeyToSetting;
}
var util$3 = {}, dist$3 = {}, envReplace = {}, hasRequiredEnvReplace;
function requireEnvReplace() {
  if (hasRequiredEnvReplace) return envReplace;
  hasRequiredEnvReplace = 1, Object.defineProperty(envReplace, "__esModule", { value: !0 }), envReplace.envReplace = void 0;
  const ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
  function envReplace$1(settingValue, env) {
    return settingValue.replace(ENV_EXPR, replaceEnvMatch.bind(null, env));
  }
  envReplace.envReplace = envReplace$1;
  function replaceEnvMatch(env, orig, escape2, name) {
    if (escape2.length % 2)
      return orig.slice((escape2.length + 1) / 2);
    const envValue = getEnvValue(env, name);
    if (envValue === void 0)
      throw new Error(`Failed to replace env in config: ${orig}`);
    return `${escape2.slice(escape2.length / 2)}${envValue}`;
  }
  const ENV_VALUE = /([^:-]+)(:?)-(.+)/;
  function getEnvValue(env, name) {
    const matched = name.match(ENV_VALUE);
    if (!matched)
      return env[name];
    const [, variableName, colon, fallback] = matched;
    return Object.prototype.hasOwnProperty.call(env, variableName) ? !env[variableName] && colon ? fallback : env[variableName] : fallback;
  }
  return envReplace;
}
var hasRequiredDist$2;
function requireDist$2() {
  return hasRequiredDist$2 || (hasRequiredDist$2 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.envReplace = void 0;
    var env_replace_1 = requireEnvReplace();
    Object.defineProperty(exports2, "envReplace", { enumerable: !0, get: function() {
      return env_replace_1.envReplace;
    } });
  }(dist$3)), dist$3;
}
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$3;
  hasRequiredUtil$2 = 1;
  const fs2 = require$$0__default$1.default, path2 = require$$0__default.default, { envReplace: envReplace2 } = requireDist$2(), parseKey = (key2) => typeof key2 != "string" ? key2 : envReplace2(key2, process.env), parseField = (types2, field, key2) => {
    if (typeof field != "string")
      return field;
    const typeList = [].concat(types2[key2]), isPath = typeList.indexOf(path2) !== -1, isBool = typeList.indexOf(Boolean) !== -1, isString = typeList.indexOf(String) !== -1, isNumber2 = typeList.indexOf(Number) !== -1;
    if (field = `${field}`.trim(), /^".*"$/.test(field))
      try {
        field = JSON.parse(field);
      } catch {
        throw new Error(`Failed parsing JSON config key ${key2}: ${field}`);
      }
    if (isBool && !isString && field === "")
      return !0;
    switch (field) {
      // eslint-disable-line default-case
      case "true":
        return !0;
      case "false":
        return !1;
      case "null":
        return null;
      case "undefined":
        return;
    }
    return field = envReplace2(field, process.env), isPath && ((process.platform === "win32" ? /^~(\/|\\)/ : /^~\//).test(field) && process.env.HOME && (field = path2.resolve(process.env.HOME, field.substr(2))), field = path2.resolve(field)), isNumber2 && !isNaN(field) && (field = Number(field)), field;
  }, findPrefix = (name) => {
    name = path2.resolve(name);
    let walkedUp = !1;
    for (; path2.basename(name) === "node_modules"; )
      name = path2.dirname(name), walkedUp = !0;
    if (walkedUp)
      return name;
    const find2 = (name2, original) => {
      const regex2 = /^[a-zA-Z]:(\\|\/)?$/;
      if (name2 === "/" || process.platform === "win32" && regex2.test(name2))
        return original;
      try {
        const files = fs2.readdirSync(name2);
        if (files.includes("node_modules") || files.includes("package.json") || files.includes("package.json5") || files.includes("package.yaml") || files.includes("pnpm-workspace.yaml"))
          return name2;
        const dirname = path2.dirname(name2);
        return dirname === name2 ? original : find2(dirname, original);
      } catch (error2) {
        if (name2 === original) {
          if (error2.code === "ENOENT")
            return original;
          throw error2;
        }
        return original;
      }
    };
    return find2(name, name);
  };
  return util$3.envReplace = envReplace2, util$3.findPrefix = findPrefix, util$3.parseField = parseField, util$3.parseKey = parseKey, util$3;
}
var types$4 = {}, hasRequiredTypes$3;
function requireTypes$3() {
  if (hasRequiredTypes$3) return types$4;
  hasRequiredTypes$3 = 1;
  const path2 = require$$0__default.default, Stream2 = require$$0__default$4.default.Stream, url = require$$0__default$8.default, Umask = () => {
  }, getLocalAddresses = () => [], semver2 = () => {
  };
  return types$4.types = {
    access: [null, "restricted", "public"],
    "allow-same-version": Boolean,
    "always-auth": Boolean,
    also: [null, "dev", "development"],
    audit: Boolean,
    "auth-type": ["legacy", "sso", "saml", "oauth"],
    "bin-links": Boolean,
    browser: [null, String],
    ca: [null, String, Array],
    cafile: path2,
    cache: path2,
    "cache-lock-stale": Number,
    "cache-lock-retries": Number,
    "cache-lock-wait": Number,
    "cache-max": Number,
    "cache-min": Number,
    cert: [null, String],
    cidr: [null, String, Array],
    color: ["always", Boolean],
    depth: Number,
    description: Boolean,
    dev: Boolean,
    "dry-run": Boolean,
    editor: String,
    "engine-strict": Boolean,
    force: Boolean,
    "fetch-retries": Number,
    "fetch-retry-factor": Number,
    "fetch-retry-mintimeout": Number,
    "fetch-retry-maxtimeout": Number,
    git: String,
    "git-tag-version": Boolean,
    "commit-hooks": Boolean,
    global: Boolean,
    globalconfig: path2,
    "global-style": Boolean,
    group: [Number, String],
    "https-proxy": [null, url],
    "user-agent": String,
    "ham-it-up": Boolean,
    heading: String,
    "if-present": Boolean,
    "ignore-prepublish": Boolean,
    "ignore-scripts": Boolean,
    "init-module": path2,
    "init-author-name": String,
    "init-author-email": String,
    "init-author-url": ["", url],
    "init-license": String,
    "init-version": semver2,
    json: Boolean,
    key: [null, String],
    "legacy-bundling": Boolean,
    link: Boolean,
    // local-address must be listed as an IP for a local network interface
    // must be IPv4 due to node bug
    "local-address": getLocalAddresses(),
    loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
    logstream: Stream2,
    "logs-max": Number,
    long: Boolean,
    maxsockets: Number,
    message: String,
    "metrics-registry": [null, String],
    "node-options": [null, String],
    "node-version": [null, semver2],
    "no-proxy": [null, String, Array],
    offline: Boolean,
    "onload-script": [null, String],
    only: [null, "dev", "development", "prod", "production"],
    optional: Boolean,
    "package-lock": Boolean,
    otp: [null, String],
    "package-lock-only": Boolean,
    parseable: Boolean,
    "prefer-offline": Boolean,
    "prefer-online": Boolean,
    prefix: path2,
    production: Boolean,
    progress: Boolean,
    proxy: [null, !1, url],
    provenance: Boolean,
    // allow proxy to be disabled explicitly
    "read-only": Boolean,
    "rebuild-bundle": Boolean,
    registry: [null, url],
    rollback: Boolean,
    save: Boolean,
    "save-bundle": Boolean,
    "save-dev": Boolean,
    "save-exact": Boolean,
    "save-optional": Boolean,
    "save-prefix": String,
    "save-prod": Boolean,
    scope: String,
    "script-shell": [null, String],
    "scripts-prepend-node-path": [!1, !0, "auto", "warn-only"],
    searchopts: String,
    searchexclude: [null, String],
    searchlimit: Number,
    searchstaleness: Number,
    "send-metrics": Boolean,
    shell: String,
    shrinkwrap: Boolean,
    "sign-git-tag": Boolean,
    "sso-poll-frequency": Number,
    "sso-type": [null, "oauth", "saml"],
    "strict-ssl": Boolean,
    tag: String,
    timing: Boolean,
    tmp: path2,
    unicode: Boolean,
    "unsafe-perm": Boolean,
    usage: Boolean,
    user: [Number, String],
    userconfig: path2,
    umask: Umask,
    version: Boolean,
    "tag-version-prefix": String,
    versions: Boolean,
    viewer: String,
    _exit: Boolean
  }, types$4;
}
var conf, hasRequiredConf;
function requireConf() {
  if (hasRequiredConf) return conf;
  hasRequiredConf = 1;
  const { readCAFileSync } = requireDist$3(), fs2 = require$$0__default$1.default, path2 = require$$0__default.default, { ConfigChain } = requireConfigChain(), envKeyToSetting2 = requireEnvKeyToSetting(), util2 = requireUtil$2();
  class Conf extends ConfigChain {
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
    constructor(base2, types2) {
      super(base2), this.root = base2, this._parseField = util2.parseField.bind(null, types2 || requireTypes$3());
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
    add(data, marker) {
      try {
        for (const [key2, value] of Object.entries(data)) {
          const substKey = util2.parseKey(key2);
          substKey !== key2 && delete data[key2], data[substKey] = this._parseField(value, substKey);
        }
      } catch (error2) {
        throw error2;
      }
      return super.add(data, marker);
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
    addFile(file, name) {
      name = name || file;
      const marker = { __source__: name };
      this.sources[name] = { path: file, type: "ini" }, this.push(marker), this._await();
      try {
        const contents = fs2.readFileSync(file, "utf8");
        this.addString(contents, file, "ini", marker);
      } catch (error2) {
        if (error2.code === "ENOENT")
          this.add({}, marker);
        else if (error2.code !== "EISDIR")
          return `Issue while reading "${file}". ${error2.message}`;
      }
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
    addEnv(env) {
      env = env || process.env;
      const conf2 = {};
      return Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
        if (!env[x])
          return;
        const key2 = envKeyToSetting2(x.substr(11)), rawVal = env[x];
        conf2[key2] = deserializeEnvVal(key2, rawVal);
      }), super.addEnv("", conf2, "env");
    }
    // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
    loadPrefix() {
      const cli = this.list[0];
      Object.defineProperty(this, "prefix", {
        enumerable: !0,
        set: (prefix) => {
          const g = this.get("global");
          this[g ? "globalPrefix" : "localPrefix"] = prefix;
        },
        get: () => this.get("global") ? this.globalPrefix : this.localPrefix
      }), Object.defineProperty(this, "globalPrefix", {
        enumerable: !0,
        set: (prefix) => {
          this.set("prefix", prefix);
        },
        get: () => path2.resolve(this.get("prefix"))
      });
      let p;
      if (Object.defineProperty(this, "localPrefix", {
        enumerable: !0,
        set: (prefix) => {
          p = prefix;
        },
        get: () => p
      }), Object.prototype.hasOwnProperty.call(cli, "prefix"))
        p = path2.resolve(cli.prefix);
      else
        try {
          p = util2.findPrefix(process.cwd());
        } catch (error2) {
          throw error2;
        }
      return p;
    }
    // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
    loadCAFile(file) {
      if (!file)
        return;
      const ca = readCAFileSync(file);
      ca && this.set("ca", ca);
    }
    // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
    loadUser() {
      const defConf = this.root;
      if (this.get("global"))
        return;
      if (process.env.SUDO_UID) {
        defConf.user = Number(process.env.SUDO_UID);
        return;
      }
      const prefix = path2.resolve(this.get("prefix"));
      try {
        const stats = fs2.statSync(prefix);
        defConf.user = stats.uid;
      } catch (error2) {
        if (error2.code === "ENOENT")
          return;
        throw error2;
      }
    }
  }
  function deserializeEnvVal(envKey, envValue) {
    function deserializeList(envValue2) {
      const npmConfigSep = `

`;
      return envValue2.indexOf(npmConfigSep) ? envValue2.split(npmConfigSep) : envValue2.split(",");
    }
    switch (envKey) {
      case "hoist-pattern":
      case "public-hoist-pattern":
        return deserializeList(envValue);
    }
    return envValue;
  }
  return conf = Conf, conf;
}
var defaults$3 = {}, hasRequiredDefaults;
function requireDefaults() {
  return hasRequiredDefaults || (hasRequiredDefaults = 1, function(exports2) {
    const os2 = require$$0__default$2.default, path2 = require$$0__default.default, temp = os2.tmpdir(), uidOrPid = process.getuid ? process.getuid() : process.pid, hasUnicode = () => !0, isWindows = process.platform === "win32", osenv = {
      editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
    }, umask = {
      fromString: () => process.umask()
    };
    let home = os2.homedir();
    home ? process.env.HOME = home : home = path2.resolve(temp, "npm-" + uidOrPid);
    const cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm", cacheRoot = process.platform === "win32" && process.env.APPDATA || home, cache = path2.resolve(cacheRoot, cacheExtra);
    let defaults2, globalPrefix;
    Object.defineProperty(exports2, "defaults", {
      get: function() {
        return defaults2 || (process.env.PREFIX ? globalPrefix = process.env.PREFIX : process.platform === "win32" ? globalPrefix = path2.dirname(process.execPath) : (globalPrefix = path2.dirname(path2.dirname(process.execPath)), process.env.DESTDIR && (globalPrefix = path2.join(process.env.DESTDIR, globalPrefix))), defaults2 = {
          access: null,
          "allow-same-version": !1,
          "always-auth": !1,
          also: null,
          audit: !0,
          "auth-type": "legacy",
          "bin-links": !0,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": 1 / 0,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env.NO_COLOR == null,
          depth: 1 / 0,
          description: !0,
          dev: !1,
          "dry-run": !1,
          editor: osenv.editor(),
          "engine-strict": !1,
          force: !1,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": !0,
          "commit-hooks": !0,
          global: !1,
          globalconfig: path2.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": !1,
          group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
          "ham-it-up": !1,
          heading: "npm",
          "if-present": !1,
          "ignore-prepublish": !1,
          "ignore-scripts": !1,
          "init-module": path2.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: !1,
          key: null,
          "legacy-bundling": !1,
          link: !1,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: !1,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
          offline: !1,
          "onload-script": !1,
          only: null,
          optional: !0,
          otp: null,
          "package-lock": !0,
          "package-lock-only": !1,
          parseable: !1,
          "prefer-offline": !1,
          "prefer-online": !1,
          prefix: globalPrefix,
          production: process.env.NODE_ENV === "production",
          progress: !process.env.TRAVIS && !process.env.CI,
          provenance: !1,
          proxy: null,
          "https-proxy": null,
          "no-proxy": null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": !1,
          "rebuild-bundle": !0,
          registry: "https://registry.npmjs.org/",
          rollback: !0,
          save: !0,
          "save-bundle": !1,
          "save-dev": !1,
          "save-exact": !1,
          "save-optional": !1,
          "save-prefix": "^",
          "save-prod": !1,
          scope: "",
          "script-shell": null,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": !1,
          shell: osenv.shell(),
          shrinkwrap: !0,
          "sign-git-tag": !1,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": !0,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: !1,
          tmp: temp,
          unicode: hasUnicode(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          usage: !1,
          user: process.platform === "win32" ? 0 : "nobody",
          userconfig: path2.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: !1,
          versions: !1,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: !0
        }, defaults2);
      }
    });
  }(defaults$3)), defaults$3;
}
var hasRequiredNpmConf;
function requireNpmConf() {
  return hasRequiredNpmConf || (hasRequiredNpmConf = 1, function(module2) {
    const path2 = require$$0__default.default, Conf = requireConf(), _defaults = requireDefaults();
    module2.exports = (opts, types2, defaults2) => {
      const conf2 = new Conf(Object.assign({}, _defaults.defaults, defaults2), types2);
      conf2.add(Object.assign({}, opts), "cli");
      const warnings = [];
      let failedToLoadBuiltInConfig = !1;
      if (require.resolve.paths) {
        const paths = require.resolve.paths("npm");
        let npmPath;
        try {
          npmPath = require.resolve("npm", { paths: paths.slice(-1) });
        } catch {
          failedToLoadBuiltInConfig = !0;
        }
        npmPath && warnings.push(conf2.addFile(path2.resolve(path2.dirname(npmPath), "..", "npmrc"), "builtin"));
      }
      conf2.addEnv(), conf2.loadPrefix();
      const projectConf = path2.resolve(conf2.localPrefix, ".npmrc"), userConf = conf2.get("userconfig");
      if (!conf2.get("global") && projectConf !== userConf ? warnings.push(conf2.addFile(projectConf, "project")) : conf2.add({}, "project"), conf2.get("workspace-prefix") && conf2.get("workspace-prefix") !== projectConf) {
        const workspaceConf = path2.resolve(conf2.get("workspace-prefix"), ".npmrc");
        warnings.push(conf2.addFile(workspaceConf, "workspace"));
      }
      if (warnings.push(conf2.addFile(conf2.get("userconfig"), "user")), conf2.get("prefix")) {
        const etc = path2.resolve(conf2.get("prefix"), "etc");
        conf2.root.globalconfig = path2.resolve(etc, "npmrc"), conf2.root.globalignorefile = path2.resolve(etc, "npmignore");
      }
      warnings.push(conf2.addFile(conf2.get("globalconfig"), "global")), conf2.loadUser();
      const caFile2 = conf2.get("cafile");
      return caFile2 && conf2.loadCAFile(caFile2), {
        config: conf2,
        warnings: warnings.filter(Boolean),
        failedToLoadBuiltInConfig
      };
    }, Object.defineProperty(module2.exports, "defaults", {
      get() {
        return _defaults.defaults;
      },
      enumerable: !0
    });
  }(npmConf)), npmConf.exports;
}
var registryAuthToken, hasRequiredRegistryAuthToken;
function requireRegistryAuthToken() {
  if (hasRequiredRegistryAuthToken) return registryAuthToken;
  hasRequiredRegistryAuthToken = 1;
  const url = require$$0__default$8.default, npmConf2 = requireNpmConf(), tokenKey = ":_authToken", legacyTokenKey = ":_auth", userKey = ":username", passwordKey = ":_password";
  registryAuthToken = function() {
    let checkUrl, options2;
    arguments.length >= 2 ? (checkUrl = arguments[0], options2 = Object.assign({}, arguments[1])) : typeof arguments[0] == "string" ? checkUrl = arguments[0] : options2 = Object.assign({}, arguments[0]), options2 = options2 || {};
    const providedNpmrc = options2.npmrc;
    return options2.npmrc = (options2.npmrc ? {
      config: {
        get: (key2) => providedNpmrc[key2]
      }
    } : npmConf2()).config, checkUrl = checkUrl || options2.npmrc.get("registry") || npmConf2.defaults.registry, getRegistryAuthInfo(checkUrl, options2) || getLegacyAuthInfo(options2.npmrc);
  };
  function getRegistryAuthInfo(checkUrl, options2) {
    const parsed = url.parse(checkUrl, !1, !0);
    let pathname;
    for (; pathname !== "/" && parsed.pathname !== pathname; ) {
      pathname = parsed.pathname || "/";
      const regUrl = "//" + parsed.host + pathname.replace(/\/$/, ""), authInfo = getAuthInfoForUrl(regUrl, options2.npmrc);
      if (authInfo)
        return authInfo;
      if (!options2.recursive)
        return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(url.resolve(checkUrl, "."), options2);
      parsed.pathname = url.resolve(normalizePath(pathname), "..") || "/";
    }
  }
  function getLegacyAuthInfo(npmrc) {
    return npmrc.get("_auth") ? { token: replaceEnvironmentVariable(npmrc.get("_auth")), type: "Basic" } : void 0;
  }
  function normalizePath(path2) {
    return path2[path2.length - 1] === "/" ? path2 : path2 + "/";
  }
  function getAuthInfoForUrl(regUrl, npmrc) {
    const bearerAuth = getBearerToken(npmrc.get(regUrl + tokenKey) || npmrc.get(regUrl + "/" + tokenKey));
    if (bearerAuth)
      return bearerAuth;
    const username = npmrc.get(regUrl + userKey) || npmrc.get(regUrl + "/" + userKey), password2 = npmrc.get(regUrl + passwordKey) || npmrc.get(regUrl + "/" + passwordKey), basicAuth = getTokenForUsernameAndPassword(username, password2);
    if (basicAuth)
      return basicAuth;
    const basicAuthWithToken = getLegacyAuthToken(npmrc.get(regUrl + legacyTokenKey) || npmrc.get(regUrl + "/" + legacyTokenKey));
    if (basicAuthWithToken)
      return basicAuthWithToken;
  }
  function replaceEnvironmentVariable(token2) {
    return token2.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
      return process.env[envVar];
    });
  }
  function getBearerToken(tok) {
    return tok ? { token: replaceEnvironmentVariable(tok), type: "Bearer" } : void 0;
  }
  function getTokenForUsernameAndPassword(username, password2) {
    if (!username || !password2)
      return;
    const pass = Buffer.from(replaceEnvironmentVariable(password2), "base64").toString("utf8");
    return {
      token: Buffer.from(username + ":" + pass, "utf8").toString("base64"),
      type: "Basic",
      password: pass,
      username
    };
  }
  function getLegacyAuthToken(tok) {
    return tok ? { token: replaceEnvironmentVariable(tok), type: "Basic" } : void 0;
  }
  return registryAuthToken;
}
var src, hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  const url = require$$0__default$8.default, { getIt } = require$$1__default$1.default, { debug: debug2, retry: retry2, promise: promise2, httpErrors, jsonResponse } = require$$2__default.default, registryUrl2 = requireRegistryUrl(), registryAuthToken2 = requireRegistryAuthToken(), semver2 = semver__default.default, isJson = (contentType) => /(application\/json|\+json)/.test(contentType || "");
  function shouldRetry(err, num, options2) {
    const response = err.response || { statusCode: 500, headers: {} };
    return (
      // allow retries on low-level errors (socket errors et al)
      retry2.shouldRetry(err, num, options2) || // npm registry routinely fails, giving 503 and similar
      response && response.statusCode >= 500 || // npm registry sometimes returns 2xx with HTML content
      response.statusCode < 300 && !isJson(response.headers["content-type"])
    );
  }
  function resolveRegistryUrl(pkgName, options2) {
    if (options2.registryUrl)
      return options2.registryUrl;
    const scope2 = pkgName.split("/")[0];
    return registryUrl2(scope2);
  }
  const httpRequest = getIt([
    jsonResponse({ force: !0 }),
    httpErrors(),
    debug2({ namespace: "get-latest-version" }),
    promise2(),
    retry2({ shouldRetry })
  ]);
  async function getLatestVersion(pkgName, opts) {
    const options2 = typeof opts == "string" ? { range: opts, auth: !0 } : Object.assign({ range: "latest", auth: !0 }, opts), regUrl = resolveRegistryUrl(pkgName, options2), pkgUrl = url.resolve(regUrl, encodeURIComponent(pkgName).replace(/^%40/, "@")), authInfo = options2.auth && registryAuthToken2(regUrl, { recursive: !0 }), request = options2.request || httpRequest, headers = {
      accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
    };
    authInfo && (headers.authorization = `${authInfo.type} ${authInfo.token}`);
    let res;
    try {
      res = await request({ url: pkgUrl, headers });
    } catch (err) {
      throw err.response && err.response.statusCode === 404 ? new Error(`Package \`${pkgName}\` doesn't exist`) : err;
    }
    const data = res.body, range2 = options2.range, latest = data["dist-tags"].latest;
    if (data["dist-tags"][range2])
      return options2.includeLatest ? { latest, inRange: data["dist-tags"][range2] } : data["dist-tags"][range2];
    if (data.versions[range2])
      return options2.includeLatest ? { latest, inRange: range2 } : range2;
    const versions = Object.keys(data.versions), version2 = semver2.maxSatisfying(versions, range2);
    return version2 ? options2.includeLatest ? { latest, inRange: version2 } : version2 : options2.includeLatest ? { latest, inRange: void 0 } : void 0;
  }
  return getLatestVersion.request = httpRequest, src = getLatestVersion, src;
}
var srcExports = requireSrc(), latestVersion = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(srcExports);
async function getCliVersion() {
  const cliPath = pkgDir__default.default.sync(__dirname);
  if (!cliPath)
    throw new Error("Unable to resolve root of @sanity/cli module");
  let data;
  try {
    data = await fs__default.default.readFile(path__default.default.join(cliPath, "package.json"), "utf-8");
  } catch (err) {
    throw new Error(`Unable to read @sanity/cli/package.json: ${err.message}`);
  }
  return JSON.parse(data).version;
}
function getLocalVersion(moduleId, workDir) {
  const fromPath = workDir || process.cwd(), modulePath = resolveFrom.silent(fromPath, path$3.join(moduleId, "package.json"));
  if (modulePath)
    return tryGetVersion(modulePath);
  const pathSegment = path$3.normalize(moduleId), parentPath = resolveFrom.silent(fromPath, moduleId);
  if (!parentPath)
    return;
  const moduleRoot = parentPath.slice(0, parentPath.lastIndexOf(pathSegment) + pathSegment.length), manifestPath = path$3.join(moduleRoot, "package.json");
  return tryGetVersion(manifestPath);
}
function tryGetVersion(modulePath) {
  try {
    const fileContent = fs$1.readFileSync(modulePath, "utf8");
    return JSON.parse(fileContent).version;
  } catch {
    return;
  }
}
const PACKAGES_TO_EXCLUDE = [
  "@sanity/block-content-to-html",
  "@sanity/block-content-to-react",
  "@sanity/block-tools",
  "@sanity/client"
], defaultOptions = {
  includeCli: !0
};
async function findSanityModuleVersions(context, options2 = {}) {
  const { spinner } = context.output, { target, includeCli } = { ...defaultOptions, ...options2 }, cliVersion = await getCliVersion(), sanityModules = filterSanityModules(getLocalManifest(context.workDir)), resolveOpts = { includeCli, target }, spin = spinner("Resolving latest versions").start(), versions = await promiseProps(
    buildPackageArray(sanityModules, context.workDir, resolveOpts, cliVersion)
  ), packages = Object.values(versions);
  return spin.stop(), packages.map((mod) => {
    const current = mod.installed || semver__default.default.minVersion(mod.declared)?.toString() || "", needsUpdate = target === "latest" ? semverCompare(current, mod.latest) === -1 : typeof mod.latestInRange < "u" && mod.installed !== mod.latestInRange;
    return { ...mod, needsUpdate };
  });
}
function getLocalManifest(workDir) {
  try {
    const fileContent = fs$1.readFileSync(path$3.join(workDir, "package.json"), "utf8");
    return JSON.parse(fileContent);
  } catch {
    return {};
  }
}
function filterSanityModules(manifest) {
  const dependencies = {
    ...manifest.dependencies,
    ...manifest.devDependencies
  };
  return Object.keys(dependencies).filter((mod) => mod.startsWith("@sanity/") || mod === "sanity").filter((mod) => !PACKAGES_TO_EXCLUDE.includes(mod)).sort().reduce(
    (versions, dependency) => (versions[dependency] = dependencies[dependency], versions),
    {}
  );
}
function buildPackageArray(packages, workDir, options2 = {}, cliVersion) {
  const { includeCli, target } = options2, modules = [];
  if (includeCli) {
    const [cliMajor] = cliVersion.split("."), latest = tryFindLatestVersion("@sanity/cli", target || `^${cliMajor}`);
    modules.push({
      name: "@sanity/cli",
      declared: `^${cliVersion}`,
      installed: trimHash(cliVersion),
      latest: latest.then((versions) => versions.latest),
      latestInRange: latest.then((versions) => versions.latestInRange),
      isPinned: !1,
      isGlobal: !0
    });
  }
  return [
    ...modules,
    ...Object.keys(packages).map((pkgName) => {
      const latest = tryFindLatestVersion(pkgName, target || packages[pkgName] || "latest"), localVersion = getLocalVersion(pkgName, workDir);
      return {
        name: pkgName,
        declared: packages[pkgName],
        installed: localVersion ? trimHash(localVersion) : void 0,
        latest: latest.then((versions) => versions.latest),
        latestInRange: latest.then((versions) => versions.latestInRange),
        isPinned: isPinnedVersion(packages[pkgName]),
        isGlobal: !1
      };
    })
  ];
}
async function tryFindLatestVersion(pkgName, range2) {
  try {
    const { latest, inRange } = await latestVersion(pkgName, { range: range2, includeLatest: !0 });
    return { latest, latestInRange: inRange };
  } catch (err) {
    if (!(err instanceof Error) || !err.message.includes("No version exists"))
      throw err;
    return { latest: await latestVersion(pkgName), latestInRange: void 0 };
  }
}
function isPinnedVersion(version2) {
  return /^\d+\.\d+\.\d+/.test(version2);
}
function trimHash(version2) {
  return version2.replace(/\+[a-z0-9]{8,}$/, "");
}
const BASE_URL = "https://docs.sanity.io/help/";
function generateHelpUrl(slug) {
  return BASE_URL + slug;
}
var polyfills, hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants2 = require$$0__default$3.default, origCwd = process.cwd, cwd = null, platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return cwd || (cwd = origCwd.call(process)), cwd;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs2) {
    constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs2), fs2.lutimes || patchLutimes(fs2), fs2.chown = chownFix(fs2.chown), fs2.fchown = chownFix(fs2.fchown), fs2.lchown = chownFix(fs2.lchown), fs2.chmod = chmodFix(fs2.chmod), fs2.fchmod = chmodFix(fs2.fchmod), fs2.lchmod = chmodFix(fs2.lchmod), fs2.chownSync = chownFixSync(fs2.chownSync), fs2.fchownSync = chownFixSync(fs2.fchownSync), fs2.lchownSync = chownFixSync(fs2.lchownSync), fs2.chmodSync = chmodFixSync(fs2.chmodSync), fs2.fchmodSync = chmodFixSync(fs2.fchmodSync), fs2.lchmodSync = chmodFixSync(fs2.lchmodSync), fs2.stat = statFix(fs2.stat), fs2.fstat = statFix(fs2.fstat), fs2.lstat = statFix(fs2.lstat), fs2.statSync = statFixSync(fs2.statSync), fs2.fstatSync = statFixSync(fs2.fstatSync), fs2.lstatSync = statFixSync(fs2.lstatSync), fs2.chmod && !fs2.lchmod && (fs2.lchmod = function(path2, mode2, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchmodSync = function() {
    }), fs2.chown && !fs2.lchown && (fs2.lchown = function(path2, uid, gid, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchownSync = function() {
    }), platform2 === "win32" && (fs2.rename = typeof fs2.rename != "function" ? fs2.rename : function(fs$rename) {
      function rename2(from2, to, cb) {
        var start = Date.now(), backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                stater && stater.code === "ENOENT" ? fs$rename(from2, to, CB) : cb(er);
              });
            }, backoff), backoff < 100 && (backoff += 10);
            return;
          }
          cb && cb(er);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(rename2, fs$rename), rename2;
    }(fs2.rename)), fs2.read = typeof fs2.read != "function" ? fs2.read : function(fs$read) {
      function read2(fd, buffer2, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ == "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10)
              return eagCounter++, fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(read2, fs$read), read2;
    }(fs2.read), fs2.readSync = typeof fs2.readSync != "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer2, offset, length, position) {
        for (var eagCounter = 0; ; )
          try {
            return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path2, mode2, callback) {
        fs3.open(
          path2,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode2,
          function(err, fd) {
            if (err) {
              callback && callback(err);
              return;
            }
            fs3.fchmod(fd, mode2, function(err2) {
              fs3.close(fd, function(err22) {
                callback && callback(err2 || err22);
              });
            });
          }
        );
      }, fs3.lchmodSync = function(path2, mode2) {
        var fd = fs3.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode2), threw = !0, ret;
        try {
          ret = fs3.fchmodSync(fd, mode2), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      constants2.hasOwnProperty("O_SYMLINK") && fs3.futimes ? (fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants2.O_SYMLINK, function(er, fd) {
          if (er) {
            cb && cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              cb && cb(er2 || er22);
            });
          });
        });
      }, fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants2.O_SYMLINK), ret, threw = !0;
        try {
          ret = fs3.futimesSync(fd, at, mt), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      }) : fs3.futimes && (fs3.lutimes = function(_a, _b, _c, cb) {
        cb && process.nextTick(cb);
      }, fs3.lutimesSync = function() {
      });
    }
    function chmodFix(orig) {
      return orig && function(target, mode2, cb) {
        return orig.call(fs2, target, mode2, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      return orig && function(target, mode2) {
        try {
          return orig.call(fs2, target, mode2);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      return orig && function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      return orig && function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      return orig && function(target, options2, cb) {
        typeof options2 == "function" && (cb = options2, options2 = null);
        function callback(er, stats) {
          stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
        }
        return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      return orig && function(target, options2) {
        var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
        return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
      };
    }
    function chownErOk(er) {
      if (!er || er.code === "ENOSYS")
        return !0;
      var nonroot = !process.getuid || process.getuid() !== 0;
      return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
    }
  }
  return polyfills;
}
var legacyStreams, hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream2 = require$$0__default$4.default.Stream;
  legacyStreams = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options2) {
      if (!(this instanceof ReadStream)) return new ReadStream(path2, options2);
      Stream2.call(this);
      var self2 = this;
      this.path = path2, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err), self2.readable = !1;
          return;
        }
        self2.fd = fd, self2.emit("open", fd), self2._read();
      });
    }
    function WriteStream(path2, options2) {
      if (!(this instanceof WriteStream)) return new WriteStream(path2, options2);
      Stream2.call(this), this.path = path2, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = fs2.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return legacyStreams;
}
var clone_1, hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1, clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj != "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(obj).forEach(function(key2) {
      Object.defineProperty(copy2, key2, Object.getOwnPropertyDescriptor(obj, key2));
    }), copy2;
  }
  return clone_1;
}
var gracefulFs, hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs2 = require$$0__default$1.default, polyfills2 = requirePolyfills(), legacy = requireLegacyStreams(), clone = requireClone(), util2 = require$$0__default$6.default, gracefulQueue, previousSymbol;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
  function noop2() {
  }
  function publishQueue(context, queue3) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue3;
      }
    });
  }
  var debug2 = noop2;
  if (util2.debuglog ? debug2 = util2.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug2 = function() {
    var m = util2.format.apply(util2, arguments);
    m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
  }), !fs2[gracefulQueue]) {
    var queue2 = loadEnv.commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue2), fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs2.close), fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs2.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug2(fs2[gracefulQueue]), require$$0__default$5.default.equal(fs2[gracefulQueue].length, 0);
    });
  }
  loadEnv.commonjsGlobal[gracefulQueue] || publishQueue(loadEnv.commonjsGlobal, fs2[gracefulQueue]), gracefulFs = patch(clone(fs2)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched && (gracefulFs = patch(fs2), fs2.__patched = !0);
  function patch(fs3) {
    polyfills2(fs3), fs3.gracefulify = patch, fs3.createReadStream = createReadStream, fs3.createWriteStream = createWriteStream;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile;
    function readFile(path2, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$readFile(path2, options2, cb);
      function go$readFile(path3, options3, cb2, startTime) {
        return fs$readFile(path3, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile;
    function writeFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$writeFile(path2, data, options2, cb);
      function go$writeFile(path3, data2, options3, cb2, startTime) {
        return fs$writeFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    fs$appendFile && (fs3.appendFile = appendFile);
    function appendFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$appendFile(path2, data, options2, cb);
      function go$appendFile(path3, data2, options3, cb2, startTime) {
        return fs$appendFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    fs$copyFile && (fs3.copyFile = copyFile);
    function copyFile(src2, dest, flags, cb) {
      return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src3, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src3, dest2, flags2, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir2;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir2(path2, options2, cb) {
      typeof options2 == "function" && (cb = options2, options2 = null);
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      } : function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, options3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      };
      return go$readdir(path2, options2, cb);
      function fs$readdirCallback(path3, options3, cb2, startTime) {
        return function(err, files) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
            go$readdir,
            [path3, options3, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs3);
      ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
    var fs$WriteStream = fs3.WriteStream;
    fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    function ReadStream(path2, options2) {
      return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
      });
    }
    function WriteStream(path2, options2) {
      return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
      });
    }
    function createReadStream(path2, options2) {
      return new fs3.ReadStream(path2, options2);
    }
    function createWriteStream(path2, options2) {
      return new fs3.WriteStream(path2, options2);
    }
    var fs$open = fs3.open;
    fs3.open = open2;
    function open2(path2, flags, mode2, cb) {
      return typeof mode2 == "function" && (cb = mode2, mode2 = null), go$open(path2, flags, mode2, cb);
      function go$open(path3, flags2, mode3, cb2, startTime) {
        return fs$open(path3, flags2, mode3, function(err, fd) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path3, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug2("ENQUEUE", elem[0].name, elem[1]), fs2[gracefulQueue].push(elem), retry2();
  }
  var retryTimer;
  function resetQueue() {
    for (var now = Date.now(), i = 0; i < fs2[gracefulQueue].length; ++i)
      fs2[gracefulQueue][i].length > 2 && (fs2[gracefulQueue][i][3] = now, fs2[gracefulQueue][i][4] = now);
    retry2();
  }
  function retry2() {
    if (clearTimeout(retryTimer), retryTimer = void 0, fs2[gracefulQueue].length !== 0) {
      var elem = fs2[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
      if (startTime === void 0)
        debug2("RETRY", fn.name, args), fn.apply(null, args);
      else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        typeof cb == "function" && cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
        sinceAttempt >= desiredDelay ? (debug2("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs2[gracefulQueue].push(elem);
      }
      retryTimer === void 0 && (retryTimer = setTimeout(retry2, 0));
    }
  }
  return gracefulFs;
}
var makeDir = { exports: {} }, hasRequiredMakeDir;
function requireMakeDir() {
  if (hasRequiredMakeDir) return makeDir.exports;
  hasRequiredMakeDir = 1;
  const fs2 = require$$0__default$1.default, path2 = require$$0__default.default, { promisify } = require$$0__default$6.default, useNativeRecursiveOption = semver__default.default.satisfies(process.version, ">=10.12.0"), checkPath = (pth) => {
    if (process.platform === "win32" && /[<>:"|?*]/.test(pth.replace(path2.parse(pth).root, ""))) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      throw error2.code = "EINVAL", error2;
    }
  }, processOptions = (options2) => ({
    ...{
      mode: 511,
      fs: fs2
    },
    ...options2
  }), permissionError = (pth) => {
    const error2 = new Error(`operation not permitted, mkdir '${pth}'`);
    return error2.code = "EPERM", error2.errno = -4048, error2.path = pth, error2.syscall = "mkdir", error2;
  }, makeDir$1 = async (input2, options2) => {
    checkPath(input2), options2 = processOptions(options2);
    const mkdir2 = promisify(options2.fs.mkdir), stat2 = promisify(options2.fs.stat);
    if (useNativeRecursiveOption && options2.fs.mkdir === fs2.mkdir) {
      const pth = path2.resolve(input2);
      return await mkdir2(pth, {
        mode: options2.mode,
        recursive: !0
      }), pth;
    }
    const make = async (pth) => {
      try {
        return await mkdir2(pth, options2.mode), pth;
      } catch (error2) {
        if (error2.code === "EPERM")
          throw error2;
        if (error2.code === "ENOENT") {
          if (path2.dirname(pth) === pth)
            throw permissionError(pth);
          if (error2.message.includes("null bytes"))
            throw error2;
          return await make(path2.dirname(pth)), make(pth);
        }
        try {
          if (!(await stat2(pth)).isDirectory())
            throw new Error("The path is not a directory");
        } catch {
          throw error2;
        }
        return pth;
      }
    };
    return make(path2.resolve(input2));
  };
  return makeDir.exports = makeDir$1, makeDir.exports.sync = (input2, options2) => {
    if (checkPath(input2), options2 = processOptions(options2), useNativeRecursiveOption && options2.fs.mkdirSync === fs2.mkdirSync) {
      const pth = path2.resolve(input2);
      return fs2.mkdirSync(pth, {
        mode: options2.mode,
        recursive: !0
      }), pth;
    }
    const make = (pth) => {
      try {
        options2.fs.mkdirSync(pth, options2.mode);
      } catch (error2) {
        if (error2.code === "EPERM")
          throw error2;
        if (error2.code === "ENOENT") {
          if (path2.dirname(pth) === pth)
            throw permissionError(pth);
          if (error2.message.includes("null bytes"))
            throw error2;
          return make(path2.dirname(pth)), make(pth);
        }
        try {
          if (!options2.fs.statSync(pth).isDirectory())
            throw new Error("The path is not a directory");
        } catch {
          throw error2;
        }
      }
      return pth;
    };
    return make(path2.resolve(input2));
  }, makeDir.exports;
}
var writeFileAtomic = { exports: {} }, imurmurhash = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
var hasRequiredImurmurhash;
function requireImurmurhash() {
  return hasRequiredImurmurhash || (hasRequiredImurmurhash = 1, function(module2) {
    (function() {
      var cache;
      function MurmurHash3(key2, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        if (m.reset(seed), typeof key2 == "string" && key2.length > 0 && m.hash(key2), m !== this)
          return m;
      }
      MurmurHash3.prototype.hash = function(key2) {
        var h1, k1, i, top, len;
        switch (len = key2.length, this.len += len, k1 = this.k1, i = 0, this.rem) {
          case 0:
            k1 ^= len > i ? key2.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key2.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key2.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key2.charCodeAt(i) & 255) << 24 : 0, k1 ^= len > i ? (key2.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        if (this.rem = len + this.rem & 3, len -= this.rem, len > 0) {
          for (h1 = this.h1; k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1, h1 = h1 << 13 | h1 >>> 19, h1 = h1 * 5 + 3864292196 & 4294967295, !(i >= len); )
            k1 = key2.charCodeAt(i++) & 65535 ^ (key2.charCodeAt(i++) & 65535) << 8 ^ (key2.charCodeAt(i++) & 65535) << 16, top = key2.charCodeAt(i++), k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          switch (k1 = 0, this.rem) {
            case 3:
              k1 ^= (key2.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key2.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key2.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        return this.k1 = k1, this;
      }, MurmurHash3.prototype.result = function() {
        var k1, h1;
        return k1 = this.k1, h1 = this.h1, k1 > 0 && (k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1), h1 ^= this.len, h1 ^= h1 >>> 16, h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295, h1 ^= h1 >>> 13, h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295, h1 ^= h1 >>> 16, h1 >>> 0;
      }, MurmurHash3.prototype.reset = function(seed) {
        return this.h1 = typeof seed == "number" ? seed : 0, this.rem = this.k1 = this.len = 0, this;
      }, cache = new MurmurHash3(), module2.exports = MurmurHash3;
    })();
  }(imurmurhash)), imurmurhash.exports;
}
var signalExit = { exports: {} }, signals$1 = { exports: {} }, hasRequiredSignals;
function requireSignals() {
  return hasRequiredSignals || (hasRequiredSignals = 1, function(module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ], process.platform !== "win32" && module2.exports.push(
      "SIGVTALRM",
      "SIGXCPU",
      "SIGXFSZ",
      "SIGUSR2",
      "SIGTRAP",
      "SIGSYS",
      "SIGQUIT",
      "SIGIOT"
      // should detect profiler and enable/disable accordingly.
      // see #21
      // 'SIGPROF'
    ), process.platform === "linux" && module2.exports.push(
      "SIGIO",
      "SIGPOLL",
      "SIGPWR",
      "SIGSTKFLT",
      "SIGUNUSED"
    );
  }(signals$1)), signals$1.exports;
}
var hasRequiredSignalExit;
function requireSignalExit() {
  if (hasRequiredSignalExit) return signalExit.exports;
  hasRequiredSignalExit = 1;
  var process2 = loadEnv.commonjsGlobal.process;
  const processOk2 = function(process3) {
    return process3 && typeof process3 == "object" && typeof process3.removeListener == "function" && typeof process3.emit == "function" && typeof process3.reallyExit == "function" && typeof process3.listeners == "function" && typeof process3.kill == "function" && typeof process3.pid == "number" && typeof process3.on == "function";
  };
  if (!processOk2(process2))
    signalExit.exports = function() {
      return function() {
      };
    };
  else {
    var assert = require$$0__default$5.default, signals2 = requireSignals(), isWin = /^win/i.test(process2.platform), EE = require$$0__default$7.default;
    typeof EE != "function" && (EE = EE.EventEmitter);
    var emitter;
    process2.__signal_exit_emitter__ ? emitter = process2.__signal_exit_emitter__ : (emitter = process2.__signal_exit_emitter__ = new EE(), emitter.count = 0, emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), signalExit.exports = function(cb, opts) {
      if (!processOk2(loadEnv.commonjsGlobal.process))
        return function() {
        };
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler"), loaded === !1 && load2();
      var ev = "exit";
      opts && opts.alwaysLast && (ev = "afterexit");
      var remove = function() {
        emitter.removeListener(ev, cb), emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0 && unload2();
      };
      return emitter.on(ev, cb), remove;
    };
    var unload2 = function() {
      !loaded || !processOk2(loadEnv.commonjsGlobal.process) || (loaded = !1, signals2.forEach(function(sig) {
        try {
          process2.removeListener(sig, sigListeners[sig]);
        } catch {
        }
      }), process2.emit = originalProcessEmit, process2.reallyExit = originalProcessReallyExit, emitter.count -= 1);
    };
    signalExit.exports.unload = unload2;
    var emit = function(event, code, signal) {
      emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
    }, sigListeners = {};
    signals2.forEach(function(sig) {
      sigListeners[sig] = function() {
        if (processOk2(loadEnv.commonjsGlobal.process)) {
          var listeners = process2.listeners(sig);
          listeners.length === emitter.count && (unload2(), emit("exit", null, sig), emit("afterexit", null, sig), isWin && sig === "SIGHUP" && (sig = "SIGINT"), process2.kill(process2.pid, sig));
        }
      };
    }), signalExit.exports.signals = function() {
      return signals2;
    };
    var loaded = !1, load2 = function() {
      loaded || !processOk2(loadEnv.commonjsGlobal.process) || (loaded = !0, emitter.count += 1, signals2 = signals2.filter(function(sig) {
        try {
          return process2.on(sig, sigListeners[sig]), !0;
        } catch {
          return !1;
        }
      }), process2.emit = processEmit, process2.reallyExit = processReallyExit);
    };
    signalExit.exports.load = load2;
    var originalProcessReallyExit = process2.reallyExit, processReallyExit = function(code) {
      processOk2(loadEnv.commonjsGlobal.process) && (process2.exitCode = code || /* istanbul ignore next */
      0, emit("exit", process2.exitCode, null), emit("afterexit", process2.exitCode, null), originalProcessReallyExit.call(process2, process2.exitCode));
    }, originalProcessEmit = process2.emit, processEmit = function(ev, arg) {
      if (ev === "exit" && processOk2(loadEnv.commonjsGlobal.process)) {
        arg !== void 0 && (process2.exitCode = arg);
        var ret = originalProcessEmit.apply(this, arguments);
        return emit("exit", process2.exitCode, null), emit("afterexit", process2.exitCode, null), ret;
      } else
        return originalProcessEmit.apply(this, arguments);
    };
  }
  return signalExit.exports;
}
var isTypedarray, hasRequiredIsTypedarray;
function requireIsTypedarray() {
  if (hasRequiredIsTypedarray) return isTypedarray;
  hasRequiredIsTypedarray = 1, isTypedarray = isTypedArray, isTypedArray.strict = isStrictTypedArray, isTypedArray.loose = isLooseTypedArray;
  var toString = Object.prototype.toString, names = {
    "[object Int8Array]": !0,
    "[object Int16Array]": !0,
    "[object Int32Array]": !0,
    "[object Uint8Array]": !0,
    "[object Uint8ClampedArray]": !0,
    "[object Uint16Array]": !0,
    "[object Uint32Array]": !0,
    "[object Float32Array]": !0,
    "[object Float64Array]": !0
  };
  function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }
  return isTypedarray;
}
var typedarrayToBuffer, hasRequiredTypedarrayToBuffer;
function requireTypedarrayToBuffer() {
  if (hasRequiredTypedarrayToBuffer) return typedarrayToBuffer;
  hasRequiredTypedarrayToBuffer = 1;
  var isTypedArray = requireIsTypedarray().strict;
  return typedarrayToBuffer = function(arr) {
    if (isTypedArray(arr)) {
      var buf = Buffer.from(arr.buffer);
      return arr.byteLength !== arr.buffer.byteLength && (buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)), buf;
    } else
      return Buffer.from(arr);
  }, typedarrayToBuffer;
}
var hasRequiredWriteFileAtomic;
function requireWriteFileAtomic() {
  if (hasRequiredWriteFileAtomic) return writeFileAtomic.exports;
  hasRequiredWriteFileAtomic = 1, writeFileAtomic.exports = writeFile, writeFileAtomic.exports.sync = writeFileSync, writeFileAtomic.exports._getTmpname = getTmpname, writeFileAtomic.exports._cleanupOnExit = cleanupOnExit;
  const fs2 = require$$0__default$1.default, MurmurHash3 = requireImurmurhash(), onExit2 = requireSignalExit(), path2 = require$$0__default.default, isTypedArray = requireIsTypedarray(), typedArrayToBuffer = requireTypedarrayToBuffer(), { promisify } = require$$0__default$6.default, activeFiles = {}, threadId = function() {
    try {
      return require("worker_threads").threadId;
    } catch {
      return 0;
    }
  }();
  let invocations = 0;
  function getTmpname(filename) {
    return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
  }
  function cleanupOnExit(tmpfile) {
    return () => {
      try {
        fs2.unlinkSync(typeof tmpfile == "function" ? tmpfile() : tmpfile);
      } catch {
      }
    };
  }
  function serializeActiveFile(absoluteName) {
    return new Promise((resolve) => {
      activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve), activeFiles[absoluteName].length === 1 && resolve();
    });
  }
  function isChownErrOk(err) {
    return err.code === "ENOSYS" || (!process.getuid || process.getuid() !== 0) && (err.code === "EINVAL" || err.code === "EPERM");
  }
  async function writeFileAsync(filename, data, options2 = {}) {
    typeof options2 == "string" && (options2 = { encoding: options2 });
    let fd, tmpfile;
    const removeOnExitHandler = onExit2(cleanupOnExit(() => tmpfile)), absoluteName = path2.resolve(filename);
    try {
      await serializeActiveFile(absoluteName);
      const truename = await promisify(fs2.realpath)(filename).catch(() => filename);
      if (tmpfile = getTmpname(truename), !options2.mode || !options2.chown) {
        const stats = await promisify(fs2.stat)(truename).catch(() => {
        });
        stats && (options2.mode == null && (options2.mode = stats.mode), options2.chown == null && process.getuid && (options2.chown = { uid: stats.uid, gid: stats.gid }));
      }
      fd = await promisify(fs2.open)(tmpfile, "w", options2.mode), options2.tmpfileCreated && await options2.tmpfileCreated(tmpfile), isTypedArray(data) && (data = typedArrayToBuffer(data)), Buffer.isBuffer(data) ? await promisify(fs2.write)(fd, data, 0, data.length, 0) : data != null && await promisify(fs2.write)(fd, String(data), 0, String(options2.encoding || "utf8")), options2.fsync !== !1 && await promisify(fs2.fsync)(fd), await promisify(fs2.close)(fd), fd = null, options2.chown && await promisify(fs2.chown)(tmpfile, options2.chown.uid, options2.chown.gid).catch((err) => {
        if (!isChownErrOk(err))
          throw err;
      }), options2.mode && await promisify(fs2.chmod)(tmpfile, options2.mode).catch((err) => {
        if (!isChownErrOk(err))
          throw err;
      }), await promisify(fs2.rename)(tmpfile, truename);
    } finally {
      fd && await promisify(fs2.close)(fd).catch(
        /* istanbul ignore next */
        () => {
        }
      ), removeOnExitHandler(), await promisify(fs2.unlink)(tmpfile).catch(() => {
      }), activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
    }
  }
  function writeFile(filename, data, options2, callback) {
    options2 instanceof Function && (callback = options2, options2 = {});
    const promise2 = writeFileAsync(filename, data, options2);
    return callback && promise2.then(callback, callback), promise2;
  }
  function writeFileSync(filename, data, options2) {
    typeof options2 == "string" ? options2 = { encoding: options2 } : options2 || (options2 = {});
    try {
      filename = fs2.realpathSync(filename);
    } catch {
    }
    const tmpfile = getTmpname(filename);
    if (!options2.mode || !options2.chown)
      try {
        const stats = fs2.statSync(filename);
        options2 = Object.assign({}, options2), options2.mode || (options2.mode = stats.mode), !options2.chown && process.getuid && (options2.chown = { uid: stats.uid, gid: stats.gid });
      } catch {
      }
    let fd;
    const cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit2(cleanup);
    let threw = !0;
    try {
      if (fd = fs2.openSync(tmpfile, "w", options2.mode || 438), options2.tmpfileCreated && options2.tmpfileCreated(tmpfile), isTypedArray(data) && (data = typedArrayToBuffer(data)), Buffer.isBuffer(data) ? fs2.writeSync(fd, data, 0, data.length, 0) : data != null && fs2.writeSync(fd, String(data), 0, String(options2.encoding || "utf8")), options2.fsync !== !1 && fs2.fsyncSync(fd), fs2.closeSync(fd), fd = null, options2.chown)
        try {
          fs2.chownSync(tmpfile, options2.chown.uid, options2.chown.gid);
        } catch (err) {
          if (!isChownErrOk(err))
            throw err;
        }
      if (options2.mode)
        try {
          fs2.chmodSync(tmpfile, options2.mode);
        } catch (err) {
          if (!isChownErrOk(err))
            throw err;
        }
      fs2.renameSync(tmpfile, filename), threw = !1;
    } finally {
      if (fd)
        try {
          fs2.closeSync(fd);
        } catch {
        }
      removeOnExitHandler(), threw && cleanup();
    }
  }
  return writeFileAtomic.exports;
}
var isObj, hasRequiredIsObj;
function requireIsObj() {
  return hasRequiredIsObj || (hasRequiredIsObj = 1, isObj = (value) => {
    const type2 = typeof value;
    return value !== null && (type2 === "object" || type2 === "function");
  }), isObj;
}
var dotProp, hasRequiredDotProp;
function requireDotProp() {
  if (hasRequiredDotProp) return dotProp;
  hasRequiredDotProp = 1;
  const isObj2 = requireIsObj(), disallowedKeys = [
    "__proto__",
    "prototype",
    "constructor"
  ], isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.includes(segment));
  function getPathSegments(path2) {
    const pathArray = path2.split("."), parts = [];
    for (let i = 0; i < pathArray.length; i++) {
      let p = pathArray[i];
      for (; p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0; )
        p = p.slice(0, -1) + ".", p += pathArray[++i];
      parts.push(p);
    }
    return isValidPath(parts) ? parts : [];
  }
  return dotProp = {
    get(object, path2, value) {
      if (!isObj2(object) || typeof path2 != "string")
        return value === void 0 ? object : value;
      const pathArray = getPathSegments(path2);
      if (pathArray.length !== 0) {
        for (let i = 0; i < pathArray.length; i++) {
          if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i]))
            return value;
          if (object = object[pathArray[i]], object == null) {
            if (i !== pathArray.length - 1)
              return value;
            break;
          }
        }
        return object;
      }
    },
    set(object, path2, value) {
      if (!isObj2(object) || typeof path2 != "string")
        return object;
      const root2 = object, pathArray = getPathSegments(path2);
      for (let i = 0; i < pathArray.length; i++) {
        const p = pathArray[i];
        isObj2(object[p]) || (object[p] = {}), i === pathArray.length - 1 && (object[p] = value), object = object[p];
      }
      return root2;
    },
    delete(object, path2) {
      if (!isObj2(object) || typeof path2 != "string")
        return !1;
      const pathArray = getPathSegments(path2);
      for (let i = 0; i < pathArray.length; i++) {
        const p = pathArray[i];
        if (i === pathArray.length - 1)
          return delete object[p], !0;
        if (object = object[p], !isObj2(object))
          return !1;
      }
    },
    has(object, path2) {
      if (!isObj2(object) || typeof path2 != "string")
        return !1;
      const pathArray = getPathSegments(path2);
      if (pathArray.length === 0)
        return !1;
      for (let i = 0; i < pathArray.length; i++)
        if (isObj2(object)) {
          if (!(pathArray[i] in object))
            return !1;
          object = object[pathArray[i]];
        } else
          return !1;
      return !0;
    }
  }, dotProp;
}
var cryptoRandomString, hasRequiredCryptoRandomString;
function requireCryptoRandomString() {
  if (hasRequiredCryptoRandomString) return cryptoRandomString;
  hasRequiredCryptoRandomString = 1;
  const crypto = require$$3__default.default;
  return cryptoRandomString = (length) => {
    if (!Number.isFinite(length))
      throw new TypeError("Expected a finite number");
    return crypto.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
  }, cryptoRandomString;
}
var uniqueString, hasRequiredUniqueString;
function requireUniqueString() {
  if (hasRequiredUniqueString) return uniqueString;
  hasRequiredUniqueString = 1;
  const cryptoRandomString2 = requireCryptoRandomString();
  return uniqueString = () => cryptoRandomString2(32), uniqueString;
}
var configstore, hasRequiredConfigstore;
function requireConfigstore() {
  if (hasRequiredConfigstore) return configstore;
  hasRequiredConfigstore = 1;
  const path2 = require$$0__default.default, os2 = require$$0__default$2.default, fs2 = requireGracefulFs(), makeDir2 = requireMakeDir(), xdgBasedir2 = requireXdgBasedir(), writeFileAtomic2 = requireWriteFileAtomic(), dotProp2 = requireDotProp(), uniqueString2 = requireUniqueString(), configDirectory = xdgBasedir2.config || path2.join(os2.tmpdir(), uniqueString2()), permissionError = "You don't have access to this file.", makeDirOptions = { mode: 448 }, writeFileOptions = { mode: 384 };
  class Configstore {
    constructor(id, defaults2, options2 = {}) {
      const pathPrefix = options2.globalConfigPath ? path2.join(id, "config.json") : path2.join("configstore", `${id}.json`);
      this.path = options2.configPath || path2.join(configDirectory, pathPrefix), defaults2 && (this.all = {
        ...defaults2,
        ...this.all
      });
    }
    get all() {
      try {
        return JSON.parse(fs2.readFileSync(this.path, "utf8"));
      } catch (error2) {
        if (error2.code === "ENOENT")
          return {};
        if (error2.code === "EACCES" && (error2.message = `${error2.message}
${permissionError}
`), error2.name === "SyntaxError")
          return writeFileAtomic2.sync(this.path, "", writeFileOptions), {};
        throw error2;
      }
    }
    set all(value) {
      try {
        makeDir2.sync(path2.dirname(this.path), makeDirOptions), writeFileAtomic2.sync(this.path, JSON.stringify(value, void 0, "	"), writeFileOptions);
      } catch (error2) {
        throw error2.code === "EACCES" && (error2.message = `${error2.message}
${permissionError}
`), error2;
      }
    }
    get size() {
      return Object.keys(this.all || {}).length;
    }
    get(key2) {
      return dotProp2.get(this.all, key2);
    }
    set(key2, value) {
      const config2 = this.all;
      if (arguments.length === 1)
        for (const k of Object.keys(key2))
          dotProp2.set(config2, k, key2[k]);
      else
        dotProp2.set(config2, key2, value);
      this.all = config2;
    }
    has(key2) {
      return dotProp2.has(this.all, key2);
    }
    delete(key2) {
      const config2 = this.all;
      dotProp2.delete(config2, key2), this.all = config2;
    }
    clear() {
      this.all = {};
    }
  }
  return configstore = Configstore, configstore;
}
var configstoreExports = requireConfigstore(), ConfigStore = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(configstoreExports);
const sanityEnv$1 = (process.env.SANITY_INTERNAL_ENV || "").toLowerCase(), configName = sanityEnv$1 && sanityEnv$1 !== "production" ? `sanity-${sanityEnv$1}` : "sanity", defaults$2 = {};
let config$1;
const getUserConfig = () => (config$1 || (config$1 = new ConfigStore(configName, defaults$2, { globalConfigPath: !0 })), config$1), apiHosts = {
  staging: "https://api.sanity.work",
  development: "http://api.sanity.wtf"
}, defaults$1 = {
  requireUser: !0,
  requireProject: !0
}, authErrors = () => ({
  onError: (err) => (!err || !isReqResError(err) || (err.response && err.response.body && err.response.body.statusCode) === 401 && (err.message = `${err.message}. You may need to login again with ${chalk__default.default.cyan(
    "sanity login"
  )}.
For more information, see ${generateHelpUrl("cli-errors")}.`), err)
});
function isReqResError(err) {
  return err.hasOwnProperty("response");
}
function getCliToken() {
  const envAuthToken = process.env.SANITY_AUTH_TOKEN, userConfig = getUserConfig();
  return envAuthToken || userConfig.get("authToken");
}
function getClientWrapper(cliApiConfig, configPath) {
  const requester = client$1.requester.clone();
  return requester.use(authErrors()), function(opts) {
    const sanityEnv2 = process.env.SANITY_INTERNAL_ENV || "production", { requireUser, requireProject, api } = { ...defaults$1, ...opts }, token2 = getCliToken(), apiHost = apiHosts[sanityEnv2], apiConfig = {
      ...cliApiConfig || {},
      ...api || {}
    };
    if (apiHost && (apiConfig.apiHost = apiHost), requireUser && !token2)
      throw new Error('You must login first - run "sanity login"');
    if (requireProject && !apiConfig.projectId) {
      const relativeConfigPath = path__default.default.relative(process.cwd(), configPath);
      throw new Error(
        `${relativeConfigPath} does not contain a project identifier ("api.projectId"), which is required for the Sanity CLI to communicate with the Sanity API`
      );
    }
    return client$1.createClient({
      ...apiConfig,
      apiVersion: "1",
      dataset: apiConfig.dataset || "~dummy-placeholder-dataset-",
      token: requireUser ? token2 : void 0,
      useProjectHostname: requireProject,
      requester,
      useCdn: !1
    });
  };
}
const printVersionResultCommand = async (args, context) => {
  const versions = await findSanityModuleVersions(context, { target: "latest" });
  printResult(versions, context.output.print);
};
function printResult(versions, print) {
  const { versionLength, formatName } = getFormatters(versions);
  versions.forEach((mod) => {
    const version2 = lodashExports.padStart(mod.installed || "<missing>", versionLength), latest = mod.installed === mod.latest ? chalk__default.default.green("(up to date)") : `(latest: ${chalk__default.default.yellow(mod.latest)})`;
    print(`${formatName(getDisplayName(mod))} ${version2} ${latest}`);
  });
}
function getFormatters(versions) {
  const nameLength = versions.reduce((max2, mod) => Math.max(max2, getDisplayName(mod).length), 0), versionLength = versions.reduce(
    (max2, mod) => Math.max(max2, (mod.installed || "<missing>").length),
    0
  );
  return { nameLength, versionLength, formatName: (name) => lodashExports.padEnd(name, nameLength + 1).replace(/^@sanity\/(.*?)(\s|$)/, `${chalk__default.default.yellow("@sanity/")}${chalk__default.default.cyan("$1")}$2`).replace(/^sanity(\s|$)/, `${chalk__default.default.yellow("sanity")}$1`) };
}
function getDisplayName(mod) {
  return mod.isGlobal ? `${mod.name} (global)` : mod.name;
}
const printDebugInfo = async (args, context) => {
  const flags = args.extOptions, { user, globalConfig, projectConfig, project, versions } = await gatherInfo(context), { chalk: chalk2 } = context;
  context.output.print(`
User:`), user instanceof Error ? context.output.print(`  ${chalk2.red(user.message)}
`) : printKeyValue(
    {
      ID: user.id,
      Name: user.name,
      Email: user.email,
      Roles: project ? project.userRoles : void 0
    },
    context
  ), project && (context.output.print("Project:"), printKeyValue(
    {
      ID: project.id,
      "Display name": project.displayName,
      "Studio URL": project.studioHostname
    },
    context
  ));
  const authToken = process.env.SANITY_AUTH_TOKEN || globalConfig.authToken;
  authToken && (context.output.print("Authentication:"), printKeyValue(
    {
      "User type": globalConfig.authType || "normal",
      "Auth token": flags.secrets ? authToken : "<redacted>"
    },
    context
  ), flags.secrets || context.output.print(`  (run with --secrets to reveal token)
`)), context.output.print(`Global config (${chalk2.yellow(getGlobalConfigLocation())}):`);
  const globalCfg = lodashExports.omit(globalConfig, ["authType", "authToken"]);
  if (context.output.print(`  ${formatObject(globalCfg).replace(/\n/g, `
  `)}
`), projectConfig) {
    const configLocation = context.cliConfigPath ? ` (${chalk2.yellow(path__default.default.relative(process.cwd(), context.cliConfigPath))})` : "";
    context.output.print(`Project config${configLocation}:`), context.output.print(`  ${formatObject(projectConfig).replace(/\n/g, `
  `)}`);
  }
  versions && (context.output.print(`
Package versions:`), printResult(versions, (line3) => context.output.print(`  ${line3}`)), context.output.print(""));
};
function formatObject(obj) {
  return util__default.default.inspect(obj, { colors: !0, depth: 1 / 0 });
}
function printKeyValue(obj, context) {
  let printedLines = 0;
  Object.keys(obj).forEach((key2) => {
    typeof obj[key2] < "u" && (context.output.print(`  ${key2}: ${formatObject(obj[key2])}`), printedLines++);
  }), printedLines > 0 && context.output.print("");
}
async function gatherInfo(context) {
  const baseInfo = await promiseProps({
    globalConfig: gatherGlobalConfigInfo(),
    projectConfig: gatherProjectConfigInfo(context)
  }), withUser = {
    ...baseInfo,
    user: await gatherUserInfo(context, {
      projectBased: !!(baseInfo.projectConfig && baseInfo.projectConfig.api)
    })
  };
  return promiseProps({
    project: gatherProjectInfo(context, withUser),
    versions: findSanityModuleVersions(context, { target: "latest" }),
    ...withUser
  });
}
function getGlobalConfigLocation() {
  const user = (os__default.default.userInfo().username || "user").replace(/\\/g, ""), configDir = xdgBasedir.config || path__default.default.join(os__default.default.tmpdir(), user, ".config");
  return path__default.default.join(configDir, "sanity", "config.json");
}
function gatherGlobalConfigInfo() {
  return getUserConfig().all;
}
function gatherProjectConfigInfo(context) {
  const { cliConfig } = context;
  return cliConfig?.api?.projectId ? cliConfig : {
    error: 'Missing required "api.projectId" key'
  };
}
async function gatherProjectInfo(context, baseInfo) {
  const projectId = context.apiClient({ requireUser: !1, requireProject: !1 }).config().projectId, hasToken = !!getCliToken();
  if (!projectId || !hasToken)
    return null;
  const projectInfo = await context.apiClient({ requireUser: !0, requireProject: !1 }).withConfig({ apiVersion: "2023-06-06" }).request({ url: `/projects/${projectId}` });
  if (!projectInfo)
    return new Error(`Project specified in configuration (${projectId}) does not exist in API`);
  const userId = baseInfo.user instanceof Error ? null : baseInfo.user.id, host = projectInfo.studioHost, member = (projectInfo.members || []).find((user) => user.id === userId), hostname = host && `https://${host}.sanity.studio/`;
  return {
    id: projectId,
    displayName: projectInfo.displayName,
    studioHostname: hostname,
    userRoles: member ? member.roles.map((role) => role.name) : ["<none>"]
  };
}
async function gatherUserInfo(context, options2) {
  if (!getCliToken())
    return new Error("Not logged in");
  const userInfo = await context.apiClient({ requireUser: !0, requireProject: options2.projectBased }).users.getById("me");
  return userInfo ? lodashExports.pick(userInfo, ["id", "name", "email"]) : new Error("Token expired or invalid");
}
const help$2 = `
Used to find information about the Sanity environment, and to debug Sanity-related issues.

Options
  --secrets Include API keys in output

Examples
  # Show information about the user, project, and local/global Sanity environment
  sanity debug

  # Include API keys in the output
  sanity debug --secrets
`, debugCommand = {
  name: "debug",
  signature: "[--secrets]",
  description: "Provides diagnostic info for Sanity Studio troubleshooting",
  helpText: help$2,
  action: printDebugInfo
};
var isWsl = { exports: {} }, isDocker_1, hasRequiredIsDocker;
function requireIsDocker() {
  if (hasRequiredIsDocker) return isDocker_1;
  hasRequiredIsDocker = 1;
  const fs2 = require$$0__default$1.default;
  let isDocker;
  function hasDockerEnv() {
    try {
      return fs2.statSync("/.dockerenv"), !0;
    } catch {
      return !1;
    }
  }
  function hasDockerCGroup() {
    try {
      return fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch {
      return !1;
    }
  }
  return isDocker_1 = () => (isDocker === void 0 && (isDocker = hasDockerEnv() || hasDockerCGroup()), isDocker), isDocker_1;
}
var hasRequiredIsWsl;
function requireIsWsl() {
  if (hasRequiredIsWsl) return isWsl.exports;
  hasRequiredIsWsl = 1;
  const os2 = require$$0__default$2.default, fs2 = require$$0__default$1.default, isDocker = requireIsDocker(), isWsl$1 = () => {
    if (process.platform !== "linux")
      return !1;
    if (os2.release().toLowerCase().includes("microsoft"))
      return !isDocker();
    try {
      return fs2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : !1;
    } catch {
      return !1;
    }
  };
  return process.env.__IS_WSL_TEST__ ? isWsl.exports = isWsl$1 : isWsl.exports = isWsl$1(), isWsl.exports;
}
var defineLazyProp, hasRequiredDefineLazyProp;
function requireDefineLazyProp() {
  return hasRequiredDefineLazyProp || (hasRequiredDefineLazyProp = 1, defineLazyProp = (object, propertyName, fn) => {
    const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: !0, writable: !0 });
    return Object.defineProperty(object, propertyName, {
      configurable: !0,
      enumerable: !0,
      get() {
        const result = fn();
        return define(result), result;
      },
      set(value) {
        define(value);
      }
    }), object;
  }), defineLazyProp;
}
var open_1, hasRequiredOpen;
function requireOpen() {
  if (hasRequiredOpen) return open_1;
  hasRequiredOpen = 1;
  const path2 = require$$0__default.default, childProcess2 = require$$1__default$2.default, { promises: fs2, constants: fsConstants } = require$$0__default$1.default, isWsl2 = requireIsWsl(), isDocker = requireIsDocker(), defineLazyProperty = requireDefineLazyProp(), localXdgOpenPath = path2.join(__dirname, "xdg-open"), { platform: platform2, arch } = process, hasContainerEnv = () => {
    try {
      return fs2.statSync("/run/.containerenv"), !0;
    } catch {
      return !1;
    }
  };
  let cachedResult;
  function isInsideContainer() {
    return cachedResult === void 0 && (cachedResult = hasContainerEnv() || isDocker()), cachedResult;
  }
  const getWslDrivesMountPoint = /* @__PURE__ */ (() => {
    const defaultMountPoint = "/mnt/";
    let mountPoint;
    return async function() {
      if (mountPoint)
        return mountPoint;
      const configFilePath = "/etc/wsl.conf";
      let isConfigFileExists = !1;
      try {
        await fs2.access(configFilePath, fsConstants.F_OK), isConfigFileExists = !0;
      } catch {
      }
      if (!isConfigFileExists)
        return defaultMountPoint;
      const configContent = await fs2.readFile(configFilePath, { encoding: "utf8" }), configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
      return configMountPoint ? (mountPoint = configMountPoint.groups.mountPoint.trim(), mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`, mountPoint) : defaultMountPoint;
    };
  })(), pTryEach = async (array, mapper) => {
    let latestError;
    for (const item of array)
      try {
        return await mapper(item);
      } catch (error2) {
        latestError = error2;
      }
    throw latestError;
  }, baseOpen = async (options2) => {
    if (options2 = {
      wait: !1,
      background: !1,
      newInstance: !1,
      allowNonzeroExitCode: !1,
      ...options2
    }, Array.isArray(options2.app))
      return pTryEach(options2.app, (singleApp) => baseOpen({
        ...options2,
        app: singleApp
      }));
    let { name: app, arguments: appArguments = [] } = options2.app || {};
    if (appArguments = [...appArguments], Array.isArray(app))
      return pTryEach(app, (appName) => baseOpen({
        ...options2,
        app: {
          name: appName,
          arguments: appArguments
        }
      }));
    let command2;
    const cliArguments = [], childProcessOptions = {};
    if (platform2 === "darwin")
      command2 = "open", options2.wait && cliArguments.push("--wait-apps"), options2.background && cliArguments.push("--background"), options2.newInstance && cliArguments.push("--new"), app && cliArguments.push("-a", app);
    else if (platform2 === "win32" || isWsl2 && !isInsideContainer() && !app) {
      const mountPoint = await getWslDrivesMountPoint();
      command2 = isWsl2 ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`, cliArguments.push(
        "-NoProfile",
        "-NonInteractive",
        "\u2013ExecutionPolicy",
        "Bypass",
        "-EncodedCommand"
      ), isWsl2 || (childProcessOptions.windowsVerbatimArguments = !0);
      const encodedArguments = ["Start"];
      options2.wait && encodedArguments.push("-Wait"), app ? (encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList"), options2.target && appArguments.unshift(options2.target)) : options2.target && encodedArguments.push(`"${options2.target}"`), appArguments.length > 0 && (appArguments = appArguments.map((arg) => `"\`"${arg}\`""`), encodedArguments.push(appArguments.join(","))), options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
    } else {
      if (app)
        command2 = app;
      else {
        const isBundled = !__dirname || __dirname === "/";
        let exeLocalXdgOpen = !1;
        try {
          await fs2.access(localXdgOpenPath, fsConstants.X_OK), exeLocalXdgOpen = !0;
        } catch {
        }
        command2 = process.versions.electron || platform2 === "android" || isBundled || !exeLocalXdgOpen ? "xdg-open" : localXdgOpenPath;
      }
      appArguments.length > 0 && cliArguments.push(...appArguments), options2.wait || (childProcessOptions.stdio = "ignore", childProcessOptions.detached = !0);
    }
    options2.target && cliArguments.push(options2.target), platform2 === "darwin" && appArguments.length > 0 && cliArguments.push("--args", ...appArguments);
    const subprocess = childProcess2.spawn(command2, cliArguments, childProcessOptions);
    return options2.wait ? new Promise((resolve, reject) => {
      subprocess.once("error", reject), subprocess.once("close", (exitCode) => {
        if (!options2.allowNonzeroExitCode && exitCode > 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve(subprocess);
      });
    }) : (subprocess.unref(), subprocess);
  }, open2 = (target, options2) => {
    if (typeof target != "string")
      throw new TypeError("Expected a `target`");
    return baseOpen({
      ...options2,
      target
    });
  }, openApp = (name, options2) => {
    if (typeof name != "string")
      throw new TypeError("Expected a `name`");
    const { arguments: appArguments = [] } = options2 || {};
    if (appArguments != null && !Array.isArray(appArguments))
      throw new TypeError("Expected `appArguments` as Array type");
    return baseOpen({
      ...options2,
      app: {
        name,
        arguments: appArguments
      }
    });
  };
  function detectArchBinary(binary2) {
    if (typeof binary2 == "string" || Array.isArray(binary2))
      return binary2;
    const { [arch]: archBinary } = binary2;
    if (!archBinary)
      throw new Error(`${arch} is not supported`);
    return archBinary;
  }
  function detectPlatformBinary({ [platform2]: platformBinary }, { wsl }) {
    if (wsl && isWsl2)
      return detectArchBinary(wsl);
    if (!platformBinary)
      throw new Error(`${platform2} is not supported`);
    return detectArchBinary(platformBinary);
  }
  const apps = {};
  return defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
    darwin: "google chrome",
    win32: "chrome",
    linux: ["google-chrome", "google-chrome-stable", "chromium"]
  }, {
    wsl: {
      ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
      x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
    }
  })), defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
    darwin: "firefox",
    win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
    linux: "firefox"
  }, {
    wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
  })), defineLazyProperty(apps, "edge", () => detectPlatformBinary({
    darwin: "microsoft edge",
    win32: "msedge",
    linux: ["microsoft-edge", "microsoft-edge-dev"]
  }, {
    wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
  })), open2.apps = apps, open2.openApp = openApp, open_1 = open2, open_1;
}
var openExports = requireOpen(), open = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(openExports);
const docsCommand = {
  name: "docs",
  helpText: "",
  signature: "docs",
  description: "Opens Sanity Studio documentation in your web browser",
  async action(args, context) {
    const { output } = context, { print } = output, url = "https://www.sanity.io/docs";
    print(`Opening ${url}`), await open(url);
  }
};
var leven$1 = { exports: {} }, hasRequiredLeven;
function requireLeven() {
  if (hasRequiredLeven) return leven$1.exports;
  hasRequiredLeven = 1;
  const array = [], charCodeCache = [], leven2 = (left, right) => {
    if (left === right)
      return 0;
    const swap = left;
    left.length > right.length && (left = right, right = swap);
    let leftLength = left.length, rightLength = right.length;
    for (; leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength); )
      leftLength--, rightLength--;
    let start = 0;
    for (; start < leftLength && left.charCodeAt(start) === right.charCodeAt(start); )
      start++;
    if (leftLength -= start, rightLength -= start, leftLength === 0)
      return rightLength;
    let bCharCode, result, temp, temp2, i = 0, j = 0;
    for (; i < leftLength; )
      charCodeCache[i] = left.charCodeAt(start + i), array[i] = ++i;
    for (; j < rightLength; )
      for (bCharCode = right.charCodeAt(start + j), temp = j++, result = j, i = 0; i < leftLength; i++)
        temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1, temp = array[i], result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
    return result;
  };
  return leven$1.exports = leven2, leven$1.exports.default = leven2, leven$1.exports;
}
var levenExports = requireLeven(), leven = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(levenExports);
const commonMistakes = { get: "list" }, levenThreshold = 3, coreCommands = [
  "build",
  "check",
  "configcheck",
  "cors",
  "dataset",
  "deploy",
  "dev",
  "documents",
  "exec",
  "graphql",
  "hook",
  "migration",
  "manifest",
  "preview",
  "schema",
  "start",
  "undeploy",
  "uninstall",
  "users"
], discouragedCommands = ["upgrade", "check", "configcheck", "uninstall"], helpText$8 = `
Run the command again within a Sanity project directory, where "sanity"
is installed as a dependency.`;
function getNoSuchCommandText(cmdName, parentGroupName, groups) {
  return parentGroupName && groups && groups[parentGroupName] ? suggestCommand(cmdName, groups[parentGroupName], parentGroupName) : coreCommands.includes(cmdName) ? `Command "${cmdName}" is not available outside of a Sanity project context.${helpText$8}` : suggestCommand(cmdName, groups ? groups.default : []);
}
function suggestCommand(cmdName, group, parentGroupName = null) {
  const closest = group.filter((command2) => !discouragedCommands.includes(command2.name)).map((command2) => leven(command2.name, cmdName)).reduce(
    (current, distance, index) => distance < current.distance ? { index, distance } : current,
    { index: 0, distance: 1 / 0 }
  );
  let suggestCmd = "";
  closest.distance <= levenThreshold && (suggestCmd = group[closest.index].name);
  const alternative = commonMistakes[cmdName];
  !suggestCmd && alternative && (suggestCmd = alternative);
  const input2 = chalk__default.default.cyan(`"${cmdName}"`), suggest = chalk__default.default.green(`"${suggestCmd}"`), help2 = chalk__default.default.cyan('"sanity --help"'), didYouMean = suggestCmd ? `Did you mean ${suggest}? ` : " ";
  return parentGroupName ? `${input2} is not a subcommand of "sanity ${parentGroupName}". ${didYouMean}See ${help2}` : `${input2} is not a sanity command. ${didYouMean}See ${help2}`;
}
function generateCommandsDocumentation(commandGroups, group = "default") {
  const commandGroup = commandGroups[group], commands = commandGroup && commandGroup.filter((cmd) => !cmd.hideFromHelp);
  if (!commands || commands.length === 0)
    throw new Error(getNoSuchCommandText(group));
  const cmdLength = commands.reduce((max2, cmd) => Math.max(cmd.name.length, max2), 0), prefix = group === "default" ? "" : ` ${group}`;
  return [
    `usage: npx sanity${prefix} [--default] [-v|--version] [-d|--debug] [-h|--help] <command> [<args>]`,
    "",
    "Commands:"
  ].concat(commands.map((cmd) => `   ${lodashExports.padEnd(cmd.name, cmdLength + 1)} ${cmd.description}`)).concat([
    "",
    `See 'npx sanity help${prefix} <command>' for specific information on a subcommand.`
  ]).join(`
`);
}
function generateCommandDocumentation(command2, group, subCommand) {
  if (!command2)
    throw new Error(
      subCommand ? `"${subCommand}" is not a subcommand of "${group}". See 'npx sanity help ${group}'` : getNoSuchCommandText(group || command2)
    );
  return [
    `usage: npx sanity ${[group || command2.name, subCommand].filter(Boolean).join(" ")} ${command2.signature}`,
    "",
    `   ${command2.description}`,
    "",
    (command2.helpText || "").trim()
  ].join(`
`);
}
function isCommandGroup(cmdOrGroup) {
  return "isGroupRoot" in cmdOrGroup;
}
const showHelpAction = async (args, context) => {
  const [commandName, subCommandName] = args.argsWithoutOptions, { commandGroups } = context.commandRunner;
  if (!commandName) {
    loadEnv.debug('No command given to "help", showing generate Sanity CLI help'), context.output.print(generateCommandsDocumentation(commandGroups));
    return;
  }
  const defaultCommand = commandGroups.default.find((cmd) => cmd.name === commandName);
  if (defaultCommand && !isCommandGroup(defaultCommand)) {
    loadEnv.debug(`Found command in default group with name "${commandName}"`), context.output.print(generateCommandDocumentation(defaultCommand));
    return;
  }
  const group = commandGroups[commandName];
  if (!subCommandName && !group)
    throw loadEnv.debug(`No subcommand given, and we couldn't find a group with name "${group}"`), new Error(getNoSuchCommandText(commandName, null, commandGroups));
  if (!subCommandName && group) {
    loadEnv.debug(`No subcommand given, but found group with name "${commandName}"`), context.output.print(generateCommandsDocumentation(commandGroups, commandName));
    return;
  }
  if (subCommandName && !group)
    throw loadEnv.debug(`Subcommand given, but couldn't find group with name "${commandName}"`), new Error(getNoSuchCommandText(subCommandName, commandName, commandGroups));
  const subCommand = context.commandRunner.resolveSubcommand(group, subCommandName, commandName);
  if (!subCommand)
    throw loadEnv.debug(`Subcommand given, but not found in group "${commandName}"`), new Error(getNoSuchCommandText(subCommandName, commandName, commandGroups));
  loadEnv.debug('Subcommand "%s" for group "%s" found, showing help', subCommandName, commandName), isCommandGroup(subCommand.command) || context.output.print(
    generateCommandDocumentation(subCommand.command, commandName, subCommandName)
  );
}, help$1 = `
With no options and no COMMAND given, the synopsis of the sanity command and a
list of the most commonly used commands are printed on the standard output.

If a command is given, the help page for that command is printed to standard
output. This will usually be more in-depth than the brief description shown in
the command list.
`, command$1 = {
  name: "help",
  signature: "[COMMAND]",
  description: "Displays help information about Sanity CLI commands",
  action: showHelpAction,
  helpText: help$1
};
var frameworks = {}, readConfigFile = {}, jsYaml$4 = {}, loader$2 = {}, common$3 = {}, hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3) return common$3;
  hasRequiredCommon$3 = 1;
  function isNothing(subject) {
    return typeof subject > "u" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject == "object" && subject !== null;
  }
  function toArray2(sequence) {
    return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
  }
  function extend(target, source2) {
    var index, length, key2, sourceKeys;
    if (source2)
      for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
        key2 = sourceKeys[index], target[key2] = source2[key2];
    return target;
  }
  function repeat2(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1)
      result += string;
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  return common$3.isNothing = isNothing, common$3.isObject = isObject2, common$3.toArray = toArray2, common$3.repeat = repeat2, common$3.isNegativeZero = isNegativeZero, common$3.extend = extend, common$3;
}
var exception$2, hasRequiredException$2;
function requireException$2() {
  if (hasRequiredException$2) return exception$2;
  hasRequiredException$2 = 1;
  function YAMLException(reason, mark2) {
    Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return YAMLException.prototype = Object.create(Error.prototype), YAMLException.prototype.constructor = YAMLException, YAMLException.prototype.toString = function(compact) {
    var result = this.name + ": ";
    return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
  }, exception$2 = YAMLException, exception$2;
}
var mark$1, hasRequiredMark$1;
function requireMark$1() {
  if (hasRequiredMark$1) return mark$1;
  hasRequiredMark$1 = 1;
  var common2 = requireCommon$3();
  function Mark(name, buffer2, position, line3, column2) {
    this.name = name, this.buffer = buffer2, this.position = position, this.line = line3, this.column = column2;
  }
  return Mark.prototype.getSnippet = function(indent, maxLength) {
    var head, start, tail, end, snippet2;
    if (!this.buffer) return null;
    for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
      if (start -= 1, this.position - start > maxLength / 2 - 1) {
        head = " ... ", start += 5;
        break;
      }
    for (tail = "", end = this.position; end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1; )
      if (end += 1, end - this.position > maxLength / 2 - 1) {
        tail = " ... ", end -= 5;
        break;
      }
    return snippet2 = this.buffer.slice(start, end), common2.repeat(" ", indent) + head + snippet2 + tail + `
` + common2.repeat(" ", indent + this.position - start + head.length) + "^";
  }, Mark.prototype.toString = function(compact) {
    var snippet2, where = "";
    return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet2 = this.getSnippet(), snippet2 && (where += `:
` + snippet2)), where;
  }, mark$1 = Mark, mark$1;
}
var type$2, hasRequiredType$2;
function requireType$2() {
  if (hasRequiredType$2) return type$2;
  hasRequiredType$2 = 1;
  var YAMLException = requireException$2(), TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ], YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    return map2 !== null && Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    }), result;
  }
  function Type(tag, options2) {
    if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }), this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
      return !0;
    }, this.construct = options2.construct || function(data) {
      return data;
    }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.defaultStyle = options2.defaultStyle || null, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
  return type$2 = Type, type$2;
}
var schema$2, hasRequiredSchema$2;
function requireSchema$2() {
  if (hasRequiredSchema$2) return schema$2;
  hasRequiredSchema$2 = 1;
  var common2 = requireCommon$3(), YAMLException = requireException$2(), Type = requireType$2();
  function compileList(schema2, name, result) {
    var exclude = [];
    return schema2.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    }), schema2[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
      }), result.push(currentType);
    }), result.filter(function(type2, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type2) {
      result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
    }
    for (index = 0, length = arguments.length; index < length; index += 1)
      arguments[index].forEach(collectType);
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type2) {
      if (type2.loadKind && type2.loadKind !== "scalar")
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  return Schema.DEFAULT = null, Schema.create = function() {
    var schemas, types2;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT, types2 = arguments[0];
        break;
      case 2:
        schemas = arguments[0], types2 = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    if (schemas = common2.toArray(schemas), types2 = common2.toArray(types2), !schemas.every(function(schema2) {
      return schema2 instanceof Schema;
    }))
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!types2.every(function(type2) {
      return type2 instanceof Type;
    }))
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new Schema({
      include: schemas,
      explicit: types2
    });
  }, schema$2 = Schema, schema$2;
}
var str$2, hasRequiredStr$2;
function requireStr$2() {
  if (hasRequiredStr$2) return str$2;
  hasRequiredStr$2 = 1;
  var Type = requireType$2();
  return str$2 = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  }), str$2;
}
var seq$2, hasRequiredSeq$2;
function requireSeq$2() {
  if (hasRequiredSeq$2) return seq$2;
  hasRequiredSeq$2 = 1;
  var Type = requireType$2();
  return seq$2 = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  }), seq$2;
}
var map$3, hasRequiredMap$2;
function requireMap$2() {
  if (hasRequiredMap$2) return map$3;
  hasRequiredMap$2 = 1;
  var Type = requireType$2();
  return map$3 = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  }), map$3;
}
var failsafe$2, hasRequiredFailsafe$2;
function requireFailsafe$2() {
  if (hasRequiredFailsafe$2) return failsafe$2;
  hasRequiredFailsafe$2 = 1;
  var Schema = requireSchema$2();
  return failsafe$2 = new Schema({
    explicit: [
      requireStr$2(),
      requireSeq$2(),
      requireMap$2()
    ]
  }), failsafe$2;
}
var _null$2, hasRequired_null$2;
function require_null$2() {
  if (hasRequired_null$2) return _null$2;
  hasRequired_null$2 = 1;
  var Type = requireType$2();
  function resolveYamlNull(data) {
    if (data === null) return !0;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  return _null$2 = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  }), _null$2;
}
var bool$2, hasRequiredBool$2;
function requireBool$2() {
  if (hasRequiredBool$2) return bool$2;
  hasRequiredBool$2 = 1;
  var Type = requireType$2();
  function resolveYamlBoolean(data) {
    if (data === null) return !1;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  return bool$2 = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), bool$2;
}
var int$2, hasRequiredInt$2;
function requireInt$2() {
  if (hasRequiredInt$2) return int$2;
  hasRequiredInt$2 = 1;
  var common2 = requireCommon$3(), Type = requireType$2();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return !1;
    var max2 = data.length, index = 0, hasDigits = !1, ch;
    if (!max2) return !1;
    if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
      if (index + 1 === max2) return !0;
      if (ch = data[++index], ch === "b") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (ch !== "0" && ch !== "1") return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isHexCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      for (; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isOctCode(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "_") return !1;
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index)))
          return !1;
        hasDigits = !0;
      }
    return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign2 = 1, ch, base2, digits = [];
    return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign2 * parseInt(value.slice(2), 2) : value[1] === "x" ? sign2 * parseInt(value, 16) : sign2 * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseInt(value, 10);
  }
  function isInteger2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common2.isNegativeZero(object);
  }
  return int$2 = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), int$2;
}
var float$2, hasRequiredFloat$2;
function requireFloat$2() {
  if (hasRequiredFloat$2) return float$2;
  hasRequiredFloat$2 = 1;
  var common2 = requireCommon$3(), Type = requireType$2(), YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_");
  }
  function constructYamlFloat(data) {
    var value, sign2, base2, digits;
    return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object))
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (common2.isNegativeZero(object))
      return "-0.0";
    return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  return float$2 = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  }), float$2;
}
var json$2, hasRequiredJson$2;
function requireJson$2() {
  if (hasRequiredJson$2) return json$2;
  hasRequiredJson$2 = 1;
  var Schema = requireSchema$2();
  return json$2 = new Schema({
    include: [
      requireFailsafe$2()
    ],
    implicit: [
      require_null$2(),
      requireBool$2(),
      requireInt$2(),
      requireFloat$2()
    ]
  }), json$2;
}
var core$5, hasRequiredCore$5;
function requireCore$5() {
  if (hasRequiredCore$5) return core$5;
  hasRequiredCore$5 = 1;
  var Schema = requireSchema$2();
  return core$5 = new Schema({
    include: [
      requireJson$2()
    ]
  }), core$5;
}
var timestamp$3, hasRequiredTimestamp$2;
function requireTimestamp$2() {
  if (hasRequiredTimestamp$2) return timestamp$3;
  hasRequiredTimestamp$2 = 1;
  var Type = requireType$2(), YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null) throw new Error("Date resolve error");
    if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
      return new Date(Date.UTC(year, month, day));
    if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
      for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
        fraction += "0";
      fraction = +fraction;
    }
    return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  return timestamp$3 = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  }), timestamp$3;
}
var merge$4, hasRequiredMerge$2;
function requireMerge$2() {
  if (hasRequiredMerge$2) return merge$4;
  hasRequiredMerge$2 = 1;
  var Type = requireType$2();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  return merge$4 = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  }), merge$4;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var binary$3, hasRequiredBinary$2;
function requireBinary$2() {
  if (hasRequiredBinary$2) return binary$3;
  hasRequiredBinary$2 = 1;
  var NodeBuffer;
  try {
    var _require = commonjsRequire;
    NodeBuffer = _require("buffer").Buffer;
  } catch {
  }
  var Type = requireType$2(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null) return !1;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
        if (code < 0) return !1;
        bitlen += 6;
      }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++)
      idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
    return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
    return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  return binary$3 = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  }), binary$3;
}
var omap$2, hasRequiredOmap$2;
function requireOmap$2() {
  if (hasRequiredOmap$2) return omap$2;
  hasRequiredOmap$2 = 1;
  var Type = requireType$2(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return !0;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]") return !1;
      for (pairKey in pair)
        if (_hasOwnProperty.call(pair, pairKey))
          if (!pairHasKey) pairHasKey = !0;
          else return !1;
      if (!pairHasKey) return !1;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return !1;
    }
    return !0;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  return omap$2 = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  }), omap$2;
}
var pairs$3, hasRequiredPairs$2;
function requirePairs$2() {
  if (hasRequiredPairs$2) return pairs$3;
  hasRequiredPairs$2 = 1;
  var Type = requireType$2(), _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return !0;
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return !0;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
      pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
    return result;
  }
  return pairs$3 = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  }), pairs$3;
}
var set$2, hasRequiredSet$2;
function requireSet$2() {
  if (hasRequiredSet$2) return set$2;
  hasRequiredSet$2 = 1;
  var Type = requireType$2(), _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return !0;
    var key2, object = data;
    for (key2 in object)
      if (_hasOwnProperty.call(object, key2) && object[key2] !== null)
        return !1;
    return !0;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  return set$2 = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  }), set$2;
}
var default_safe$1, hasRequiredDefault_safe$1;
function requireDefault_safe$1() {
  if (hasRequiredDefault_safe$1) return default_safe$1;
  hasRequiredDefault_safe$1 = 1;
  var Schema = requireSchema$2();
  return default_safe$1 = new Schema({
    include: [
      requireCore$5()
    ],
    implicit: [
      requireTimestamp$2(),
      requireMerge$2()
    ],
    explicit: [
      requireBinary$2(),
      requireOmap$2(),
      requirePairs$2(),
      requireSet$2()
    ]
  }), default_safe$1;
}
var _undefined$1, hasRequired_undefined$1;
function require_undefined$1() {
  if (hasRequired_undefined$1) return _undefined$1;
  hasRequired_undefined$1 = 1;
  var Type = requireType$2();
  function resolveJavascriptUndefined() {
    return !0;
  }
  function constructJavascriptUndefined() {
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object > "u";
  }
  return _undefined$1 = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  }), _undefined$1;
}
var regexp$1, hasRequiredRegexp$1;
function requireRegexp$1() {
  if (hasRequiredRegexp$1) return regexp$1;
  hasRequiredRegexp$1 = 1;
  var Type = requireType$2();
  function resolveJavascriptRegExp(data) {
    if (data === null || data.length === 0) return !1;
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return !(regexp2[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp2[regexp2.length - modifiers.length - 1] !== "/"));
  }
  function constructJavascriptRegExp(data) {
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return regexp2[0] === "/" && (tail && (modifiers = tail[1]), regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1)), new RegExp(regexp2, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  return regexp$1 = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  }), regexp$1;
}
var _function$1, hasRequired_function$1;
function require_function$1() {
  if (hasRequired_function$1) return _function$1;
  hasRequired_function$1 = 1;
  var esprima2;
  try {
    var _require = commonjsRequire;
    esprima2 = _require("esprima");
  } catch {
    typeof window < "u" && (esprima2 = window.esprima);
  }
  var Type = requireType$2();
  function resolveJavascriptFunction(data) {
    if (data === null) return !1;
    try {
      var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 });
      return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
    } catch {
      return !1;
    }
  }
  function constructJavascriptFunction(data) {
    var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
      throw new Error("Failed to resolve function");
    return ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source2.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source2.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction2(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  return _function$1 = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction2,
    represent: representJavascriptFunction
  }), _function$1;
}
var default_full$1, hasRequiredDefault_full$1;
function requireDefault_full$1() {
  if (hasRequiredDefault_full$1) return default_full$1;
  hasRequiredDefault_full$1 = 1;
  var Schema = requireSchema$2();
  return default_full$1 = Schema.DEFAULT = new Schema({
    include: [
      requireDefault_safe$1()
    ],
    explicit: [
      require_undefined$1(),
      requireRegexp$1(),
      require_function$1()
    ]
  }), default_full$1;
}
var hasRequiredLoader$2;
function requireLoader$2() {
  if (hasRequiredLoader$2) return loader$2;
  hasRequiredLoader$2 = 1;
  var common2 = requireCommon$3(), YAMLException = requireException$2(), Mark = requireMark$1(), DEFAULT_SAFE_SCHEMA = requireDefault_safe$1(), DEFAULT_FULL_SCHEMA = requireDefault_full$1(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
  }
  function escapedHexLen(c2) {
    return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
  }
  function fromDecimalCode(c2) {
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  for (var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++)
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
  function State(input2, options2) {
    this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(
      message,
      new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
    );
  }
  function throwError2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    state.onWarning && state.onWarning.call(null, generateError(state, message));
  }
  var directiveHandlers = {
    YAML: function(state, name, args) {
      var match2, major2, minor2;
      state.version !== null && throwError2(state, "duplication of %YAML directive"), args.length !== 1 && throwError2(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError2(state, "ill-formed argument of the YAML directive"), major2 = parseInt(match2[1], 10), minor2 = parseInt(match2[2], 10), major2 !== 1 && throwError2(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor2 < 2, minor2 !== 1 && minor2 !== 2 && throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function(state, name, args) {
      var handle, prefix;
      args.length !== 2 && throwError2(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError2(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      if (_result = state.input.slice(start, end), checkJson)
        for (_position = 0, _length = _result.length; _position < _length; _position += 1)
          _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError2(state, "expected valid JSON character");
      else PATTERN_NON_PRINTABLE.test(_result) && throwError2(state, "the stream contains non-printable characters");
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source2, overridableKeys) {
    var sourceKeys, key2, index, quantity;
    for (common2.isObject(source2) || throwError2(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
      key2 = sourceKeys[index], _hasOwnProperty.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode))
      for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
        Array.isArray(keyNode[index]) && throwError2(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
    if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
      if (Array.isArray(valueNode))
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
          mergeMappings(state, _result, valueNode[index], overridableKeys);
      else
        mergeMappings(state, _result, valueNode, overridableKeys);
    else
      !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError2(state, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError2(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state.input.charCodeAt(++state.position);
      if (allowComments && ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 10 && ch !== 13 && ch !== 0);
      if (is_EOL(ch))
        for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      else
        break;
    }
    return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
  }
  function writeFoldedLines(state, count2) {
    count2 === 1 ? state.result += " " : count2 > 1 && (state.result += common2.repeat(`
`, count2 - 1));
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
      return !1;
    for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
      if (ch === 58) {
        if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
          break;
      } else if (ch === 35) {
        if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
          break;
      } else {
        if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
          break;
        if (is_EOL(ch))
          if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
            hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
            break;
          }
      }
      hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
    }
    return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    if (ch = state.input.charCodeAt(state.position), ch !== 39)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
      if (ch === 39)
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
          captureStart = state.position, state.position++, captureEnd = state.position;
        else
          return !0;
      else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
    throwError2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 34)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
      if (ch === 34)
        return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
      if (ch === 92) {
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
          skipSeparationSpace(state, !1, nodeIndent);
        else if (ch < 256 && simpleEscapeCheck[ch])
          state.result += simpleEscapeMap[ch], state.position++;
        else if ((tmp2 = escapedHexLen(ch)) > 0) {
          for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
            ch = state.input.charCodeAt(++state.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError2(state, "expected hexadecimal character");
          state.result += charFromCodepoint(hexResult), state.position++;
        } else
          throwError2(state, "unknown escape sequence");
        captureStart = captureEnd = state.position;
      } else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
    }
    throwError2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 91)
      terminator = 93, isMapping = !1, _result = [];
    else if (ch === 123)
      terminator = 125, isMapping = !0, _result = {};
    else
      return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
      if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
        return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
      readNext || throwError2(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
    }
    throwError2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 124)
      folding = !1;
    else if (ch === 62)
      folding = !0;
    else
      return !1;
    for (state.kind = "scalar", state.result = ""; ch !== 0; )
      if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
        CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError2(state, "repeat of a chomping mode identifier");
      else if ((tmp2 = fromDecimalCode(ch)) >= 0)
        tmp2 === 0 ? throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError2(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
      else
        break;
    if (is_WHITE_SPACE(ch)) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (is_WHITE_SPACE(ch));
      if (ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    for (; ch !== 0; ) {
      for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        chomping === CHOMPING_KEEP ? state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
        break;
      }
      for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common2.repeat(`
`, emptyLines) : state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
        ch = state.input.charCodeAt(++state.position);
      captureSegment(state, captureStart, state.position, !1);
    }
    return !0;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following))); ) {
      if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
        _result.push(null), ch = state.input.charCodeAt(state.position);
        continue;
      }
      if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a sequence entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
        ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
      else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
        if (state.line === _line) {
          for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 58)
            ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
          else if (detected)
            throwError2(state, "can not read an implicit mapping pair; a colon is missed");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        } else if (detected)
          throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      else
        break;
      if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0)
        throwError2(state, "bad indentation of a mapping entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 33) return !1;
    if (state.tag !== null && throwError2(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 0 && ch !== 62);
      state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError2(state, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch === 33 && (isNamed ? throwError2(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError2(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
      tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError2(state, "tag suffix cannot contain flow indicator characters");
    }
    return tagName && !PATTERN_TAG_URI.test(tagName) && throwError2(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError2(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 38) return !1;
    for (state.anchor !== null && throwError2(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
  }
  function readAlias(state) {
    var _position, alias, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 42) return !1;
    for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), state.anchorMap.hasOwnProperty(alias) || throwError2(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
    if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
      for (; readTagProperty(state) || readAnchorProperty(state); )
        skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
    if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError2(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!")
      if (state.tag === "?") {
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
          if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
            state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
            break;
          }
      } else _hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type2 = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type2.kind !== state.kind && throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result) ? (state.result = type2.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError2(state, "unknown tag !<" + state.tag + ">");
    return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
    for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
      for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError2(state, "directive name must not be less than one character in length"); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 35) {
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError2(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
      state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
      return;
    }
    if (state.position < state.length - 1)
      throwError2(state, "end of the stream or a document separator is expected");
    else
      return;
  }
  function loadDocuments(input2, options2) {
    input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
    var state = new State(input2, options2);
    for (state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
      state.lineIndent += 1, state.position += 1;
    for (; state.position < state.length - 1; )
      readDocument(state);
    return state.documents;
  }
  function loadAll(input2, iterator2, options2) {
    var documents = loadDocuments(input2, options2), index, length;
    if (typeof iterator2 != "function")
      return documents;
    for (index = 0, length = documents.length; index < length; index += 1)
      iterator2(documents[index]);
  }
  function load2(input2, options2) {
    var documents = loadDocuments(input2, options2);
    if (documents.length !== 0) {
      if (documents.length === 1)
        return documents[0];
      throw new YAMLException("expected a single document in the stream, but found more");
    }
  }
  function safeLoadAll(input2, output, options2) {
    if (typeof output == "function")
      loadAll(input2, output, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    else
      return loadAll(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  function safeLoad(input2, options2) {
    return load2(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return loader$2.loadAll = loadAll, loader$2.load = load2, loader$2.safeLoadAll = safeLoadAll, loader$2.safeLoad = safeLoad, loader$2;
}
var dumper$2 = {}, hasRequiredDumper$2;
function requireDumper$2() {
  if (hasRequiredDumper$2) return dumper$2;
  hasRequiredDumper$2 = 1;
  var common2 = requireCommon$3(), YAMLException = requireException$2(), DEFAULT_FULL_SCHEMA = requireDefault_full$1(), DEFAULT_SAFE_SCHEMA = requireDefault_safe$1(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA2 = 44, CHAR_MINUS = 45, CHAR_COLON2 = 58, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
      tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    if (string = character.toString(16).toUpperCase(), character <= 255)
      handle = "x", length = 2;
    else if (character <= 65535)
      handle = "u", length = 4;
    else if (character <= 4294967295)
      handle = "U", length = 8;
    else
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  function State(options2) {
    this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common2.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    for (var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
      next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
      if (type2 = state.implicitTypes[index], type2.resolve(str2))
        return !0;
    return !1;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
  }
  function isPlainSafe(c2) {
    return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON2 && c2 !== CHAR_SHARP;
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i, char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly)
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), !isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char);
      }
    else {
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), char === CHAR_LINE_FEED)
          hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
        else if (!isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0)
        return "''";
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
        return "'" + string + "'";
      var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
      var nextLF = string.indexOf(`
`);
      return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
    }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
      var prefix = match2[1], line3 = match2[2];
      moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line3, width) {
    if (line3 === "" || line3[0] === " ") return line3;
    for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line3); )
      next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line3.slice(start, end), start = end + 1), curr = next;
    return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
  }
  function escapeString(string) {
    for (var result = "", char, nextChar, escapeSeq, i = 0; i < string.length; i++) {
      if (char = string.charCodeAt(i), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i + 1), nextChar >= 56320 && nextChar <= 57343)) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i++;
        continue;
      }
      escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
    state.tag = _tag, state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
    state.tag = _tag, state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = state.condenseFlow ? '"' : "", index !== 0 && (pairBuffer += ", "), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === !0)
      objectKeyList.sort();
    else if (typeof state.sortKeys == "function")
      objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys)
      throw new YAMLException("sortKeys must be a boolean or a function");
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
      if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (state.tag = explicit ? type2.tag : "?", type2.represent) {
          if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
            _result = type2.represent(object, style);
          else if (_hasOwnProperty.call(type2.represent, style))
            _result = type2.represent[style](object, style);
          else
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          state.dump = _result;
        }
        return !0;
      }
    return !1;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
    var type2 = _toString.call(state.dump);
    block && (block = state.flowLevel < 0 || state.flowLevel > level);
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
      state.dump = "*ref_" + duplicateIndex;
    else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
        block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      } else if (type2 === "[object String]")
        state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
      else {
        if (state.skipInvalid) return !1;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
    }
    return !0;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object == "object")
      if (index = objects.indexOf(object), index !== -1)
        duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
      else if (objects.push(object), Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          inspectNode(object[index], objects, duplicatesIndexes);
      else
        for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
  }
  function dump(input2, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    return state.noRefs || getDuplicateReferences(input2, state), writeNode(state, 0, input2, !0, !0) ? state.dump + `
` : "";
  }
  function safeDump(input2, options2) {
    return dump(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return dumper$2.dump = dump, dumper$2.safeDump = safeDump, dumper$2;
}
var hasRequiredJsYaml$4;
function requireJsYaml$4() {
  if (hasRequiredJsYaml$4) return jsYaml$4;
  hasRequiredJsYaml$4 = 1;
  var loader2 = requireLoader$2(), dumper2 = requireDumper$2();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  return jsYaml$4.Type = requireType$2(), jsYaml$4.Schema = requireSchema$2(), jsYaml$4.FAILSAFE_SCHEMA = requireFailsafe$2(), jsYaml$4.JSON_SCHEMA = requireJson$2(), jsYaml$4.CORE_SCHEMA = requireCore$5(), jsYaml$4.DEFAULT_SAFE_SCHEMA = requireDefault_safe$1(), jsYaml$4.DEFAULT_FULL_SCHEMA = requireDefault_full$1(), jsYaml$4.load = loader2.load, jsYaml$4.loadAll = loader2.loadAll, jsYaml$4.safeLoad = loader2.safeLoad, jsYaml$4.safeLoadAll = loader2.safeLoadAll, jsYaml$4.dump = dumper2.dump, jsYaml$4.safeDump = dumper2.safeDump, jsYaml$4.YAMLException = requireException$2(), jsYaml$4.MINIMAL_SCHEMA = requireFailsafe$2(), jsYaml$4.SAFE_SCHEMA = requireDefault_safe$1(), jsYaml$4.DEFAULT_SCHEMA = requireDefault_full$1(), jsYaml$4.scan = deprecated("scan"), jsYaml$4.parse = deprecated("parse"), jsYaml$4.compose = deprecated("compose"), jsYaml$4.addConstructor = deprecated("addConstructor"), jsYaml$4;
}
var jsYaml$3, hasRequiredJsYaml$3;
function requireJsYaml$3() {
  if (hasRequiredJsYaml$3) return jsYaml$3;
  hasRequiredJsYaml$3 = 1;
  var yaml = requireJsYaml$4();
  return jsYaml$3 = yaml, jsYaml$3;
}
var toml = {}, parse$2 = { exports: {} }, tomlParser = { exports: {} }, parser$2, hasRequiredParser$1;
function requireParser$1() {
  if (hasRequiredParser$1) return parser$2;
  hasRequiredParser$1 = 1;
  const ParserEND = 1114112;
  class ParserError extends Error {
    /* istanbul ignore next */
    constructor(msg, filename, linenumber) {
      super("[ParserError] " + msg, filename, linenumber), this.name = "ParserError", this.code = "ParserError", Error.captureStackTrace && Error.captureStackTrace(this, ParserError);
    }
  }
  class State {
    constructor(parser2) {
      this.parser = parser2, this.buf = "", this.returned = null, this.result = null, this.resultTable = null, this.resultArr = null;
    }
  }
  class Parser {
    constructor() {
      this.pos = 0, this.col = 0, this.line = 0, this.obj = {}, this.ctx = this.obj, this.stack = [], this._buf = "", this.char = null, this.ii = 0, this.state = new State(this.parseStart);
    }
    parse(str2) {
      if (str2.length === 0 || str2.length == null) return;
      this._buf = String(str2), this.ii = -1, this.char = -1;
      let getNext;
      for (; getNext === !1 || this.nextChar(); )
        getNext = this.runOne();
      this._buf = null;
    }
    nextChar() {
      return this.char === 10 && (++this.line, this.col = -1), ++this.ii, this.char = this._buf.codePointAt(this.ii), ++this.pos, ++this.col, this.haveBuffer();
    }
    haveBuffer() {
      return this.ii < this._buf.length;
    }
    runOne() {
      return this.state.parser.call(this, this.state.returned);
    }
    finish() {
      this.char = ParserEND;
      let last2;
      do
        last2 = this.state.parser, this.runOne();
      while (this.state.parser !== last2);
      return this.ctx = null, this.state = null, this._buf = null, this.obj;
    }
    next(fn) {
      if (typeof fn != "function") throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
      this.state.parser = fn;
    }
    goto(fn) {
      return this.next(fn), this.runOne();
    }
    call(fn, returnWith) {
      returnWith && this.next(returnWith), this.stack.push(this.state), this.state = new State(fn);
    }
    callNow(fn, returnWith) {
      return this.call(fn, returnWith), this.runOne();
    }
    return(value) {
      if (this.stack.length === 0) throw this.error(new ParserError("Stack underflow"));
      value === void 0 && (value = this.state.buf), this.state = this.stack.pop(), this.state.returned = value;
    }
    returnNow(value) {
      return this.return(value), this.runOne();
    }
    consume() {
      if (this.char === ParserEND) throw this.error(new ParserError("Unexpected end-of-buffer"));
      this.state.buf += this._buf[this.ii];
    }
    error(err) {
      return err.line = this.line, err.col = this.col, err.pos = this.pos, err;
    }
    /* istanbul ignore next */
    parseStart() {
      throw new ParserError("Must declare a parseStart method");
    }
  }
  return Parser.END = ParserEND, Parser.Error = ParserError, parser$2 = Parser, parser$2;
}
var createDatetime, hasRequiredCreateDatetime;
function requireCreateDatetime() {
  return hasRequiredCreateDatetime || (hasRequiredCreateDatetime = 1, createDatetime = (value) => {
    const date = new Date(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }), createDatetime;
}
var formatNum, hasRequiredFormatNum;
function requireFormatNum() {
  return hasRequiredFormatNum || (hasRequiredFormatNum = 1, formatNum = (d, num) => {
    for (num = String(num); num.length < d; ) num = "0" + num;
    return num;
  }), formatNum;
}
var createDatetimeFloat, hasRequiredCreateDatetimeFloat;
function requireCreateDatetimeFloat() {
  if (hasRequiredCreateDatetimeFloat) return createDatetimeFloat;
  hasRequiredCreateDatetimeFloat = 1;
  const f = requireFormatNum();
  class FloatingDateTime extends Date {
    constructor(value) {
      super(value + "Z"), this.isFloating = !0;
    }
    toISOString() {
      const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`, time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
      return `${date}T${time}`;
    }
  }
  return createDatetimeFloat = (value) => {
    const date = new FloatingDateTime(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }, createDatetimeFloat;
}
var createDate, hasRequiredCreateDate;
function requireCreateDate() {
  if (hasRequiredCreateDate) return createDate;
  hasRequiredCreateDate = 1;
  const f = requireFormatNum(), DateTime = loadEnv.commonjsGlobal.Date;
  class Date2 extends DateTime {
    constructor(value) {
      super(value), this.isDate = !0;
    }
    toISOString() {
      return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
    }
  }
  return createDate = (value) => {
    const date = new Date2(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }, createDate;
}
var createTime, hasRequiredCreateTime;
function requireCreateTime() {
  if (hasRequiredCreateTime) return createTime;
  hasRequiredCreateTime = 1;
  const f = requireFormatNum();
  class Time extends Date {
    constructor(value) {
      super(`0000-01-01T${value}Z`), this.isTime = !0;
    }
    toISOString() {
      return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
    }
  }
  return createTime = (value) => {
    const date = new Time(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }, createTime;
}
var hasRequiredTomlParser;
function requireTomlParser() {
  if (hasRequiredTomlParser) return tomlParser.exports;
  hasRequiredTomlParser = 1, tomlParser.exports = makeParserClass(requireParser$1()), tomlParser.exports.makeParserClass = makeParserClass;
  class TomlError extends Error {
    constructor(msg) {
      super(msg), this.name = "TomlError", Error.captureStackTrace && Error.captureStackTrace(this, TomlError), this.fromTOML = !0, this.wrapped = null;
    }
  }
  TomlError.wrap = (err) => {
    const terr = new TomlError(err.message);
    return terr.code = err.code, terr.wrapped = err, terr;
  }, tomlParser.exports.TomlError = TomlError;
  const createDateTime = requireCreateDatetime(), createDateTimeFloat = requireCreateDatetimeFloat(), createDate = requireCreateDate(), createTime = requireCreateTime(), CTRL_I = 9, CTRL_J = 10, CTRL_M = 13, CTRL_CHAR_BOUNDARY = 31, CHAR_SP = 32, CHAR_QUOT = 34, CHAR_NUM = 35, CHAR_APOS = 39, CHAR_PLUS = 43, CHAR_COMMA = 44, CHAR_HYPHEN = 45, CHAR_PERIOD = 46, CHAR_0 = 48, CHAR_1 = 49, CHAR_7 = 55, CHAR_9 = 57, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_A = 65, CHAR_E = 69, CHAR_F = 70, CHAR_T = 84, CHAR_U = 85, CHAR_Z = 90, CHAR_LOWBAR = 95, CHAR_a = 97, CHAR_b = 98, CHAR_e = 101, CHAR_f = 102, CHAR_i = 105, CHAR_l = 108, CHAR_n = 110, CHAR_o = 111, CHAR_r = 114, CHAR_s = 115, CHAR_t = 116, CHAR_u = 117, CHAR_x = 120, CHAR_z = 122, CHAR_LCUB = 123, CHAR_RCUB = 125, CHAR_LSQB = 91, CHAR_BSOL = 92, CHAR_RSQB = 93, CHAR_DEL = 127, SURROGATE_FIRST = 55296, SURROGATE_LAST = 57343, escapes = {
    [CHAR_b]: "\b",
    [CHAR_t]: "	",
    [CHAR_n]: `
`,
    [CHAR_f]: "\f",
    [CHAR_r]: "\r",
    [CHAR_QUOT]: '"',
    [CHAR_BSOL]: "\\"
  };
  function isDigit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_9;
  }
  function isHexit(cp) {
    return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
  }
  function isBit(cp) {
    return cp === CHAR_1 || cp === CHAR_0;
  }
  function isOctit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_7;
  }
  function isAlphaNumQuoteHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
  }
  function isAlphaNumHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
  }
  const _type = Symbol("type"), _declared = Symbol("declared"), hasOwnProperty = Object.prototype.hasOwnProperty, defineProperty = Object.defineProperty, descriptor = { configurable: !0, enumerable: !0, writable: !0, value: void 0 };
  function hasKey(obj, key2) {
    return hasOwnProperty.call(obj, key2) ? !0 : (key2 === "__proto__" && defineProperty(obj, "__proto__", descriptor), !1);
  }
  const INLINE_TABLE = Symbol("inline-table");
  function InlineTable() {
    return Object.defineProperties({}, {
      [_type]: { value: INLINE_TABLE }
    });
  }
  function isInlineTable(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_TABLE;
  }
  const TABLE = Symbol("table");
  function Table() {
    return Object.defineProperties({}, {
      [_type]: { value: TABLE },
      [_declared]: { value: !1, writable: !0 }
    });
  }
  function isTable(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === TABLE;
  }
  const _contentType = Symbol("content-type"), INLINE_LIST = Symbol("inline-list");
  function InlineList(type2) {
    return Object.defineProperties([], {
      [_type]: { value: INLINE_LIST },
      [_contentType]: { value: type2 }
    });
  }
  function isInlineList(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_LIST;
  }
  const LIST = Symbol("list");
  function List() {
    return Object.defineProperties([], {
      [_type]: { value: LIST }
    });
  }
  function isList(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === LIST;
  }
  let _custom;
  try {
    const utilInspect = eval("require('util').inspect");
    _custom = utilInspect.custom;
  } catch (_) {
  }
  const _inspect = _custom || "inspect";
  class BoxedBigInt {
    constructor(value) {
      try {
        this.value = loadEnv.commonjsGlobal.BigInt.asIntN(64, value);
      } catch {
        this.value = null;
      }
      Object.defineProperty(this, _type, { value: INTEGER });
    }
    isNaN() {
      return this.value === null;
    }
    /* istanbul ignore next */
    toString() {
      return String(this.value);
    }
    /* istanbul ignore next */
    [_inspect]() {
      return `[BigInt: ${this.toString()}]}`;
    }
    valueOf() {
      return this.value;
    }
  }
  const INTEGER = Symbol("integer");
  function Integer(value) {
    let num = Number(value);
    return Object.is(num, -0) && (num = 0), loadEnv.commonjsGlobal.BigInt && !Number.isSafeInteger(num) ? new BoxedBigInt(value) : Object.defineProperties(new Number(num), {
      isNaN: { value: function() {
        return isNaN(this);
      } },
      [_type]: { value: INTEGER },
      [_inspect]: { value: () => `[Integer: ${value}]` }
    });
  }
  function isInteger(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === INTEGER;
  }
  const FLOAT = Symbol("float");
  function Float(value) {
    return Object.defineProperties(new Number(value), {
      [_type]: { value: FLOAT },
      [_inspect]: { value: () => `[Float: ${value}]` }
    });
  }
  function isFloat(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === FLOAT;
  }
  function tomlType(value) {
    const type2 = typeof value;
    if (type2 === "object") {
      if (value === null) return "null";
      if (value instanceof Date) return "datetime";
      if (_type in value)
        switch (value[_type]) {
          case INLINE_TABLE:
            return "inline-table";
          case INLINE_LIST:
            return "inline-list";
          /* istanbul ignore next */
          case TABLE:
            return "table";
          /* istanbul ignore next */
          case LIST:
            return "list";
          case FLOAT:
            return "float";
          case INTEGER:
            return "integer";
        }
    }
    return type2;
  }
  function makeParserClass(Parser) {
    class TOMLParser extends Parser {
      constructor() {
        super(), this.ctx = this.obj = Table();
      }
      /* MATCH HELPER */
      atEndOfWord() {
        return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
      }
      atEndOfLine() {
        return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
      }
      parseStart() {
        if (this.char === Parser.END)
          return null;
        if (this.char === CHAR_LSQB)
          return this.call(this.parseTableOrList);
        if (this.char === CHAR_NUM)
          return this.call(this.parseComment);
        if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
          return null;
        if (isAlphaNumQuoteHyphen(this.char))
          return this.callNow(this.parseAssignStatement);
        throw this.error(new TomlError(`Unknown character "${this.char}"`));
      }
      // HELPER, this strips any whitespace and comments to the end of the line
      // then RETURNS. Last state in a production.
      parseWhitespaceToEOL() {
        if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
          return null;
        if (this.char === CHAR_NUM)
          return this.goto(this.parseComment);
        if (this.char === Parser.END || this.char === CTRL_J)
          return this.return();
        throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
      }
      /* ASSIGNMENT: key = value */
      parseAssignStatement() {
        return this.callNow(this.parseAssign, this.recordAssignStatement);
      }
      recordAssignStatement(kv) {
        let target = this.ctx, finalKey = kv.key.pop();
        for (let kw of kv.key) {
          if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
            throw this.error(new TomlError("Can't redefine existing key"));
          target = target[kw] = target[kw] || Table();
        }
        if (hasKey(target, finalKey))
          throw this.error(new TomlError("Can't redefine existing key"));
        return isInteger(kv.value) || isFloat(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseWhitespaceToEOL);
      }
      /* ASSSIGNMENT expression, key = value possibly inside an inline table */
      parseAssign() {
        return this.callNow(this.parseKeyword, this.recordAssignKeyword);
      }
      recordAssignKeyword(key2) {
        return this.state.resultTable ? this.state.resultTable.push(key2) : this.state.resultTable = [key2], this.goto(this.parseAssignKeywordPreDot);
      }
      parseAssignKeywordPreDot() {
        if (this.char === CHAR_PERIOD)
          return this.next(this.parseAssignKeywordPostDot);
        if (this.char !== CHAR_SP && this.char !== CTRL_I)
          return this.goto(this.parseAssignEqual);
      }
      parseAssignKeywordPostDot() {
        if (this.char !== CHAR_SP && this.char !== CTRL_I)
          return this.callNow(this.parseKeyword, this.recordAssignKeyword);
      }
      parseAssignEqual() {
        if (this.char === CHAR_EQUALS)
          return this.next(this.parseAssignPreValue);
        throw this.error(new TomlError('Invalid character, expected "="'));
      }
      parseAssignPreValue() {
        return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseValue, this.recordAssignValue);
      }
      recordAssignValue(value) {
        return this.returnNow({ key: this.state.resultTable, value });
      }
      /* COMMENTS: #...eol */
      parseComment() {
        do
          if (this.char === Parser.END || this.char === CTRL_J)
            return this.return();
        while (this.nextChar());
      }
      /* TABLES AND LISTS, [foo] and [[foo]] */
      parseTableOrList() {
        if (this.char === CHAR_LSQB)
          this.next(this.parseList);
        else
          return this.goto(this.parseTable);
      }
      /* TABLE [foo.bar.baz] */
      parseTable() {
        return this.ctx = this.obj, this.goto(this.parseTableNext);
      }
      parseTableNext() {
        return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseTableMore);
      }
      parseTableMore(keyword) {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === CHAR_RSQB) {
          if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared]))
            throw this.error(new TomlError("Can't redefine existing key"));
          return this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table(), this.ctx[_declared] = !0, this.next(this.parseWhitespaceToEOL);
        } else if (this.char === CHAR_PERIOD) {
          if (!hasKey(this.ctx, keyword))
            this.ctx = this.ctx[keyword] = Table();
          else if (isTable(this.ctx[keyword]))
            this.ctx = this.ctx[keyword];
          else if (isList(this.ctx[keyword]))
            this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
          else
            throw this.error(new TomlError("Can't redefine existing key"));
          return this.next(this.parseTableNext);
        } else
          throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
      }
      /* LIST [[a.b.c]] */
      parseList() {
        return this.ctx = this.obj, this.goto(this.parseListNext);
      }
      parseListNext() {
        return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseListMore);
      }
      parseListMore(keyword) {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === CHAR_RSQB) {
          if (hasKey(this.ctx, keyword) || (this.ctx[keyword] = List()), isInlineList(this.ctx[keyword]))
            throw this.error(new TomlError("Can't extend an inline array"));
          if (isList(this.ctx[keyword])) {
            const next = Table();
            this.ctx[keyword].push(next), this.ctx = next;
          } else
            throw this.error(new TomlError("Can't redefine an existing key"));
          return this.next(this.parseListEnd);
        } else if (this.char === CHAR_PERIOD) {
          if (!hasKey(this.ctx, keyword))
            this.ctx = this.ctx[keyword] = Table();
          else {
            if (isInlineList(this.ctx[keyword]))
              throw this.error(new TomlError("Can't extend an inline array"));
            if (isInlineTable(this.ctx[keyword]))
              throw this.error(new TomlError("Can't extend an inline table"));
            if (isList(this.ctx[keyword]))
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            else if (isTable(this.ctx[keyword]))
              this.ctx = this.ctx[keyword];
            else
              throw this.error(new TomlError("Can't redefine an existing key"));
          }
          return this.next(this.parseListNext);
        } else
          throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
      }
      parseListEnd(keyword) {
        if (this.char === CHAR_RSQB)
          return this.next(this.parseWhitespaceToEOL);
        throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
      }
      /* VALUE string, number, boolean, inline list, inline object */
      parseValue() {
        if (this.char === Parser.END)
          throw this.error(new TomlError("Key without value"));
        if (this.char === CHAR_QUOT)
          return this.next(this.parseDoubleString);
        if (this.char === CHAR_APOS)
          return this.next(this.parseSingleString);
        if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
          return this.goto(this.parseNumberSign);
        if (this.char === CHAR_i)
          return this.next(this.parseInf);
        if (this.char === CHAR_n)
          return this.next(this.parseNan);
        if (isDigit(this.char))
          return this.goto(this.parseNumberOrDateTime);
        if (this.char === CHAR_t || this.char === CHAR_f)
          return this.goto(this.parseBoolean);
        if (this.char === CHAR_LSQB)
          return this.call(this.parseInlineList, this.recordValue);
        if (this.char === CHAR_LCUB)
          return this.call(this.parseInlineTable, this.recordValue);
        throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
      }
      recordValue(value) {
        return this.returnNow(value);
      }
      parseInf() {
        if (this.char === CHAR_n)
          return this.next(this.parseInf2);
        throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
      }
      parseInf2() {
        if (this.char === CHAR_f)
          return this.state.buf === "-" ? this.return(-1 / 0) : this.return(1 / 0);
        throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
      }
      parseNan() {
        if (this.char === CHAR_a)
          return this.next(this.parseNan2);
        throw this.error(new TomlError('Unexpected character, expected "nan"'));
      }
      parseNan2() {
        if (this.char === CHAR_n)
          return this.return(NaN);
        throw this.error(new TomlError('Unexpected character, expected "nan"'));
      }
      /* KEYS, barewords or basic, literal, or dotted */
      parseKeyword() {
        return this.char === CHAR_QUOT ? this.next(this.parseBasicString) : this.char === CHAR_APOS ? this.next(this.parseLiteralString) : this.goto(this.parseBareKey);
      }
      /* KEYS: barewords */
      parseBareKey() {
        do {
          if (this.char === Parser.END)
            throw this.error(new TomlError("Key ended without value"));
          if (isAlphaNumHyphen(this.char))
            this.consume();
          else {
            if (this.state.buf.length === 0)
              throw this.error(new TomlError("Empty bare keys are not allowed"));
            return this.returnNow();
          }
        } while (this.nextChar());
      }
      /* STRINGS, single quoted (literal) */
      parseSingleString() {
        return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiStringMaybe) : this.goto(this.parseLiteralString);
      }
      parseLiteralString() {
        do {
          if (this.char === CHAR_APOS)
            return this.return();
          if (this.atEndOfLine())
            throw this.error(new TomlError("Unterminated string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      parseLiteralMultiStringMaybe() {
        return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiString) : this.returnNow();
      }
      parseLiteralMultiString() {
        return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseLiteralMultiStringContent) : this.goto(this.parseLiteralMultiStringContent);
      }
      parseLiteralMultiStringContent() {
        do {
          if (this.char === CHAR_APOS)
            return this.next(this.parseLiteralMultiEnd);
          if (this.char === Parser.END)
            throw this.error(new TomlError("Unterminated multi-line string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      parseLiteralMultiEnd() {
        return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiEnd2) : (this.state.buf += "'", this.goto(this.parseLiteralMultiStringContent));
      }
      parseLiteralMultiEnd2() {
        return this.char === CHAR_APOS ? this.return() : (this.state.buf += "''", this.goto(this.parseLiteralMultiStringContent));
      }
      /* STRINGS double quoted */
      parseDoubleString() {
        return this.char === CHAR_QUOT ? this.next(this.parseMultiStringMaybe) : this.goto(this.parseBasicString);
      }
      parseBasicString() {
        do {
          if (this.char === CHAR_BSOL)
            return this.call(this.parseEscape, this.recordEscapeReplacement);
          if (this.char === CHAR_QUOT)
            return this.return();
          if (this.atEndOfLine())
            throw this.error(new TomlError("Unterminated string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      recordEscapeReplacement(replacement) {
        return this.state.buf += replacement, this.goto(this.parseBasicString);
      }
      parseMultiStringMaybe() {
        return this.char === CHAR_QUOT ? this.next(this.parseMultiString) : this.returnNow();
      }
      parseMultiString() {
        return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseMultiStringContent) : this.goto(this.parseMultiStringContent);
      }
      parseMultiStringContent() {
        do {
          if (this.char === CHAR_BSOL)
            return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
          if (this.char === CHAR_QUOT)
            return this.next(this.parseMultiEnd);
          if (this.char === Parser.END)
            throw this.error(new TomlError("Unterminated multi-line string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      errorControlCharInString() {
        let displayCode = "\\u00";
        return this.char < 16 && (displayCode += "0"), displayCode += this.char.toString(16), this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
      }
      recordMultiEscapeReplacement(replacement) {
        return this.state.buf += replacement, this.goto(this.parseMultiStringContent);
      }
      parseMultiEnd() {
        return this.char === CHAR_QUOT ? this.next(this.parseMultiEnd2) : (this.state.buf += '"', this.goto(this.parseMultiStringContent));
      }
      parseMultiEnd2() {
        return this.char === CHAR_QUOT ? this.return() : (this.state.buf += '""', this.goto(this.parseMultiStringContent));
      }
      parseMultiEscape() {
        return this.char === CTRL_M || this.char === CTRL_J ? this.next(this.parseMultiTrim) : this.char === CHAR_SP || this.char === CTRL_I ? this.next(this.parsePreMultiTrim) : this.goto(this.parseEscape);
      }
      parsePreMultiTrim() {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === CTRL_M || this.char === CTRL_J)
          return this.next(this.parseMultiTrim);
        throw this.error(new TomlError("Can't escape whitespace"));
      }
      parseMultiTrim() {
        return this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M ? null : this.returnNow();
      }
      parseEscape() {
        if (this.char in escapes)
          return this.return(escapes[this.char]);
        if (this.char === CHAR_u)
          return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
        if (this.char === CHAR_U)
          return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
        throw this.error(new TomlError("Unknown escape character: " + this.char));
      }
      parseUnicodeReturn(char) {
        try {
          const codePoint = parseInt(char, 16);
          if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST)
            throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
          return this.returnNow(String.fromCodePoint(codePoint));
        } catch (err) {
          throw this.error(TomlError.wrap(err));
        }
      }
      parseSmallUnicode() {
        if (isHexit(this.char)) {
          if (this.consume(), this.state.buf.length >= 4) return this.return();
        } else
          throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
      }
      parseLargeUnicode() {
        if (isHexit(this.char)) {
          if (this.consume(), this.state.buf.length >= 8) return this.return();
        } else
          throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
      }
      /* NUMBERS */
      parseNumberSign() {
        return this.consume(), this.next(this.parseMaybeSignedInfOrNan);
      }
      parseMaybeSignedInfOrNan() {
        return this.char === CHAR_i ? this.next(this.parseInf) : this.char === CHAR_n ? this.next(this.parseNan) : this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
      }
      parseNumberIntegerStart() {
        return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberIntegerExponentOrDecimal)) : this.goto(this.parseNumberInteger);
      }
      parseNumberIntegerExponentOrDecimal() {
        return this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Integer(this.state.buf));
      }
      parseNumberInteger() {
        if (isDigit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          if (this.char === CHAR_E || this.char === CHAR_e)
            return this.consume(), this.next(this.parseNumberExponentSign);
          if (this.char === CHAR_PERIOD)
            return this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      parseNoUnder() {
        if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e)
          throw this.error(new TomlError("Unexpected character, expected digit"));
        if (this.atEndOfWord())
          throw this.error(new TomlError("Incomplete number"));
        return this.returnNow();
      }
      parseNumberFloat() {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder, this.parseNumberFloat);
        if (isDigit(this.char))
          this.consume();
        else return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Float(this.state.buf));
      }
      parseNumberExponentSign() {
        if (isDigit(this.char))
          return this.goto(this.parseNumberExponent);
        if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
          this.consume(), this.call(this.parseNoUnder, this.parseNumberExponent);
        else
          throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
      }
      parseNumberExponent() {
        if (isDigit(this.char))
          this.consume();
        else return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder) : this.returnNow(Float(this.state.buf));
      }
      /* NUMBERS or DATETIMES  */
      parseNumberOrDateTime() {
        return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberBaseOrDateTime)) : this.goto(this.parseNumberOrDateTimeOnly);
      }
      parseNumberOrDateTimeOnly() {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder, this.parseNumberInteger);
        if (isDigit(this.char))
          this.consume(), this.state.buf.length > 4 && this.next(this.parseNumberInteger);
        else return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_HYPHEN ? this.goto(this.parseDateTime) : this.char === CHAR_COLON ? this.goto(this.parseOnlyTimeHour) : this.returnNow(Integer(this.state.buf));
      }
      parseDateTimeOnly() {
        if (this.state.buf.length < 4) {
          if (isDigit(this.char))
            return this.consume();
          if (this.char === CHAR_COLON)
            return this.goto(this.parseOnlyTimeHour);
          throw this.error(new TomlError("Expected digit while parsing year part of a date"));
        } else {
          if (this.char === CHAR_HYPHEN)
            return this.goto(this.parseDateTime);
          throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
        }
      }
      parseNumberBaseOrDateTime() {
        return this.char === CHAR_b ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerBin)) : this.char === CHAR_o ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerOct)) : this.char === CHAR_x ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerHex)) : this.char === CHAR_PERIOD ? this.goto(this.parseNumberInteger) : isDigit(this.char) ? this.goto(this.parseDateTimeOnly) : this.returnNow(Integer(this.state.buf));
      }
      parseIntegerHex() {
        if (isHexit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      parseIntegerOct() {
        if (isOctit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      parseIntegerBin() {
        if (isBit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      /* DATETIME */
      parseDateTime() {
        if (this.state.buf.length < 4)
          throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
        return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseDateMonth);
      }
      parseDateMonth() {
        if (this.char === CHAR_HYPHEN) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
          return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseDateDay);
        } else if (isDigit(this.char))
          this.consume();
        else
          throw this.error(new TomlError("Incomplete datetime"));
      }
      parseDateDay() {
        if (this.char === CHAR_T || this.char === CHAR_SP) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
          return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseStartTimeHour);
        } else {
          if (this.atEndOfWord())
            return this.return(createDate(this.state.result + "-" + this.state.buf));
          if (isDigit(this.char))
            this.consume();
          else
            throw this.error(new TomlError("Incomplete datetime"));
        }
      }
      parseStartTimeHour() {
        return this.atEndOfWord() ? this.returnNow(createDate(this.state.result)) : this.goto(this.parseTimeHour);
      }
      parseTimeHour() {
        if (this.char === CHAR_COLON) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
          return this.state.result += "T" + this.state.buf, this.state.buf = "", this.next(this.parseTimeMin);
        } else if (isDigit(this.char))
          this.consume();
        else
          throw this.error(new TomlError("Incomplete datetime"));
      }
      parseTimeMin() {
        if (this.state.buf.length < 2 && isDigit(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 2 && this.char === CHAR_COLON)
            return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeSec);
          throw this.error(new TomlError("Incomplete datetime"));
        }
      }
      parseTimeSec() {
        if (isDigit(this.char)) {
          if (this.consume(), this.state.buf.length === 2)
            return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeZoneOrFraction);
        } else
          throw this.error(new TomlError("Incomplete datetime"));
      }
      parseOnlyTimeHour() {
        if (this.char === CHAR_COLON) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
          return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeMin);
        } else
          throw this.error(new TomlError("Incomplete time"));
      }
      parseOnlyTimeMin() {
        if (this.state.buf.length < 2 && isDigit(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 2 && this.char === CHAR_COLON)
            return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeSec);
          throw this.error(new TomlError("Incomplete time"));
        }
      }
      parseOnlyTimeSec() {
        if (isDigit(this.char)) {
          if (this.consume(), this.state.buf.length === 2)
            return this.next(this.parseOnlyTimeFractionMaybe);
        } else
          throw this.error(new TomlError("Incomplete time"));
      }
      parseOnlyTimeFractionMaybe() {
        if (this.state.result += ":" + this.state.buf, this.char === CHAR_PERIOD)
          this.state.buf = "", this.next(this.parseOnlyTimeFraction);
        else
          return this.return(createTime(this.state.result));
      }
      parseOnlyTimeFraction() {
        if (isDigit(this.char))
          this.consume();
        else if (this.atEndOfWord()) {
          if (this.state.buf.length === 0) throw this.error(new TomlError("Expected digit in milliseconds"));
          return this.returnNow(createTime(this.state.result + "." + this.state.buf));
        } else
          throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
      }
      parseTimeZoneOrFraction() {
        if (this.char === CHAR_PERIOD)
          this.consume(), this.next(this.parseDateTimeFraction);
        else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
          this.consume(), this.next(this.parseTimeZoneHour);
        else {
          if (this.char === CHAR_Z)
            return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
          if (this.atEndOfWord())
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
      }
      parseDateTimeFraction() {
        if (isDigit(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 1)
            throw this.error(new TomlError("Expected digit in milliseconds"));
          if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
            this.consume(), this.next(this.parseTimeZoneHour);
          else {
            if (this.char === CHAR_Z)
              return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
            if (this.atEndOfWord())
              return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
      }
      parseTimeZoneHour() {
        if (isDigit(this.char)) {
          if (this.consume(), /\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
        } else
          throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
      }
      parseTimeZoneSep() {
        if (this.char === CHAR_COLON)
          this.consume(), this.next(this.parseTimeZoneMin);
        else
          throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
      }
      parseTimeZoneMin() {
        if (isDigit(this.char)) {
          if (this.consume(), /\d\d$/.test(this.state.buf)) return this.return(createDateTime(this.state.result + this.state.buf));
        } else
          throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
      }
      /* BOOLEAN */
      parseBoolean() {
        if (this.char === CHAR_t)
          return this.consume(), this.next(this.parseTrue_r);
        if (this.char === CHAR_f)
          return this.consume(), this.next(this.parseFalse_a);
      }
      parseTrue_r() {
        if (this.char === CHAR_r)
          return this.consume(), this.next(this.parseTrue_u);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseTrue_u() {
        if (this.char === CHAR_u)
          return this.consume(), this.next(this.parseTrue_e);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseTrue_e() {
        if (this.char === CHAR_e)
          return this.return(!0);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_a() {
        if (this.char === CHAR_a)
          return this.consume(), this.next(this.parseFalse_l);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_l() {
        if (this.char === CHAR_l)
          return this.consume(), this.next(this.parseFalse_s);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_s() {
        if (this.char === CHAR_s)
          return this.consume(), this.next(this.parseFalse_e);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_e() {
        if (this.char === CHAR_e)
          return this.return(!1);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      /* INLINE LISTS */
      parseInlineList() {
        if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
          return null;
        if (this.char === Parser.END)
          throw this.error(new TomlError("Unterminated inline array"));
        return this.char === CHAR_NUM ? this.call(this.parseComment) : this.char === CHAR_RSQB ? this.return(this.state.resultArr || InlineList()) : this.callNow(this.parseValue, this.recordInlineListValue);
      }
      recordInlineListValue(value) {
        if (this.state.resultArr) {
          const listType = this.state.resultArr[_contentType], valueType = tomlType(value);
          if (listType !== valueType)
            throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
        } else
          this.state.resultArr = InlineList(tomlType(value));
        return isFloat(value) || isInteger(value) ? this.state.resultArr.push(value.valueOf()) : this.state.resultArr.push(value), this.goto(this.parseInlineListNext);
      }
      parseInlineListNext() {
        if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
          return null;
        if (this.char === CHAR_NUM)
          return this.call(this.parseComment);
        if (this.char === CHAR_COMMA)
          return this.next(this.parseInlineList);
        if (this.char === CHAR_RSQB)
          return this.goto(this.parseInlineList);
        throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
      }
      /* INLINE TABLE */
      parseInlineTable() {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
          throw this.error(new TomlError("Unterminated inline array"));
        return this.char === CHAR_RCUB ? this.return(this.state.resultTable || InlineTable()) : (this.state.resultTable || (this.state.resultTable = InlineTable()), this.callNow(this.parseAssign, this.recordInlineTableValue));
      }
      recordInlineTableValue(kv) {
        let target = this.state.resultTable, finalKey = kv.key.pop();
        for (let kw of kv.key) {
          if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
            throw this.error(new TomlError("Can't redefine existing key"));
          target = target[kw] = target[kw] || Table();
        }
        if (hasKey(target, finalKey))
          throw this.error(new TomlError("Can't redefine existing key"));
        return isInteger(kv.value) || isFloat(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseInlineTableNext);
      }
      parseInlineTableNext() {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
          throw this.error(new TomlError("Unterminated inline array"));
        if (this.char === CHAR_COMMA)
          return this.next(this.parseInlineTable);
        if (this.char === CHAR_RCUB)
          return this.goto(this.parseInlineTable);
        throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
      }
    }
    return TOMLParser;
  }
  return tomlParser.exports;
}
var parsePrettyError, hasRequiredParsePrettyError;
function requireParsePrettyError() {
  if (hasRequiredParsePrettyError) return parsePrettyError;
  hasRequiredParsePrettyError = 1, parsePrettyError = prettyError;
  function prettyError(err, buf) {
    if (err.pos == null || err.line == null) return err;
    let msg = err.message;
    if (msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`, buf && buf.split) {
      const lines2 = buf.split(/\n/), lineNumWidth = String(Math.min(lines2.length, err.line + 3)).length;
      let linePadding = " ";
      for (; linePadding.length < lineNumWidth; ) linePadding += " ";
      for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines2.length, err.line + 2); ++ii) {
        let lineNum = String(ii + 1);
        if (lineNum.length < lineNumWidth && (lineNum = " " + lineNum), err.line === ii) {
          msg += lineNum + "> " + lines2[ii] + `
`, msg += linePadding + "  ";
          for (let hh = 0; hh < err.col; ++hh)
            msg += " ";
          msg += `^
`;
        } else
          msg += lineNum + ": " + lines2[ii] + `
`;
      }
    }
    return err.message = msg + `
`, err;
  }
  return parsePrettyError;
}
var parseString_1, hasRequiredParseString;
function requireParseString() {
  if (hasRequiredParseString) return parseString_1;
  hasRequiredParseString = 1, parseString_1 = parseString;
  const TOMLParser = requireTomlParser(), prettyError = requireParsePrettyError();
  function parseString(str2) {
    loadEnv.commonjsGlobal.Buffer && loadEnv.commonjsGlobal.Buffer.isBuffer(str2) && (str2 = str2.toString("utf8"));
    const parser2 = new TOMLParser();
    try {
      return parser2.parse(str2), parser2.finish();
    } catch (err) {
      throw prettyError(err, str2);
    }
  }
  return parseString_1;
}
var parseAsync_1, hasRequiredParseAsync;
function requireParseAsync() {
  if (hasRequiredParseAsync) return parseAsync_1;
  hasRequiredParseAsync = 1, parseAsync_1 = parseAsync;
  const TOMLParser = requireTomlParser(), prettyError = requireParsePrettyError();
  function parseAsync(str2, opts) {
    opts || (opts = {});
    const index = 0, blocksize = opts.blocksize || 40960, parser2 = new TOMLParser();
    return new Promise((resolve, reject) => {
      setImmediate(parseAsyncNext, index, blocksize, resolve, reject);
    });
    function parseAsyncNext(index2, blocksize2, resolve, reject) {
      if (index2 >= str2.length)
        try {
          return resolve(parser2.finish());
        } catch (err) {
          return reject(prettyError(err, str2));
        }
      try {
        parser2.parse(str2.slice(index2, index2 + blocksize2)), setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve, reject);
      } catch (err) {
        reject(prettyError(err, str2));
      }
    }
  }
  return parseAsync_1;
}
var parseStream_1, hasRequiredParseStream;
function requireParseStream() {
  if (hasRequiredParseStream) return parseStream_1;
  hasRequiredParseStream = 1, parseStream_1 = parseStream;
  const stream2 = require$$0__default$4.default, TOMLParser = requireTomlParser();
  function parseStream(stm) {
    return stm ? parseReadable(stm) : parseTransform();
  }
  function parseReadable(stm) {
    const parser2 = new TOMLParser();
    return stm.setEncoding("utf8"), new Promise((resolve, reject) => {
      let readable, ended = !1, errored = !1;
      function finish() {
        if (ended = !0, !readable)
          try {
            resolve(parser2.finish());
          } catch (err) {
            reject(err);
          }
      }
      function error2(err) {
        errored = !0, reject(err);
      }
      stm.once("end", finish), stm.once("error", error2), readNext();
      function readNext() {
        readable = !0;
        let data;
        for (; (data = stm.read()) !== null; )
          try {
            parser2.parse(data);
          } catch (err) {
            return error2(err);
          }
        if (readable = !1, ended) return finish();
        errored || stm.once("readable", readNext);
      }
    });
  }
  function parseTransform() {
    const parser2 = new TOMLParser();
    return new stream2.Transform({
      objectMode: !0,
      transform(chunk, encoding, cb) {
        try {
          parser2.parse(chunk.toString(encoding));
        } catch (err) {
          this.emit("error", err);
        }
        cb();
      },
      flush(cb) {
        try {
          this.push(parser2.finish());
        } catch (err) {
          this.emit("error", err);
        }
        cb();
      }
    });
  }
  return parseStream_1;
}
var hasRequiredParse$4;
function requireParse$4() {
  return hasRequiredParse$4 || (hasRequiredParse$4 = 1, parse$2.exports = requireParseString(), parse$2.exports.async = requireParseAsync(), parse$2.exports.stream = requireParseStream(), parse$2.exports.prettyError = requireParsePrettyError()), parse$2.exports;
}
var stringify$2 = { exports: {} }, hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify$2.exports;
  hasRequiredStringify$1 = 1, stringify$2.exports = stringify3, stringify$2.exports.value = stringifyInline;
  function stringify3(obj) {
    if (obj === null) throw typeError("null");
    if (obj === void 0) throw typeError("undefined");
    if (typeof obj != "object") throw typeError(typeof obj);
    if (typeof obj.toJSON == "function" && (obj = obj.toJSON()), obj == null) return null;
    const type2 = tomlType2(obj);
    if (type2 !== "table") throw typeError(type2);
    return stringifyObject("", "", obj);
  }
  function typeError(type2) {
    return new Error("Can only stringify objects, not " + type2);
  }
  function arrayOneTypeError() {
    return new Error("Array values can't have mixed types");
  }
  function getInlineKeys(obj) {
    return Object.keys(obj).filter((key2) => isInline(obj[key2]));
  }
  function getComplexKeys(obj) {
    return Object.keys(obj).filter((key2) => !isInline(obj[key2]));
  }
  function toJSON(obj) {
    let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? { ["__proto__"]: void 0 } : {};
    for (let prop of Object.keys(obj))
      obj[prop] && typeof obj[prop].toJSON == "function" && !("toISOString" in obj[prop]) ? nobj[prop] = obj[prop].toJSON() : nobj[prop] = obj[prop];
    return nobj;
  }
  function stringifyObject(prefix, indent, obj) {
    obj = toJSON(obj);
    var inlineKeys, complexKeys;
    inlineKeys = getInlineKeys(obj), complexKeys = getComplexKeys(obj);
    var result = [], inlineIndent = indent || "";
    inlineKeys.forEach((key2) => {
      var type2 = tomlType2(obj[key2]);
      type2 !== "undefined" && type2 !== "null" && result.push(inlineIndent + stringifyKey(key2) + " = " + stringifyAnyInline(obj[key2], !0));
    }), result.length > 0 && result.push("");
    var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
    return complexKeys.forEach((key2) => {
      result.push(stringifyComplex(prefix, complexIndent, key2, obj[key2]));
    }), result.join(`
`);
  }
  function isInline(value) {
    switch (tomlType2(value)) {
      case "undefined":
      case "null":
      case "integer":
      case "nan":
      case "float":
      case "boolean":
      case "string":
      case "datetime":
        return !0;
      case "array":
        return value.length === 0 || tomlType2(value[0]) !== "table";
      case "table":
        return Object.keys(value).length === 0;
      /* istanbul ignore next */
      default:
        return !1;
    }
  }
  function tomlType2(value) {
    return value === void 0 ? "undefined" : value === null ? "null" : typeof value == "bigint" || Number.isInteger(value) && !Object.is(value, -0) ? "integer" : typeof value == "number" ? "float" : typeof value == "boolean" ? "boolean" : typeof value == "string" ? "string" : "toISOString" in value ? isNaN(value) ? "undefined" : "datetime" : Array.isArray(value) ? "array" : "table";
  }
  function stringifyKey(key2) {
    var keyStr = String(key2);
    return /^[-A-Za-z0-9_]+$/.test(keyStr) ? keyStr : stringifyBasicString(keyStr);
  }
  function stringifyBasicString(str2) {
    return '"' + escapeString(str2).replace(/"/g, '\\"') + '"';
  }
  function stringifyLiteralString(str2) {
    return "'" + str2 + "'";
  }
  function numpad(num, str2) {
    for (; str2.length < num; ) str2 = "0" + str2;
    return str2;
  }
  function escapeString(str2) {
    return str2.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/([\u0000-\u001f\u007f])/, (c2) => "\\u" + numpad(4, c2.codePointAt(0).toString(16)));
  }
  function stringifyMultilineString(str2) {
    let escaped = str2.split(/\n/).map((str3) => escapeString(str3).replace(/"(?="")/g, '\\"')).join(`
`);
    return escaped.slice(-1) === '"' && (escaped += `\\
`), `"""
` + escaped + '"""';
  }
  function stringifyAnyInline(value, multilineOk) {
    let type2 = tomlType2(value);
    return type2 === "string" && (multilineOk && /\n/.test(value) ? type2 = "string-multiline" : !/[\b\t\n\f\r']/.test(value) && /"/.test(value) && (type2 = "string-literal")), stringifyInline(value, type2);
  }
  function stringifyInline(value, type2) {
    switch (type2 || (type2 = tomlType2(value)), type2) {
      case "string-multiline":
        return stringifyMultilineString(value);
      case "string":
        return stringifyBasicString(value);
      case "string-literal":
        return stringifyLiteralString(value);
      case "integer":
        return stringifyInteger(value);
      case "float":
        return stringifyFloat(value);
      case "boolean":
        return stringifyBoolean(value);
      case "datetime":
        return stringifyDatetime(value);
      case "array":
        return stringifyInlineArray(value.filter((_) => tomlType2(_) !== "null" && tomlType2(_) !== "undefined" && tomlType2(_) !== "nan"));
      case "table":
        return stringifyInlineTable(value);
      /* istanbul ignore next */
      default:
        throw typeError(type2);
    }
  }
  function stringifyInteger(value) {
    return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
  }
  function stringifyFloat(value) {
    if (value === 1 / 0)
      return "inf";
    if (value === -1 / 0)
      return "-inf";
    if (Object.is(value, NaN))
      return "nan";
    if (Object.is(value, -0))
      return "-0.0";
    var chunks = String(value).split("."), int2 = chunks[0], dec = chunks[1] || 0;
    return stringifyInteger(int2) + "." + dec;
  }
  function stringifyBoolean(value) {
    return String(value);
  }
  function stringifyDatetime(value) {
    return value.toISOString();
  }
  function isNumber2(type2) {
    return type2 === "float" || type2 === "integer";
  }
  function arrayType(values) {
    var contentType = tomlType2(values[0]);
    return values.every((_) => tomlType2(_) === contentType) ? contentType : values.every((_) => isNumber2(tomlType2(_))) ? "float" : "mixed";
  }
  function validateArray(values) {
    const type2 = arrayType(values);
    if (type2 === "mixed")
      throw arrayOneTypeError();
    return type2;
  }
  function stringifyInlineArray(values) {
    values = toJSON(values);
    const type2 = validateArray(values);
    var result = "[", stringified = values.map((_) => stringifyInline(_, type2));
    return stringified.join(", ").length > 60 || /\n/.test(stringified) ? result += `
  ` + stringified.join(`,
  `) + `
` : result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : ""), result + "]";
  }
  function stringifyInlineTable(value) {
    value = toJSON(value);
    var result = [];
    return Object.keys(value).forEach((key2) => {
      result.push(stringifyKey(key2) + " = " + stringifyAnyInline(value[key2], !1));
    }), "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
  }
  function stringifyComplex(prefix, indent, key2, value) {
    var valueType = tomlType2(value);
    if (valueType === "array")
      return stringifyArrayOfTables(prefix, indent, key2, value);
    if (valueType === "table")
      return stringifyComplexTable(prefix, indent, key2, value);
    throw typeError(valueType);
  }
  function stringifyArrayOfTables(prefix, indent, key2, values) {
    values = toJSON(values), validateArray(values);
    var firstValueType = tomlType2(values[0]);
    if (firstValueType !== "table") throw typeError(firstValueType);
    var fullKey = prefix + stringifyKey(key2), result = "";
    return values.forEach((table) => {
      result.length > 0 && (result += `
`), result += indent + "[[" + fullKey + `]]
`, result += stringifyObject(fullKey + ".", indent, table);
    }), result;
  }
  function stringifyComplexTable(prefix, indent, key2, value) {
    var fullKey = prefix + stringifyKey(key2), result = "";
    return getInlineKeys(value).length > 0 && (result += indent + "[" + fullKey + `]
`), result + stringifyObject(fullKey + ".", indent, value);
  }
  return stringify$2.exports;
}
var hasRequiredToml;
function requireToml() {
  return hasRequiredToml || (hasRequiredToml = 1, toml.parse = requireParse$4(), toml.stringify = requireStringify$1()), toml;
}
var dist$2 = {}, hasRequiredDist$1;
function requireDist$1() {
  return hasRequiredDist$1 || (hasRequiredDist$1 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isSpawnError = exports2.normalizeError = exports2.errorToString = exports2.isErrorLike = exports2.isErrnoException = exports2.isError = exports2.isObject = void 0;
    const isObject2 = (obj) => typeof obj == "object" && obj !== null;
    exports2.isObject = isObject2;
    const isError = (error2) => {
      if (!(0, exports2.isObject)(error2))
        return !1;
      if (error2 instanceof Error)
        return !0;
      for (; error2; ) {
        if (Object.prototype.toString.call(error2) === "[object Error]")
          return !0;
        error2 = Object.getPrototypeOf(error2);
      }
      return !1;
    };
    exports2.isError = isError;
    const isErrnoException = (error2) => (0, exports2.isError)(error2) && "code" in error2;
    exports2.isErrnoException = isErrnoException;
    const isErrorLike = (error2) => (0, exports2.isObject)(error2) && "message" in error2;
    exports2.isErrorLike = isErrorLike;
    const errorToString = (error2, fallback) => (0, exports2.isError)(error2) || (0, exports2.isErrorLike)(error2) ? error2.message : typeof error2 == "string" ? error2 : fallback ?? "An unknown error has ocurred.";
    exports2.errorToString = errorToString;
    const normalizeError = (error2) => {
      if ((0, exports2.isError)(error2))
        return error2;
      const errorMessage = (0, exports2.errorToString)(error2);
      return (0, exports2.isErrorLike)(error2) ? Object.assign(new Error(errorMessage), error2) : new Error(errorMessage);
    };
    exports2.normalizeError = normalizeError;
    function isSpawnError(v) {
      return (0, exports2.isErrnoException)(v) && "spawnargs" in v;
    }
    exports2.isSpawnError = isSpawnError;
  }(dist$2)), dist$2;
}
var hasRequiredReadConfigFile;
function requireReadConfigFile() {
  if (hasRequiredReadConfigFile) return readConfigFile;
  hasRequiredReadConfigFile = 1;
  var __importDefault2 = readConfigFile && readConfigFile.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(readConfigFile, "__esModule", { value: !0 }), readConfigFile.readConfigFile = void 0;
  const js_yaml_1 = __importDefault2(requireJsYaml$3()), toml_1 = __importDefault2(requireToml()), fs_1 = require$$0__default$1.default, error_utils_1 = requireDist$1(), { readFile } = fs_1.promises;
  async function readFileOrNull(file) {
    try {
      return await readFile(file);
    } catch (error2) {
      if (!(0, error_utils_1.isErrnoException)(error2) || error2.code !== "ENOENT")
        throw error2;
    }
    return null;
  }
  async function readConfigFile$1(files) {
    files = Array.isArray(files) ? files : [files];
    for (const name of files) {
      const data = await readFileOrNull(name);
      if (data) {
        const str2 = data.toString("utf8");
        if (name.endsWith(".json"))
          return JSON.parse(str2);
        if (name.endsWith(".toml"))
          return toml_1.default.parse(str2);
        if (name.endsWith(".yaml") || name.endsWith(".yml"))
          return js_yaml_1.default.safeLoad(str2, { filename: name });
      }
    }
    return null;
  }
  return readConfigFile.readConfigFile = readConfigFile$1, readConfigFile;
}
var types$3 = {}, hasRequiredTypes$2;
function requireTypes$2() {
  return hasRequiredTypes$2 || (hasRequiredTypes$2 = 1, Object.defineProperty(types$3, "__esModule", { value: !0 })), types$3;
}
var hasRequiredFrameworks;
function requireFrameworks() {
  return hasRequiredFrameworks || (hasRequiredFrameworks = 1, function(exports2) {
    var __createBinding2 = frameworks && frameworks.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = frameworks && frameworks.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.frameworks = void 0;
    const path_1 = require$$0__default.default, fs_1 = require$$0__default$1.default, read_config_file_1 = requireReadConfigFile();
    __exportStar2(requireTypes$2(), exports2);
    const { readdir: readdir2, readFile, unlink: unlink2 } = fs_1.promises;
    exports2.frameworks = [
      {
        name: "Blitz.js (Legacy)",
        slug: "blitzjs",
        demo: "https://blitz-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/blitz.svg",
        tagline: "Blitz.js: The Fullstack React Framework",
        description: "A brand new Blitz.js app - the result of running `npx blitz@0.45.4 new`.",
        website: "https://blitzjs.com",
        envPrefix: "NEXT_PUBLIC_",
        useRuntime: { src: "package.json", use: "@vercel/next" },
        detectors: {
          some: [
            // Intentionally does not detect a package name
            // https://github.com/vercel/vercel/pull/8432
            {
              path: "blitz.config.js"
            },
            {
              path: "blitz.config.ts"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `blitz build`",
            value: "blitz build"
          },
          devCommand: {
            value: "blitz start"
          },
          outputDirectory: {
            placeholder: "Next.js default"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Next.js",
        slug: "nextjs",
        demo: "https://nextjs-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/next.svg",
        darkModeLogo: "https://api-frameworks.vercel.sh/framework-logos/next-dark.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1673027027/front/import/nextjs.png",
        tagline: "Next.js makes you productive with React instantly \u2014 whether you want to build static or dynamic sites.",
        description: "A Next.js app and a Serverless Function API.",
        website: "https://nextjs.org",
        sort: 1,
        envPrefix: "NEXT_PUBLIC_",
        useRuntime: { src: "package.json", use: "@vercel/next" },
        detectors: {
          every: [
            {
              matchPackage: "next"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `next build`",
            value: "next build"
          },
          devCommand: {
            value: "next dev --port $PORT",
            placeholder: "next"
          },
          outputDirectory: {
            placeholder: "Next.js default"
          }
        },
        recommendedIntegrations: [
          {
            id: "oac_5lUsiANun1DEzgLg0NZx5Es3",
            dependencies: ["next-plugin-sentry", "next-sentry-source-maps"]
          }
        ],
        getOutputDirName: async () => "public",
        cachePattern: ".next/cache/**"
      },
      {
        name: "Gatsby.js",
        slug: "gatsby",
        demo: "https://gatsby.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/gatsby.svg",
        tagline: "Gatsby helps developers build blazing fast websites and apps with React.",
        description: "A Gatsby starter app with an API Route.",
        website: "https://gatsbyjs.org",
        sort: 5,
        envPrefix: "GATSBY_",
        detectors: {
          every: [
            {
              matchPackage: "gatsby"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `gatsby build`",
            value: "gatsby build"
          },
          devCommand: {
            value: "gatsby develop --port $PORT",
            placeholder: "gatsby develop"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "gatsby",
        getOutputDirName: async () => "public",
        defaultRoutes: async (dirPrefix) => {
          try {
            const nowRoutesPath = (0, path_1.join)(dirPrefix, "public", "__now_routes_g4t5bY.json"), content = await readFile(nowRoutesPath, "utf8"), nowRoutes = JSON.parse(content);
            try {
              await unlink2(nowRoutesPath);
            } catch {
            }
            return nowRoutes;
          } catch {
            return [
              {
                src: "^/static/(.*)$",
                headers: { "cache-control": "public,max-age=31536000,immutable" },
                continue: !0
              },
              {
                src: "^/.*\\.(js|css)$",
                headers: { "cache-control": "public,max-age=31536000,immutable" },
                continue: !0
              },
              {
                src: "^/(sw\\.js|app-data\\.json|.*\\.html|page-data/.*)$",
                headers: { "cache-control": "public,max-age=0,must-revalidate" },
                continue: !0
              },
              {
                handle: "filesystem"
              },
              {
                src: ".*",
                status: 404,
                dest: "404.html"
              }
            ];
          }
        },
        cachePattern: "{.cache,public}/**"
      },
      {
        name: "Remix",
        slug: "remix",
        demo: "https://remix-run-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/remix-no-shadow.svg",
        tagline: "Build Better Websites",
        description: "A new Remix app \u2014 the result of running `npx create-remix`.",
        website: "https://remix.run",
        sort: 6,
        useRuntime: { src: "package.json", use: "@vercel/remix-builder" },
        ignoreRuntimes: ["@vercel/node"],
        detectors: {
          some: [
            {
              path: "remix.config.js"
            },
            {
              path: "remix.config.mjs"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "remix build",
            placeholder: "`npm run build` or `remix build`"
          },
          devCommand: {
            value: "remix dev",
            placeholder: "remix dev"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "remix",
        getOutputDirName: async () => "public"
      },
      {
        name: "Astro",
        slug: "astro",
        demo: "https://astro-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/astro.svg",
        darkModeLogo: "https://api-frameworks.vercel.sh/framework-logos/astro-dark.svg",
        tagline: "Astro is a new kind of static site builder for the modern web. Powerful developer experience meets lightweight output.",
        description: "An Astro site, using the basics starter kit.",
        website: "https://astro.build",
        envPrefix: "PUBLIC_",
        detectors: {
          every: [
            {
              matchPackage: "astro"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install` or `npm install`"
          },
          buildCommand: {
            value: "astro build",
            placeholder: "`npm run build` or `astro build`"
          },
          devCommand: {
            value: "astro dev --port $PORT",
            placeholder: "astro dev"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "astro",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            src: "^/assets/(.*)$",
            headers: { "cache-control": "public, max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/_astro/(.*)$",
            headers: { "cache-control": "public, max-age=31536000, immutable" },
            continue: !0
          }
        ]
      },
      {
        name: "Hexo",
        slug: "hexo",
        demo: "https://hexo-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/hexo.svg",
        tagline: "Hexo is a fast, simple & powerful blog framework powered by Node.js.",
        description: "A Hexo site, created with the Hexo CLI.",
        website: "https://hexo.io",
        detectors: {
          every: [
            {
              matchPackage: "hexo"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `hexo generate`",
            value: "hexo generate"
          },
          devCommand: {
            value: "hexo server --port $PORT",
            placeholder: "hexo server"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "hexo",
        getOutputDirName: async () => "public"
      },
      {
        name: "Eleventy",
        slug: "eleventy",
        demo: "https://eleventy-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/eleventy.svg",
        tagline: "11ty is a simpler static site generator written in JavaScript, created to be an alternative to Jekyll.",
        description: "An Eleventy site, created with npm init.",
        website: "https://www.11ty.dev",
        detectors: {
          every: [
            {
              matchPackage: "@11ty/eleventy"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `npx @11ty/eleventy`",
            value: "npx @11ty/eleventy"
          },
          devCommand: {
            value: "npx @11ty/eleventy --serve --watch --port $PORT",
            placeholder: "npx @11ty/eleventy --serve"
          },
          outputDirectory: {
            value: "_site"
          }
        },
        dependency: "@11ty/eleventy",
        getOutputDirName: async () => "_site",
        cachePattern: ".cache/**"
      },
      {
        name: "Docusaurus (v2)",
        slug: "docusaurus-2",
        demo: "https://docusaurus-2-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/docusaurus.svg",
        tagline: "Docusaurus makes it easy to maintain Open Source documentation websites.",
        description: "A static Docusaurus site that makes it easy to maintain OSS documentation.",
        website: "https://v2.docusaurus.io",
        detectors: {
          some: [
            {
              matchPackage: "@docusaurus/core"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `docusaurus build`",
            value: "docusaurus build"
          },
          devCommand: {
            value: "docusaurus start --port $PORT",
            placeholder: "docusaurus start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "@docusaurus/core",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "build";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), content = await readdir2(location, { withFileTypes: !0 });
            if (content.length === 1 && content[0].isDirectory())
              return (0, path_1.join)(base2, content[0].name);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        },
        defaultRoutes: [
          {
            src: "^/[^./]+\\.[0-9a-f]{8}\\.(css|js)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/assets/images/[^/]+-[0-9a-f]{32}\\.(ico|svg|jpg|jpeg|png|gif|webp)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/assets/medias/[^/]+-[0-9a-f]{32}\\.(ogv|wav|mp3|m4a|aac|oga|flac)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/assets/files/[^/]+-[0-9a-f]{32}\\.(pdf|doc|docx|xls|xlsx|zip|rar)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/ideal-img/[^/]+\\.[0-9a-f]{7}\\.\\d+\\.(png|jpe?g|gif)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: ".*",
            status: 404,
            dest: "404.html"
          }
        ]
      },
      {
        name: "Docusaurus (v1)",
        slug: "docusaurus",
        demo: "https://docusaurus-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/docusaurus.svg",
        tagline: "Docusaurus makes it easy to maintain Open Source documentation websites.",
        description: "A static Docusaurus site that makes it easy to maintain OSS documentation.",
        website: "https://docusaurus.io/",
        detectors: {
          some: [
            {
              matchPackage: "docusaurus"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `docusaurus-build`",
            value: "docusaurus-build"
          },
          devCommand: {
            value: "docusaurus-start --port $PORT",
            placeholder: "docusaurus-start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "docusaurus",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "build";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), content = await readdir2(location, { withFileTypes: !0 });
            if (content.length === 1 && content[0].isDirectory())
              return (0, path_1.join)(base2, content[0].name);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        }
      },
      {
        name: "Preact",
        slug: "preact",
        demo: "https://preact-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/preact.svg",
        tagline: "Preact is a fast 3kB alternative to React with the same modern API.",
        description: "A Preact app, created with the Preact CLI.",
        website: "https://preactjs.com",
        detectors: {
          every: [
            // Intentionally does not detect "preact" package because that can be
            // used to power other frameworks.
            {
              matchPackage: "preact-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `preact build`",
            value: "preact build"
          },
          devCommand: {
            value: "preact watch --port $PORT",
            placeholder: "preact watch"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "preact-cli",
        getOutputDirName: async () => "build",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "SolidStart",
        slug: "solidstart",
        demo: "https://solid-start-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/solid.svg",
        tagline: "Simple and performant reactivity for building user interfaces.",
        description: "A Solid app, created with SolidStart.",
        website: "https://solidjs.com",
        envPrefix: "VITE_",
        detectors: {
          every: [
            {
              matchPackage: "solid-js"
            },
            {
              matchPackage: "solid-start"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `solid-start build`",
            value: "solid-start build"
          },
          devCommand: {
            value: "solid-start dev"
          },
          outputDirectory: {
            value: ".output"
          }
        },
        getOutputDirName: async () => ".output"
      },
      {
        name: "Dojo",
        slug: "dojo",
        demo: "https://dojo-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/dojo.png",
        tagline: "Dojo is a modern progressive, TypeScript first framework.",
        description: "A Dojo app, created with the Dojo CLI's cli-create-app command.",
        website: "https://dojo.io",
        detectors: {
          some: [
            {
              matchPackage: "@dojo/framework"
            },
            {
              path: ".dojorc"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `dojo build`",
            value: "dojo build"
          },
          devCommand: {
            value: "dojo build -m dev -w -s -p $PORT",
            placeholder: "dojo build -m dev -w -s"
          },
          outputDirectory: {
            value: "output/dist"
          }
        },
        dependency: "@dojo/cli",
        getOutputDirName: async () => (0, path_1.join)("output", "dist"),
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ],
        defaulHeaders: [
          {
            source: "/service-worker.js",
            regex: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          }
        ]
      },
      {
        name: "Ember.js",
        slug: "ember",
        demo: "https://ember-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/ember.svg",
        tagline: "Ember.js helps webapp developers be more productive out of the box.",
        description: "An Ember app, created with the Ember CLI.",
        website: "https://emberjs.com/",
        detectors: {
          some: [
            {
              matchPackage: "ember-source"
            },
            {
              matchPackage: "ember-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ember build`",
            value: "ember build"
          },
          devCommand: {
            value: "ember serve --port $PORT",
            placeholder: "ember serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "ember-cli",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Vue.js",
        slug: "vue",
        demo: "https://vue-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vue.svg",
        tagline: "Vue.js is a versatile JavaScript framework that is as approachable as it is performant.",
        description: "A Vue.js app, created with the Vue CLI.",
        website: "https://vuejs.org",
        envPrefix: "VUE_APP_",
        detectors: {
          every: [
            {
              matchPackage: "@vue/cli-service"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vue-cli-service build`",
            value: "vue-cli-service build"
          },
          devCommand: {
            value: "vue-cli-service serve --port $PORT",
            placeholder: "vue-cli-service serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@vue/cli-service",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            src: "^/[^/]*\\.(js|txt|ico|json)",
            headers: { "cache-control": "max-age=300" },
            continue: !0
          },
          {
            src: "^/(img|js|css|fonts|media)/[^/]+\\.[0-9a-f]{8}\\.*",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: "^.*",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Scully",
        slug: "scully",
        demo: "https://scully-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/scullyio-logo.png",
        tagline: "Scully is a static site generator for Angular.",
        description: "The Static Site Generator for Angular apps.",
        website: "https://github.com/scullyio/scully",
        detectors: {
          every: [
            {
              matchPackage: "@scullyio/init"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ng build && scully`",
            value: "ng build && scully"
          },
          devCommand: {
            value: "ng serve --port $PORT",
            placeholder: "ng serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@scullyio/init",
        getOutputDirName: async () => "dist/static"
      },
      {
        name: "Ionic Angular",
        slug: "ionic-angular",
        demo: "https://ionic-angular-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/ionic.svg",
        tagline: "Ionic Angular allows you to build mobile PWAs with Angular and the Ionic Framework.",
        description: "An Ionic Angular site, created with the Ionic CLI.",
        website: "https://ionicframework.com",
        detectors: {
          every: [
            {
              matchPackage: "@ionic/angular"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ng build`",
            value: "ng build"
          },
          devCommand: {
            value: "ng serve --port $PORT"
          },
          outputDirectory: {
            value: "www"
          }
        },
        dependency: "@ionic/angular",
        getOutputDirName: async () => "www",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Angular",
        slug: "angular",
        demo: "https://angular-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/angular.svg",
        tagline: "Angular is a TypeScript-based cross-platform framework from Google.",
        description: "An Angular app, created with the Angular CLI.",
        website: "https://angular.io",
        detectors: {
          every: [
            {
              matchPackage: "@angular/cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ng build`",
            value: "ng build"
          },
          devCommand: {
            value: "ng serve --port $PORT",
            placeholder: "ng serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@angular/cli",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "dist";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), content = await readdir2(location, { withFileTypes: !0 });
            if (content.length === 1 && content[0].isDirectory())
              return (0, path_1.join)(base2, content[0].name);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        },
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Polymer",
        slug: "polymer",
        demo: "https://polymer-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/polymer.svg",
        tagline: "Polymer is an open-source webapps library from Google, for building using Web Components.",
        description: "A Polymer app, created with the Polymer CLI.",
        website: "https://www.polymer-project.org/",
        detectors: {
          every: [
            {
              matchPackage: "polymer-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `polymer build`",
            value: "polymer build"
          },
          devCommand: {
            value: "polymer serve --port $PORT",
            placeholder: "polymer serve"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "polymer-cli",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "build";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), paths = (await readdir2(location)).filter((item) => !item.includes("."));
            return (0, path_1.join)(base2, paths[0]);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        },
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Svelte",
        slug: "svelte",
        demo: "https://svelte.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        tagline: "Svelte lets you write high performance reactive apps with significantly less boilerplate.",
        description: "A basic Svelte app using the default template.",
        website: "https://svelte.dev",
        sort: 3,
        detectors: {
          every: [
            {
              matchPackage: "svelte"
            },
            {
              matchPackage: "sirv-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `rollup -c`",
            value: "rollup -c"
          },
          devCommand: {
            value: "rollup -c -w"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "sirv-cli",
        getOutputDirName: async () => "public",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        // TODO: fix detected as "sveltekit-1"
        name: "SvelteKit (v0)",
        slug: "sveltekit",
        demo: "https://sveltekit-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/sveltekit.png",
        tagline: "SvelteKit is a framework for building web applications of all sizes.",
        description: "A SvelteKit legacy app optimized Edge-first.",
        website: "https://kit.svelte.dev",
        sort: 99,
        envPrefix: "VITE_",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"(dev)?(d|D)ependencies":\\s*{[^}]*"@sveltejs\\/kit":\\s*"1\\.0\\.0-next\\.(\\d+)"[^}]*}'
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `svelte-kit build`",
            value: "svelte-kit build"
          },
          devCommand: {
            value: "svelte-kit dev --port $PORT",
            placeholder: "svelte-kit dev"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "SvelteKit (v1)",
        slug: "sveltekit-1",
        demo: "https://sveltekit-1-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/sveltekit.png",
        tagline: "SvelteKit is a framework for building web applications of all sizes.",
        description: "A SvelteKit app optimized Edge-first.",
        website: "https://kit.svelte.dev",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"(dev)?(d|D)ependencies":\\s*{[^}]*"@sveltejs\\/kit":\\s*".+?"[^}]*}'
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "vite build",
            value: "vite build"
          },
          devCommand: {
            placeholder: "vite dev",
            value: "vite dev --port $PORT"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Ionic React",
        slug: "ionic-react",
        demo: "https://ionic-react-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/ionic.svg",
        tagline: "Ionic React allows you to build mobile PWAs with React and the Ionic Framework.",
        description: "An Ionic React site, created with the Ionic CLI.",
        website: "https://ionicframework.com",
        detectors: {
          every: [
            {
              matchPackage: "@ionic/react"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `react-scripts build`",
            value: "react-scripts build"
          },
          devCommand: {
            value: "react-scripts start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "@ionic/react",
        getOutputDirName: async () => "build",
        defaultRoutes: [
          {
            src: "/static/(.*)",
            headers: { "cache-control": "s-maxage=31536000, immutable" },
            continue: !0
          },
          {
            src: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          },
          {
            src: "/sockjs-node/(.*)",
            dest: "/sockjs-node/$1"
          },
          {
            handle: "filesystem"
          },
          { src: "/static/(.*)", status: 404, dest: "/404.html" },
          {
            src: "/(.*)",
            headers: { "cache-control": "s-maxage=0" },
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Create React App",
        slug: "create-react-app",
        demo: "https://create-react-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/react.svg",
        tagline: "Create React App allows you to get going with React in no time.",
        description: "A client-side React app created with create-react-app.",
        website: "https://create-react-app.dev",
        sort: 4,
        envPrefix: "REACT_APP_",
        detectors: {
          some: [
            {
              matchPackage: "react-scripts"
            },
            {
              matchPackage: "react-dev-utils"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `react-scripts build`",
            value: "react-scripts build"
          },
          devCommand: {
            value: "react-scripts start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "react-scripts",
        getOutputDirName: async () => "build",
        defaultRoutes: [
          {
            src: "/static/(.*)",
            headers: { "cache-control": "s-maxage=31536000, immutable" },
            continue: !0
          },
          {
            src: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          },
          {
            src: "/sockjs-node/(.*)",
            dest: "/sockjs-node/$1"
          },
          {
            handle: "filesystem"
          },
          { src: "/static/(.*)", status: 404, dest: "/404.html" },
          {
            src: "/(.*)",
            headers: { "cache-control": "s-maxage=0" },
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Gridsome",
        slug: "gridsome",
        demo: "https://gridsome-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/gridsome.svg",
        tagline: "Gridsome is a Vue.js-powered framework for building websites & apps that are fast by default.",
        description: "A Gridsome app, created with the Gridsome CLI.",
        website: "https://gridsome.org/",
        detectors: {
          every: [
            {
              matchPackage: "gridsome"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `gridsome build`",
            value: "gridsome build"
          },
          devCommand: {
            value: "gridsome develop -p $PORT",
            placeholder: "gridsome develop"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "gridsome",
        getOutputDirName: async () => "dist"
      },
      {
        name: "UmiJS",
        slug: "umijs",
        demo: "https://umijs-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/umi.svg",
        tagline: "UmiJS is an extensible enterprise-level React application framework.",
        description: "An UmiJS app, created using the Umi CLI.",
        website: "https://umijs.org",
        detectors: {
          every: [
            {
              matchPackage: "umi"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `umi build`",
            value: "umi build"
          },
          devCommand: {
            value: "umi dev --port $PORT",
            placeholder: "umi dev"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "umi",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Sapper",
        slug: "sapper",
        demo: "https://sapper-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        tagline: "Sapper is a framework for building high-performance universal web apps with Svelte.",
        description: "A Sapper app, using the Sapper template.",
        website: "https://sapper.svelte.dev",
        detectors: {
          every: [
            {
              matchPackage: "sapper"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `sapper export`",
            value: "sapper export"
          },
          devCommand: {
            value: "sapper dev --port $PORT",
            placeholder: "sapper dev"
          },
          outputDirectory: {
            value: "__sapper__/export"
          }
        },
        dependency: "sapper",
        getOutputDirName: async () => "__sapper__/export"
      },
      {
        name: "Saber",
        slug: "saber",
        demo: "https://saber-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/saber.svg",
        tagline: "Saber is a framework for building static sites in Vue.js that supports data from any source.",
        description: "A Saber site, created with npm init.",
        website: "https://saber.egoist.dev",
        detectors: {
          every: [
            {
              matchPackage: "saber"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `saber build`",
            value: "saber build"
          },
          devCommand: {
            value: "saber --port $PORT",
            placeholder: "saber"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "saber",
        getOutputDirName: async () => "public",
        defaultRoutes: [
          {
            src: "/_saber/.*",
            headers: { "cache-control": "max-age=31536000, immutable" }
          },
          {
            handle: "filesystem"
          },
          {
            src: ".*",
            status: 404,
            dest: "404.html"
          }
        ]
      },
      {
        name: "Stencil",
        slug: "stencil",
        demo: "https://stencil.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/stencil.svg",
        tagline: "Stencil is a powerful toolchain for building Progressive Web Apps and Design Systems.",
        description: "A Stencil site, created with the Stencil CLI.",
        website: "https://stenciljs.com/",
        detectors: {
          every: [
            {
              matchPackage: "@stencil/core"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `stencil build`",
            value: "stencil build"
          },
          devCommand: {
            value: "stencil build --dev --watch --serve --port $PORT",
            placeholder: "stencil build --dev --watch --serve"
          },
          outputDirectory: {
            value: "www"
          }
        },
        dependency: "@stencil/core",
        getOutputDirName: async () => "www",
        defaultRoutes: [
          {
            src: "/assets/(.*)",
            headers: { "cache-control": "max-age=2592000" },
            continue: !0
          },
          {
            src: "/build/p-.*",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "/sw.js",
            headers: { "cache-control": "no-cache" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Nuxt.js",
        slug: "nuxtjs",
        demo: "https://nuxtjs-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/nuxt.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/nuxtjs.png",
        tagline: "Nuxt.js is the web comprehensive framework that lets you dream big with Vue.js.",
        description: "A Nuxt.js app, bootstrapped with create-nuxt-app.",
        website: "https://nuxtjs.org",
        sort: 2,
        envPrefix: "NUXT_ENV_",
        detectors: {
          some: [
            {
              matchPackage: "nuxt"
            },
            {
              matchPackage: "nuxt3"
            },
            {
              matchPackage: "nuxt-edge"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `nuxt generate`",
            value: "nuxt generate"
          },
          devCommand: {
            value: "nuxt"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "nuxt",
        getOutputDirName: async () => "dist",
        cachePattern: ".nuxt/**",
        defaultRoutes: [
          {
            src: "/sw.js",
            headers: { "cache-control": "no-cache" },
            continue: !0
          },
          {
            src: "/_nuxt/(.*)",
            headers: { "cache-control": "public,max-age=31536000,immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/200.html"
          }
        ]
      },
      {
        name: "RedwoodJS",
        slug: "redwoodjs",
        demo: "https://redwood-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/redwoodjs.svg",
        tagline: "RedwoodJS is a full-stack framework for the Jamstack.",
        description: "A RedwoodJS app, bootstraped with create-redwood-app.",
        website: "https://redwoodjs.com",
        envPrefix: "REDWOOD_ENV_",
        useRuntime: { src: "package.json", use: "@vercel/redwood" },
        ignoreRuntimes: ["@vercel/node"],
        detectors: {
          every: [
            {
              matchPackage: "@redwoodjs/core"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "yarn rw deploy vercel"
          },
          devCommand: {
            value: 'yarn rw dev --fwd="--port=$PORT --open=false"',
            placeholder: "yarn rw dev"
          },
          outputDirectory: {
            placeholder: "RedwoodJS default"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Hugo",
        slug: "hugo",
        demo: "https://hugo-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/hugo.svg",
        tagline: "Hugo is the world\u2019s fastest framework for building websites, written in Go.",
        description: "A Hugo site, created with the Hugo CLI.",
        website: "https://gohugo.io",
        detectors: {
          some: [
            {
              path: "config.yaml",
              matchContent: "baseURL"
            },
            {
              path: "config.toml",
              matchContent: "baseURL"
            },
            {
              path: "config.json",
              matchContent: "baseURL"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "None"
          },
          buildCommand: {
            placeholder: "`npm run build` or `hugo --gc`",
            value: "hugo --gc"
          },
          devCommand: {
            value: "hugo server -D -w -p $PORT",
            placeholder: "hugo server -D"
          },
          outputDirectory: {
            placeholder: "`public` or `publishDir` from the `config` file"
          }
        },
        getOutputDirName: async (dirPrefix) => {
          const config2 = await (0, read_config_file_1.readConfigFile)(["config.json", "config.yaml", "config.toml"].map((fileName) => (0, path_1.join)(dirPrefix, fileName)));
          return config2 && config2.publishDir || "public";
        },
        defaultVersion: "0.58.2"
        // Must match the build image
      },
      {
        name: "Jekyll",
        slug: "jekyll",
        demo: "https://jekyll-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/jekyll.svg",
        tagline: "Jekyll makes it super easy to transform your plain text into static websites and blogs.",
        description: "A Jekyll site, created with the Jekyll CLI.",
        website: "https://jekyllrb.com/",
        detectors: {
          every: [
            {
              path: "_config.yml"
            }
          ]
        },
        settings: {
          installCommand: {
            value: "bundle install"
          },
          buildCommand: {
            placeholder: "`npm run build` or `jekyll build`",
            value: "jekyll build"
          },
          devCommand: {
            value: "bundle exec jekyll serve --watch --port $PORT",
            placeholder: "bundle exec jekyll serve"
          },
          outputDirectory: {
            placeholder: "`_site` or `destination` from `_config.yml`"
          }
        },
        getOutputDirName: async (dirPrefix) => {
          const config2 = await (0, read_config_file_1.readConfigFile)((0, path_1.join)(dirPrefix, "_config.yml"));
          return config2 && config2.destination || "_site";
        },
        cachePattern: "{vendor/bin,vendor/cache,vendor/bundle}/**"
      },
      {
        name: "Brunch",
        slug: "brunch",
        demo: "https://brunch-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/brunch.svg",
        tagline: "Brunch is a fast and simple webapp build tool with seamless incremental compilation for rapid development.",
        description: "A Brunch app, created with the Brunch CLI.",
        website: "https://brunch.io/",
        detectors: {
          some: [
            {
              matchPackage: "brunch"
            },
            {
              path: "brunch-config.js"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `brunch build --production`",
            value: "brunch build --production"
          },
          devCommand: {
            value: "brunch watch --server --port $PORT",
            placeholder: "brunch watch --server"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Middleman",
        slug: "middleman",
        demo: "https://middleman-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/middleman.svg",
        tagline: "Middleman is a static site generator that uses all the shortcuts and tools in modern web development.",
        description: "A Middleman app, created with the Middleman CLI.",
        website: "https://middlemanapp.com/",
        detectors: {
          every: [
            {
              path: "config.rb"
            }
          ]
        },
        settings: {
          installCommand: {
            value: "bundle install"
          },
          buildCommand: {
            placeholder: "`npm run build` or `bundle exec middleman build`",
            value: "bundle exec middleman build"
          },
          devCommand: {
            placeholder: "bundle exec middleman server",
            value: "bundle exec middleman server -p $PORT"
          },
          outputDirectory: {
            value: "build"
          }
        },
        getOutputDirName: async () => "build",
        cachePattern: "{vendor/bin,vendor/cache,vendor/bundle}/**"
      },
      {
        name: "Zola",
        slug: "zola",
        demo: "https://zola-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/zola.png",
        tagline: "Everything you need to make a static site engine in one binary.",
        description: 'A Zola app, created with the "Getting Started" tutorial.',
        website: "https://www.getzola.org",
        detectors: {
          every: [
            {
              path: "config.toml",
              matchContent: "base_url"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "None"
          },
          buildCommand: {
            value: "zola build"
          },
          devCommand: {
            placeholder: "zola serve",
            value: "zola serve --port $PORT"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public",
        defaultVersion: "0.13.0"
        // Must match the build image
      },
      {
        name: "Hydrogen (v1)",
        slug: "hydrogen",
        demo: "https://hydrogen-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/hydrogen.svg",
        tagline: "React framework for headless commerce",
        description: "React framework for headless commerce",
        website: "https://hydrogen.shopify.dev",
        useRuntime: { src: "package.json", use: "@vercel/hydrogen" },
        envPrefix: "PUBLIC_",
        detectors: {
          some: [
            {
              matchPackage: "@shopify/hydrogen"
            },
            {
              path: "hydrogen.config.js"
            },
            {
              path: "hydrogen.config.ts"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "shopify hydrogen build",
            placeholder: "`npm run build` or `shopify hydrogen build`"
          },
          devCommand: {
            value: "shopify hydrogen dev",
            placeholder: "shopify hydrogen dev"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@shopify/hydrogen",
        getOutputDirName: async () => "dist"
      },
      {
        name: "Vite",
        slug: "vite",
        demo: "https://vite-vue-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vite.svg",
        tagline: "Vite is a new breed of frontend build tool that significantly improves the frontend development experience.",
        description: "A Vue.js app, created with Vite.",
        website: "https://vitejs.dev",
        envPrefix: "VITE_",
        detectors: {
          every: [
            {
              matchPackage: "vite"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vite build`",
            value: "vite build"
          },
          devCommand: {
            placeholder: "vite",
            value: "vite --port $PORT"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "vite",
        getOutputDirName: async () => "dist"
      },
      {
        name: "VitePress",
        slug: "vitepress",
        demo: "https://vitepress-starter-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vite.svg",
        tagline: "VitePress is VuePress' little brother, built on top of Vite.",
        description: "VuePress on top of Vite",
        website: "https://vitepress.vuejs.org/",
        detectors: {
          every: [
            {
              matchPackage: "vitepress"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vitepress build docs`",
            value: "vitepress build docs"
          },
          devCommand: {
            value: "vitepress dev docs --port $PORT"
          },
          outputDirectory: {
            value: "docs/.vitepress/dist"
          }
        },
        getOutputDirName: async () => "docs/.vitepress/dist"
      },
      {
        name: "VuePress",
        slug: "vuepress",
        demo: "https://vuepress-starter-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vuepress.png",
        tagline: "Vue-powered Static Site Generator",
        description: "Vue-powered Static Site Generator",
        website: "https://vuepress.vuejs.org/",
        detectors: {
          every: [
            {
              matchPackage: "vuepress"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vuepress build src`",
            value: "vuepress build src"
          },
          devCommand: {
            value: "vuepress dev src --port $PORT"
          },
          outputDirectory: {
            value: "src/.vuepress/dist"
          }
        },
        getOutputDirName: async () => "src/.vuepress/dist"
      },
      {
        name: "Parcel",
        slug: "parcel",
        demo: "https://parcel-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/parcel.png",
        tagline: "Parcel is a zero configuration build tool for the web that scales to projects of any size and complexity.",
        description: "A vanilla web app built with Parcel.",
        website: "https://parceljs.org",
        detectors: {
          every: [
            {
              matchPackage: "parcel"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `parcel build`",
            value: "parcel build"
          },
          devCommand: {
            placeholder: "parcel",
            value: "parcel"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "parcel",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            src: "^/[^./]+\\.[0-9a-f]{8}\\.(css|js|png|jpg|webp|avif|svg)$",
            headers: { "cache-control": "s-maxage=31536000, immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          }
        ]
      },
      {
        name: "Sanity",
        slug: "sanity",
        demo: "https://sanity-studio-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/sanity.svg",
        tagline: "The structured content platform.",
        description: "A Sanity Studio",
        website: "https://www.sanity.io",
        envPrefix: "SANITY_STUDIO_",
        detectors: {
          some: [
            {
              path: "sanity.json"
            },
            {
              path: "sanity.config.js"
            },
            {
              path: "sanity.config.jsx"
            },
            {
              path: "sanity.config.ts"
            },
            {
              path: "sanity.config.tsx"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `sanity build`",
            value: "sanity build"
          },
          devCommand: {
            value: "sanity start --port $PORT"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@sanity/cli",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Storybook",
        slug: "storybook",
        logo: "https://api-frameworks.vercel.sh/framework-logos/storybook.svg",
        tagline: "Frontend workshop for UI development",
        description: "Storybook is a frontend workshop for building UI components and pages in isolation.",
        website: "https://storybook.js.org",
        ignoreRuntimes: ["@vercel/next", "@vercel/node"],
        disableRootMiddleware: !0,
        detectors: {
          every: [
            {
              matchPackage: "storybook"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "storybook build",
            ignorePackageJsonScript: !0
          },
          devCommand: {
            value: "storybook dev -p $PORT"
          },
          outputDirectory: {
            value: "storybook-static"
          }
        },
        getOutputDirName: async () => "storybook-static"
      },
      {
        name: "Other",
        slug: null,
        logo: "https://api-frameworks.vercel.sh/framework-logos/other.svg",
        description: "No framework or an unoptimized framework.",
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run vercel-build` or `npm run build`",
            value: null
          },
          devCommand: {
            placeholder: "None",
            value: null
          },
          outputDirectory: {
            placeholder: "`public` if it exists, or `.`"
          }
        },
        getOutputDirName: async () => "public"
      }
    ];
    const def = exports2.frameworks;
    exports2.default = def;
  }(frameworks)), frameworks;
}
var frameworksExports = requireFrameworks(), dist$1 = {}, detectBuilders = {}, concatMap$1, hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap$1;
  hasRequiredConcatMap = 1, concatMap$1 = function(xs, fn) {
    for (var res = [], i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      isArray2(x) ? res.push.apply(res, x) : res.push(x);
    }
    return res;
  };
  var isArray2 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap$1;
}
var balancedMatch, hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1, balancedMatch = balanced;
  function balanced(a, b, str2) {
    a instanceof RegExp && (a = maybeMatch(a, str2)), b instanceof RegExp && (b = maybeMatch(b, str2));
    var r = range2(a, b, str2);
    return r && {
      start: r[0],
      end: r[1],
      pre: str2.slice(0, r[0]),
      body: str2.slice(r[0] + a.length, r[1]),
      post: str2.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str2) {
    var m = str2.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range2;
  function range2(a, b, str2) {
    var begs, beg, left, right, result, ai = str2.indexOf(a), bi = str2.indexOf(b, ai + 1), i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b)
        return [ai, bi];
      for (begs = [], left = str2.length; i >= 0 && !result; )
        i == ai ? (begs.push(i), ai = str2.indexOf(a, i + 1)) : begs.length == 1 ? result = [begs.pop(), bi] : (beg = begs.pop(), beg < left && (left = beg, right = bi), bi = str2.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
      begs.length && (result = [left, right]);
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion$1, hasRequiredBraceExpansion$1;
function requireBraceExpansion$1() {
  if (hasRequiredBraceExpansion$1) return braceExpansion$1;
  hasRequiredBraceExpansion$1 = 1;
  var concatMap2 = requireConcatMap(), balanced = requireBalancedMatch();
  braceExpansion$1 = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str2) {
    return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
  }
  function escapeBraces(str2) {
    return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str2) {
    return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str2) {
    if (!str2)
      return [""];
    var parts = [], m = balanced("{", "}", str2);
    if (!m)
      return str2.split(",");
    var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
  }
  function expandTop(str2) {
    return str2 ? (str2.substr(0, 2) === "{}" && (str2 = "\\{\\}" + str2.substr(2)), expand2(escapeBraces(str2), !0).map(unescapeBraces)) : [];
  }
  function embrace(str2) {
    return "{" + str2 + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand2(str2, isTop) {
    var expansions = [], m = balanced("{", "}", str2);
    if (!m || /\$$/.test(m.pre)) return [str2];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions)
      return m.post.match(/,.*\}/) ? (str2 = m.pre + "{" + m.body + escClose + m.post, expand2(str2)) : [str2];
    var n;
    if (isSequence)
      n = m.body.split(/\.\./);
    else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand2(n[0], !1).map(embrace), n.length === 1)) {
      var post = m.post.length ? expand2(m.post, !1) : [""];
      return post.map(function(p) {
        return m.pre + n[0] + p;
      });
    }
    var pre = m.pre, post = m.post.length ? expand2(m.post, !1) : [""], N;
    if (isSequence) {
      var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
      reverse && (incr *= -1, test = gte);
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c2;
        if (isAlphaSequence)
          c2 = String.fromCharCode(i), c2 === "\\" && (c2 = "");
        else if (c2 = String(i), pad) {
          var need = width - c2.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            i < 0 ? c2 = "-" + z + c2.slice(1) : c2 = z + c2;
          }
        }
        N.push(c2);
      }
    } else
      N = concatMap2(n, function(el) {
        return expand2(el, !1);
      });
    for (var j = 0; j < N.length; j++)
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        (!isTop || isSequence || expansion) && expansions.push(expansion);
      }
    return expansions;
  }
  return braceExpansion$1;
}
var minimatch_1$1, hasRequiredMinimatch$1;
function requireMinimatch$1() {
  if (hasRequiredMinimatch$1) return minimatch_1$1;
  hasRequiredMinimatch$1 = 1, minimatch_1$1 = minimatch2, minimatch2.Minimatch = Minimatch2;
  var path2 = function() {
    try {
      return require("path");
    } catch {
    }
  }() || {
    sep: "/"
  };
  minimatch2.sep = path2.sep;
  var GLOBSTAR2 = minimatch2.GLOBSTAR = Minimatch2.GLOBSTAR = {}, expand2 = requireBraceExpansion$1(), plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, qmark2 = "[^/]", star3 = qmark2 + "*?", twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials2 = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set2, c2) {
      return set2[c2] = !0, set2;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch2.filter = filter2;
  function filter2(pattern, options2) {
    return options2 = options2 || {}, function(p, i, list2) {
      return minimatch2(p, pattern, options2);
    };
  }
  function ext2(a, b) {
    b = b || {};
    var t = {};
    return Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    }), Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    }), t;
  }
  minimatch2.defaults = function(def) {
    if (!def || typeof def != "object" || !Object.keys(def).length)
      return minimatch2;
    var orig = minimatch2, m = function(p, pattern, options2) {
      return orig(p, pattern, ext2(def, options2));
    };
    return m.Minimatch = function(pattern, options2) {
      return new orig.Minimatch(pattern, ext2(def, options2));
    }, m.Minimatch.defaults = function(options2) {
      return orig.defaults(ext2(def, options2)).Minimatch;
    }, m.filter = function(pattern, options2) {
      return orig.filter(pattern, ext2(def, options2));
    }, m.defaults = function(options2) {
      return orig.defaults(ext2(def, options2));
    }, m.makeRe = function(pattern, options2) {
      return orig.makeRe(pattern, ext2(def, options2));
    }, m.braceExpand = function(pattern, options2) {
      return orig.braceExpand(pattern, ext2(def, options2));
    }, m.match = function(list2, pattern, options2) {
      return orig.match(list2, pattern, ext2(def, options2));
    }, m;
  }, Minimatch2.defaults = function(def) {
    return minimatch2.defaults(def).Minimatch;
  };
  function minimatch2(p, pattern, options2) {
    return assertValidPattern2(pattern), options2 || (options2 = {}), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch2(pattern, options2).match(p);
  }
  function Minimatch2(pattern, options2) {
    if (!(this instanceof Minimatch2))
      return new Minimatch2(pattern, options2);
    assertValidPattern2(pattern), options2 || (options2 = {}), pattern = pattern.trim(), !options2.allowWindowsEscape && path2.sep !== "/" && (pattern = pattern.split(path2.sep).join("/")), this.options = options2, this.set = [], this.pattern = pattern, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.make();
  }
  Minimatch2.prototype.debug = function() {
  }, Minimatch2.prototype.make = make;
  function make() {
    var pattern = this.pattern, options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!pattern) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var set2 = this.globSet = this.braceExpand();
    options2.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, set2), set2 = this.globParts = set2.map(function(s) {
      return s.split(slashSplit);
    }), this.debug(this.pattern, set2), set2 = set2.map(function(s, si, set3) {
      return s.map(this.parse, this);
    }, this), this.debug(this.pattern, set2), set2 = set2.filter(function(s) {
      return s.indexOf(!1) === -1;
    }), this.debug(this.pattern, set2), this.set = set2;
  }
  Minimatch2.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern, negate = !1, options2 = this.options, negateOffset = 0;
    if (!options2.nonegate) {
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.substr(negateOffset)), this.negate = negate;
    }
  }
  minimatch2.braceExpand = function(pattern, options2) {
    return braceExpand2(pattern, options2);
  }, Minimatch2.prototype.braceExpand = braceExpand2;
  function braceExpand2(pattern, options2) {
    return options2 || (this instanceof Minimatch2 ? options2 = this.options : options2 = {}), pattern = typeof pattern > "u" ? this.pattern : pattern, assertValidPattern2(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand2(pattern);
  }
  var MAX_PATTERN_LENGTH2 = 1024 * 64, assertValidPattern2 = function(pattern) {
    if (typeof pattern != "string")
      throw new TypeError("invalid pattern");
    if (pattern.length > MAX_PATTERN_LENGTH2)
      throw new TypeError("pattern is too long");
  };
  Minimatch2.prototype.parse = parse3;
  var SUBPARSE = {};
  function parse3(pattern, isSub) {
    assertValidPattern2(pattern);
    var options2 = this.options;
    if (pattern === "**")
      if (options2.noglobstar)
        pattern = "*";
      else
        return GLOBSTAR2;
    if (pattern === "") return "";
    var re = "", hasMagic2 = !!options2.nocase, escaping = !1, patternListStack = [], negativeLists = [], stateChar, inClass = !1, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star3, hasMagic2 = !0;
            break;
          case "?":
            re += qmark2, hasMagic2 = !0;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
      }
    }
    for (var i = 0, len = pattern.length, c2; i < len && (c2 = pattern.charAt(i)); i++) {
      if (this.debug("%s	%s %s %j", pattern, i, re, c2), escaping && reSpecials2[c2]) {
        re += "\\" + c2, escaping = !1;
        continue;
      }
      switch (c2) {
        /* istanbul ignore next */
        case "/":
          return !1;
        case "\\":
          clearStateChar(), escaping = !0;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2), inClass) {
            this.debug("  in class"), c2 === "!" && i === classStart + 1 && (c2 = "^"), re += c2;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c2, options2.noext && clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          }), re += stateChar === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", stateChar, re), stateChar = !1;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar(), hasMagic2 = !0;
          var pl = patternListStack.pop();
          re += pl.close, pl.type === "!" && negativeLists.push(pl), pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|", escaping = !1;
            continue;
          }
          clearStateChar(), re += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          if (clearStateChar(), inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = !0, classStart = i, reClassStart = re.length, re += c2;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c2, escaping = !1;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]", hasMagic2 = hasMagic2 || sp[1], inClass = !1;
            continue;
          }
          hasMagic2 = !0, inClass = !1, re += c2;
          continue;
        default:
          clearStateChar(), escaping ? escaping = !1 : reSpecials2[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
      }
    }
    for (inClass && (cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic2 = hasMagic2 || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
      }), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
      var t = pl.type === "*" ? star3 : pl.type === "?" ? qmark2 : "\\" + pl.type;
      hasMagic2 = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar(), escaping && (re += "\\\\");
    var addPatternStart2 = !1;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart2 = !0;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8), nlLast = re.slice(nl.reEnd - 8, nl.reEnd), nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1, cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++)
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      nlAfter = cleanAfter;
      var dollar = "";
      nlAfter === "" && isSub !== SUBPARSE && (dollar = "$");
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic2 && (re = "(?=.)" + re), addPatternStart2 && (re = patternStart + re), isSub === SUBPARSE)
      return [re, hasMagic2];
    if (!hasMagic2)
      return globUnescape(pattern);
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch {
      return new RegExp("$.");
    }
    return regExp._glob = pattern, regExp._src = re, regExp;
  }
  minimatch2.makeRe = function(pattern, options2) {
    return new Minimatch2(pattern, options2 || {}).makeRe();
  }, Minimatch2.prototype.makeRe = makeRe2;
  function makeRe2() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    var set2 = this.set;
    if (!set2.length)
      return this.regexp = !1, this.regexp;
    var options2 = this.options, twoStar = options2.noglobstar ? star3 : options2.dot ? twoStarDot2 : twoStarNoDot2, flags = options2.nocase ? "i" : "", re = set2.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR2 ? twoStar : typeof p == "string" ? regExpEscape2(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
    try {
      this.regexp = new RegExp(re, flags);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  minimatch2.match = function(list2, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch2(pattern, options2);
    return list2 = list2.filter(function(f) {
      return mm.match(f);
    }), mm.options.nonull && !list2.length && list2.push(pattern), list2;
  }, Minimatch2.prototype.match = function(f, partial) {
    if (typeof partial > "u" && (partial = this.partial), this.debug("match", f, this.pattern), this.comment) return !1;
    if (this.empty) return f === "";
    if (f === "/" && partial) return !0;
    var options2 = this.options;
    path2.sep !== "/" && (f = f.split(path2.sep).join("/")), f = f.split(slashSplit), this.debug(this.pattern, "split", f);
    var set2 = this.set;
    this.debug(this.pattern, "set", set2);
    var filename, i;
    for (i = f.length - 1; i >= 0 && (filename = f[i], !filename); i--)
      ;
    for (i = 0; i < set2.length; i++) {
      var pattern = set2[i], file = f;
      options2.matchBase && pattern.length === 1 && (file = [filename]);
      var hit = this.matchOne(file, pattern, partial);
      if (hit)
        return options2.flipNegate ? !0 : !this.negate;
    }
    return options2.flipNegate ? !1 : this.negate;
  }, Minimatch2.prototype.matchOne = function(file, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { this: this, file, pattern }
    ), this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f = file[fi];
      if (this.debug(pattern, p, f), p === !1) return !1;
      if (p === GLOBSTAR2) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file[fr];
          if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
      }
      var hit;
      if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), this.debug("pattern match", p, f, hit)), !hit) return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl)
      return fi === fl - 1 && file[fi] === "";
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape2(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1$1;
}
var isOfficialRuntime = {}, hasRequiredIsOfficialRuntime;
function requireIsOfficialRuntime() {
  return hasRequiredIsOfficialRuntime || (hasRequiredIsOfficialRuntime = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isStaticRuntime = exports2.isOfficialRuntime = void 0;
    const isOfficialRuntime2 = (desired, name) => typeof name != "string" ? !1 : name === `@vercel/${desired}` || name === `@now/${desired}` || name.startsWith(`@vercel/${desired}@`) || name.startsWith(`@now/${desired}@`);
    exports2.isOfficialRuntime = isOfficialRuntime2;
    const isStaticRuntime = (name) => (0, exports2.isOfficialRuntime)("static", name);
    exports2.isStaticRuntime = isStaticRuntime;
  }(isOfficialRuntime)), isOfficialRuntime;
}
var hasRequiredDetectBuilders;
function requireDetectBuilders() {
  if (hasRequiredDetectBuilders) return detectBuilders;
  hasRequiredDetectBuilders = 1;
  var __importDefault2 = detectBuilders && detectBuilders.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(detectBuilders, "__esModule", { value: !0 }), detectBuilders.detectBuilders = detectBuilders.detectOutputDirectory = detectBuilders.detectApiDirectory = detectBuilders.detectApiExtensions = detectBuilders.sortFiles = void 0;
  const minimatch_12 = __importDefault2(requireMinimatch$1()), semver_1 = semver__default.default, path_1 = require$$0__default.default, frameworks_1 = __importDefault2(requireFrameworks()), is_official_runtime_1 = requireIsOfficialRuntime(), slugToFramework = new Map(frameworks_1.default.map((f) => [f.slug, f]));
  function sortFiles(fileA, fileB) {
    return fileA.localeCompare(fileB);
  }
  detectBuilders.sortFiles = sortFiles;
  function detectApiExtensions(builders) {
    return new Set(builders.filter((b) => !!(b.config && b.config.zeroConfig && b.src?.startsWith("api/"))).map((b) => (0, path_1.extname)(b.src)).filter(Boolean));
  }
  detectBuilders.detectApiExtensions = detectApiExtensions;
  function detectApiDirectory(builders) {
    return builders.some((b) => b.config && b.config.zeroConfig && b.src?.startsWith("api/")) ? "api" : null;
  }
  detectBuilders.detectApiDirectory = detectApiDirectory;
  function getPublicBuilder(builders) {
    for (const builder of builders)
      if (typeof builder.src == "string" && (0, is_official_runtime_1.isOfficialRuntime)("static", builder.use) && /^.*\/\*\*\/\*$/.test(builder.src) && builder.config?.zeroConfig === !0)
        return builder;
    return null;
  }
  function detectOutputDirectory(builders) {
    const publicBuilder = getPublicBuilder(builders);
    return publicBuilder ? publicBuilder.src.replace("/**/*", "") : null;
  }
  detectBuilders.detectOutputDirectory = detectOutputDirectory;
  async function detectBuilders$1(files, pkg, options2 = {}) {
    const errors = [], warnings = [];
    let apiBuilders = [], frontendBuilder = null;
    const functionError = validateFunctions(options2);
    if (functionError)
      return {
        builders: null,
        errors: [functionError],
        warnings,
        defaultRoutes: null,
        redirectRoutes: null,
        rewriteRoutes: null,
        errorRoutes: null
      };
    const sortedFiles = files.sort(sortFiles), apiSortedFiles = files.sort(sortFilesBySegmentCount), usedFunctions = /* @__PURE__ */ new Set(), addToUsedFunctions = (builder) => {
      const key2 = Object.keys(builder.config.functions || {})[0];
      key2 && usedFunctions.add(key2);
    }, absolutePathCache = /* @__PURE__ */ new Map(), { projectSettings = {} } = options2, { buildCommand, outputDirectory, framework } = projectSettings, frameworkConfig = slugToFramework.get(framework || ""), ignoreRuntimes = new Set(frameworkConfig?.ignoreRuntimes), withTag = options2.tag ? `@${options2.tag}` : "", apiMatches = getApiMatches().filter((b) => (
      // Root-level middleware is enabled, unless `disableRootMiddleware: true`
      b.config?.middleware && !frameworkConfig?.disableRootMiddleware || // "api" dir runtimes are enabled, unless opted-out via `ignoreRuntimes`
      !ignoreRuntimes.has(b.use)
    )).map((b) => (b.use = `${b.use}${withTag}`, b)), makeFrontendStatic = buildCommand === "" || outputDirectory === "", usedOutputDirectory = outputDirectory || "public";
    let hasUsedOutputDirectory = !1, hasNoneApiFiles = !1, hasNextApiFiles = !1, fallbackEntrypoint = null;
    const apiRoutes = [], dynamicRoutes = [];
    for (const fileName of sortedFiles) {
      const apiBuilder = maybeGetApiBuilder(fileName, apiMatches, options2);
      if (apiBuilder) {
        const { routeError, apiRoute, isDynamic } = getApiRoute(fileName, apiSortedFiles, options2, absolutePathCache);
        if (routeError)
          return {
            builders: null,
            errors: [routeError],
            warnings,
            defaultRoutes: null,
            redirectRoutes: null,
            rewriteRoutes: null,
            errorRoutes: null
          };
        apiRoute && (apiRoutes.push(apiRoute), isDynamic && dynamicRoutes.push(apiRoute)), addToUsedFunctions(apiBuilder), apiBuilders.push(apiBuilder);
        continue;
      }
      !hasUsedOutputDirectory && fileName.startsWith(`${usedOutputDirectory}/`) && (hasUsedOutputDirectory = !0), !hasNoneApiFiles && !fileName.startsWith("api/") && fileName !== "package.json" && (hasNoneApiFiles = !0), !hasNextApiFiles && (fileName.startsWith("pages/api") || fileName.startsWith("src/pages/api")) && (hasNextApiFiles = !0), !fallbackEntrypoint && buildCommand && !fileName.includes("/") && fileName !== "now.json" && fileName !== "vercel.json" && (fallbackEntrypoint = fileName);
    }
    if (!makeFrontendStatic && (hasBuildScript(pkg) || buildCommand || framework))
      frontendBuilder = detectFrontBuilder(pkg, files, usedFunctions, fallbackEntrypoint, options2);
    else {
      if (pkg && !makeFrontendStatic && !apiBuilders.length && !options2.ignoreBuildScript)
        return errors.push(getMissingBuildScriptError()), {
          errors,
          warnings,
          builders: null,
          redirectRoutes: null,
          defaultRoutes: null,
          rewriteRoutes: null,
          errorRoutes: null
        };
      hasUsedOutputDirectory && outputDirectory !== "" ? frontendBuilder = {
        use: "@vercel/static",
        src: `${usedOutputDirectory}/**/*`,
        config: {
          zeroConfig: !0,
          outputDirectory: usedOutputDirectory
        }
      } : apiBuilders.length && hasNoneApiFiles && (frontendBuilder = {
        use: "@vercel/static",
        src: "!{api/**,package.json,middleware.[jt]s}",
        config: {
          zeroConfig: !0
        }
      });
    }
    const unusedFunctionError = checkUnusedFunctions(frontendBuilder, usedFunctions, options2);
    if (unusedFunctionError)
      return {
        builders: null,
        errors: [unusedFunctionError],
        warnings,
        redirectRoutes: null,
        defaultRoutes: null,
        rewriteRoutes: null,
        errorRoutes: null
      };
    framework === null && frontendBuilder?.use === "@vercel/next" && apiBuilders.length > 0 && (apiBuilders = apiBuilders.filter((builder) => !(builder.use === "@vercel/node" && builder.config?.middleware)));
    const builders = [];
    apiBuilders.length && builders.push(...apiBuilders), frontendBuilder && (builders.push(frontendBuilder), hasNextApiFiles && apiBuilders.some((b) => (0, is_official_runtime_1.isOfficialRuntime)("node", b.use)) && warnings.push({
      code: "conflicting_files",
      message: "When using Next.js, it is recommended to place JavaScript Functions inside of the `pages/api` (provided by Next.js) directory instead of `api` (provided by Vercel). Other languages (Python, Go, etc) should still go in the `api` directory.",
      link: "https://nextjs.org/docs/api-routes/introduction",
      action: "Learn More"
    }));
    const routesResult = getRouteResult(apiRoutes, dynamicRoutes, usedOutputDirectory, apiBuilders, frontendBuilder, options2);
    return {
      warnings,
      builders: builders.length ? builders : null,
      errors: errors.length ? errors : null,
      redirectRoutes: routesResult.redirectRoutes,
      defaultRoutes: routesResult.defaultRoutes,
      rewriteRoutes: routesResult.rewriteRoutes,
      errorRoutes: routesResult.errorRoutes
    };
  }
  detectBuilders.detectBuilders = detectBuilders$1;
  function maybeGetApiBuilder(fileName, apiMatches, options2) {
    const middleware = fileName === "middleware.js" || fileName === "middleware.ts";
    if (middleware && options2.projectSettings?.framework === "nextjs" || !(fileName.startsWith("api/") || middleware) || fileName.includes("/.") || fileName.includes("/_") || fileName.includes("/node_modules/") || fileName.endsWith(".d.ts"))
      return null;
    const match2 = apiMatches.find(({ src: src2 = "**" }) => src2 === fileName || (0, minimatch_12.default)(fileName, src2)), { fnPattern, func } = getFunction(fileName, options2), use = func?.runtime || match2?.use;
    if (!use)
      return null;
    const config2 = { zeroConfig: !0 };
    return middleware && (config2.middleware = !0), fnPattern && func && (config2.functions = { [fnPattern]: func }, func.includeFiles && (config2.includeFiles = func.includeFiles), func.excludeFiles && (config2.excludeFiles = func.excludeFiles)), {
      use,
      src: fileName,
      config: config2
    };
  }
  function getFunction(fileName, { functions = {} }) {
    const keys = Object.keys(functions);
    if (!keys.length)
      return { fnPattern: null, func: null };
    const func = keys.find((key2) => key2 === fileName || (0, minimatch_12.default)(fileName, key2));
    return func ? { fnPattern: func, func: functions[func] } : { fnPattern: null, func: null };
  }
  function getApiMatches() {
    const config2 = { zeroConfig: !0 };
    return [
      {
        src: "middleware.[jt]s",
        use: "@vercel/node",
        config: { ...config2, middleware: !0 }
      },
      { src: "api/**/*.+(js|mjs|ts|tsx)", use: "@vercel/node", config: config2 },
      { src: "api/**/!(*_test).go", use: "@vercel/go", config: config2 },
      { src: "api/**/*.py", use: "@vercel/python", config: config2 },
      { src: "api/**/*.rb", use: "@vercel/ruby", config: config2 }
    ];
  }
  function hasBuildScript(pkg) {
    const { scripts = {} } = pkg || {};
    return !!(scripts && scripts.build);
  }
  function detectFrontBuilder(pkg, files, usedFunctions, fallbackEntrypoint, options2) {
    const { tag, projectSettings = {} } = options2, withTag = tag ? `@${tag}` : "", { createdAt = 0 } = projectSettings;
    let { framework } = projectSettings;
    const config2 = {
      zeroConfig: !0
    };
    framework && (config2.framework = framework), projectSettings.devCommand && (config2.devCommand = projectSettings.devCommand), typeof projectSettings.installCommand == "string" && (config2.installCommand = projectSettings.installCommand), projectSettings.buildCommand && (config2.buildCommand = projectSettings.buildCommand), projectSettings.outputDirectory && (config2.outputDirectory = projectSettings.outputDirectory), pkg && (framework === void 0 || framework !== "storybook" && createdAt < Date.parse("2020-03-01")) && {
      ...pkg.dependencies,
      ...pkg.devDependencies
    }.next && (framework = "nextjs"), options2.functions && Object.entries(options2.functions).forEach(([key2, func]) => {
      usedFunctions.has(key2) || (config2.functions || (config2.functions = {}), config2.functions[key2] = { ...func });
    });
    const f = slugToFramework.get(framework || "");
    if (f && f.useRuntime) {
      const { src: src2, use } = f.useRuntime;
      return { src: src2, use: `${use}${withTag}`, config: config2 };
    }
    const entrypoints = /* @__PURE__ */ new Set([
      "package.json",
      "config.yaml",
      "config.toml",
      "config.json",
      "_config.yml",
      "config.yml",
      "config.rb"
    ]);
    return {
      src: (pkg ? "package.json" : files.find((file) => entrypoints.has(file)) || fallbackEntrypoint || "package.json") || "package.json",
      use: `@vercel/static-build${withTag}`,
      config: config2
    };
  }
  function getMissingBuildScriptError() {
    return {
      code: "missing_build_script",
      message: "Your `package.json` file is missing a `build` property inside the `scripts` property.\nLearn More: https://vercel.link/missing-build-script"
    };
  }
  function validateFunctions({ functions = {} }) {
    for (const [path2, func] of Object.entries(functions)) {
      if (path2.length > 256)
        return {
          code: "invalid_function_glob",
          message: "Function globs must be less than 256 characters long."
        };
      if (!func || typeof func != "object")
        return {
          code: "invalid_function",
          message: "Function must be an object."
        };
      if (Object.keys(func).length === 0)
        return {
          code: "invalid_function",
          message: "Function must contain at least one property."
        };
      if (func.maxDuration !== void 0 && (func.maxDuration < 1 || func.maxDuration > 900 || !Number.isInteger(func.maxDuration)))
        return {
          code: "invalid_function_duration",
          message: "Functions must have a duration between 1 and 900."
        };
      if (func.memory !== void 0 && (func.memory < 128 || func.memory > 3008))
        return {
          code: "invalid_function_memory",
          message: "Functions must have a memory value between 128 and 3008"
        };
      if (path2.startsWith("/"))
        return {
          code: "invalid_function_source",
          message: `The function path "${path2}" is invalid. The path must be relative to your project root and therefore cannot start with a slash.`
        };
      if (func.runtime !== void 0) {
        const tag = `${func.runtime}`.split("@").pop();
        if (!tag || !(0, semver_1.valid)(tag))
          return {
            code: "invalid_function_runtime",
            message: "Function Runtimes must have a valid version, for example `now-php@1.0.0`."
          };
      }
      if (func.includeFiles !== void 0 && typeof func.includeFiles != "string")
        return {
          code: "invalid_function_property",
          message: "The property `includeFiles` must be a string."
        };
      if (func.excludeFiles !== void 0 && typeof func.excludeFiles != "string")
        return {
          code: "invalid_function_property",
          message: "The property `excludeFiles` must be a string."
        };
    }
    return null;
  }
  function checkUnusedFunctions(frontendBuilder, usedFunctions, options2) {
    const unusedFunctions = new Set(Object.keys(options2.functions || {}).filter((key2) => !usedFunctions.has(key2)));
    if (!unusedFunctions.size)
      return null;
    if (frontendBuilder && (0, is_official_runtime_1.isOfficialRuntime)("next", frontendBuilder.use))
      for (const fnKey of unusedFunctions.values())
        if (fnKey.startsWith("pages/") || fnKey.startsWith("src/pages") || fnKey.startsWith("app/") || fnKey.startsWith("src/app/"))
          unusedFunctions.delete(fnKey);
        else
          return {
            code: "unused_function",
            message: `The pattern "${fnKey}" defined in \`functions\` doesn't match any Serverless Functions.`,
            action: "Learn More",
            link: "https://vercel.link/unmatched-function-pattern"
          };
    if (unusedFunctions.size) {
      const [fnKey] = Array.from(unusedFunctions);
      return {
        code: "unused_function",
        message: `The pattern "${fnKey}" defined in \`functions\` doesn't match any Serverless Functions inside the \`api\` directory.`,
        action: "Learn More",
        link: "https://vercel.link/unmatched-function-pattern"
      };
    }
    return null;
  }
  function getApiRoute(fileName, sortedFiles, options2, absolutePathCache) {
    const conflictingSegment = getConflictingSegment(fileName);
    if (conflictingSegment)
      return {
        apiRoute: null,
        isDynamic: !1,
        routeError: {
          code: "conflicting_path_segment",
          message: `The segment "${conflictingSegment}" occurs more than one time in your path "${fileName}". Please make sure that every segment in a path is unique.`
        }
      };
    const occurrences = pathOccurrences(fileName, sortedFiles, absolutePathCache);
    if (occurrences.length > 0) {
      const messagePaths = concatArrayOfText(occurrences.map((name) => `"${name}"`));
      return {
        apiRoute: null,
        isDynamic: !1,
        routeError: {
          code: "conflicting_file_path",
          message: `Two or more files have conflicting paths or names. Please make sure path segments and filenames, without their extension, are unique. The path "${fileName}" has conflicts with ${messagePaths}.`
        }
      };
    }
    const out = createRouteFromPath(fileName, !!options2.featHandleMiss, !!options2.cleanUrls);
    return {
      apiRoute: out.route,
      isDynamic: out.isDynamic,
      routeError: null
    };
  }
  function getConflictingSegment(filePath) {
    const segments = /* @__PURE__ */ new Set();
    for (const segment of filePath.split("/")) {
      const name = getSegmentName(segment);
      if (name !== null && segments.has(name))
        return name;
      name && segments.add(name);
    }
    return null;
  }
  function getSegmentName(segment) {
    const { name } = (0, path_1.parse)(segment);
    return name.startsWith("[") && name.endsWith("]") ? name.slice(1, -1) : null;
  }
  function getAbsolutePath(unresolvedPath) {
    const { dir, name } = (0, path_1.parse)(unresolvedPath);
    return joinPath(dir, name).split("/").map((part) => part.replace(/\[.*\]/, "1")).join("/");
  }
  function pathOccurrences(fileName, files, absolutePathCache) {
    let currentAbsolutePath = absolutePathCache.get(fileName);
    currentAbsolutePath || (currentAbsolutePath = getAbsolutePath(fileName), absolutePathCache.set(fileName, currentAbsolutePath));
    const prev = [];
    for (const file of files) {
      if (file === fileName)
        continue;
      let absolutePath = absolutePathCache.get(file);
      absolutePath || (absolutePath = getAbsolutePath(file), absolutePathCache.set(file, absolutePath)), (absolutePath === currentAbsolutePath || partiallyMatches(fileName, file)) && prev.push(file);
    }
    return prev;
  }
  function joinPath(...segments) {
    return segments.join("/").replace(/\/{2,}/g, "/");
  }
  function escapeName(name) {
    const special = "[]^$.|?*+()".split("");
    for (const char of special)
      name = name.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
    return name;
  }
  function concatArrayOfText(texts) {
    if (texts.length <= 2)
      return texts.join(" and ");
    const last2 = texts.pop();
    return `${texts.join(", ")}, and ${last2}`;
  }
  function partiallyMatches(pathA, pathB) {
    const partsA = pathA.split("/"), partsB = pathB.split("/"), long = partsA.length > partsB.length ? partsA : partsB, short = long === partsA ? partsB : partsA;
    let index = 0;
    for (const segmentShort of short) {
      const segmentLong = long[index], nameLong = getSegmentName(segmentLong), nameShort = getSegmentName(segmentShort);
      if (segmentShort !== segmentLong && (!nameLong || !nameShort))
        return !1;
      if (nameLong !== nameShort)
        return !0;
      index += 1;
    }
    return !1;
  }
  function createRouteFromPath(filePath, featHandleMiss, cleanUrls) {
    const parts = filePath.split("/");
    let counter = 1;
    const query = [];
    let isDynamic = !1;
    const srcParts = parts.map((segment, i) => {
      const name = getSegmentName(segment), isLast = i === parts.length - 1;
      if (name !== null)
        return query.push(`${name}=$${counter++}`), isDynamic = !0, "([^/]+)";
      if (isLast) {
        const { name: fileName2, ext: ext3 } = (0, path_1.parse)(segment), isIndex2 = fileName2 === "index", prefix = isIndex2 ? "/" : "";
        return `(${[
          isIndex2 ? prefix : `${fileName2}/`,
          prefix + escapeName(fileName2),
          featHandleMiss && cleanUrls ? "" : prefix + escapeName(fileName2) + escapeName(ext3)
        ].filter(Boolean).join("|")})${isIndex2 ? "?" : ""}`;
      }
      return segment;
    }), { name: fileName, ext: ext2 } = (0, path_1.parse)(filePath), isIndex = fileName === "index", queryString = `${query.length ? "?" : ""}${query.join("&")}`, src2 = isIndex ? `^/${srcParts.slice(0, -1).join("/")}${srcParts.slice(-1)[0]}$` : `^/${srcParts.join("/")}$`;
    let route;
    if (featHandleMiss) {
      const extensionless = ext2 ? filePath.slice(0, -ext2.length) : filePath;
      route = {
        src: src2,
        dest: `/${extensionless}${queryString}`,
        check: !0
      };
    } else
      route = {
        src: src2,
        dest: `/${filePath}${queryString}`
      };
    return { route, isDynamic };
  }
  function getRouteResult(apiRoutes, dynamicRoutes, outputDirectory, apiBuilders, frontendBuilder, options2) {
    const defaultRoutes = [], redirectRoutes = [], rewriteRoutes = [], errorRoutes = [], framework = frontendBuilder?.config?.framework || "", isNextjs = framework === "nextjs" || (0, is_official_runtime_1.isOfficialRuntime)("next", frontendBuilder?.use), ignoreRuntimes = slugToFramework.get(framework)?.ignoreRuntimes;
    if (apiRoutes && apiRoutes.length > 0)
      if (options2.featHandleMiss) {
        const extSet = detectApiExtensions(apiBuilders);
        if (extSet.size > 0) {
          const extGroup = `(?:\\.(?:${Array.from(extSet).map((ext2) => ext2.slice(1)).join("|")}))`;
          options2.cleanUrls ? (redirectRoutes.push({
            src: `^/(api(?:.+)?)/index${extGroup}?/?$`,
            headers: { Location: options2.trailingSlash ? "/$1/" : "/$1" },
            status: 308
          }), redirectRoutes.push({
            src: `^/api/(.+)${extGroup}/?$`,
            headers: {
              Location: options2.trailingSlash ? "/api/$1/" : "/api/$1"
            },
            status: 308
          })) : (defaultRoutes.push({ handle: "miss" }), defaultRoutes.push({
            src: `^/api/(.+)${extGroup}$`,
            dest: "/api/$1",
            check: !0
          }));
        }
        rewriteRoutes.push(...dynamicRoutes);
        const hasApiBuild = apiBuilders.find((builder) => builder.src?.startsWith("api/"));
        typeof ignoreRuntimes > "u" && hasApiBuild && rewriteRoutes.push({
          src: "^/api(/.*)?$",
          status: 404
        });
      } else
        defaultRoutes.push(...apiRoutes), apiRoutes.length && defaultRoutes.push({
          status: 404,
          src: "^/api(/.*)?$"
        });
    return outputDirectory && frontendBuilder && !options2.featHandleMiss && (0, is_official_runtime_1.isOfficialRuntime)("static", frontendBuilder.use) && defaultRoutes.push({
      src: "/(.*)",
      dest: `/${outputDirectory}/$1`
    }), options2.featHandleMiss && !isNextjs && errorRoutes.push({
      status: 404,
      src: "^(?!/api).*$",
      dest: options2.cleanUrls ? "/404" : "/404.html"
    }), {
      defaultRoutes,
      redirectRoutes,
      rewriteRoutes,
      errorRoutes
    };
  }
  function sortFilesBySegmentCount(fileA, fileB) {
    const lengthA = fileA.split("/").length, lengthB = fileB.split("/").length;
    if (lengthA > lengthB)
      return -1;
    if (lengthA < lengthB)
      return 1;
    const countSegments = (prev, segment) => getSegmentName(segment) ? prev + 1 : 0, segmentLengthA = fileA.split("/").reduce(countSegments, 0), segmentLengthB = fileB.split("/").reduce(countSegments, 0);
    return segmentLengthA > segmentLengthB ? 1 : segmentLengthA < segmentLengthB ? -1 : fileA.localeCompare(fileB);
  }
  return detectBuilders;
}
var detectFileSystemApi = {}, hasRequiredDetectFileSystemApi;
function requireDetectFileSystemApi() {
  if (hasRequiredDetectFileSystemApi) return detectFileSystemApi;
  hasRequiredDetectFileSystemApi = 1;
  var __importDefault2 = detectFileSystemApi && detectFileSystemApi.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(detectFileSystemApi, "__esModule", { value: !0 }), detectFileSystemApi.detectFileSystemAPI = void 0;
  const semver_1 = __importDefault2(semver__default.default), _1 = requireDist();
  async function detectFileSystemAPI({ files, projectSettings, builders, vercelConfig, pkg, tag, enableFlag = !1 }) {
    const framework = projectSettings.framework || "", deps = Object.assign({}, pkg?.dependencies, pkg?.devDependencies), plugins = Object.keys(deps).filter((dep) => dep.startsWith("vercel-plugin-")), hasDotOutput = Object.keys(files).some((file) => file.startsWith(".output/")), hasMiddleware = !!(files["_middleware.js"] || files["_middleware.ts"]), metadata = {
      plugins,
      hasDotOutput,
      hasMiddleware
    };
    if (!(enableFlag || hasMiddleware || hasDotOutput))
      return { metadata, fsApiBuilder: null, reason: "Flag not enabled." };
    if (vercelConfig?.builds && vercelConfig.builds.length > 0)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `builds` in vercel.json. Please remove it in favor of CLI plugins."
      };
    if (Object.values(vercelConfig?.functions || {}).some((fn) => !!fn.runtime))
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `functions.runtime` in vercel.json. Please remove it in favor of CLI plugins."
      };
    if (process.env.HUGO_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `HUGO_VERSION` environment variable. Please remove it."
      };
    if (process.env.ZOLA_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `ZOLA_VERSION` environment variable. Please remove it."
      };
    if (process.env.GUTENBERG_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `GUTENBERG_VERSION` environment variable. Please remove it."
      };
    const invalidBuilder = builders.find(({ use }) => !((0, _1.isOfficialRuntime)("go", use) || (0, _1.isOfficialRuntime)("python", use) || (0, _1.isOfficialRuntime)("ruby", use) || (0, _1.isOfficialRuntime)("node", use) || (0, _1.isOfficialRuntime)("next", use) || (0, _1.isOfficialRuntime)("static", use) || (0, _1.isOfficialRuntime)("static-build", use)));
    if (invalidBuilder)
      return {
        metadata,
        fsApiBuilder: null,
        reason: `Detected \`${invalidBuilder.use}\` in vercel.json. Please remove it in favor of CLI plugins.`
      };
    for (const lang of ["go", "python", "ruby"])
      for (const { use } of builders) {
        const plugin = "vercel-plugin-" + lang;
        if ((0, _1.isOfficialRuntime)(lang, use) && !deps[plugin])
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected \`${lang}\` Serverless Function usage without plugin \`${plugin}\`. Please run \`npm i ${plugin}\`.`
          };
      }
    if (framework === "nuxtjs" || framework === "sveltekit" || framework === "redwoodjs")
      return {
        metadata,
        fsApiBuilder: null,
        reason: `Detected framework \`${framework}\` that only supports legacy File System API. Please contact the framework author.`
      };
    if (framework === "nextjs" && !hasDotOutput) {
      if (projectSettings?.outputDirectory)
        return {
          metadata,
          fsApiBuilder: null,
          reason: `Detected Next.js with Output Directory \`${projectSettings.outputDirectory}\` override. Please change it back to the default.`
        };
      const nextVersion = deps.next;
      if (!nextVersion)
        return {
          metadata,
          fsApiBuilder: null,
          reason: "Detected Next.js in Project Settings but missing `next` package.json dependencies. Please run `npm i next`."
        };
      if (nextVersion !== "latest" && nextVersion !== "canary") {
        const fixedVersion = semver_1.default.valid(semver_1.default.coerce(nextVersion) || "");
        if (!fixedVersion || !semver_1.default.gte(fixedVersion, "12.0.0"))
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected legacy Next.js version "${nextVersion}" in package.json. Please run \`npm i next@latest\` to upgrade.`
          };
      }
    }
    if (!hasDotOutput) {
      const vercelCliVersion = deps.vercel;
      if (vercelCliVersion && vercelCliVersion !== "latest" && vercelCliVersion !== "canary") {
        const fixedVersion = semver_1.default.valid(semver_1.default.coerce(vercelCliVersion) || "");
        if (!fixedVersion || !semver_1.default.gte(fixedVersion, "23.1.3-canary.68"))
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected legacy Vercel CLI version "${vercelCliVersion}" in package.json. Please run \`npm i vercel@latest\` to upgrade.`
          };
      }
    }
    const config2 = builders.find(({ use }) => (0, _1.isOfficialRuntime)("next", use) || (0, _1.isOfficialRuntime)("static", use) || (0, _1.isOfficialRuntime)("static-build", use))?.config || {}, fsApiBuilder = {
      use: `@vercelruntimes/file-system-api${tag ? `@${tag}` : ""}`,
      src: "**",
      config: {
        ...config2,
        fileSystemAPI: !0,
        framework: config2.framework || framework || null,
        projectSettings,
        hasMiddleware,
        hasDotOutput
      }
    };
    return { metadata, fsApiBuilder, reason: null };
  }
  return detectFileSystemApi.detectFileSystemAPI = detectFileSystemAPI, detectFileSystemApi;
}
var detectFramework = {}, hasRequiredDetectFramework;
function requireDetectFramework() {
  if (hasRequiredDetectFramework) return detectFramework;
  hasRequiredDetectFramework = 1, Object.defineProperty(detectFramework, "__esModule", { value: !0 }), detectFramework.detectFrameworkVersion = detectFramework.detectFrameworkRecord = detectFramework.detectFrameworks = detectFramework.detectFramework = void 0;
  const child_process_1 = require$$1__default$2.default;
  async function matches(fs2, framework) {
    const { detectors } = framework;
    if (!detectors)
      return;
    const { every: every2, some } = detectors;
    if (every2 !== void 0 && !Array.isArray(every2) || some !== void 0 && !Array.isArray(some))
      return;
    const check = async ({ path: path2, matchContent, matchPackage }) => {
      if (matchPackage && matchContent)
        throw new Error(`Cannot specify "matchPackage" and "matchContent" in the same detector for "${framework.slug}"`);
      if (matchPackage && path2)
        throw new Error(`Cannot specify "matchPackage" and "path" in the same detector for "${framework.slug}" because "path" is assumed to be "package.json".`);
      if (!path2 && !matchPackage)
        throw new Error(`Must specify either "path" or "matchPackage" in detector for "${framework.slug}".`);
      if (path2 || (path2 = "package.json"), matchPackage && (matchContent = `"(dev)?(d|D)ependencies":\\s*{[^}]*"${matchPackage}":\\s*"(.+?)"[^}]*}`), await fs2.hasPath(path2) !== !1) {
        if (matchContent) {
          if (await fs2.isFile(path2) === !1)
            return;
          const regex2 = new RegExp(matchContent, "m"), match2 = (await fs2.readFile(path2)).toString().match(regex2);
          if (!match2)
            return;
          if (matchPackage && match2[3])
            return {
              framework,
              detectedVersion: match2[3]
            };
        }
        return {
          framework
        };
      }
    }, result = [];
    if (every2) {
      const everyResult = await Promise.all(every2.map((item) => check(item)));
      result.push(...everyResult);
    }
    if (some) {
      let someResult;
      for (const item of some) {
        const itemResult = await check(item);
        if (itemResult) {
          someResult = itemResult;
          break;
        }
      }
      result.push(someResult);
    }
    if (!result.every((res) => !!res))
      return;
    const detectedVersion = result.find((r) => typeof r == "object" && r.detectedVersion)?.detectedVersion;
    return {
      framework,
      detectedVersion
    };
  }
  async function detectFramework$1({ fs: fs2, frameworkList }) {
    return (await Promise.all(frameworkList.map(async (frameworkMatch) => await matches(fs2, frameworkMatch) ? frameworkMatch.slug : null))).find((res) => res !== null) ?? null;
  }
  detectFramework.detectFramework = detectFramework$1;
  async function detectFrameworks({ fs: fs2, frameworkList }) {
    return (await Promise.all(frameworkList.map(async (frameworkMatch) => await matches(fs2, frameworkMatch) ? frameworkMatch : null))).filter((res) => res !== null);
  }
  detectFramework.detectFrameworks = detectFrameworks;
  async function detectFrameworkRecord({ fs: fs2, frameworkList }) {
    return (await Promise.all(frameworkList.map(async (frameworkMatch) => {
      const matchResult = await matches(fs2, frameworkMatch);
      return matchResult ? {
        ...frameworkMatch,
        detectedVersion: matchResult?.detectedVersion
      } : null;
    }))).find((res) => res !== null) ?? null;
  }
  detectFramework.detectFrameworkRecord = detectFrameworkRecord;
  function detectFrameworkVersion(frameworkRecord) {
    const firstMatchPackage = [
      ...frameworkRecord.detectors?.every || [],
      ...frameworkRecord.detectors?.some || []
    ].find((d) => d.matchPackage);
    if (firstMatchPackage?.matchPackage)
      return lookupInstalledVersion(process.execPath, firstMatchPackage.matchPackage);
  }
  detectFramework.detectFrameworkVersion = detectFrameworkVersion;
  function lookupInstalledVersion(cwd, packageName) {
    try {
      const script = `require('${packageName}/package.json').version`;
      return (0, child_process_1.spawnSync)(cwd, ["-p", script], {
        encoding: "utf-8"
      }).stdout.trim();
    } catch (error2) {
      console.debug(`Error looking up version of installed package "${packageName}": ${error2}`);
    }
  }
  return detectFramework;
}
var getProjectPaths = {}, hasRequiredGetProjectPaths;
function requireGetProjectPaths() {
  return hasRequiredGetProjectPaths || (hasRequiredGetProjectPaths = 1, function(exports2) {
    var __importDefault2 = getProjectPaths && getProjectPaths.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.getProjectPaths = void 0;
    const detect_framework_1 = requireDetectFramework(), frameworks_1 = __importDefault2(requireFrameworks()), MAX_DEPTH_TRAVERSE = 3, getProjectPaths$1 = async ({ fs: fs2, path: path2, skipPaths, depth = MAX_DEPTH_TRAVERSE }) => {
      if (depth === 0)
        return [];
      const allPaths = [], topPath = path2 ?? "./";
      if (path2 && skipPaths?.includes(path2))
        return allPaths;
      if (await (0, detect_framework_1.detectFramework)({
        fs: fs2.chdir(topPath),
        frameworkList: frameworks_1.default
      }) !== null && allPaths.push(topPath), depth > 1) {
        const childDirectories = (await fs2.readdir(topPath)).filter((stat2) => stat2.type === "dir" && !skipPaths?.includes(stat2.path));
        return [...(await Promise.all(childDirectories.map(({ path: path3 }) => (0, exports2.getProjectPaths)({
          fs: fs2,
          path: path3,
          depth: depth - 1,
          skipPaths
        })))).flat(), ...allPaths];
      }
      return allPaths;
    };
    exports2.getProjectPaths = getProjectPaths$1;
  }(getProjectPaths)), getProjectPaths;
}
var filesystem = {}, hasRequiredFilesystem;
function requireFilesystem() {
  if (hasRequiredFilesystem) return filesystem;
  hasRequiredFilesystem = 1, Object.defineProperty(filesystem, "__esModule", { value: !0 }), filesystem.DetectorFilesystem = void 0;
  const path_1 = require$$0__default.default;
  class DetectorFilesystem {
    constructor() {
      this.hasPath = async (path2) => {
        let p = this.pathCache.get(path2);
        return p || (p = this._hasPath(path2), this.pathCache.set(path2, p)), p;
      }, this.isFile = async (name) => {
        let p = this.fileCache.get(name);
        return p || (p = this._isFile(name), this.fileCache.set(name, p)), p;
      }, this.readFile = async (name) => {
        let p = this.readFileCache.get(name);
        return p || (p = this._readFile(name), this.readFileCache.set(name, p)), p;
      }, this.readdir = async (dirPath, options2) => {
        let p = this.readdirCache.get(dirPath);
        p || (p = this._readdir(dirPath), this.readdirCache.set(dirPath, p));
        const directoryContent = await p, directoryFiles = /* @__PURE__ */ new Set();
        for (const file of directoryContent)
          file.type === "file" && (this.fileCache.set(file.path, Promise.resolve(!0)), this.pathCache.set(file.path, Promise.resolve(!0)), directoryFiles.add(file.name));
        if (options2?.potentialFiles) {
          const filesThatDoNotExist = options2.potentialFiles.filter((path2) => !directoryFiles.has(path2));
          for (const filePath of filesThatDoNotExist) {
            const fullFilePath = dirPath === "/" ? filePath : path_1.posix.join(dirPath, filePath);
            this.fileCache.set(fullFilePath, Promise.resolve(!1)), this.pathCache.set(fullFilePath, Promise.resolve(!1));
          }
        }
        return p;
      }, this.chdir = (name) => this._chdir(name), this.writeFile = async (name, content) => {
        this.readFileCache.set(name, Promise.resolve(Buffer.from(content))), this.fileCache.set(name, Promise.resolve(!0)), this.pathCache.set(name, Promise.resolve(!0));
      }, this.pathCache = /* @__PURE__ */ new Map(), this.fileCache = /* @__PURE__ */ new Map(), this.readFileCache = /* @__PURE__ */ new Map(), this.readdirCache = /* @__PURE__ */ new Map();
    }
  }
  return filesystem.DetectorFilesystem = DetectorFilesystem, filesystem;
}
var localFileSystemDetector = {}, hasRequiredLocalFileSystemDetector;
function requireLocalFileSystemDetector() {
  if (hasRequiredLocalFileSystemDetector) return localFileSystemDetector;
  hasRequiredLocalFileSystemDetector = 1;
  var __importDefault2 = localFileSystemDetector && localFileSystemDetector.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(localFileSystemDetector, "__esModule", { value: !0 }), localFileSystemDetector.LocalFileSystemDetector = void 0;
  const promises_1 = __importDefault2(require$$0__default$9.default), path_1 = require$$0__default.default, filesystem_1 = requireFilesystem(), error_utils_1 = requireDist$1();
  class LocalFileSystemDetector extends filesystem_1.DetectorFilesystem {
    constructor(rootPath) {
      super(), this.rootPath = rootPath;
    }
    async _hasPath(name) {
      try {
        return await promises_1.default.stat(this.getFilePath(name)), !0;
      } catch (err) {
        if ((0, error_utils_1.isErrnoException)(err) && err.code === "ENOENT")
          return !1;
        throw err;
      }
    }
    _readFile(name) {
      return promises_1.default.readFile(this.getFilePath(name));
    }
    async _isFile(name) {
      return (await promises_1.default.stat(this.getFilePath(name))).isFile();
    }
    async _readdir(dir) {
      const dirPath = this.getFilePath(dir), files = await promises_1.default.readdir(dirPath);
      return Promise.all(files.map(async (name) => {
        const absPath = (0, path_1.join)(this.rootPath, dir, name), path2 = (0, path_1.join)(this.getRelativeFilePath(dir), name), stat2 = await promises_1.default.stat(absPath);
        let type2;
        if (stat2.isFile())
          type2 = "file";
        else if (stat2.isDirectory())
          type2 = "dir";
        else
          throw new Error(`Dirent was neither file nor directory: ${path2}`);
        return { name, path: path2, type: type2 };
      }));
    }
    _chdir(name) {
      return new LocalFileSystemDetector(this.getFilePath(name));
    }
    getRelativeFilePath(name) {
      return name.startsWith(this.rootPath) ? (0, path_1.relative)(this.rootPath, name) : name;
    }
    getFilePath(name) {
      return (0, path_1.join)(this.rootPath, this.getRelativeFilePath(name));
    }
  }
  return localFileSystemDetector.LocalFileSystemDetector = LocalFileSystemDetector, localFileSystemDetector;
}
var workspaceManagers = {}, hasRequiredWorkspaceManagers;
function requireWorkspaceManagers() {
  return hasRequiredWorkspaceManagers || (hasRequiredWorkspaceManagers = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.workspaceManagers = void 0, exports2.workspaceManagers = [
      {
        name: "Yarn",
        slug: "yarn",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
            },
            {
              path: "yarn.lock"
            }
          ]
        }
      },
      {
        name: "pnpm",
        slug: "pnpm",
        detectors: {
          every: [
            {
              path: "pnpm-workspace.yaml"
            }
          ]
        }
      },
      {
        name: "npm",
        slug: "npm",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
            },
            {
              path: "package-lock.json"
            }
          ]
        }
      },
      {
        name: "nx",
        slug: "nx",
        detectors: {
          every: [
            {
              path: "workspace.json",
              matchContent: '"projects":\\s*{[^}]'
            }
          ]
        }
      },
      {
        name: "rush",
        slug: "rush",
        detectors: {
          every: [
            {
              path: "rush.json"
            }
          ]
        }
      },
      {
        name: "default",
        slug: "yarn",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
            }
          ]
        }
      }
    ], exports2.default = exports2.workspaceManagers;
  }(workspaceManagers)), workspaceManagers;
}
var getWorkspaces = {}, hasRequiredGetWorkspaces;
function requireGetWorkspaces() {
  if (hasRequiredGetWorkspaces) return getWorkspaces;
  hasRequiredGetWorkspaces = 1;
  var __importDefault2 = getWorkspaces && getWorkspaces.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getWorkspaces, "__esModule", { value: !0 }), getWorkspaces.getWorkspaces = void 0;
  const path_1 = __importDefault2(require$$0__default.default), workspace_managers_1 = requireWorkspaceManagers(), detect_framework_1 = requireDetectFramework(), MAX_DEPTH_TRAVERSE = 3, posixPath = path_1.default.posix;
  async function getWorkspaces$1({ fs: fs2, depth = MAX_DEPTH_TRAVERSE, cwd = "/" }) {
    if (depth === 0)
      return [];
    const workspaceType = await (0, detect_framework_1.detectFramework)({
      fs: fs2,
      frameworkList: workspace_managers_1.workspaceManagers
    });
    if (workspaceType === null) {
      const childDirectories = (await fs2.readdir("./")).filter((stat2) => stat2.type === "dir");
      return (await Promise.all(childDirectories.map((childDirectory) => getWorkspaces$1({
        fs: fs2.chdir(childDirectory.path),
        depth: depth - 1,
        cwd: posixPath.join(cwd, childDirectory.path)
      })))).flat();
    }
    return [
      {
        type: workspaceType,
        rootPath: cwd
      }
    ];
  }
  return getWorkspaces.getWorkspaces = getWorkspaces$1, getWorkspaces;
}
var getWorkspacePackagePaths = {}, jsYaml$2 = {}, loader$1 = {}, common$2 = {}, hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2) return common$2;
  hasRequiredCommon$2 = 1;
  function isNothing(subject) {
    return typeof subject > "u" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject == "object" && subject !== null;
  }
  function toArray2(sequence) {
    return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
  }
  function extend(target, source2) {
    var index, length, key2, sourceKeys;
    if (source2)
      for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
        key2 = sourceKeys[index], target[key2] = source2[key2];
    return target;
  }
  function repeat2(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1)
      result += string;
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  return common$2.isNothing = isNothing, common$2.isObject = isObject2, common$2.toArray = toArray2, common$2.repeat = repeat2, common$2.isNegativeZero = isNegativeZero, common$2.extend = extend, common$2;
}
var exception$1, hasRequiredException$1;
function requireException$1() {
  if (hasRequiredException$1) return exception$1;
  hasRequiredException$1 = 1;
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    return exception2.mark ? (exception2.mark.name && (where += 'in "' + exception2.mark.name + '" '), where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")", !compact && exception2.mark.snippet && (where += `

` + exception2.mark.snippet), message + " " + where) : message;
  }
  function YAMLException(reason, mark2) {
    Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = formatError(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return YAMLException.prototype = Object.create(Error.prototype), YAMLException.prototype.constructor = YAMLException, YAMLException.prototype.toString = function(compact) {
    return this.name + ": " + formatError(this, compact);
  }, exception$1 = YAMLException, exception$1;
}
var snippet, hasRequiredSnippet;
function requireSnippet() {
  if (hasRequiredSnippet) return snippet;
  hasRequiredSnippet = 1;
  var common2 = requireCommon$2();
  function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
    var head = "", tail = "", maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    return position - lineStart > maxHalfLength && (head = " ... ", lineStart = position - maxHalfLength + head.length), lineEnd - position > maxHalfLength && (tail = " ...", lineEnd = position + maxHalfLength - tail.length), {
      str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max2) {
    return common2.repeat(" ", max2 - string.length) + string;
  }
  function makeSnippet(mark2, options2) {
    if (options2 = Object.create(options2 || null), !mark2.buffer) return null;
    options2.maxLength || (options2.maxLength = 79), typeof options2.indent != "number" && (options2.indent = 1), typeof options2.linesBefore != "number" && (options2.linesBefore = 3), typeof options2.linesAfter != "number" && (options2.linesAfter = 2);
    for (var re = /\r?\n|\r|\0/g, lineStarts = [0], lineEnds = [], match2, foundLineNo = -1; match2 = re.exec(mark2.buffer); )
      lineEnds.push(match2.index), lineStarts.push(match2.index + match2[0].length), mark2.position <= match2.index && foundLineNo < 0 && (foundLineNo = lineStarts.length - 2);
    foundLineNo < 0 && (foundLineNo = lineStarts.length - 1);
    var result = "", i, line3, lineNoLength = Math.min(mark2.line + options2.linesAfter, lineEnds.length).toString().length, maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
    for (i = 1; i <= options2.linesBefore && !(foundLineNo - i < 0); i++)
      line3 = getLine(
        mark2.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      ), result = common2.repeat(" ", options2.indent) + padStart((mark2.line - i + 1).toString(), lineNoLength) + " | " + line3.str + `
` + result;
    for (line3 = getLine(mark2.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark2.position, maxLineLength), result += common2.repeat(" ", options2.indent) + padStart((mark2.line + 1).toString(), lineNoLength) + " | " + line3.str + `
`, result += common2.repeat("-", options2.indent + lineNoLength + 3 + line3.pos) + `^
`, i = 1; i <= options2.linesAfter && !(foundLineNo + i >= lineEnds.length); i++)
      line3 = getLine(
        mark2.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      ), result += common2.repeat(" ", options2.indent) + padStart((mark2.line + i + 1).toString(), lineNoLength) + " | " + line3.str + `
`;
    return result.replace(/\n$/, "");
  }
  return snippet = makeSnippet, snippet;
}
var type$1, hasRequiredType$1;
function requireType$1() {
  if (hasRequiredType$1) return type$1;
  hasRequiredType$1 = 1;
  var YAMLException = requireException$1(), TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    return map2 !== null && Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    }), result;
  }
  function Type(tag, options2) {
    if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }), this.options = options2, this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
      return !0;
    }, this.construct = options2.construct || function(data) {
      return data;
    }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.representName = options2.representName || null, this.defaultStyle = options2.defaultStyle || null, this.multi = options2.multi || !1, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
  return type$1 = Type, type$1;
}
var schema$1, hasRequiredSchema$1;
function requireSchema$1() {
  if (hasRequiredSchema$1) return schema$1;
  hasRequiredSchema$1 = 1;
  var YAMLException = requireException$1(), Type = requireType$1();
  function compileList(schema2, name) {
    var result = [];
    return schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi && (newIndex = previousIndex);
      }), result[newIndex] = currentType;
    }), result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      type2.multi ? (result.multi[type2.kind].push(type2), result.multi.fallback.push(type2)) : result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
    }
    for (index = 0, length = arguments.length; index < length; index += 1)
      arguments[index].forEach(collectType);
    return result;
  }
  function Schema(definition) {
    return this.extend(definition);
  }
  return Schema.prototype.extend = function(definition) {
    var implicit = [], explicit = [];
    if (definition instanceof Type)
      explicit.push(definition);
    else if (Array.isArray(definition))
      explicit = explicit.concat(definition);
    else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit)))
      definition.implicit && (implicit = implicit.concat(definition.implicit)), definition.explicit && (explicit = explicit.concat(definition.explicit));
    else
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    implicit.forEach(function(type2) {
      if (!(type2 instanceof Type))
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (type2.loadKind && type2.loadKind !== "scalar")
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (type2.multi)
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), explicit.forEach(function(type2) {
      if (!(type2 instanceof Type))
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var result = Object.create(Schema.prototype);
    return result.implicit = (this.implicit || []).concat(implicit), result.explicit = (this.explicit || []).concat(explicit), result.compiledImplicit = compileList(result, "implicit"), result.compiledExplicit = compileList(result, "explicit"), result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit), result;
  }, schema$1 = Schema, schema$1;
}
var str$1, hasRequiredStr$1;
function requireStr$1() {
  if (hasRequiredStr$1) return str$1;
  hasRequiredStr$1 = 1;
  var Type = requireType$1();
  return str$1 = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  }), str$1;
}
var seq$1, hasRequiredSeq$1;
function requireSeq$1() {
  if (hasRequiredSeq$1) return seq$1;
  hasRequiredSeq$1 = 1;
  var Type = requireType$1();
  return seq$1 = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  }), seq$1;
}
var map$2, hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1) return map$2;
  hasRequiredMap$1 = 1;
  var Type = requireType$1();
  return map$2 = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  }), map$2;
}
var failsafe$1, hasRequiredFailsafe$1;
function requireFailsafe$1() {
  if (hasRequiredFailsafe$1) return failsafe$1;
  hasRequiredFailsafe$1 = 1;
  var Schema = requireSchema$1();
  return failsafe$1 = new Schema({
    explicit: [
      requireStr$1(),
      requireSeq$1(),
      requireMap$1()
    ]
  }), failsafe$1;
}
var _null$1, hasRequired_null$1;
function require_null$1() {
  if (hasRequired_null$1) return _null$1;
  hasRequired_null$1 = 1;
  var Type = requireType$1();
  function resolveYamlNull(data) {
    if (data === null) return !0;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  return _null$1 = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  }), _null$1;
}
var bool$1, hasRequiredBool$1;
function requireBool$1() {
  if (hasRequiredBool$1) return bool$1;
  hasRequiredBool$1 = 1;
  var Type = requireType$1();
  function resolveYamlBoolean(data) {
    if (data === null) return !1;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  return bool$1 = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), bool$1;
}
var int$1, hasRequiredInt$1;
function requireInt$1() {
  if (hasRequiredInt$1) return int$1;
  hasRequiredInt$1 = 1;
  var common2 = requireCommon$2(), Type = requireType$1();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return !1;
    var max2 = data.length, index = 0, hasDigits = !1, ch;
    if (!max2) return !1;
    if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
      if (index + 1 === max2) return !0;
      if (ch = data[++index], ch === "b") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (ch !== "0" && ch !== "1") return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isHexCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isOctCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return !1;
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (!isDecCode(data.charCodeAt(index)))
          return !1;
        hasDigits = !0;
      }
    return !(!hasDigits || ch === "_");
  }
  function constructYamlInteger(data) {
    var value = data, sign2 = 1, ch;
    if (value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign2 * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign2 * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign2 * parseInt(value.slice(2), 8);
    }
    return sign2 * parseInt(value, 10);
  }
  function isInteger2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common2.isNegativeZero(object);
  }
  return int$1 = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), int$1;
}
var float$1, hasRequiredFloat$1;
function requireFloat$1() {
  if (hasRequiredFloat$1) return float$1;
  hasRequiredFloat$1 = 1;
  var common2 = requireCommon$2(), Type = requireType$1(), YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_");
  }
  function constructYamlFloat(data) {
    var value, sign2;
    return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : sign2 * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object))
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (common2.isNegativeZero(object))
      return "-0.0";
    return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  return float$1 = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  }), float$1;
}
var json$1, hasRequiredJson$1;
function requireJson$1() {
  return hasRequiredJson$1 || (hasRequiredJson$1 = 1, json$1 = requireFailsafe$1().extend({
    implicit: [
      require_null$1(),
      requireBool$1(),
      requireInt$1(),
      requireFloat$1()
    ]
  })), json$1;
}
var core$4, hasRequiredCore$4;
function requireCore$4() {
  return hasRequiredCore$4 || (hasRequiredCore$4 = 1, core$4 = requireJson$1()), core$4;
}
var timestamp$2, hasRequiredTimestamp$1;
function requireTimestamp$1() {
  if (hasRequiredTimestamp$1) return timestamp$2;
  hasRequiredTimestamp$1 = 1;
  var Type = requireType$1(), YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null) throw new Error("Date resolve error");
    if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
      return new Date(Date.UTC(year, month, day));
    if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
      for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
        fraction += "0";
      fraction = +fraction;
    }
    return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  return timestamp$2 = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  }), timestamp$2;
}
var merge$3, hasRequiredMerge$1;
function requireMerge$1() {
  if (hasRequiredMerge$1) return merge$3;
  hasRequiredMerge$1 = 1;
  var Type = requireType$1();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  return merge$3 = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  }), merge$3;
}
var binary$2, hasRequiredBinary$1;
function requireBinary$1() {
  if (hasRequiredBinary$1) return binary$2;
  hasRequiredBinary$1 = 1;
  var Type = requireType$1(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null) return !1;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
        if (code < 0) return !1;
        bitlen += 6;
      }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++)
      idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
    return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
    return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  return binary$2 = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  }), binary$2;
}
var omap$1, hasRequiredOmap$1;
function requireOmap$1() {
  if (hasRequiredOmap$1) return omap$1;
  hasRequiredOmap$1 = 1;
  var Type = requireType$1(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return !0;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]") return !1;
      for (pairKey in pair)
        if (_hasOwnProperty.call(pair, pairKey))
          if (!pairHasKey) pairHasKey = !0;
          else return !1;
      if (!pairHasKey) return !1;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return !1;
    }
    return !0;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  return omap$1 = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  }), omap$1;
}
var pairs$2, hasRequiredPairs$1;
function requirePairs$1() {
  if (hasRequiredPairs$1) return pairs$2;
  hasRequiredPairs$1 = 1;
  var Type = requireType$1(), _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return !0;
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return !0;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
      pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
    return result;
  }
  return pairs$2 = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  }), pairs$2;
}
var set$1, hasRequiredSet$1;
function requireSet$1() {
  if (hasRequiredSet$1) return set$1;
  hasRequiredSet$1 = 1;
  var Type = requireType$1(), _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return !0;
    var key2, object = data;
    for (key2 in object)
      if (_hasOwnProperty.call(object, key2) && object[key2] !== null)
        return !1;
    return !0;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  return set$1 = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  }), set$1;
}
var _default, hasRequired_default;
function require_default() {
  return hasRequired_default || (hasRequired_default = 1, _default = requireCore$4().extend({
    implicit: [
      requireTimestamp$1(),
      requireMerge$1()
    ],
    explicit: [
      requireBinary$1(),
      requireOmap$1(),
      requirePairs$1(),
      requireSet$1()
    ]
  })), _default;
}
var hasRequiredLoader$1;
function requireLoader$1() {
  if (hasRequiredLoader$1) return loader$1;
  hasRequiredLoader$1 = 1;
  var common2 = requireCommon$2(), YAMLException = requireException$1(), makeSnippet = requireSnippet(), DEFAULT_SCHEMA = require_default(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
  }
  function escapedHexLen(c2) {
    return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
  }
  function fromDecimalCode(c2) {
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  for (var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++)
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
  function State(input2, options2) {
    this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_SCHEMA, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function generateError(state, message) {
    var mark2 = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    return mark2.snippet = makeSnippet(mark2), new YAMLException(message, mark2);
  }
  function throwError2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    state.onWarning && state.onWarning.call(null, generateError(state, message));
  }
  var directiveHandlers = {
    YAML: function(state, name, args) {
      var match2, major2, minor2;
      state.version !== null && throwError2(state, "duplication of %YAML directive"), args.length !== 1 && throwError2(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError2(state, "ill-formed argument of the YAML directive"), major2 = parseInt(match2[1], 10), minor2 = parseInt(match2[2], 10), major2 !== 1 && throwError2(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor2 < 2, minor2 !== 1 && minor2 !== 2 && throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function(state, name, args) {
      var handle, prefix;
      args.length !== 2 && throwError2(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError2(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        prefix = decodeURIComponent(prefix);
      } catch {
        throwError2(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      if (_result = state.input.slice(start, end), checkJson)
        for (_position = 0, _length = _result.length; _position < _length; _position += 1)
          _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError2(state, "expected valid JSON character");
      else PATTERN_NON_PRINTABLE.test(_result) && throwError2(state, "the stream contains non-printable characters");
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source2, overridableKeys) {
    var sourceKeys, key2, index, quantity;
    for (common2.isObject(source2) || throwError2(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
      key2 = sourceKeys[index], _hasOwnProperty.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode))
      for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
        Array.isArray(keyNode[index]) && throwError2(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
    if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
      if (Array.isArray(valueNode))
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
          mergeMappings(state, _result, valueNode[index], overridableKeys);
      else
        mergeMappings(state, _result, valueNode, overridableKeys);
    else
      !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.lineStart = startLineStart || state.lineStart, state.position = startPos || state.position, throwError2(state, "duplicated mapping key")), keyNode === "__proto__" ? Object.defineProperty(_result, keyNode, {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: valueNode
      }) : _result[keyNode] = valueNode, delete overridableKeys[keyNode];
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError2(state, "a line break is expected"), state.line += 1, state.lineStart = state.position, state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch === 9 && state.firstTabInLine === -1 && (state.firstTabInLine = state.position), ch = state.input.charCodeAt(++state.position);
      if (allowComments && ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 10 && ch !== 13 && ch !== 0);
      if (is_EOL(ch))
        for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      else
        break;
    }
    return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
  }
  function writeFoldedLines(state, count2) {
    count2 === 1 ? state.result += " " : count2 > 1 && (state.result += common2.repeat(`
`, count2 - 1));
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
      return !1;
    for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
      if (ch === 58) {
        if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
          break;
      } else if (ch === 35) {
        if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
          break;
      } else {
        if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
          break;
        if (is_EOL(ch))
          if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
            hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
            break;
          }
      }
      hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
    }
    return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    if (ch = state.input.charCodeAt(state.position), ch !== 39)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
      if (ch === 39)
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
          captureStart = state.position, state.position++, captureEnd = state.position;
        else
          return !0;
      else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
    throwError2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 34)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
      if (ch === 34)
        return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
      if (ch === 92) {
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
          skipSeparationSpace(state, !1, nodeIndent);
        else if (ch < 256 && simpleEscapeCheck[ch])
          state.result += simpleEscapeMap[ch], state.position++;
        else if ((tmp2 = escapedHexLen(ch)) > 0) {
          for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
            ch = state.input.charCodeAt(++state.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError2(state, "expected hexadecimal character");
          state.result += charFromCodepoint(hexResult), state.position++;
        } else
          throwError2(state, "unknown escape sequence");
        captureStart = captureEnd = state.position;
      } else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
    }
    throwError2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = !0, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 91)
      terminator = 93, isMapping = !1, _result = [];
    else if (ch === 123)
      terminator = 125, isMapping = !0, _result = {};
    else
      return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
      if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
        return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
      readNext ? ch === 44 && throwError2(state, "expected the node content, but found ','") : throwError2(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, _lineStart = state.lineStart, _pos = state.position, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
    }
    throwError2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 124)
      folding = !1;
    else if (ch === 62)
      folding = !0;
    else
      return !1;
    for (state.kind = "scalar", state.result = ""; ch !== 0; )
      if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
        CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError2(state, "repeat of a chomping mode identifier");
      else if ((tmp2 = fromDecimalCode(ch)) >= 0)
        tmp2 === 0 ? throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError2(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
      else
        break;
    if (is_WHITE_SPACE(ch)) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (is_WHITE_SPACE(ch));
      if (ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    for (; ch !== 0; ) {
      for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        chomping === CHOMPING_KEEP ? state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
        break;
      }
      for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common2.repeat(`
`, emptyLines) : state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
        ch = state.input.charCodeAt(++state.position);
      captureSegment(state, captureStart, state.position, !1);
    }
    return !0;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
    if (state.firstTabInLine !== -1) return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && (state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError2(state, "tab characters must not be used in indentation")), !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following)))); ) {
      if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
        _result.push(null), ch = state.input.charCodeAt(state.position);
        continue;
      }
      if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a sequence entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
    if (state.firstTabInLine !== -1) return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      if (!atExplicitKey && state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError2(state, "tab characters must not be used in indentation")), following = state.input.charCodeAt(state.position + 1), _line = state.line, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
        ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
      else {
        if (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position, !composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
          break;
        if (state.line === _line) {
          for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 58)
            ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
          else if (detected)
            throwError2(state, "can not read an implicit mapping pair; a colon is missed");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        } else if (detected)
          throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && (atExplicitKey && (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position), composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a mapping entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 33) return !1;
    if (state.tag !== null && throwError2(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 0 && ch !== 62);
      state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError2(state, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch === 33 && (isNamed ? throwError2(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError2(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
      tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError2(state, "tag suffix cannot contain flow indicator characters");
    }
    tagName && !PATTERN_TAG_URI.test(tagName) && throwError2(state, "tag name cannot contain such characters: " + tagName);
    try {
      tagName = decodeURIComponent(tagName);
    } catch {
      throwError2(state, "tag name is malformed: " + tagName);
    }
    return isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError2(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 38) return !1;
    for (state.anchor !== null && throwError2(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
  }
  function readAlias(state) {
    var _position, alias, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 42) return !1;
    for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty.call(state.anchorMap, alias) || throwError2(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
      for (; readTagProperty(state) || readAnchorProperty(state); )
        skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
    if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError2(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag === null)
      state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
    else if (state.tag === "?") {
      for (state.result !== null && state.kind !== "scalar" && throwError2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
        if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
          state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
          break;
        }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag))
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      else
        for (type2 = null, typeList = state.typeMap.multi[state.kind || "fallback"], typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
      type2 || throwError2(state, "unknown tag !<" + state.tag + ">"), state.result !== null && type2.kind !== state.kind && throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result, state.tag) ? (state.result = type2.construct(state.result, state.tag), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    }
    return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
    for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = /* @__PURE__ */ Object.create(null), state.anchorMap = /* @__PURE__ */ Object.create(null); (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
      for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError2(state, "directive name must not be less than one character in length"); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 35) {
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError2(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
      state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
      return;
    }
    if (state.position < state.length - 1)
      throwError2(state, "end of the stream or a document separator is expected");
    else
      return;
  }
  function loadDocuments(input2, options2) {
    input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
    var state = new State(input2, options2), nullpos = input2.indexOf("\0");
    for (nullpos !== -1 && (state.position = nullpos, throwError2(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
      state.lineIndent += 1, state.position += 1;
    for (; state.position < state.length - 1; )
      readDocument(state);
    return state.documents;
  }
  function loadAll(input2, iterator2, options2) {
    iterator2 !== null && typeof iterator2 == "object" && typeof options2 > "u" && (options2 = iterator2, iterator2 = null);
    var documents = loadDocuments(input2, options2);
    if (typeof iterator2 != "function")
      return documents;
    for (var index = 0, length = documents.length; index < length; index += 1)
      iterator2(documents[index]);
  }
  function load2(input2, options2) {
    var documents = loadDocuments(input2, options2);
    if (documents.length !== 0) {
      if (documents.length === 1)
        return documents[0];
      throw new YAMLException("expected a single document in the stream, but found more");
    }
  }
  return loader$1.loadAll = loadAll, loader$1.load = load2, loader$1;
}
var dumper$1 = {}, hasRequiredDumper$1;
function requireDumper$1() {
  if (hasRequiredDumper$1) return dumper$1;
  hasRequiredDumper$1 = 1;
  var common2 = requireCommon$2(), YAMLException = requireException$1(), DEFAULT_SCHEMA = require_default(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_BOM = 65279, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA2 = 44, CHAR_MINUS = 45, CHAR_COLON2 = 58, CHAR_EQUALS2 = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
      tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    if (string = character.toString(16).toUpperCase(), character <= 255)
      handle = "x", length = 2;
    else if (character <= 65535)
      handle = "u", length = 4;
    else if (character <= 4294967295)
      handle = "U", length = 8;
    else
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options2) {
    this.schema = options2.schema || DEFAULT_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common2.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.quotingType = options2.quotingType === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE, this.forceQuotes = options2.forceQuotes || !1, this.replacer = typeof options2.replacer == "function" ? options2.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    for (var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
      next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
      if (type2 = state.implicitTypes[index], type2.resolve(str2))
        return !0;
    return !1;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsCharOrWhitespace(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2), cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON2 && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON2 && cIsNsChar
    );
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS2 && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c2) {
    return !isWhitespace(c2) && c2 !== CHAR_COLON2;
  }
  function codePointAt(string, pos2) {
    var first2 = string.charCodeAt(pos2), second;
    return first2 >= 55296 && first2 <= 56319 && pos2 + 1 < string.length && (second = string.charCodeAt(pos2 + 1), second >= 56320 && second <= 57343) ? (first2 - 55296) * 1024 + second - 56320 + 65536 : first2;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i, char = 0, prevChar = null, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes)
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        if (char = codePointAt(string, i), !isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char, prevChar, inblock), prevChar = char;
      }
    else {
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        if (char = codePointAt(string, i), char === CHAR_LINE_FEED)
          hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
        else if (!isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char, prevChar, inblock), prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    return !hasLineBreak && !hasFoldableLine ? plain && !forceQuotes && !testAmbiguousType(string) ? STYLE_PLAIN : quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : forceQuotes ? quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0)
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      if (!state.noCompatMode && (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)))
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
      var nextLF = string.indexOf(`
`);
      return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
    }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
      var prefix = match2[1], line3 = match2[2];
      moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line3, width) {
    if (line3 === "" || line3[0] === " ") return line3;
    for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line3); )
      next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line3.slice(start, end), start = end + 1), curr = next;
    return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
  }
  function escapeString(string) {
    for (var result = "", char = 0, escapeSeq, i = 0; i < string.length; char >= 65536 ? i += 2 : i++)
      char = codePointAt(string, i), escapeSeq = ESCAPE_SEQUENCES[char], !escapeSeq && isPrintable(char) ? (result += string[i], char >= 65536 && (result += string[i + 1])) : result += escapeSeq || encodeHex(char);
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1)
      value = object[index], state.replacer && (value = state.replacer.call(object, String(index), value)), (writeNode(state, level, value, !1, !1) || typeof value > "u" && writeNode(state, level, null, !1, !1)) && (_result !== "" && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
    state.tag = _tag, state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1)
      value = object[index], state.replacer && (value = state.replacer.call(object, String(index), value)), (writeNode(state, level + 1, value, !0, !0, !1, !0) || typeof value > "u" && writeNode(state, level + 1, null, !0, !0, !1, !0)) && ((!compact || _result !== "") && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
    state.tag = _tag, state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", _result !== "" && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], state.replacer && (objectValue = state.replacer.call(object, objectKey, objectValue)), writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === !0)
      objectKeyList.sort();
    else if (typeof state.sortKeys == "function")
      objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys)
      throw new YAMLException("sortKeys must be a boolean or a function");
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", (!compact || _result !== "") && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], state.replacer && (objectValue = state.replacer.call(object, objectKey, objectValue)), writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
      if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit ? type2.multi && type2.representName ? state.tag = type2.representName(object) : state.tag = type2.tag : state.tag = "?", type2.represent) {
          if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
            _result = type2.represent(object, style);
          else if (_hasOwnProperty.call(type2.represent, style))
            _result = type2.represent[style](object, style);
          else
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          state.dump = _result;
        }
        return !0;
      }
    return !1;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
    var type2 = _toString.call(state.dump), inblock = block, tagStr;
    block && (block = state.flowLevel < 0 || state.flowLevel > level);
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
      state.dump = "*ref_" + duplicateIndex;
    else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
        block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object Array]")
        block && state.dump.length !== 0 ? (state.noArrayIndent && !isblockseq && level > 0 ? writeBlockSequence(state, level - 1, state.dump, compact) : writeBlockSequence(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object String]")
        state.tag !== "?" && writeScalar(state, state.dump, level, iskey, inblock);
      else {
        if (type2 === "[object Undefined]")
          return !1;
        if (state.skipInvalid) return !1;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      state.tag !== null && state.tag !== "?" && (tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21"), state.tag[0] === "!" ? tagStr = "!" + tagStr : tagStr.slice(0, 18) === "tag:yaml.org,2002:" ? tagStr = "!!" + tagStr.slice(18) : tagStr = "!<" + tagStr + ">", state.dump = tagStr + " " + state.dump);
    }
    return !0;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object == "object")
      if (index = objects.indexOf(object), index !== -1)
        duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
      else if (objects.push(object), Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          inspectNode(object[index], objects, duplicatesIndexes);
      else
        for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
  }
  function dump(input2, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    state.noRefs || getDuplicateReferences(input2, state);
    var value = input2;
    return state.replacer && (value = state.replacer.call({ "": value }, "", value)), writeNode(state, 0, value, !0, !0) ? state.dump + `
` : "";
  }
  return dumper$1.dump = dump, dumper$1;
}
var hasRequiredJsYaml$2;
function requireJsYaml$2() {
  if (hasRequiredJsYaml$2) return jsYaml$2;
  hasRequiredJsYaml$2 = 1;
  var loader2 = requireLoader$1(), dumper2 = requireDumper$1();
  function renamed(from2, to) {
    return function() {
      throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  return jsYaml$2.Type = requireType$1(), jsYaml$2.Schema = requireSchema$1(), jsYaml$2.FAILSAFE_SCHEMA = requireFailsafe$1(), jsYaml$2.JSON_SCHEMA = requireJson$1(), jsYaml$2.CORE_SCHEMA = requireCore$4(), jsYaml$2.DEFAULT_SCHEMA = require_default(), jsYaml$2.load = loader2.load, jsYaml$2.loadAll = loader2.loadAll, jsYaml$2.dump = dumper2.dump, jsYaml$2.YAMLException = requireException$1(), jsYaml$2.types = {
    binary: requireBinary$1(),
    float: requireFloat$1(),
    map: requireMap$1(),
    null: require_null$1(),
    pairs: requirePairs$1(),
    set: requireSet$1(),
    timestamp: requireTimestamp$1(),
    bool: requireBool$1(),
    int: requireInt$1(),
    merge: requireMerge$1(),
    omap: requireOmap$1(),
    seq: requireSeq$1(),
    str: requireStr$1()
  }, jsYaml$2.safeLoad = renamed("safeLoad", "load"), jsYaml$2.safeLoadAll = renamed("safeLoadAll", "loadAll"), jsYaml$2.safeDump = renamed("safeDump", "dump"), jsYaml$2;
}
var old = {}, hasRequiredOld;
function requireOld() {
  if (hasRequiredOld) return old;
  hasRequiredOld = 1;
  var pathModule = require$$0__default.default, isWindows = process.platform === "win32", fs2 = require$$0__default$1.default, DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      err && (backtrace.message = err.message, err = backtrace, missingCallback(err));
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          process.traceDeprecation ? console.trace(msg) : console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb == "function" ? cb : rethrow();
  }
  if (isWindows)
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  else
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  if (isWindows)
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  else
    var splitRootRe = /^[\/]*/;
  return old.realpathSync = function(p, cache) {
    if (p = pathModule.resolve(p), cache && Object.prototype.hasOwnProperty.call(cache, p))
      return cache[p];
    var original = p, seenLinks = {}, knownHard = {}, pos2, current, base2, previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos2 = m[0].length, current = m[0], base2 = m[0], previous = "", isWindows && !knownHard[base2] && (fs2.lstatSync(base2), knownHard[base2] = !0);
    }
    for (; pos2 < p.length; ) {
      nextPartRe.lastIndex = pos2;
      var result = nextPartRe.exec(p);
      if (previous = current, current += result[0], base2 = previous + result[1], pos2 = nextPartRe.lastIndex, !(knownHard[base2] || cache && cache[base2] === base2)) {
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2))
          resolvedLink = cache[base2];
        else {
          var stat2 = fs2.lstatSync(base2);
          if (!stat2.isSymbolicLink()) {
            knownHard[base2] = !0, cache && (cache[base2] = base2);
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            seenLinks.hasOwnProperty(id) && (linkTarget = seenLinks[id]);
          }
          linkTarget === null && (fs2.statSync(base2), linkTarget = fs2.readlinkSync(base2)), resolvedLink = pathModule.resolve(previous, linkTarget), cache && (cache[base2] = resolvedLink), isWindows || (seenLinks[id] = linkTarget);
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos2)), start();
      }
    }
    return cache && (cache[original] = p), p;
  }, old.realpath = function(p, cache, cb) {
    if (typeof cb != "function" && (cb = maybeCallback(cache), cache = null), p = pathModule.resolve(p), cache && Object.prototype.hasOwnProperty.call(cache, p))
      return process.nextTick(cb.bind(null, null, cache[p]));
    var original = p, seenLinks = {}, knownHard = {}, pos2, current, base2, previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos2 = m[0].length, current = m[0], base2 = m[0], previous = "", isWindows && !knownHard[base2] ? fs2.lstat(base2, function(err) {
        if (err) return cb(err);
        knownHard[base2] = !0, LOOP();
      }) : process.nextTick(LOOP);
    }
    function LOOP() {
      if (pos2 >= p.length)
        return cache && (cache[original] = p), cb(null, p);
      nextPartRe.lastIndex = pos2;
      var result = nextPartRe.exec(p);
      return previous = current, current += result[0], base2 = previous + result[1], pos2 = nextPartRe.lastIndex, knownHard[base2] || cache && cache[base2] === base2 ? process.nextTick(LOOP) : cache && Object.prototype.hasOwnProperty.call(cache, base2) ? gotResolvedLink(cache[base2]) : fs2.lstat(base2, gotStat);
    }
    function gotStat(err, stat2) {
      if (err) return cb(err);
      if (!stat2.isSymbolicLink())
        return knownHard[base2] = !0, cache && (cache[base2] = base2), process.nextTick(LOOP);
      if (!isWindows) {
        var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
        if (seenLinks.hasOwnProperty(id))
          return gotTarget(null, seenLinks[id], base2);
      }
      fs2.stat(base2, function(err2) {
        if (err2) return cb(err2);
        fs2.readlink(base2, function(err3, target) {
          isWindows || (seenLinks[id] = target), gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base3) {
      if (err) return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      cache && (cache[base3] = resolvedLink), gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos2)), start();
    }
  }, old;
}
var fs_realpath, hasRequiredFs_realpath;
function requireFs_realpath() {
  if (hasRequiredFs_realpath) return fs_realpath;
  hasRequiredFs_realpath = 1, fs_realpath = realpath, realpath.realpath = realpath, realpath.sync = realpathSync2, realpath.realpathSync = realpathSync2, realpath.monkeypatch = monkeypatch, realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require$$0__default$1.default, origRealpath = fs2.realpath, origRealpathSync = fs2.realpathSync, version2 = process.version, ok = /^v[0-5]\./.test(version2), old2 = requireOld();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok)
      return origRealpath(p, cache, cb);
    typeof cache == "function" && (cb = cache, cache = null), origRealpath(p, cache, function(er, result) {
      newError(er) ? old2.realpath(p, cache, cb) : cb(er, result);
    });
  }
  function realpathSync2(p, cache) {
    if (ok)
      return origRealpathSync(p, cache);
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er))
        return old2.realpathSync(p, cache);
      throw er;
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath, fs2.realpathSync = realpathSync2;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath, fs2.realpathSync = origRealpathSync;
  }
  return fs_realpath;
}
var path$2, hasRequiredPath$1;
function requirePath$1() {
  return hasRequiredPath$1 || (hasRequiredPath$1 = 1, path$2 = typeof process == "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" }), path$2;
}
var braceExpansion, hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str2) {
    return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
  }
  function escapeBraces(str2) {
    return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str2) {
    return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str2) {
    if (!str2)
      return [""];
    var parts = [], m = balanced("{", "}", str2);
    if (!m)
      return str2.split(",");
    var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
  }
  function expandTop(str2) {
    return str2 ? (str2.substr(0, 2) === "{}" && (str2 = "\\{\\}" + str2.substr(2)), expand2(escapeBraces(str2), !0).map(unescapeBraces)) : [];
  }
  function embrace(str2) {
    return "{" + str2 + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand2(str2, isTop) {
    var expansions = [], m = balanced("{", "}", str2);
    if (!m) return [str2];
    var pre = m.pre, post = m.post.length ? expand2(m.post, !1) : [""];
    if (/\$$/.test(m.pre))
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions)
        return m.post.match(/,.*\}/) ? (str2 = m.pre + "{" + m.body + escClose + m.post, expand2(str2)) : [str2];
      var n;
      if (isSequence)
        n = m.body.split(/\.\./);
      else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand2(n[0], !1).map(embrace), n.length === 1))
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      var N;
      if (isSequence) {
        var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
        reverse && (incr *= -1, test = gte);
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c2;
          if (isAlphaSequence)
            c2 = String.fromCharCode(i), c2 === "\\" && (c2 = "");
          else if (c2 = String(i), pad) {
            var need = width - c2.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              i < 0 ? c2 = "-" + z + c2.slice(1) : c2 = z + c2;
            }
          }
          N.push(c2);
        }
      } else {
        N = [];
        for (var j = 0; j < n.length; j++)
          N.push.apply(N, expand2(n[j], !1));
      }
      for (var j = 0; j < N.length; j++)
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          (!isTop || isSequence || expansion) && expansions.push(expansion);
        }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1, hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  const minimatch2 = minimatch_1 = (p, pattern, options2 = {}) => (assertValidPattern2(pattern), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch2(pattern, options2).match(p));
  minimatch_1 = minimatch2;
  const path2 = requirePath$1();
  minimatch2.sep = path2.sep;
  const GLOBSTAR2 = Symbol("globstar **");
  minimatch2.GLOBSTAR = GLOBSTAR2;
  const expand2 = requireBraceExpansion(), plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, qmark2 = "[^/]", star3 = qmark2 + "*?", twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?", charSet = (s) => s.split("").reduce((set2, c2) => (set2[c2] = !0, set2), {}), reSpecials2 = charSet("().*{}+?[]^$\\!"), addPatternStartSet = charSet("[.("), slashSplit = /\/+/;
  minimatch2.filter = (pattern, options2 = {}) => (p, i, list2) => minimatch2(p, pattern, options2);
  const ext2 = (a, b = {}) => {
    const t = {};
    return Object.keys(a).forEach((k) => t[k] = a[k]), Object.keys(b).forEach((k) => t[k] = b[k]), t;
  };
  minimatch2.defaults = (def) => {
    if (!def || typeof def != "object" || !Object.keys(def).length)
      return minimatch2;
    const orig = minimatch2, m = (p, pattern, options2) => orig(p, pattern, ext2(def, options2));
    return m.Minimatch = class extends orig.Minimatch {
      constructor(pattern, options2) {
        super(pattern, ext2(def, options2));
      }
    }, m.Minimatch.defaults = (options2) => orig.defaults(ext2(def, options2)).Minimatch, m.filter = (pattern, options2) => orig.filter(pattern, ext2(def, options2)), m.defaults = (options2) => orig.defaults(ext2(def, options2)), m.makeRe = (pattern, options2) => orig.makeRe(pattern, ext2(def, options2)), m.braceExpand = (pattern, options2) => orig.braceExpand(pattern, ext2(def, options2)), m.match = (list2, pattern, options2) => orig.match(list2, pattern, ext2(def, options2)), m;
  }, minimatch2.braceExpand = (pattern, options2) => braceExpand2(pattern, options2);
  const braceExpand2 = (pattern, options2 = {}) => (assertValidPattern2(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand2(pattern)), MAX_PATTERN_LENGTH2 = 1024 * 64, assertValidPattern2 = (pattern) => {
    if (typeof pattern != "string")
      throw new TypeError("invalid pattern");
    if (pattern.length > MAX_PATTERN_LENGTH2)
      throw new TypeError("pattern is too long");
  }, SUBPARSE = Symbol("subparse");
  minimatch2.makeRe = (pattern, options2) => new Minimatch2(pattern, options2 || {}).makeRe(), minimatch2.match = (list2, pattern, options2 = {}) => {
    const mm = new Minimatch2(pattern, options2);
    return list2 = list2.filter((f) => mm.match(f)), mm.options.nonull && !list2.length && list2.push(pattern), list2;
  };
  const globUnescape = (s) => s.replace(/\\(.)/g, "$1"), charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1"), regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
  class Minimatch2 {
    constructor(pattern, options2) {
      assertValidPattern2(pattern), options2 || (options2 = {}), this.options = options2, this.set = [], this.pattern = pattern, this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.make();
    }
    debug() {
    }
    make() {
      const pattern = this.pattern, options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let set2 = this.globSet = this.braceExpand();
      options2.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, set2), set2 = this.globParts = set2.map((s) => s.split(slashSplit)), this.debug(this.pattern, set2), set2 = set2.map((s, si, set3) => s.map(this.parse, this)), this.debug(this.pattern, set2), set2 = set2.filter((s) => s.indexOf(!1) === -1), this.debug(this.pattern, set2), this.set = set2;
    }
    parseNegate() {
      if (this.options.nonegate) return;
      const pattern = this.pattern;
      let negate = !1, negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial) {
      var options2 = this.options;
      this.debug(
        "matchOne",
        { this: this, file, pattern }
      ), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi], f = file[fi];
        if (this.debug(pattern, p, f), p === !1) return !1;
        if (p === GLOBSTAR2) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            for (this.debug("** at the end"); fi < fl; fi++)
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return !1;
            return !0;
          }
          for (; fr < fl; ) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
              return this.debug("globstar found match!", fr, fl, swallowee), !0;
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), fr++;
          }
          return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
        }
        var hit;
        if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), this.debug("pattern match", p, f, hit)), !hit) return !1;
      }
      if (fi === fl && pi === pl)
        return !0;
      if (fi === fl)
        return partial;
      if (pi === pl)
        return fi === fl - 1 && file[fi] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand2(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern2(pattern);
      const options2 = this.options;
      if (pattern === "**")
        if (options2.noglobstar)
          pattern = "*";
        else
          return GLOBSTAR2;
      if (pattern === "") return "";
      let re = "", hasMagic2 = !1, escaping = !1;
      const patternListStack = [], negativeLists = [];
      let stateChar, inClass = !1, reClassStart = -1, classStart = -1, cs, pl, sp, dotTravAllowed = pattern.charAt(0) === ".", dotFileAllowed = options2.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", subPatternStart = (p) => p.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star3, hasMagic2 = !0;
              break;
            case "?":
              re += qmark2, hasMagic2 = !0;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
        }
      };
      for (let i = 0, c2; i < pattern.length && (c2 = pattern.charAt(i)); i++) {
        if (this.debug("%s	%s %s %j", pattern, i, re, c2), escaping) {
          if (c2 === "/")
            return !1;
          reSpecials2[c2] && (re += "\\"), re += c2, escaping = !1;
          continue;
        }
        switch (c2) {
          /* istanbul ignore next */
          case "/":
            return !1;
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c2;
              continue;
            }
            clearStateChar(), escaping = !0;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2), inClass) {
              this.debug("  in class"), c2 === "!" && i === classStart + 1 && (c2 = "^"), re += c2;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c2, options2.noext && clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "	", plEntry), patternListStack.push(plEntry), re += plEntry.open, plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1))), this.debug("plType %j %j", stateChar, re), stateChar = !1;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop(), clearStateChar(), hasMagic2 = !0, pl = plEntry, re += pl.close, pl.type === "!" && negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar(), re += "|", plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1)));
            continue;
          }
          // these are mostly the same in regexp and glob
          case "[":
            if (clearStateChar(), inClass) {
              re += "\\" + c2;
              continue;
            }
            inClass = !0, classStart = i, reClassStart = re.length, re += c2;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c2;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]"), re += c2;
            } catch {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic2 = !0, inClass = !1;
            continue;
          default:
            clearStateChar(), reSpecials2[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
            break;
        }
      }
      for (inClass && (cs = pattern.slice(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substring(0, reClassStart) + "\\[" + sp[0], hasMagic2 = hasMagic2 || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length), this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => ($2 || ($2 = "\\"), $1 + $1 + $2 + "|")), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
        const t = pl.type === "*" ? star3 : pl.type === "?" ? qmark2 : "\\" + pl.type;
        hasMagic2 = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar(), escaping && (re += "\\\\");
      const addPatternStart2 = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1; n > -1; n--) {
        const nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter, closeParensBefore = nlBefore.split(")").length, openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0; i < openParensBefore; i++)
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic2 && (re = "(?=.)" + re), addPatternStart2 && (re = patternStart() + re), isSub === SUBPARSE)
        return [re, hasMagic2];
      if (options2.nocase && !hasMagic2 && (hasMagic2 = pattern.toUpperCase() !== pattern.toLowerCase()), !hasMagic2)
        return globUnescape(pattern);
      const flags = options2.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      const set2 = this.set;
      if (!set2.length)
        return this.regexp = !1, this.regexp;
      const options2 = this.options, twoStar = options2.noglobstar ? star3 : options2.dot ? twoStarDot2 : twoStarNoDot2, flags = options2.nocase ? "i" : "";
      let re = set2.map((pattern) => (pattern = pattern.map(
        (p) => typeof p == "string" ? regExpEscape2(p) : p === GLOBSTAR2 ? GLOBSTAR2 : p._src
      ).reduce((set3, p) => (set3[set3.length - 1] === GLOBSTAR2 && p === GLOBSTAR2 || set3.push(p), set3), []), pattern.forEach((p, i) => {
        p !== GLOBSTAR2 || pattern[i - 1] === GLOBSTAR2 || (i === 0 ? pattern.length > 1 ? pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1] : pattern[i] = twoStar : i === pattern.length - 1 ? pattern[i - 1] += "(?:\\/|" + twoStar + ")?" : (pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1], pattern[i + 1] = GLOBSTAR2));
      }), pattern.filter((p) => p !== GLOBSTAR2).join("/"))).join("|");
      re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
      try {
        this.regexp = new RegExp(re, flags);
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment) return !1;
      if (this.empty) return f === "";
      if (f === "/" && partial) return !0;
      const options2 = this.options;
      path2.sep !== "/" && (f = f.split(path2.sep).join("/")), f = f.split(slashSplit), this.debug(this.pattern, "split", f);
      const set2 = this.set;
      this.debug(this.pattern, "set", set2);
      let filename;
      for (let i = f.length - 1; i >= 0 && (filename = f[i], !filename); i--)
        ;
      for (let i = 0; i < set2.length; i++) {
        const pattern = set2[i];
        let file = f;
        if (options2.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial))
          return options2.flipNegate ? !0 : !this.negate;
      }
      return options2.flipNegate ? !1 : this.negate;
    }
    static defaults(def) {
      return minimatch2.defaults(def).Minimatch;
    }
  }
  return minimatch2.Minimatch = Minimatch2, minimatch_1;
}
var inherits = { exports: {} }, inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(ctor, superCtor) {
    superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
    }
  }), inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits != "function") throw "";
    inherits.exports = util2.inherits;
  } catch {
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1, common$1.setopts = setopts, common$1.ownProp = ownProp, common$1.makeAbs = makeAbs, common$1.finish = finish, common$1.mark = mark2, common$1.isIgnored = isIgnored, common$1.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var fs2 = require$$0__default$1.default, path2 = require$$0__default.default, minimatch2 = requireMinimatch(), isAbsolute = require$$0__default.default.isAbsolute, Minimatch2 = minimatch2.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options2) {
    self2.ignore = options2.ignore || [], Array.isArray(self2.ignore) || (self2.ignore = [self2.ignore]), self2.ignore.length && (self2.ignore = self2.ignore.map(ignoreMap));
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch2(gpattern, { dot: !0 });
    }
    return {
      matcher: new Minimatch2(pattern, { dot: !0 }),
      gmatcher
    };
  }
  function setopts(self2, pattern, options2) {
    if (options2 || (options2 = {}), options2.matchBase && pattern.indexOf("/") === -1) {
      if (options2.noglobstar)
        throw new Error("base matching requires globstar");
      pattern = "**/" + pattern;
    }
    self2.silent = !!options2.silent, self2.pattern = pattern, self2.strict = options2.strict !== !1, self2.realpath = !!options2.realpath, self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null), self2.follow = !!options2.follow, self2.dot = !!options2.dot, self2.mark = !!options2.mark, self2.nodir = !!options2.nodir, self2.nodir && (self2.mark = !0), self2.sync = !!options2.sync, self2.nounique = !!options2.nounique, self2.nonull = !!options2.nonull, self2.nosort = !!options2.nosort, self2.nocase = !!options2.nocase, self2.stat = !!options2.stat, self2.noprocess = !!options2.noprocess, self2.absolute = !!options2.absolute, self2.fs = options2.fs || fs2, self2.maxLength = options2.maxLength || 1 / 0, self2.cache = options2.cache || /* @__PURE__ */ Object.create(null), self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null), self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null), setupIgnores(self2, options2), self2.changedCwd = !1;
    var cwd = process.cwd();
    ownProp(options2, "cwd") ? (self2.cwd = path2.resolve(options2.cwd), self2.changedCwd = self2.cwd !== cwd) : self2.cwd = path2.resolve(cwd), self2.root = options2.root || path2.resolve(self2.cwd, "/"), self2.root = path2.resolve(self2.root), self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd), self2.nomount = !!options2.nomount, process.platform === "win32" && (self2.root = self2.root.replace(/\\/g, "/"), self2.cwd = self2.cwd.replace(/\\/g, "/"), self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/")), options2.nonegate = !0, options2.nocomment = !0, options2.allowWindowsEscape = !0, self2.minimatch = new Minimatch2(pattern, options2), self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    for (var nou = self2.nounique, all = nou ? [] : /* @__PURE__ */ Object.create(null), i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal2 = self2.minimatch.globSet[i];
          nou ? all.push(literal2) : all[literal2] = !0;
        }
      } else {
        var m = Object.keys(matches);
        nou ? all.push.apply(all, m) : m.forEach(function(m2) {
          all[m2] = !0;
        });
      }
    }
    if (nou || (all = Object.keys(all)), self2.nosort || (all = all.sort(alphasort)), self2.mark) {
      for (var i = 0; i < all.length; i++)
        all[i] = self2._mark(all[i]);
      self2.nodir && (all = all.filter(function(e) {
        var notDir = !/\/$/.test(e), c2 = self2.cache[e] || self2.cache[makeAbs(self2, e)];
        return notDir && c2 && (notDir = c2 !== "DIR" && !Array.isArray(c2)), notDir;
      }));
    }
    self2.ignore.length && (all = all.filter(function(m2) {
      return !isIgnored(self2, m2);
    })), self2.found = all;
  }
  function mark2(self2, p) {
    var abs = makeAbs(self2, p), c2 = self2.cache[abs], m = p;
    if (c2) {
      var isDir2 = c2 === "DIR" || Array.isArray(c2), slash = p.slice(-1) === "/";
      if (isDir2 && !slash ? m += "/" : !isDir2 && slash && (m = m.slice(0, -1)), m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs], self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self2, f) {
    var abs = f;
    return f.charAt(0) === "/" ? abs = path2.join(self2.root, f) : isAbsolute(f) || f === "" ? abs = f : self2.changedCwd ? abs = path2.resolve(self2.cwd, f) : abs = path2.resolve(f), process.platform === "win32" && (abs = abs.replace(/\\/g, "/")), abs;
  }
  function isIgnored(self2, path3) {
    return self2.ignore.length ? self2.ignore.some(function(item) {
      return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
    }) : !1;
  }
  function childrenIgnored(self2, path3) {
    return self2.ignore.length ? self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path3));
    }) : !1;
  }
  return common$1;
}
var sync$1, hasRequiredSync;
function requireSync() {
  if (hasRequiredSync) return sync$1;
  hasRequiredSync = 1, sync$1 = globSync2, globSync2.GlobSync = GlobSync;
  var rp = requireFs_realpath(), minimatch2 = requireMinimatch();
  requireGlob().Glob;
  var path2 = require$$0__default.default, assert = require$$0__default$5.default, isAbsolute = require$$0__default.default.isAbsolute, common2 = requireCommon$1(), setopts = common2.setopts, ownProp = common2.ownProp, childrenIgnored = common2.childrenIgnored, isIgnored = common2.isIgnored;
  function globSync2(pattern, options2) {
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    return new GlobSync(pattern, options2).found;
  }
  function GlobSync(pattern, options2) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options2);
    if (setopts(this, pattern, options2), this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++)
      this._process(this.minimatch.set[i], i, !1);
    this._finish();
  }
  return GlobSync.prototype._finish = function() {
    if (assert.ok(this instanceof GlobSync), this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset)
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = !0;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = !0;
            else
              throw er;
          }
      });
    }
    common2.finish(this);
  }, GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    for (var n = 0; typeof pattern[n] == "string"; )
      n++;
    var prefix;
    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n), read2;
    prefix === null ? read2 = "." : ((isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p == "string" ? p : "[*]";
    }).join("/"))) && (!prefix || !isAbsolute(prefix)) && (prefix = "/" + prefix), read2 = prefix);
    var abs = this._makeAbs(read2);
    if (!childrenIgnored(this, read2)) {
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar);
    }
  }, GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len !== 0) {
        if (remain.length === 1 && !this.mark && !this.stat) {
          this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            prefix && (prefix.slice(-1) !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i], newPattern;
          prefix ? newPattern = [prefix, e] : newPattern = [e], this._process(newPattern.concat(remain), index, inGlobStar);
        }
      }
    }
  }, GlobSync.prototype._emitMatch = function(index, e) {
    if (!isIgnored(this, e)) {
      var abs = this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0, this.stat && this._stat(e);
      }
    }
  }, GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, !1);
    var entries, lstat2;
    try {
      lstat2 = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT")
        return null;
    }
    var isSym = lstat2 && lstat2.isSymbolicLink();
    return this.symlinks[abs] = isSym, !isSym && lstat2 && !lstat2.isDirectory() ? this.cache[abs] = "FILE" : entries = this._readdir(abs, !1), entries;
  }, GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      return this._readdirError(abs, er), null;
    }
  }, GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat)
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
      }
    return this.cache[abs] = entries, entries;
  }, GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      // https://github.com/isaacs/node-glob/issues/205
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          throw error2.path = this.cwd, error2.code = er.code, error2;
        }
        break;
      case "ENOENT":
      // not terribly unusual
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = !1;
        break;
      default:
        if (this.cache[this._makeAbs(f)] = !1, this.strict)
          throw er;
        this.silent || console.error("glob error", er);
        break;
    }
  }, GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, !1);
      var len = entries.length, isSym = this.symlinks[abs];
      if (!(isSym && inGlobStar))
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (!(e.charAt(0) === "." && !this.dot)) {
            var instead = gspref.concat(entries[i], remainWithoutGlobStar);
            this._process(instead, index, !0);
            var below = gspref.concat(entries[i], remain);
            this._process(below, index, !0);
          }
        }
    }
  }, GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !!exists) {
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
      }
      process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix);
    }
  }, GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f), needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return !1;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return !1;
    }
    var stat2 = this.statCache[abs];
    if (!stat2) {
      var lstat2;
      try {
        lstat2 = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
          return this.statCache[abs] = !1, !1;
      }
      if (lstat2 && lstat2.isSymbolicLink())
        try {
          stat2 = this.fs.statSync(abs);
        } catch {
          stat2 = lstat2;
        }
      else
        stat2 = lstat2;
    }
    this.statCache[abs] = stat2;
    var c2 = !0;
    return stat2 && (c2 = stat2.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? !1 : c2;
  }, GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  }, sync$1;
}
var wrappy_1, hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1, wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    }), wrapper;
    function wrapper() {
      for (var args = new Array(arguments.length), i = 0; i < args.length; i++)
        args[i] = arguments[i];
      var ret = fn.apply(this, args), cb2 = args[args.length - 1];
      return typeof ret == "function" && ret !== cb2 && Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      }), ret;
    }
  }
  return wrappy_1;
}
var once = { exports: {} }, hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$1), once.exports.strict = wrappy(onceStrict), once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$1(this);
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: !0
    });
  });
  function once$1(fn) {
    var f = function() {
      return f.called ? f.value : (f.called = !0, f.value = fn.apply(this, arguments));
    };
    return f.called = !1, f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      return f.called = !0, f.value = fn.apply(this, arguments);
    }, name = fn.name || "Function wrapped with `once`";
    return f.onceError = name + " shouldn't be called more than once", f.called = !1, f;
  }
  return once.exports;
}
var inflight_1, hasRequiredInflight;
function requireInflight() {
  if (hasRequiredInflight) return inflight_1;
  hasRequiredInflight = 1;
  var wrappy = requireWrappy(), reqs = /* @__PURE__ */ Object.create(null), once2 = requireOnce();
  inflight_1 = wrappy(inflight);
  function inflight(key2, cb) {
    return reqs[key2] ? (reqs[key2].push(cb), null) : (reqs[key2] = [cb], makeres(key2));
  }
  function makeres(key2) {
    return once2(function RES() {
      var cbs = reqs[key2], len = cbs.length, args = slice(arguments);
      try {
        for (var i = 0; i < len; i++)
          cbs[i].apply(null, args);
      } finally {
        cbs.length > len ? (cbs.splice(0, len), process.nextTick(function() {
          RES.apply(null, args);
        })) : delete reqs[key2];
      }
    });
  }
  function slice(args) {
    for (var length = args.length, array = [], i = 0; i < length; i++) array[i] = args[i];
    return array;
  }
  return inflight_1;
}
var glob_1, hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob_1;
  hasRequiredGlob = 1, glob_1 = glob2;
  var rp = requireFs_realpath(), minimatch2 = requireMinimatch(), inherits2 = requireInherits(), EE = require$$0__default$7.default.EventEmitter, path2 = require$$0__default.default, assert = require$$0__default$5.default, isAbsolute = require$$0__default.default.isAbsolute, globSync2 = requireSync(), common2 = requireCommon$1(), setopts = common2.setopts, ownProp = common2.ownProp, inflight = requireInflight(), childrenIgnored = common2.childrenIgnored, isIgnored = common2.isIgnored, once2 = requireOnce();
  function glob2(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), options2 || (options2 = {}), options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync2(pattern, options2);
    }
    return new Glob2(pattern, options2, cb);
  }
  glob2.sync = globSync2;
  var GlobSync = glob2.GlobSync = globSync2.GlobSync;
  glob2.glob = glob2;
  function extend(origin, add) {
    if (add === null || typeof add != "object")
      return origin;
    for (var keys = Object.keys(add), i = keys.length; i--; )
      origin[keys[i]] = add[keys[i]];
    return origin;
  }
  glob2.hasMagic = function(pattern, options_) {
    var options2 = extend({}, options_);
    options2.noprocess = !0;
    var g = new Glob2(pattern, options2), set2 = g.minimatch.set;
    if (!pattern)
      return !1;
    if (set2.length > 1)
      return !0;
    for (var j = 0; j < set2[0].length; j++)
      if (typeof set2[0][j] != "string")
        return !0;
    return !1;
  }, glob2.Glob = Glob2, inherits2(Glob2, EE);
  function Glob2(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = null), options2 && options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options2);
    }
    if (!(this instanceof Glob2))
      return new Glob2(pattern, options2, cb);
    setopts(this, pattern, options2), this._didRealPath = !1;
    var n = this.minimatch.set.length;
    this.matches = new Array(n), typeof cb == "function" && (cb = once2(cb), this.on("error", cb), this.on("end", function(matches) {
      cb(null, matches);
    }));
    var self2 = this;
    if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = !1, this.noprocess)
      return this;
    if (n === 0)
      return done();
    for (var sync2 = !0, i = 0; i < n; i++)
      this._process(this.minimatch.set[i], i, !1, done);
    sync2 = !1;
    function done() {
      --self2._processing, self2._processing <= 0 && (sync2 ? process.nextTick(function() {
        self2._finish();
      }) : self2._finish());
    }
  }
  Glob2.prototype._finish = function() {
    if (assert(this instanceof Glob2), !this.aborted) {
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common2.finish(this), this.emit("end", this.found);
    }
  }, Glob2.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = !0;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    for (var self2 = this, i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      --n === 0 && self2._finish();
    }
  }, Glob2.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset), self2 = this, n = found.length;
    if (n === 0)
      return cb();
    var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p), rp.realpath(p, self2.realpathCache, function(er, real) {
        er ? er.syscall === "stat" ? set2[p] = !0 : self2.emit("error", er) : set2[real] = !0, --n === 0 && (self2.matches[index] = set2, cb());
      });
    });
  }, Glob2.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, Glob2.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  }, Glob2.prototype.abort = function() {
    this.aborted = !0, this.emit("abort");
  }, Glob2.prototype.pause = function() {
    this.paused || (this.paused = !0, this.emit("pause"));
  }, Glob2.prototype.resume = function() {
    if (this.paused) {
      if (this.emit("resume"), this.paused = !1, this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--, this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  }, Glob2.prototype._process = function(pattern, index, inGlobStar, cb) {
    if (assert(this instanceof Glob2), assert(typeof cb == "function"), !this.aborted) {
      if (this._processing++, this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      for (var n = 0; typeof pattern[n] == "string"; )
        n++;
      var prefix;
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n), read2;
      prefix === null ? read2 = "." : ((isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p == "string" ? p : "[*]";
      }).join("/"))) && (!prefix || !isAbsolute(prefix)) && (prefix = "/" + prefix), read2 = prefix);
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar, cb) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar, cb);
    }
  }, Glob2.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob2.prototype._processReaddir2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  }, Glob2.prototype._emitMatch = function(index, e) {
    if (!this.aborted && !isIgnored(this, e)) {
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0;
        var st = this.statCache[abs];
        st && this.emit("stat", e, st), this.emit("match", e);
      }
    }
  }, Glob2.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, !1, cb);
    var lstatkey = "lstat\0" + abs, self2 = this, lstatcb = inflight(lstatkey, lstatcb_);
    lstatcb && self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat2) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat2 && lstat2.isSymbolicLink();
      self2.symlinks[abs] = isSym, !isSym && lstat2 && !lstat2.isDirectory() ? (self2.cache[abs] = "FILE", cb()) : self2._readdir(abs, !1, cb);
    }
  }, Glob2.prototype._readdir = function(abs, inGlobStar, cb) {
    if (!this.aborted && (cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb), !!cb)) {
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return cb();
        if (Array.isArray(c2))
          return cb(null, c2);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    }
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      er ? self2._readdirError(abs, er, cb) : self2._readdirEntries(abs, entries, cb);
    };
  }
  return Glob2.prototype._readdirEntries = function(abs, entries, cb) {
    if (!this.aborted) {
      if (!this.mark && !this.stat)
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
        }
      return this.cache[abs] = entries, cb(null, entries);
    }
  }, Glob2.prototype._readdirError = function(f, er, cb) {
    if (!this.aborted) {
      switch (er.code) {
        case "ENOTSUP":
        // https://github.com/isaacs/node-glob/issues/205
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd, error2.code = er.code, this.emit("error", error2), this.abort();
          }
          break;
        case "ENOENT":
        // not terribly unusual
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = !1;
          break;
        default:
          this.cache[this._makeAbs(f)] = !1, this.strict && (this.emit("error", er), this.abort()), this.silent || console.error("glob error", er);
          break;
      }
      return cb();
    }
  }, Glob2.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob2.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, !1, cb);
    var isSym = this.symlinks[abs], len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (!(e.charAt(0) === "." && !this.dot)) {
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, !0, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, !0, cb);
      }
    }
    cb();
  }, Glob2.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  }, Glob2.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
    }
    process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix), cb();
  }, Glob2.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f), needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat2 = this.statCache[abs];
    if (stat2 !== void 0) {
      if (stat2 === !1)
        return cb(null, stat2);
      var type2 = stat2.isDirectory() ? "DIR" : "FILE";
      return needDir && type2 === "FILE" ? cb() : cb(null, type2, stat2);
    }
    var self2 = this, statcb = inflight("stat\0" + abs, lstatcb_);
    statcb && self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat2) {
      if (lstat2 && lstat2.isSymbolicLink())
        return self2.fs.stat(abs, function(er2, stat3) {
          er2 ? self2._stat2(f, abs, null, lstat2, cb) : self2._stat2(f, abs, er2, stat3, cb);
        });
      self2._stat2(f, abs, er, lstat2, cb);
    }
  }, Glob2.prototype._stat2 = function(f, abs, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
      return this.statCache[abs] = !1, cb();
    var needDir = f.slice(-1) === "/";
    if (this.statCache[abs] = stat2, abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, !1, stat2);
    var c2 = !0;
    return stat2 && (c2 = stat2.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? cb() : cb(null, c2, stat2);
  }, glob_1;
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, unicode$1 = {
  Space_Separator,
  ID_Start,
  ID_Continue
}, util$2 = {
  isSpaceSeparator(c2) {
    return typeof c2 == "string" && unicode$1.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode$1.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode$1.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 == "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 == "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source, parseState, stack, pos, line$1, column, token, key, root;
var parse$1 = function parse2(text, reviver) {
  source = String(text), parseState = "start", stack = [], pos = 0, line$1 = 1, column = 0, token = void 0, key = void 0, root = void 0;
  do
    token = lex(), parseStates[parseState]();
  while (token.type !== "eof");
  return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value == "object")
    if (Array.isArray(value))
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i), replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return reviver.call(holder, name, value);
}
let lexState, buffer$1, doubleQuote, sign, c;
function lex() {
  for (lexState = "default", buffer$1 = "", doubleQuote = !1, sign = 1; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2)
      return token2;
  }
}
function peek() {
  if (source[pos])
    return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  const c2 = peek();
  return c2 === `
` ? (line$1++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read(), lexState = "comment";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    if (util$2.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineComment";
        return;
      case "/":
        read(), lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read(), lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read(), lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read(), lexState = "default";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        return read(), literal("ull"), newToken("null", null);
      case "t":
        return read(), literal("rue"), newToken("boolean", !0);
      case "f":
        return read(), literal("alse"), newToken("boolean", !1);
      case "-":
      case "+":
        read() === "-" && (sign = -1), lexState = "sign";
        return;
      case ".":
        buffer$1 = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer$1 = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer$1 = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", 1 / 0);
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"', buffer$1 = "", lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util$2.isIdStartChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer$1 += u, lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer$1 += read();
        return;
      case "\\":
        read(), lexState = "identifierNameEscape";
        return;
    }
    if (util$2.isIdContinueChar(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("identifier", buffer$1);
  },
  identifierNameEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util$2.isIdContinueChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer$1 += u, lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer$1 = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer$1 = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer$1 = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer$1 += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer$1 += read(), lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer$1 += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalPointLeading() {
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer$1 += read(), lexState = "decimalExponentSign";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util$2.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  hexadecimal() {
    if (util$2.isHexDigit(c)) {
      buffer$1 += read(), lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util$2.isHexDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  string() {
    switch (c) {
      case "\\":
        read(), buffer$1 += escape$1();
        return;
      case '"':
        if (doubleQuote)
          return read(), newToken("string", buffer$1);
        buffer$1 += read();
        return;
      case "'":
        if (!doubleQuote)
          return read(), newToken("string", buffer$1);
        buffer$1 += read();
        return;
      case `
`:
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer$1 += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer$1 = read(), lexState = "identifierName";
        return;
      case "\\":
        read(), lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"', lexState = "string";
        return;
    }
    if (util$2.isIdStartChar(c)) {
      buffer$1 += read(), lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":")
      return newToken("punctuator", read());
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]")
      return newToken("punctuator", read());
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line: line$1,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    if (peek() !== c2)
      throw invalidChar(read());
    read();
  }
}
function escape$1() {
  switch (peek()) {
    case "b":
      return read(), "\b";
    case "f":
      return read(), "\f";
    case "n":
      return read(), `
`;
    case "r":
      return read(), "\r";
    case "t":
      return read(), "	";
    case "v":
      return read(), "\v";
    case "0":
      if (read(), util$2.isDigit(peek()))
        throw invalidChar(read());
      return "\0";
    case "x":
      return read(), hexEscape();
    case "u":
      return read(), unicodeEscape();
    case `
`:
    case "\u2028":
    case "\u2029":
      return read(), "";
    case "\r":
      return read(), peek() === `
` && read(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "", c2 = peek();
  if (!util$2.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util$2.isHexDigit(c2)))
    throw invalidChar(read());
  return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "", count2 = 4;
  for (; count2-- > 0; ) {
    const c2 = peek();
    if (!util$2.isHexDigit(c2))
      throw invalidChar(read());
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value, parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof")
      throw invalidEOF();
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0)
    root = value;
  else {
    const parent = stack[stack.length - 1];
    Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
      value,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (value !== null && typeof value == "object")
    stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
  else {
    const current = stack[stack.length - 1];
    current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
}
function invalidChar(c2) {
  return syntaxError(c2 === void 0 ? `JSON5: invalid end of input at ${line$1}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line$1}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line$1}:${column}`);
}
function invalidIdentifier() {
  return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line$1}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2])
    return replacements[c2];
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  return err.lineNumber = line$1, err.columnNumber = column, err;
}
var stringify$1 = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent = "", propertyList, replacerFunc, gap = "", quote;
  if (replacer != null && typeof replacer == "object" && !Array.isArray(replacer) && (space = replacer.space, quote = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
    replacerFunc = replacer;
  else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      typeof v == "string" ? item = v : (typeof v == "number" || v instanceof String || v instanceof Number) && (item = String(v)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
    }
  }
  return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    switch (value2 != null && (typeof value2.toJSON5 == "function" ? value2 = value2.toJSON5(key2) : typeof value2.toJSON == "function" && (value2 = value2.toJSON(key2))), replacerFunc && (value2 = replacerFunc.call(holder, key2, value2)), value2 instanceof Number ? value2 = Number(value2) : value2 instanceof String ? value2 = String(value2) : value2 instanceof Boolean && (value2 = value2.valueOf()), value2) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof value2 == "string")
      return quoteString(value2);
    if (typeof value2 == "number")
      return String(value2);
    if (typeof value2 == "object")
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    }, replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++, product += c2;
          continue;
        case "\0":
          if (util$2.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys = propertyList || Object.keys(value2), partial = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        gap !== "" && (member += " "), member += propertyString, partial.push(member);
      }
    }
    let final;
    if (partial.length === 0)
      final = "{}";
    else {
      let properties;
      if (gap === "")
        properties = partial.join(","), final = "{" + properties + "}";
      else {
        let separator2 = `,
` + indent;
        properties = partial.join(separator2), final = `{
` + indent + properties + `,
` + stepback + "}";
      }
    }
    return stack2.pop(), indent = stepback, final;
  }
  function serializeKey(key2) {
    if (key2.length === 0)
      return quoteString(key2);
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util$2.isIdStartChar(firstChar))
      return quoteString(key2);
    for (let i = firstChar.length; i < key2.length; i++)
      if (!util$2.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i))))
        return quoteString(key2);
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0)
      final = "[]";
    else if (gap === "")
      final = "[" + partial.join(",") + "]";
    else {
      let separator2 = `,
` + indent, properties = partial.join(separator2);
      final = `[
` + indent + properties + `,
` + stepback + "]";
    }
    return stack2.pop(), indent = stepback, final;
  }
};
const JSON5 = {
  parse: parse$1,
  stringify: stringify$1
};
var lib$2 = JSON5, dist = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: lib$2
}), require$$4$2 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(dist), getGlobFs = {}, hasRequiredGetGlobFs;
function requireGetGlobFs() {
  if (hasRequiredGetGlobFs) return getGlobFs;
  hasRequiredGetGlobFs = 1;
  var __importDefault2 = getGlobFs && getGlobFs.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getGlobFs, "__esModule", { value: !0 }), getGlobFs.getGlobFs = void 0;
  const fs_1 = __importDefault2(require$$0__default$1.default);
  function removeWindowsPrefix(path2) {
    return path2.replace(/^[a-zA-Z]:/, "");
  }
  function getGlobFs$1(_fs) {
    const readdir2 = (path2, callback) => {
      _fs.readdir(removeWindowsPrefix(String(path2))).then((stats) => callback(null, stats.map((stat3) => stat3.name))).catch((err) => callback(err, []));
    }, stat2 = (path2, callback) => {
      _fs.isFile(removeWindowsPrefix(String(path2))).then((isPathAFile) => {
        callback(null, {
          ino: 0,
          mode: 0,
          nlink: 0,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          blksize: 0,
          blocks: 0,
          atimeMs: 0,
          mtimeMs: 0,
          ctimeMs: 0,
          birthtimeMs: 0,
          atime: /* @__PURE__ */ new Date(),
          mtime: /* @__PURE__ */ new Date(),
          ctime: /* @__PURE__ */ new Date(),
          birthtime: /* @__PURE__ */ new Date(),
          dev: 0,
          isBlockDevice: () => !1,
          isCharacterDevice: () => !1,
          isDirectory: () => !isPathAFile,
          isFIFO: () => !1,
          isFile: () => isPathAFile,
          isSocket: () => !1,
          isSymbolicLink: () => !1
        });
      }).catch((err) => callback(err, null));
    };
    return new Proxy(fs_1.default, {
      get(_target, prop) {
        switch (prop) {
          case "readdir":
            return readdir2;
          case "lstat":
          case "stat":
            return stat2;
          default:
            throw new Error("Not Implemented");
        }
      }
    });
  }
  return getGlobFs.getGlobFs = getGlobFs$1, getGlobFs;
}
var hasRequiredGetWorkspacePackagePaths;
function requireGetWorkspacePackagePaths() {
  if (hasRequiredGetWorkspacePackagePaths) return getWorkspacePackagePaths;
  hasRequiredGetWorkspacePackagePaths = 1;
  var __importDefault2 = getWorkspacePackagePaths && getWorkspacePackagePaths.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getWorkspacePackagePaths, "__esModule", { value: !0 }), getWorkspacePackagePaths.getWorkspacePackagePaths = void 0;
  const path_1 = __importDefault2(require$$0__default.default), js_yaml_1 = __importDefault2(requireJsYaml$2()), glob_12 = __importDefault2(requireGlob()), json5_1 = __importDefault2(require$$4$2), get_glob_fs_1 = requireGetGlobFs(), posixPath = path_1.default.posix;
  async function getWorkspacePackagePaths$1({ fs: fs2, workspace }) {
    const { type: type2, rootPath } = workspace, workspaceFs = fs2.chdir(rootPath);
    let results = [];
    switch (type2) {
      case "yarn":
      case "npm":
        results = await getPackageJsonWorkspacePackagePaths({ fs: workspaceFs });
        break;
      case "pnpm":
        results = await getPnpmWorkspacePackagePaths({ fs: workspaceFs });
        break;
      case "nx":
        results = await getNxWorkspacePackagePaths({ fs: workspaceFs });
        break;
      case "rush":
        results = await getRushWorkspacePackagePaths({ fs: workspaceFs });
        break;
      default:
        throw new Error(`Unknown workspace implementation: ${type2}`);
    }
    return results.map((packagePath) => posixPath.join(rootPath, posixPath.dirname(packagePath)));
  }
  getWorkspacePackagePaths.getWorkspacePackagePaths = getWorkspacePackagePaths$1;
  const isWin = process.platform === "win32", normalizePath = (p) => isWin ? p.replace(/\\/g, "/") : p;
  async function getPackagePaths(packages, fs2) {
    return (await Promise.all(packages.map((packageGlob) => new Promise((resolve, reject) => {
      (0, glob_12.default)(normalizePath(posixPath.join(packageGlob, "package.json")), {
        cwd: "/",
        fs: (0, get_glob_fs_1.getGlobFs)(fs2)
      }, (err, matches) => {
        err ? reject(err) : resolve(matches);
      });
    })))).flat();
  }
  async function getPackageJsonWorkspacePackagePaths({ fs: fs2 }) {
    const packageJsonAsBuffer = await fs2.readFile("package.json"), { workspaces } = JSON.parse(packageJsonAsBuffer.toString());
    let packages = [];
    return Array.isArray(workspaces) ? packages = workspaces : packages = workspaces?.packages ?? [], getPackagePaths(packages, fs2);
  }
  async function getNxWorkspacePackagePaths({ fs: fs2 }) {
    const nxWorkspaceJsonAsBuffer = await fs2.readFile("workspace.json"), { projects } = JSON.parse(nxWorkspaceJsonAsBuffer.toString()), packages = Object.values(projects);
    return getPackagePaths(packages, fs2);
  }
  async function getPnpmWorkspacePackagePaths({ fs: fs2 }) {
    const pnpmWorkspaceAsBuffer = await fs2.readFile("pnpm-workspace.yaml"), { packages = [] } = js_yaml_1.default.load(pnpmWorkspaceAsBuffer.toString());
    return getPackagePaths(packages, fs2);
  }
  async function getRushWorkspacePackagePaths({ fs: fs2 }) {
    const rushWorkspaceAsBuffer = await fs2.readFile("rush.json"), { projects = [] } = json5_1.default.parse(rushWorkspaceAsBuffer.toString());
    if (Array.isArray(projects)) {
      const packages = projects.filter((proj) => proj.projectFolder).map((project) => project.projectFolder);
      return getPackagePaths(packages, fs2);
    } else
      return [];
  }
  return getWorkspacePackagePaths;
}
var monorepoManagers = {}, hasRequiredMonorepoManagers;
function requireMonorepoManagers() {
  return hasRequiredMonorepoManagers || (hasRequiredMonorepoManagers = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.monorepoManagers = void 0, exports2.monorepoManagers = [
      {
        name: "Turborepo",
        slug: "turbo",
        logo: "https://api-frameworks.vercel.sh/monorepo-logos/turborepo.svg",
        darkModeLogo: "https://api-frameworks.vercel.sh/monorepo-logos/turborepo-dark.svg",
        detectors: {
          some: [
            {
              path: "turbo.json"
            },
            {
              path: "package.json",
              matchContent: '"turbo":\\s*{[^}]*.+[^}]*}'
            }
          ]
        },
        settings: {
          buildCommand: {
            placeholder: "Turborepo default",
            value: null
          },
          outputDirectory: {
            value: null
          },
          installCommand: {
            value: null
          },
          devCommand: {
            value: null
          }
        }
      },
      {
        name: "Nx",
        slug: "nx",
        logo: "https://api-frameworks.vercel.sh/monorepo-logos/nx.svg",
        detectors: {
          every: [
            {
              path: "nx.json"
            }
          ]
        },
        settings: {
          buildCommand: {
            placeholder: "Nx default",
            value: null
          },
          outputDirectory: {
            value: null
          },
          installCommand: {
            value: null
          },
          devCommand: {
            value: null
          }
        }
      },
      {
        name: "Rush",
        slug: "rush",
        logo: "https://api-frameworks.vercel.sh/monorepo-logos/rush.svg",
        detectors: {
          every: [
            {
              path: "rush.json"
            }
          ]
        },
        settings: {
          buildCommand: {
            placeholder: "Rush default",
            value: null
          },
          outputDirectory: {
            value: null
          },
          installCommand: {
            placeholder: "Rush default"
          },
          devCommand: {
            value: null
          }
        }
      }
    ], exports2.default = exports2.monorepoManagers;
  }(monorepoManagers)), monorepoManagers;
}
var packageManagers = {}, hasRequiredPackageManagers;
function requirePackageManagers() {
  return hasRequiredPackageManagers || (hasRequiredPackageManagers = 1, Object.defineProperty(packageManagers, "__esModule", { value: !0 }), packageManagers.packageManagers = void 0, packageManagers.packageManagers = [
    {
      name: "npm",
      slug: "npm",
      logo: "",
      darkModeLogo: "",
      detectors: {
        some: [
          {
            path: "package-lock.json"
          },
          {
            path: "package.json",
            matchContent: '"packageManager":\\s*"npm@.*"'
          }
        ]
      }
    },
    {
      name: "pnpm",
      slug: "pnpm",
      logo: "",
      darkModeLogo: "",
      detectors: {
        some: [
          {
            path: "pnpm-lock.yaml"
          },
          {
            path: "package.json",
            matchContent: '"packageManager":\\s*"pnpm@.*"'
          }
        ]
      }
    },
    {
      name: "yarn",
      slug: "yarn",
      logo: "",
      darkModeLogo: "",
      detectors: {
        some: [
          {
            path: "yarn.lock"
          },
          {
            path: "package.json",
            matchContent: '"packageManager":\\s*"yarn@.*"'
          },
          {
            path: "package.json"
          }
        ]
      }
    }
  ]), packageManagers;
}
var getMonorepoDefaultSettings = {}, hasRequiredGetMonorepoDefaultSettings;
function requireGetMonorepoDefaultSettings() {
  if (hasRequiredGetMonorepoDefaultSettings) return getMonorepoDefaultSettings;
  hasRequiredGetMonorepoDefaultSettings = 1;
  var __importDefault2 = getMonorepoDefaultSettings && getMonorepoDefaultSettings.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getMonorepoDefaultSettings, "__esModule", { value: !0 }), getMonorepoDefaultSettings.getMonorepoDefaultSettings = getMonorepoDefaultSettings.MissingBuildTarget = getMonorepoDefaultSettings.MissingBuildPipeline = void 0;
  const path_1 = require$$0__default.default, monorepo_managers_1 = requireMonorepoManagers(), package_managers_1 = requirePackageManagers(), detect_framework_1 = requireDetectFramework(), json5_1 = __importDefault2(require$$4$2), semver_1 = __importDefault2(semver__default.default);
  class MissingBuildPipeline extends Error {
    constructor() {
      super("Missing required `build` pipeline in turbo.json or package.json Turbo configuration.");
    }
  }
  getMonorepoDefaultSettings.MissingBuildPipeline = MissingBuildPipeline;
  class MissingBuildTarget extends Error {
    constructor() {
      super("Missing required `build` target in either nx.json, project.json, or package.json Nx configuration.");
    }
  }
  getMonorepoDefaultSettings.MissingBuildTarget = MissingBuildTarget;
  function supportsRootCommand(turboSemVer) {
    return !turboSemVer || !semver_1.default.validRange(turboSemVer) ? !1 : !semver_1.default.intersects(turboSemVer, "<1.8.0");
  }
  async function getMonorepoDefaultSettings$1(projectName, projectPath, relativeToRoot, detectorFilesystem) {
    const [monorepoManager, packageManager] = await Promise.all([
      (0, detect_framework_1.detectFramework)({
        fs: detectorFilesystem,
        frameworkList: monorepo_managers_1.monorepoManagers
      }),
      (0, detect_framework_1.detectFramework)({
        fs: detectorFilesystem,
        frameworkList: package_managers_1.packageManagers
      })
    ]);
    if (monorepoManager === "turbo") {
      const [turboJSONBuf, packageJSONBuf] = await Promise.all([
        detectorFilesystem.readFile("turbo.json").catch(() => null),
        detectorFilesystem.readFile("package.json").catch(() => null)
      ]);
      let hasBuildPipeline = !1, turboSemVer = null;
      if (turboJSONBuf !== null && json5_1.default.parse(turboJSONBuf.toString("utf-8"))?.pipeline?.build && (hasBuildPipeline = !0), packageJSONBuf !== null) {
        const packageJSON = JSON.parse(packageJSONBuf.toString("utf-8"));
        packageJSON?.turbo?.pipeline?.build && (hasBuildPipeline = !0), turboSemVer = packageJSON?.dependencies?.turbo || packageJSON?.devDependencies?.turbo || null;
      }
      if (!hasBuildPipeline)
        throw new MissingBuildPipeline();
      if (projectPath === "/")
        return {
          monorepoManager: "turbo",
          buildCommand: "turbo run build",
          installCommand: packageManager ? `${packageManager} install` : null,
          commandForIgnoringBuildStep: "npx turbo-ignore"
        };
      let buildCommand = null;
      return projectPath && (supportsRootCommand(turboSemVer) ? buildCommand = "turbo run build" : buildCommand = `cd ${relativeToRoot} && turbo run build --filter={${projectPath}}...`), {
        monorepoManager: "turbo",
        buildCommand,
        installCommand: packageManager === "npm" ? `${packageManager} install --prefix=${relativeToRoot}` : packageManager ? `${packageManager} install` : null,
        commandForIgnoringBuildStep: "npx turbo-ignore"
      };
    } else if (monorepoManager === "nx") {
      const nxJSONBuf = await detectorFilesystem.readFile("nx.json");
      if (!json5_1.default.parse(nxJSONBuf.toString("utf-8"))?.targetDefaults?.build) {
        const [projectJSONBuf, packageJSONBuf] = await Promise.all([
          detectorFilesystem.readFile((0, path_1.join)(projectPath, "project.json")).catch(() => null),
          detectorFilesystem.readFile((0, path_1.join)(projectPath, "package.json")).catch(() => null)
        ]);
        let hasBuildTarget = !1;
        if (projectJSONBuf && json5_1.default.parse(projectJSONBuf.toString("utf-8"))?.targets?.build && (hasBuildTarget = !0), packageJSONBuf) {
          const packageJSON = json5_1.default.parse(packageJSONBuf.toString("utf-8"));
          packageJSON?.nx && packageJSON.nx.targets?.build && (hasBuildTarget = !0);
        }
        if (!hasBuildTarget)
          throw new MissingBuildTarget();
      }
      return projectPath === "/" ? {
        monorepoManager: "nx",
        buildCommand: "npx nx build",
        installCommand: packageManager ? `${packageManager} install` : null
      } : {
        monorepoManager: "nx",
        buildCommand: projectName ? `cd ${relativeToRoot} && npx nx build ${projectName}` : null,
        installCommand: packageManager === "npm" ? `${packageManager} install --prefix=${relativeToRoot}` : packageManager ? `${packageManager} install` : null
      };
    }
    return null;
  }
  return getMonorepoDefaultSettings.getMonorepoDefaultSettings = getMonorepoDefaultSettings$1, getMonorepoDefaultSettings;
}
var hasRequiredDist;
function requireDist() {
  return hasRequiredDist || (hasRequiredDist = 1, function(exports2) {
    var __createBinding2 = dist$1 && dist$1.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = dist$1 && dist$1.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.packageManagers = exports2.isStaticRuntime = exports2.isOfficialRuntime = exports2.monorepoManagers = exports2.getWorkspacePackagePaths = exports2.getWorkspaces = exports2.workspaceManagers = exports2.LocalFileSystemDetector = exports2.DetectorFilesystem = exports2.getProjectPaths = exports2.detectFrameworkVersion = exports2.detectFrameworkRecord = exports2.detectFrameworks = exports2.detectFramework = exports2.detectFileSystemAPI = exports2.detectApiExtensions = exports2.detectApiDirectory = exports2.detectOutputDirectory = exports2.detectBuilders = void 0;
    var detect_builders_1 = requireDetectBuilders();
    Object.defineProperty(exports2, "detectBuilders", { enumerable: !0, get: function() {
      return detect_builders_1.detectBuilders;
    } }), Object.defineProperty(exports2, "detectOutputDirectory", { enumerable: !0, get: function() {
      return detect_builders_1.detectOutputDirectory;
    } }), Object.defineProperty(exports2, "detectApiDirectory", { enumerable: !0, get: function() {
      return detect_builders_1.detectApiDirectory;
    } }), Object.defineProperty(exports2, "detectApiExtensions", { enumerable: !0, get: function() {
      return detect_builders_1.detectApiExtensions;
    } });
    var detect_file_system_api_1 = requireDetectFileSystemApi();
    Object.defineProperty(exports2, "detectFileSystemAPI", { enumerable: !0, get: function() {
      return detect_file_system_api_1.detectFileSystemAPI;
    } });
    var detect_framework_1 = requireDetectFramework();
    Object.defineProperty(exports2, "detectFramework", { enumerable: !0, get: function() {
      return detect_framework_1.detectFramework;
    } }), Object.defineProperty(exports2, "detectFrameworks", { enumerable: !0, get: function() {
      return detect_framework_1.detectFrameworks;
    } }), Object.defineProperty(exports2, "detectFrameworkRecord", { enumerable: !0, get: function() {
      return detect_framework_1.detectFrameworkRecord;
    } }), Object.defineProperty(exports2, "detectFrameworkVersion", { enumerable: !0, get: function() {
      return detect_framework_1.detectFrameworkVersion;
    } });
    var get_project_paths_1 = requireGetProjectPaths();
    Object.defineProperty(exports2, "getProjectPaths", { enumerable: !0, get: function() {
      return get_project_paths_1.getProjectPaths;
    } });
    var filesystem_1 = requireFilesystem();
    Object.defineProperty(exports2, "DetectorFilesystem", { enumerable: !0, get: function() {
      return filesystem_1.DetectorFilesystem;
    } });
    var local_file_system_detector_1 = requireLocalFileSystemDetector();
    Object.defineProperty(exports2, "LocalFileSystemDetector", { enumerable: !0, get: function() {
      return local_file_system_detector_1.LocalFileSystemDetector;
    } });
    var workspace_managers_1 = requireWorkspaceManagers();
    Object.defineProperty(exports2, "workspaceManagers", { enumerable: !0, get: function() {
      return workspace_managers_1.workspaceManagers;
    } });
    var get_workspaces_1 = requireGetWorkspaces();
    Object.defineProperty(exports2, "getWorkspaces", { enumerable: !0, get: function() {
      return get_workspaces_1.getWorkspaces;
    } });
    var get_workspace_package_paths_1 = requireGetWorkspacePackagePaths();
    Object.defineProperty(exports2, "getWorkspacePackagePaths", { enumerable: !0, get: function() {
      return get_workspace_package_paths_1.getWorkspacePackagePaths;
    } });
    var monorepo_managers_1 = requireMonorepoManagers();
    Object.defineProperty(exports2, "monorepoManagers", { enumerable: !0, get: function() {
      return monorepo_managers_1.monorepoManagers;
    } });
    var is_official_runtime_1 = requireIsOfficialRuntime();
    Object.defineProperty(exports2, "isOfficialRuntime", { enumerable: !0, get: function() {
      return is_official_runtime_1.isOfficialRuntime;
    } }), Object.defineProperty(exports2, "isStaticRuntime", { enumerable: !0, get: function() {
      return is_official_runtime_1.isStaticRuntime;
    } });
    var package_managers_1 = requirePackageManagers();
    Object.defineProperty(exports2, "packageManagers", { enumerable: !0, get: function() {
      return package_managers_1.packageManagers;
    } }), __exportStar2(requireGetMonorepoDefaultSettings(), exports2);
  }(dist$1)), dist$1;
}
var distExports = requireDist(), execa$1 = { exports: {} }, crossSpawn = { exports: {} }, windows$1, hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows$1;
  hasRequiredWindows = 1, windows$1 = isexe, isexe.sync = sync2;
  var fs2 = require$$0__default$1.default;
  function checkPathExt(path2, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext || (pathext = pathext.split(";"), pathext.indexOf("") !== -1))
      return !0;
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p)
        return !0;
    }
    return !1;
  }
  function checkStat(stat2, path2, options2) {
    return !stat2.isSymbolicLink() && !stat2.isFile() ? !1 : checkPathExt(path2, options2);
  }
  function isexe(path2, options2, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? !1 : checkStat(stat2, path2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), path2, options2);
  }
  return windows$1;
}
var mode, hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1, mode = isexe, isexe.sync = sync2;
  var fs2 = require$$0__default$1.default;
  function isexe(path2, options2, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? !1 : checkStat(stat2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), options2);
  }
  function checkStat(stat2, options2) {
    return stat2.isFile() && checkMode(stat2, options2);
  }
  function checkMode(stat2, options2) {
    var mod = stat2.mode, uid = stat2.uid, gid = stat2.gid, myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid(), myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g, ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var isexe_1, hasRequiredIsexe;
function requireIsexe() {
  if (hasRequiredIsexe) return isexe_1;
  hasRequiredIsexe = 1;
  var core2;
  process.platform === "win32" || loadEnv.commonjsGlobal.TESTING_WINDOWS ? core2 = requireWindows() : core2 = requireMode(), isexe_1 = isexe, isexe.sync = sync2;
  function isexe(path2, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), !cb) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function(resolve, reject) {
        isexe(path2, options2 || {}, function(er, is) {
          er ? reject(er) : resolve(is);
        });
      });
    }
    core2(path2, options2 || {}, function(er, is) {
      er && (er.code === "EACCES" || options2 && options2.ignoreErrors) && (er = null, is = !1), cb(er, is);
    });
  }
  function sync2(path2, options2) {
    try {
      return core2.sync(path2, options2 || {});
    } catch (er) {
      if (options2 && options2.ignoreErrors || er.code === "EACCES")
        return !1;
      throw er;
    }
  }
  return isexe_1;
}
var which_1, hasRequiredWhich;
function requireWhich() {
  if (hasRequiredWhich) return which_1;
  hasRequiredWhich = 1;
  const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path2 = require$$0__default.default, COLON = isWindows ? ";" : ":", isexe = requireIsexe(), getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      // windows always checks the cwd first
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
      "").split(colon)
    ], pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [""];
    return isWindows && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
      pathEnv,
      pathExt,
      pathExtExe
    };
  }, which2 = (cmd, opt, cb) => {
    typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [], step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path2.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    }), subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext2 = pathExt[ii];
      isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is)
          if (opt.all)
            found.push(p + ext2);
          else
            return resolve(p + ext2);
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  }, whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path2.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          if (isexe.sync(cur, { pathExt: pathExtExe }))
            if (opt.all)
              found.push(cur);
            else
              return cur;
        } catch {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  return which_1 = which2, which2.sync = whichSync, which_1;
}
var pathKey = { exports: {} }, hasRequiredPathKey;
function requirePathKey() {
  if (hasRequiredPathKey) return pathKey.exports;
  hasRequiredPathKey = 1;
  const pathKey$1 = (options2 = {}) => {
    const environment = options2.env || process.env;
    return (options2.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
  };
  return pathKey.exports = pathKey$1, pathKey.exports.default = pathKey$1, pathKey.exports;
}
var resolveCommand_1, hasRequiredResolveCommand;
function requireResolveCommand() {
  if (hasRequiredResolveCommand) return resolveCommand_1;
  hasRequiredResolveCommand = 1;
  const path2 = require$$0__default.default, which2 = requireWhich(), getPathKey = requirePathKey();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env, cwd = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
    if (shouldSwitchCwd)
      try {
        process.chdir(parsed.options.cwd);
      } catch {
      }
    let resolved;
    try {
      resolved = which2.sync(parsed.command, {
        path: env[getPathKey({ env })],
        pathExt: withoutPathExt ? path2.delimiter : void 0
      });
    } catch {
    } finally {
      shouldSwitchCwd && process.chdir(cwd);
    }
    return resolved && (resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
  }
  return resolveCommand_1 = resolveCommand, resolveCommand_1;
}
var _escape = {}, hasRequired_escape;
function require_escape() {
  if (hasRequired_escape) return _escape;
  hasRequired_escape = 1;
  const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    return arg = `${arg}`, arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"'), arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1"), arg = `"${arg}"`, arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
  }
  return _escape.command = escapeCommand, _escape.argument = escapeArgument, _escape;
}
var shebangRegex, hasRequiredShebangRegex;
function requireShebangRegex() {
  return hasRequiredShebangRegex || (hasRequiredShebangRegex = 1, shebangRegex = /^#!(.*)/), shebangRegex;
}
var shebangCommand, hasRequiredShebangCommand;
function requireShebangCommand() {
  if (hasRequiredShebangCommand) return shebangCommand;
  hasRequiredShebangCommand = 1;
  const shebangRegex2 = requireShebangRegex();
  return shebangCommand = (string = "") => {
    const match2 = string.match(shebangRegex2);
    if (!match2)
      return null;
    const [path2, argument] = match2[0].replace(/#! ?/, "").split(" "), binary2 = path2.split("/").pop();
    return binary2 === "env" ? argument : argument ? `${binary2} ${argument}` : binary2;
  }, shebangCommand;
}
var readShebang_1, hasRequiredReadShebang;
function requireReadShebang() {
  if (hasRequiredReadShebang) return readShebang_1;
  hasRequiredReadShebang = 1;
  const fs2 = require$$0__default$1.default, shebangCommand2 = requireShebangCommand();
  function readShebang(command2) {
    const buffer2 = Buffer.alloc(150);
    let fd;
    try {
      fd = fs2.openSync(command2, "r"), fs2.readSync(fd, buffer2, 0, 150, 0), fs2.closeSync(fd);
    } catch {
    }
    return shebangCommand2(buffer2.toString());
  }
  return readShebang_1 = readShebang, readShebang_1;
}
var parse_1$2, hasRequiredParse$3;
function requireParse$3() {
  if (hasRequiredParse$3) return parse_1$2;
  hasRequiredParse$3 = 1;
  const path2 = require$$0__default.default, resolveCommand = requireResolveCommand(), escape2 = require_escape(), readShebang = requireReadShebang(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin)
      return parsed;
    const commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path2.normalize(parsed.command), parsed.command = escape2.command(parsed.command), parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
    }
    return parsed;
  }
  function parse3(command2, args, options2) {
    args && !Array.isArray(args) && (options2 = args, args = null), args = args ? args.slice(0) : [], options2 = Object.assign({}, options2);
    const parsed = {
      command: command2,
      args,
      options: options2,
      file: void 0,
      original: {
        command: command2,
        args
      }
    };
    return options2.shell ? parsed : parseNonShell(parsed);
  }
  return parse_1$2 = parse3, parse_1$2;
}
var enoent, hasRequiredEnoent;
function requireEnoent() {
  if (hasRequiredEnoent) return enoent;
  hasRequiredEnoent = 1;
  const isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin)
      return;
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err)
          return originalEmit.call(cp, "error", err);
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
  }
  function verifyENOENTSync(status, parsed) {
    return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
  }
  return enoent = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  }, enoent;
}
var hasRequiredCrossSpawn;
function requireCrossSpawn() {
  if (hasRequiredCrossSpawn) return crossSpawn.exports;
  hasRequiredCrossSpawn = 1;
  const cp = require$$1__default$2.default, parse3 = requireParse$3(), enoent2 = requireEnoent();
  function spawn(command2, args, options2) {
    const parsed = parse3(command2, args, options2), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    return enoent2.hookChildProcess(spawned, parsed), spawned;
  }
  function spawnSync(command2, args, options2) {
    const parsed = parse3(command2, args, options2), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    return result.error = result.error || enoent2.verifyENOENTSync(result.status, parsed), result;
  }
  return crossSpawn.exports = spawn, crossSpawn.exports.spawn = spawn, crossSpawn.exports.sync = spawnSync, crossSpawn.exports._parse = parse3, crossSpawn.exports._enoent = enoent2, crossSpawn.exports;
}
var stripFinalNewline, hasRequiredStripFinalNewline;
function requireStripFinalNewline() {
  return hasRequiredStripFinalNewline || (hasRequiredStripFinalNewline = 1, stripFinalNewline = (input2) => {
    const LF = typeof input2 == "string" ? `
` : 10, CR = typeof input2 == "string" ? "\r" : 13;
    return input2[input2.length - 1] === LF && (input2 = input2.slice(0, input2.length - 1)), input2[input2.length - 1] === CR && (input2 = input2.slice(0, input2.length - 1)), input2;
  }), stripFinalNewline;
}
var npmRunPath = { exports: {} }, hasRequiredNpmRunPath;
function requireNpmRunPath() {
  return hasRequiredNpmRunPath || (hasRequiredNpmRunPath = 1, function(module2) {
    const path2 = require$$0__default.default, pathKey2 = requirePathKey(), npmRunPath2 = (options2) => {
      options2 = {
        cwd: process.cwd(),
        path: process.env[pathKey2()],
        ...options2
      };
      let previous, cwdPath = path2.resolve(options2.cwd);
      const result = [];
      for (; previous !== cwdPath; )
        result.push(path2.join(cwdPath, "node_modules/.bin")), previous = cwdPath, cwdPath = path2.resolve(cwdPath, "..");
      return result.push(path2.dirname(process.execPath)), result.concat(options2.path).join(path2.delimiter);
    };
    module2.exports = npmRunPath2, module2.exports.default = npmRunPath2, module2.exports.env = (options2) => {
      options2 = {
        env: process.env,
        ...options2
      };
      const env = { ...options2.env }, path3 = pathKey2({ env });
      return options2.path = env[path3], env[path3] = module2.exports(options2), env;
    };
  }(npmRunPath)), npmRunPath.exports;
}
var onetime$2 = { exports: {} }, mimicFn$1 = { exports: {} }, hasRequiredMimicFn$1;
function requireMimicFn$1() {
  if (hasRequiredMimicFn$1) return mimicFn$1.exports;
  hasRequiredMimicFn$1 = 1;
  const mimicFn2 = (to, from2) => {
    for (const prop of Reflect.ownKeys(from2))
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
    return to;
  };
  return mimicFn$1.exports = mimicFn2, mimicFn$1.exports.default = mimicFn2, mimicFn$1.exports;
}
var hasRequiredOnetime$1;
function requireOnetime$1() {
  if (hasRequiredOnetime$1) return onetime$2.exports;
  hasRequiredOnetime$1 = 1;
  const mimicFn2 = requireMimicFn$1(), calledFunctions2 = /* @__PURE__ */ new WeakMap(), onetime2 = (function_, options2 = {}) => {
    if (typeof function_ != "function")
      throw new TypeError("Expected a function");
    let returnValue, callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>", onetime3 = function(...arguments_) {
      if (calledFunctions2.set(onetime3, ++callCount), callCount === 1)
        returnValue = function_.apply(this, arguments_), function_ = null;
      else if (options2.throw === !0)
        throw new Error(`Function \`${functionName}\` can only be called once`);
      return returnValue;
    };
    return mimicFn2(onetime3, function_), calledFunctions2.set(onetime3, callCount), onetime3;
  };
  return onetime$2.exports = onetime2, onetime$2.exports.default = onetime2, onetime$2.exports.callCount = (function_) => {
    if (!calledFunctions2.has(function_))
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return calledFunctions2.get(function_);
  }, onetime$2.exports;
}
var error, hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  const os2 = require$$0__default$2.default, util2 = require$$0__default$6.default, getCode = (error2, code) => error2 && error2.code ? [error2.code, os2.constants.errno[error2.code]] : Number.isInteger(code) ? [util2.getSystemErrorName(-code), code] : [], getErrorPrefix = ({ timedOut, timeout: timeout2, signal, exitCodeName, exitCode, isCanceled }) => timedOut ? `timed out after ${timeout2} milliseconds` : isCanceled ? "was canceled" : signal ? `was killed with ${signal}` : exitCode !== void 0 ? `failed with exit code ${exitCode} (${exitCodeName})` : "failed";
  return error = ({
    stdout,
    stderr,
    all,
    error: error2,
    signal,
    code,
    command: command2,
    timedOut,
    isCanceled,
    killed,
    parsed: { options: { timeout: timeout2 } }
  }) => {
    const [exitCodeName, exitCode] = getCode(error2, code), message = `Command ${getErrorPrefix({ timedOut, timeout: timeout2, signal, exitCodeName, exitCode, isCanceled })}: ${command2}`;
    return error2 instanceof Error ? (error2.originalMessage = error2.message, error2.message = `${message}
${error2.message}`) : error2 = new Error(message), error2.command = command2, delete error2.code, error2.exitCode = exitCode, error2.exitCodeName = exitCodeName, error2.stdout = stdout, error2.stderr = stderr, all !== void 0 && (error2.all = all), "bufferedData" in error2 && delete error2.bufferedData, error2.failed = !0, error2.timedOut = !!timedOut, error2.isCanceled = isCanceled, error2.killed = killed && !timedOut, error2.signal = signal || void 0, error2;
  }, error;
}
var stdio = { exports: {} }, hasRequiredStdio;
function requireStdio() {
  if (hasRequiredStdio) return stdio.exports;
  hasRequiredStdio = 1;
  const aliases = ["stdin", "stdout", "stderr"], hasAlias = (opts) => aliases.some((alias) => opts[alias] !== void 0), normalizeStdio = (opts) => {
    if (!opts)
      return;
    const { stdio: stdio2 } = opts;
    if (stdio2 === void 0)
      return aliases.map((alias) => opts[alias]);
    if (hasAlias(opts))
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    if (typeof stdio2 == "string")
      return stdio2;
    if (!Array.isArray(stdio2))
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio2}\``);
    const length = Math.max(stdio2.length, aliases.length);
    return Array.from({ length }, (value, index) => stdio2[index]);
  };
  return stdio.exports = normalizeStdio, stdio.exports.node = (opts) => {
    const stdio2 = normalizeStdio(opts);
    return stdio2 === "ipc" ? "ipc" : stdio2 === void 0 || typeof stdio2 == "string" ? [stdio2, stdio2, stdio2, "ipc"] : stdio2.includes("ipc") ? stdio2 : [...stdio2, "ipc"];
  }, stdio.exports;
}
var pFinally, hasRequiredPFinally;
function requirePFinally() {
  return hasRequiredPFinally || (hasRequiredPFinally = 1, pFinally = async (promise2, onFinally = () => {
  }) => {
    let value;
    try {
      value = await promise2;
    } catch (error2) {
      throw await onFinally(), error2;
    }
    return await onFinally(), value;
  }), pFinally;
}
var kill, hasRequiredKill;
function requireKill() {
  if (hasRequiredKill) return kill;
  hasRequiredKill = 1;
  const os2 = require$$0__default$2.default, onExit2 = requireSignalExit(), pFinally2 = requirePFinally(), DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5, spawnedKill = (kill2, signal = "SIGTERM", options2 = {}) => {
    const killResult = kill2(signal);
    return setKillTimeout(kill2, signal, options2, killResult), killResult;
  }, setKillTimeout = (kill2, signal, options2, killResult) => {
    if (!shouldForceKill(signal, options2, killResult))
      return;
    const timeout2 = getForceKillAfterTimeout(options2);
    setTimeout(() => {
      kill2("SIGKILL");
    }, timeout2).unref();
  }, shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== !1 && killResult, isSigterm = (signal) => signal === os2.constants.signals.SIGTERM || typeof signal == "string" && signal.toUpperCase() === "SIGTERM", getForceKillAfterTimeout = ({ forceKillAfterTimeout = !0 }) => {
    if (forceKillAfterTimeout === !0)
      return DEFAULT_FORCE_KILL_TIMEOUT;
    if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0)
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    return forceKillAfterTimeout;
  }, spawnedCancel = (spawned, context) => {
    spawned.kill() && (context.isCanceled = !0);
  }, timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal), reject(Object.assign(new Error("Timed out"), { timedOut: !0, signal }));
  };
  return kill = {
    spawnedKill,
    spawnedCancel,
    setupTimeout: (spawned, { timeout: timeout2, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout2 === 0 || timeout2 === void 0)
        return spawnedPromise;
      if (!Number.isInteger(timeout2) || timeout2 < 0)
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout2}\` (${typeof timeout2})`);
      let timeoutId;
      const timeoutPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout2);
      }), safeSpawnedPromise = pFinally2(spawnedPromise, () => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    },
    setExitHandler: (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached)
        return timedPromise;
      const removeExitHandler = onExit2(() => {
        spawned.kill();
      });
      return pFinally2(timedPromise, removeExitHandler);
    }
  }, kill;
}
var isStream_1, hasRequiredIsStream;
function requireIsStream() {
  if (hasRequiredIsStream) return isStream_1;
  hasRequiredIsStream = 1;
  const isStream2 = (stream2) => stream2 !== null && typeof stream2 == "object" && typeof stream2.pipe == "function";
  return isStream2.writable = (stream2) => isStream2(stream2) && stream2.writable !== !1 && typeof stream2._write == "function" && typeof stream2._writableState == "object", isStream2.readable = (stream2) => isStream2(stream2) && stream2.readable !== !1 && typeof stream2._read == "function" && typeof stream2._readableState == "object", isStream2.duplex = (stream2) => isStream2.writable(stream2) && isStream2.readable(stream2), isStream2.transform = (stream2) => isStream2.duplex(stream2) && typeof stream2._transform == "function", isStream_1 = isStream2, isStream_1;
}
var getStream = { exports: {} }, endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var once2 = requireOnce(), noop2 = function() {
  }, isRequest = function(stream2) {
    return stream2.setHeader && typeof stream2.abort == "function";
  }, isChildProcess = function(stream2) {
    return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
  }, eos = function(stream2, opts, callback) {
    if (typeof opts == "function") return eos(stream2, null, opts);
    opts || (opts = {}), callback = once2(callback || noop2);
    var ws = stream2._writableState, rs = stream2._readableState, readable = opts.readable || opts.readable !== !1 && stream2.readable, writable = opts.writable || opts.writable !== !1 && stream2.writable, cancelled = !1, onlegacyfinish = function() {
      stream2.writable || onfinish();
    }, onfinish = function() {
      writable = !1, readable || callback.call(stream2);
    }, onend = function() {
      readable = !1, writable || callback.call(stream2);
    }, onexit = function(exitCode) {
      callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
    }, onerror = function(err) {
      callback.call(stream2, err);
    }, onclose = function() {
      process.nextTick(onclosenexttick);
    }, onclosenexttick = function() {
      if (!cancelled) {
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream2, new Error("premature close"));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream2, new Error("premature close"));
      }
    }, onrequest = function() {
      stream2.req.on("finish", onfinish);
    };
    return isRequest(stream2) ? (stream2.on("complete", onfinish), stream2.on("abort", onclose), stream2.req ? onrequest() : stream2.on("request", onrequest)) : writable && !ws && (stream2.on("end", onlegacyfinish), stream2.on("close", onlegacyfinish)), isChildProcess(stream2) && stream2.on("exit", onexit), stream2.on("end", onend), stream2.on("finish", onfinish), opts.error !== !1 && stream2.on("error", onerror), stream2.on("close", onclose), function() {
      cancelled = !0, stream2.removeListener("complete", onfinish), stream2.removeListener("abort", onclose), stream2.removeListener("request", onrequest), stream2.req && stream2.req.removeListener("finish", onfinish), stream2.removeListener("end", onlegacyfinish), stream2.removeListener("close", onlegacyfinish), stream2.removeListener("finish", onfinish), stream2.removeListener("exit", onexit), stream2.removeListener("end", onend), stream2.removeListener("error", onerror), stream2.removeListener("close", onclose);
    };
  };
  return endOfStream = eos, endOfStream;
}
var pump_1, hasRequiredPump;
function requirePump() {
  if (hasRequiredPump) return pump_1;
  hasRequiredPump = 1;
  var once2 = requireOnce(), eos = requireEndOfStream(), fs2;
  try {
    fs2 = require("fs");
  } catch {
  }
  var noop2 = function() {
  }, ancient = /^v?\.0/.test(process.version), isFn = function(fn) {
    return typeof fn == "function";
  }, isFS = function(stream2) {
    return !ancient || !fs2 ? !1 : (stream2 instanceof (fs2.ReadStream || noop2) || stream2 instanceof (fs2.WriteStream || noop2)) && isFn(stream2.close);
  }, isRequest = function(stream2) {
    return stream2.setHeader && isFn(stream2.abort);
  }, destroyer = function(stream2, reading, writing, callback) {
    callback = once2(callback);
    var closed = !1;
    stream2.on("close", function() {
      closed = !0;
    }), eos(stream2, { readable: reading, writable: writing }, function(err) {
      if (err) return callback(err);
      closed = !0, callback();
    });
    var destroyed = !1;
    return function(err) {
      if (!closed && !destroyed) {
        if (destroyed = !0, isFS(stream2)) return stream2.close(noop2);
        if (isRequest(stream2)) return stream2.abort();
        if (isFn(stream2.destroy)) return stream2.destroy();
        callback(err || new Error("stream was destroyed"));
      }
    };
  }, call = function(fn) {
    fn();
  }, pipe2 = function(from2, to) {
    return from2.pipe(to);
  }, pump = function() {
    var streams2 = Array.prototype.slice.call(arguments), callback = isFn(streams2[streams2.length - 1] || noop2) && streams2.pop() || noop2;
    if (Array.isArray(streams2[0]) && (streams2 = streams2[0]), streams2.length < 2) throw new Error("pump requires two streams per minimum");
    var error2, destroys = streams2.map(function(stream2, i) {
      var reading = i < streams2.length - 1, writing = i > 0;
      return destroyer(stream2, reading, writing, function(err) {
        error2 || (error2 = err), err && destroys.forEach(call), !reading && (destroys.forEach(call), callback(error2));
      });
    });
    return streams2.reduce(pipe2);
  };
  return pump_1 = pump, pump_1;
}
var bufferStream, hasRequiredBufferStream;
function requireBufferStream() {
  if (hasRequiredBufferStream) return bufferStream;
  hasRequiredBufferStream = 1;
  const { PassThrough: PassThroughStream } = require$$0__default$4.default;
  return bufferStream = (options2) => {
    options2 = { ...options2 };
    const { array } = options2;
    let { encoding } = options2;
    const isBuffer = encoding === "buffer";
    let objectMode = !1;
    array ? objectMode = !(encoding || isBuffer) : encoding = encoding || "utf8", isBuffer && (encoding = null);
    const stream2 = new PassThroughStream({ objectMode });
    encoding && stream2.setEncoding(encoding);
    let length = 0;
    const chunks = [];
    return stream2.on("data", (chunk) => {
      chunks.push(chunk), objectMode ? length = chunks.length : length += chunk.length;
    }), stream2.getBufferedValue = () => array ? chunks : isBuffer ? Buffer.concat(chunks, length) : chunks.join(""), stream2.getBufferedLength = () => length, stream2;
  }, bufferStream;
}
var hasRequiredGetStream;
function requireGetStream() {
  if (hasRequiredGetStream) return getStream.exports;
  hasRequiredGetStream = 1;
  const { constants: BufferConstants } = require$$0__default$a.default, pump = requirePump(), bufferStream2 = requireBufferStream();
  class MaxBufferError extends Error {
    constructor() {
      super("maxBuffer exceeded"), this.name = "MaxBufferError";
    }
  }
  async function getStream$1(inputStream, options2) {
    if (!inputStream)
      return Promise.reject(new Error("Expected a stream"));
    options2 = {
      maxBuffer: 1 / 0,
      ...options2
    };
    const { maxBuffer } = options2;
    let stream2;
    return await new Promise((resolve, reject) => {
      const rejectPromise = (error2) => {
        error2 && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH && (error2.bufferedData = stream2.getBufferedValue()), reject(error2);
      };
      stream2 = pump(inputStream, bufferStream2(options2), (error2) => {
        if (error2) {
          rejectPromise(error2);
          return;
        }
        resolve();
      }), stream2.on("data", () => {
        stream2.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError());
      });
    }), stream2.getBufferedValue();
  }
  return getStream.exports = getStream$1, getStream.exports.default = getStream$1, getStream.exports.buffer = (stream2, options2) => getStream$1(stream2, { ...options2, encoding: "buffer" }), getStream.exports.array = (stream2, options2) => getStream$1(stream2, { ...options2, array: !0 }), getStream.exports.MaxBufferError = MaxBufferError, getStream.exports;
}
var mergeStream, hasRequiredMergeStream;
function requireMergeStream() {
  if (hasRequiredMergeStream) return mergeStream;
  hasRequiredMergeStream = 1;
  const { PassThrough } = require$$0__default$4.default;
  return mergeStream = function() {
    var sources = [], output = new PassThrough({ objectMode: !0 });
    return output.setMaxListeners(0), output.add = add, output.isEmpty = isEmpty2, output.on("unpipe", remove), Array.prototype.slice.call(arguments).forEach(add), output;
    function add(source2) {
      return Array.isArray(source2) ? (source2.forEach(add), this) : (sources.push(source2), source2.once("end", remove.bind(null, source2)), source2.once("error", output.emit.bind(output, "error")), source2.pipe(output, { end: !1 }), this);
    }
    function isEmpty2() {
      return sources.length == 0;
    }
    function remove(source2) {
      sources = sources.filter(function(it) {
        return it !== source2;
      }), !sources.length && output.readable && output.end();
    }
  }, mergeStream;
}
var stream$1, hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream$1;
  hasRequiredStream = 1;
  const isStream2 = requireIsStream(), getStream2 = requireGetStream(), mergeStream2 = requireMergeStream(), handleInput = (spawned, input2) => {
    input2 === void 0 || spawned.stdin === void 0 || (isStream2(input2) ? input2.pipe(spawned.stdin) : spawned.stdin.end(input2));
  }, makeAllStream = (spawned) => {
    if (!spawned.stdout && !spawned.stderr)
      return;
    const mixed = mergeStream2();
    return spawned.stdout && mixed.add(spawned.stdout), spawned.stderr && mixed.add(spawned.stderr), mixed;
  }, getBufferedData = async (stream2, streamPromise) => {
    if (stream2) {
      stream2.destroy();
      try {
        return await streamPromise;
      } catch (error2) {
        return error2.bufferedData;
      }
    }
  }, getStreamPromise = (stream2, { encoding, buffer: buffer2, maxBuffer }) => {
    if (stream2)
      return buffer2 ? encoding ? getStream2(stream2, { encoding, maxBuffer }) : getStream2.buffer(stream2, { maxBuffer }) : new Promise((resolve, reject) => {
        stream2.once("end", resolve).once("error", reject);
      });
  };
  return stream$1 = {
    handleInput,
    makeAllStream,
    getSpawnedResult: async ({ stdout, stderr, all }, { encoding, buffer: buffer2, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer: buffer2, maxBuffer }), stderrPromise = getStreamPromise(stderr, { encoding, buffer: buffer2, maxBuffer }), allPromise = getStreamPromise(all, { encoding, buffer: buffer2, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error2) {
        return Promise.all([
          { error: error2, code: error2.code, signal: error2.signal, timedOut: error2.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    },
    validateInputSync: ({ input: input2 }) => {
      if (isStream2(input2))
        throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
  }, stream$1;
}
var promise, hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  const mergePromiseProperty = (spawned, promise2, property) => {
    const value = typeof promise2 == "function" ? (...args) => promise2()[property](...args) : promise2[property].bind(promise2);
    Object.defineProperty(spawned, property, {
      value,
      writable: !0,
      enumerable: !1,
      configurable: !0
    });
  };
  return promise = {
    mergePromise: (spawned, promise2) => (mergePromiseProperty(spawned, promise2, "then"), mergePromiseProperty(spawned, promise2, "catch"), Promise.prototype.finally && mergePromiseProperty(spawned, promise2, "finally"), spawned),
    getSpawnedPromise: (spawned) => new Promise((resolve, reject) => {
      spawned.on("exit", (code, signal) => {
        resolve({ code, signal });
      }), spawned.on("error", (error2) => {
        reject(error2);
      }), spawned.stdin && spawned.stdin.on("error", (error2) => {
        reject(error2);
      });
    })
  }, promise;
}
var command, hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command;
  hasRequiredCommand = 1;
  const SPACES_REGEXP = / +/g, joinCommand = (file, args = []) => Array.isArray(args) ? [file, ...args].join(" ") : file, handleEscaping = (tokens, token2, index) => {
    if (index === 0)
      return [token2];
    const previousToken = tokens[tokens.length - 1];
    return previousToken.endsWith("\\") ? [...tokens.slice(0, -1), `${previousToken.slice(0, -1)} ${token2}`] : [...tokens, token2];
  };
  return command = {
    joinCommand,
    parseCommand: (command2) => command2.trim().split(SPACES_REGEXP).reduce(handleEscaping, [])
  }, command;
}
var hasRequiredExeca;
function requireExeca() {
  if (hasRequiredExeca) return execa$1.exports;
  hasRequiredExeca = 1;
  const path2 = require$$0__default.default, childProcess2 = require$$1__default$2.default, crossSpawn2 = requireCrossSpawn(), stripFinalNewline2 = requireStripFinalNewline(), npmRunPath2 = requireNpmRunPath(), onetime2 = requireOnetime$1(), makeError = requireError(), normalizeStdio = requireStdio(), { spawnedKill, spawnedCancel, setupTimeout, setExitHandler } = requireKill(), { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = requireStream(), { mergePromise, getSpawnedPromise } = requirePromise(), { joinCommand, parseCommand } = requireCommand(), DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100, getEnv = ({ env: envOption, extendEnv, preferLocal, localDir }) => {
    const env = extendEnv ? { ...process.env, ...envOption } : envOption;
    return preferLocal ? npmRunPath2.env({ env, cwd: localDir }) : env;
  }, handleArgs = (file, args, options2 = {}) => {
    const parsed = crossSpawn2._parse(file, args, options2);
    return file = parsed.command, args = parsed.args, options2 = parsed.options, options2 = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: !0,
      stripFinalNewline: !0,
      extendEnv: !0,
      preferLocal: !1,
      localDir: options2.cwd || process.cwd(),
      encoding: "utf8",
      reject: !0,
      cleanup: !0,
      ...options2,
      windowsHide: !0
    }, options2.env = getEnv(options2), options2.stdio = normalizeStdio(options2), process.platform === "win32" && path2.basename(file, ".exe") === "cmd" && args.unshift("/q"), { file, args, options: options2, parsed };
  }, handleOutput = (options2, value, error2) => typeof value != "string" && !Buffer.isBuffer(value) ? error2 === void 0 ? void 0 : "" : options2.stripFinalNewline ? stripFinalNewline2(value) : value, execa2 = (file, args, options2) => {
    const parsed = handleArgs(file, args, options2), command2 = joinCommand(file, args);
    let spawned;
    try {
      spawned = childProcess2.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error2) {
      const dummySpawned = new childProcess2.ChildProcess(), errorPromise = Promise.reject(makeError({
        error: error2,
        stdout: "",
        stderr: "",
        all: "",
        command: command2,
        parsed,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      }));
      return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned), timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise), processDone = setExitHandler(spawned, parsed.options, timedPromise), context = { isCanceled: !1 };
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned)), spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromiseOnce = onetime2(async () => {
      const [{ error: error2, code, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone), stdout = handleOutput(parsed.options, stdoutResult), stderr = handleOutput(parsed.options, stderrResult), all = handleOutput(parsed.options, allResult);
      if (error2 || code !== 0 || signal !== null) {
        const returnedError = makeError({
          error: error2,
          code,
          signal,
          stdout,
          stderr,
          all,
          command: command2,
          parsed,
          timedOut,
          isCanceled: context.isCanceled,
          killed: spawned.killed
        });
        if (!parsed.options.reject)
          return returnedError;
        throw returnedError;
      }
      return {
        command: command2,
        exitCode: 0,
        exitCodeName: "SUCCESS",
        stdout,
        stderr,
        all,
        failed: !1,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      };
    });
    return crossSpawn2._enoent.hookChildProcess(spawned, parsed.parsed), handleInput(spawned, parsed.options.input), spawned.all = makeAllStream(spawned), mergePromise(spawned, handlePromiseOnce);
  };
  return execa$1.exports = execa2, execa$1.exports.sync = (file, args, options2) => {
    const parsed = handleArgs(file, args, options2), command2 = joinCommand(file, args);
    validateInputSync(parsed.options);
    let result;
    try {
      result = childProcess2.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error2) {
      throw makeError({
        error: error2,
        stdout: "",
        stderr: "",
        all: "",
        command: command2,
        parsed,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      });
    }
    if (result.stdout = handleOutput(parsed.options, result.stdout, result.error), result.stderr = handleOutput(parsed.options, result.stderr, result.error), result.error || result.status !== 0 || result.signal !== null) {
      const error2 = makeError({
        ...result,
        code: result.status,
        command: command2,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: !1,
        killed: result.signal !== null
      });
      if (!parsed.options.reject)
        return error2;
      throw error2;
    }
    return {
      command: command2,
      exitCode: 0,
      exitCodeName: "SUCCESS",
      stdout: result.stdout,
      stderr: result.stderr,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  }, execa$1.exports.command = (command2, options2) => {
    const [file, ...args] = parseCommand(command2);
    return execa2(file, args, options2);
  }, execa$1.exports.commandSync = (command2, options2) => {
    const [file, ...args] = parseCommand(command2);
    return execa2.sync(file, args, options2);
  }, execa$1.exports.node = (scriptPath, args, options2 = {}) => {
    args && !Array.isArray(args) && typeof args == "object" && (options2 = args, args = []);
    const stdio2 = normalizeStdio.node(options2), { nodePath: nodePath2 = process.execPath, nodeOptions = process.execArgv } = options2;
    return execa2(
      nodePath2,
      [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
      ],
      {
        ...options2,
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio: stdio2,
        shell: !1
      }
    );
  }, execa$1.exports;
}
var execaExports = requireExeca(), execa = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(execaExports), pFilter$1 = { exports: {} }, pMap = { exports: {} }, hasRequiredPMap;
function requirePMap() {
  if (hasRequiredPMap) return pMap.exports;
  hasRequiredPMap = 1;
  const pMap$1 = (iterable, mapper, options2) => new Promise((resolve, reject) => {
    if (options2 = Object.assign({
      concurrency: 1 / 0
    }, options2), typeof mapper != "function")
      throw new TypeError("Mapper function is required");
    const { concurrency } = options2;
    if (!(typeof concurrency == "number" && concurrency >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
    const ret = [], iterator2 = iterable[Symbol.iterator]();
    let isRejected = !1, isIterableDone = !1, resolvingCount = 0, currentIndex = 0;
    const next = () => {
      if (isRejected)
        return;
      const nextItem = iterator2.next(), i = currentIndex;
      if (currentIndex++, nextItem.done) {
        isIterableDone = !0, resolvingCount === 0 && resolve(ret);
        return;
      }
      resolvingCount++, Promise.resolve(nextItem.value).then((element) => mapper(element, i)).then(
        (value) => {
          ret[i] = value, resolvingCount--, next();
        },
        (error2) => {
          isRejected = !0, reject(error2);
        }
      );
    };
    for (let i = 0; i < concurrency && (next(), !isIterableDone); i++)
      ;
  });
  return pMap.exports = pMap$1, pMap.exports.default = pMap$1, pMap.exports;
}
var hasRequiredPFilter;
function requirePFilter() {
  if (hasRequiredPFilter) return pFilter$1.exports;
  hasRequiredPFilter = 1;
  const pMap2 = requirePMap(), pFilter2 = async (iterable, filterer, options2) => (await pMap2(
    iterable,
    (element, index) => Promise.all([filterer(element, index), element]),
    options2
  )).filter((value) => !!value[0]).map((value) => value[1]);
  return pFilter$1.exports = pFilter2, pFilter$1.exports.default = pFilter2, pFilter$1.exports;
}
var pFilterExports = requirePFilter(), pFilter = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(pFilterExports);
const CLIInitStepCompleted = telemetry.defineTrace({
  name: "CLI Init Step Completed",
  version: 1,
  description: "User completed a step in the CLI init flow"
});
var core$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(exports2) {
    exports2.isInteger = (num) => typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1, exports2.find = (node, type2) => node.nodes.find((node2) => node2.type === type2), exports2.exceedsLimit = (min2, max2, step = 1, limit) => limit === !1 || !exports2.isInteger(min2) || !exports2.isInteger(max2) ? !1 : (Number(max2) - Number(min2)) / Number(step) >= limit, exports2.escapeNode = (block, n = 0, type2) => {
      const node = block.nodes[n];
      node && (type2 && node.type === type2 || node.type === "open" || node.type === "close") && node.escaped !== !0 && (node.value = "\\" + node.value, node.escaped = !0);
    }, exports2.encloseBrace = (node) => node.type !== "brace" || node.commas >> 0 + node.ranges >> 0 ? !1 : (node.invalid = !0, !0), exports2.isInvalidBrace = (block) => block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : !(block.commas >> 0 + block.ranges >> 0) || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1, exports2.isOpenOrClose = (node) => node.type === "open" || node.type === "close" ? !0 : node.open === !0 || node.close === !0, exports2.reduce = (nodes) => nodes.reduce((acc, node) => (node.type === "text" && acc.push(node.value), node.type === "range" && (node.type = "text"), acc), []), exports2.flatten = (...args) => {
      const result = [], flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          ele !== void 0 && result.push(ele);
        }
        return result;
      };
      return flat(args), result;
    };
  }(utils$2)), utils$2;
}
var stringify, hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  const utils2 = requireUtils$2();
  return stringify = (ast, options2 = {}) => {
    const stringify3 = (node, parent = {}) => {
      const invalidBlock = options2.escapeInvalid && utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options2.escapeInvalid === !0;
      let output = "";
      if (node.value)
        return (invalidBlock || invalidNode) && utils2.isOpenOrClose(node) ? "\\" + node.value : node.value;
      if (node.value)
        return node.value;
      if (node.nodes)
        for (const child of node.nodes)
          output += stringify3(child);
      return output;
    };
    return stringify3(ast);
  }, stringify;
}
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isNumber, hasRequiredIsNumber;
function requireIsNumber() {
  return hasRequiredIsNumber || (hasRequiredIsNumber = 1, isNumber = function(num) {
    return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
  }), isNumber;
}
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var toRegexRange_1, hasRequiredToRegexRange;
function requireToRegexRange() {
  if (hasRequiredToRegexRange) return toRegexRange_1;
  hasRequiredToRegexRange = 1;
  const isNumber2 = requireIsNumber(), toRegexRange = (min2, max2, options2) => {
    if (isNumber2(min2) === !1)
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    if (max2 === void 0 || min2 === max2)
      return String(min2);
    if (isNumber2(max2) === !1)
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    let opts = { relaxZeros: !0, ...options2 };
    typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
    let relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap2 = String(opts.wrap), cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap2;
    if (toRegexRange.cache.hasOwnProperty(cacheKey))
      return toRegexRange.cache[cacheKey].result;
    let a = Math.min(min2, max2), b = Math.max(min2, max2);
    if (Math.abs(a - b) === 1) {
      let result = min2 + "|" + max2;
      return opts.capture ? `(${result})` : opts.wrap === !1 ? result : `(?:${result})`;
    }
    let isPadded = hasPadding(min2) || hasPadding(max2), state = { min: min2, max: max2, a, b }, positives = [], negatives = [];
    if (isPadded && (state.isPadded = isPadded, state.maxLen = String(state.max).length), a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts), a = state.a = 0;
    }
    return b >= 0 && (positives = splitToPatterns(a, b, state, opts)), state.negatives = negatives, state.positives = positives, state.result = collatePatterns(negatives, positives), opts.capture === !0 ? state.result = `(${state.result})` : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state.result = `(?:${state.result})`), toRegexRange.cache[cacheKey] = state, state.result;
  };
  function collatePatterns(neg, pos2, options2) {
    let onlyNegative = filterPatterns(neg, pos2, "-", !1) || [], onlyPositive = filterPatterns(pos2, neg, "", !1) || [], intersected = filterPatterns(neg, pos2, "-?", !0) || [];
    return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
  }
  function splitToRanges(min2, max2) {
    let nines = 1, zeros = 1, stop = countNines(min2, nines), stops = /* @__PURE__ */ new Set([max2]);
    for (; min2 <= stop && stop <= max2; )
      stops.add(stop), nines += 1, stop = countNines(min2, nines);
    for (stop = countZeros(max2 + 1, zeros) - 1; min2 < stop && stop <= max2; )
      stops.add(stop), zeros += 1, stop = countZeros(max2 + 1, zeros) - 1;
    return stops = [...stops], stops.sort(compare), stops;
  }
  function rangeToPattern(start, stop, options2) {
    if (start === stop)
      return { pattern: start, count: [], digits: 0 };
    let zipped = zip2(start, stop), digits = zipped.length, pattern = "", count2 = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit) : count2++;
    }
    return count2 && (pattern += options2.shorthand === !0 ? "\\d" : "[0-9]"), { pattern, count: [count2], digits };
  }
  function splitToPatterns(min2, max2, tok, options2) {
    let ranges = splitToRanges(min2, max2), tokens = [], start = min2, prev;
    for (let i = 0; i < ranges.length; i++) {
      let max3 = ranges[i], obj = rangeToPattern(String(start), String(max3), options2), zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = max3 + 1;
        continue;
      }
      tok.isPadded && (zeros = padZeros(max3, tok, options2)), obj.string = zeros + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = max3 + 1, prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options2) {
    let result = [];
    for (let ele of arr) {
      let { string } = ele;
      !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
    }
    return result;
  }
  function zip2(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key2, val) {
    return arr.some((ele) => ele[key2] === val);
  }
  function countNines(min2, len) {
    return Number(String(min2).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    return stop || start > 1 ? `{${start + (stop ? "," + stop : "")}}` : "";
  }
  function toCharacterClass(a, b, options2) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str2) {
    return /^-?(0+)\d/.test(str2);
  }
  function padZeros(value, tok, options2) {
    if (!tok.isPadded)
      return value;
    let diff = Math.abs(tok.maxLen - String(value).length), relax = options2.relaxZeros !== !1;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default:
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
  return toRegexRange.cache = {}, toRegexRange.clearCache = () => toRegexRange.cache = {}, toRegexRange_1 = toRegexRange, toRegexRange_1;
}
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var fillRange, hasRequiredFillRange;
function requireFillRange() {
  if (hasRequiredFillRange) return fillRange;
  hasRequiredFillRange = 1;
  const util2 = require$$0__default$6.default, toRegexRange = requireToRegexRange(), isObject2 = (val) => val !== null && typeof val == "object" && !Array.isArray(val), transform = (toNumber) => (value) => toNumber === !0 ? Number(value) : String(value), isValidValue = (value) => typeof value == "number" || typeof value == "string" && value !== "", isNumber2 = (num) => Number.isInteger(+num), zeros = (input2) => {
    let value = `${input2}`, index = -1;
    if (value[0] === "-" && (value = value.slice(1)), value === "0") return !1;
    for (; value[++index] === "0"; ) ;
    return index > 0;
  }, stringify3 = (start, end, options2) => typeof start == "string" || typeof end == "string" ? !0 : options2.stringify === !0, pad = (input2, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input2[0] === "-" ? "-" : "";
      dash && (input2 = input2.slice(1)), input2 = dash + input2.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    return toNumber === !1 ? String(input2) : input2;
  }, toMaxLen = (input2, maxLength) => {
    let negative = input2[0] === "-" ? "-" : "";
    for (negative && (input2 = input2.slice(1), maxLength--); input2.length < maxLength; ) input2 = "0" + input2;
    return negative ? "-" + input2 : input2;
  }, toSequence = (parts, options2, maxLen) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0), parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options2.capture ? "" : "?:", positives = "", negatives = "", result;
    return parts.positives.length && (positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|")), parts.negatives.length && (negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`), positives && negatives ? result = `${positives}|${negatives}` : result = positives || negatives, options2.wrap ? `(${prefix}${result})` : result;
  }, toRange = (a, b, isNumbers, options2) => {
    if (isNumbers)
      return toRegexRange(a, b, { wrap: !1, ...options2 });
    let start = String.fromCharCode(a);
    if (a === b) return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  }, toRegex = (start, end, options2) => {
    if (Array.isArray(start)) {
      let wrap2 = options2.wrap === !0, prefix = options2.capture ? "" : "?:";
      return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options2);
  }, rangeError = (...args) => new RangeError("Invalid range arguments: " + util2.inspect(...args)), invalidRange = (start, end, options2) => {
    if (options2.strictRanges === !0) throw rangeError([start, end]);
    return [];
  }, invalidStep = (step, options2) => {
    if (options2.strictRanges === !0)
      throw new TypeError(`Expected step "${step}" to be a number`);
    return [];
  }, fillNumbers = (start, end, step = 1, options2 = {}) => {
    let a = Number(start), b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options2.strictRanges === !0) throw rangeError([start, end]);
      return [];
    }
    a === 0 && (a = 0), b === 0 && (b = 0);
    let descending = a > b, startString = String(start), endString = String(end), stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify3(start, end, options2) === !1, format = options2.transform || transform(toNumber);
    if (options2.toRegex && step === 1)
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), !0, options2);
    let parts = { negatives: [], positives: [] }, push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), range2 = [], index = 0;
    for (; descending ? a >= b : a <= b; )
      options2.toRegex === !0 && step > 1 ? push2(a) : range2.push(pad(format(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
    return options2.toRegex === !0 ? step > 1 ? toSequence(parts, options2, maxLen) : toRegex(range2, null, { wrap: !1, ...options2 }) : range2;
  }, fillLetters = (start, end, step = 1, options2 = {}) => {
    if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1)
      return invalidRange(start, end, options2);
    let format = options2.transform || ((val) => String.fromCharCode(val)), a = `${start}`.charCodeAt(0), b = `${end}`.charCodeAt(0), descending = a > b, min2 = Math.min(a, b), max2 = Math.max(a, b);
    if (options2.toRegex && step === 1)
      return toRange(min2, max2, !1, options2);
    let range2 = [], index = 0;
    for (; descending ? a >= b : a <= b; )
      range2.push(format(a, index)), a = descending ? a - step : a + step, index++;
    return options2.toRegex === !0 ? toRegex(range2, null, { wrap: !1, options: options2 }) : range2;
  }, fill = (start, end, step, options2 = {}) => {
    if (end == null && isValidValue(start))
      return [start];
    if (!isValidValue(start) || !isValidValue(end))
      return invalidRange(start, end, options2);
    if (typeof step == "function")
      return fill(start, end, 1, { transform: step });
    if (isObject2(step))
      return fill(start, end, 0, step);
    let opts = { ...options2 };
    return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber2(step) ? isNumber2(start) && isNumber2(end) ? fillNumbers(start, end, step, opts) : fillLetters(start, end, Math.max(Math.abs(step), 1), opts) : step != null && !isObject2(step) ? invalidStep(step, opts) : fill(start, end, 1, step);
  };
  return fillRange = fill, fillRange;
}
var compile_1, hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile_1;
  hasRequiredCompile = 1;
  const fill = requireFillRange(), utils2 = requireUtils$2();
  return compile_1 = (ast, options2 = {}) => {
    const walk = (node, parent = {}) => {
      const invalidBlock = utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options2.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options2.escapeInvalid === !0 ? "\\" : "";
      let output = "";
      if (node.isOpen === !0)
        return prefix + node.value;
      if (node.isClose === !0)
        return console.log("node.isClose", prefix, node.value), prefix + node.value;
      if (node.type === "open")
        return invalid ? prefix + node.value : "(";
      if (node.type === "close")
        return invalid ? prefix + node.value : ")";
      if (node.type === "comma")
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      if (node.value)
        return node.value;
      if (node.nodes && node.ranges > 0) {
        const args = utils2.reduce(node.nodes), range2 = fill(...args, { ...options2, wrap: !1, toRegex: !0, strictZeros: !0 });
        if (range2.length !== 0)
          return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
      }
      if (node.nodes)
        for (const child of node.nodes)
          output += walk(child, node);
      return output;
    };
    return walk(ast);
  }, compile_1;
}
var expand_1, hasRequiredExpand$1;
function requireExpand$1() {
  if (hasRequiredExpand$1) return expand_1;
  hasRequiredExpand$1 = 1;
  const fill = requireFillRange(), stringify3 = requireStringify(), utils2 = requireUtils$2(), append = (queue2 = "", stash = "", enclose = !1) => {
    const result = [];
    if (queue2 = [].concat(queue2), stash = [].concat(stash), !stash.length) return queue2;
    if (!queue2.length)
      return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
    for (const item of queue2)
      if (Array.isArray(item))
        for (const value of item)
          result.push(append(value, stash, enclose));
      else
        for (let ele of stash)
          enclose === !0 && typeof ele == "string" && (ele = `{${ele}}`), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
    return utils2.flatten(result);
  };
  return expand_1 = (ast, options2 = {}) => {
    const rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit, walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent, q = parent.queue;
      for (; p.type !== "brace" && p.type !== "root" && p.parent; )
        p = p.parent, q = p.queue;
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify3(node, options2)));
        return;
      }
      if (node.type === "brace" && node.invalid !== !0 && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        const args = utils2.reduce(node.nodes);
        if (utils2.exceedsLimit(...args, options2.step, rangeLimit))
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        let range2 = fill(...args, options2);
        range2.length === 0 && (range2 = stringify3(node, options2)), q.push(append(q.pop(), range2)), node.nodes = [];
        return;
      }
      const enclose = utils2.encloseBrace(node);
      let queue2 = node.queue, block = node;
      for (; block.type !== "brace" && block.type !== "root" && block.parent; )
        block = block.parent, queue2 = block.queue;
      for (let i = 0; i < node.nodes.length; i++) {
        const child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          i === 1 && queue2.push(""), queue2.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue2, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue2.push(append(queue2.pop(), child.value));
          continue;
        }
        child.nodes && walk(child, node);
      }
      return queue2;
    };
    return utils2.flatten(walk(ast));
  }, expand_1;
}
var constants$2, hasRequiredConstants$2;
function requireConstants$2() {
  return hasRequiredConstants$2 || (hasRequiredConstants$2 = 1, constants$2 = {
    MAX_LENGTH: 1e4,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: `
`,
    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  }), constants$2;
}
var parse_1$1, hasRequiredParse$2;
function requireParse$2() {
  if (hasRequiredParse$2) return parse_1$1;
  hasRequiredParse$2 = 1;
  const stringify3 = requireStringify(), {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    /* \ */
    CHAR_BACKTICK,
    /* ` */
    CHAR_COMMA: CHAR_COMMA2,
    /* , */
    CHAR_DOT,
    /* . */
    CHAR_LEFT_PARENTHESES,
    /* ( */
    CHAR_RIGHT_PARENTHESES,
    /* ) */
    CHAR_LEFT_CURLY_BRACE,
    /* { */
    CHAR_RIGHT_CURLY_BRACE,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET,
    /* ] */
    CHAR_DOUBLE_QUOTE,
    /* " */
    CHAR_SINGLE_QUOTE,
    /* ' */
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = requireConstants$2();
  return parse_1$1 = (input2, options2 = {}) => {
    if (typeof input2 != "string")
      throw new TypeError("Expected a string");
    const opts = options2 || {}, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input2.length > max2)
      throw new SyntaxError(`Input length (${input2.length}), exceeds max characters (${max2})`);
    const ast = { type: "root", input: input2, nodes: [] }, stack2 = [ast];
    let block = ast, prev = ast, brackets = 0;
    const length = input2.length;
    let index = 0, depth = 0, value;
    const advance = () => input2[index++], push2 = (node) => {
      if (node.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      return block.nodes.push(node), node.parent = block, node.prev = prev, prev = node, node;
    };
    for (push2({ type: "bos" }); index < length; )
      if (block = stack2[stack2.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
        if (value === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push2({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          for (; index < length && (next = advance()); ) {
            if (value += next, next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET && (brackets--, brackets === 0))
              break;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push2({ type: "paren", nodes: [] }), stack2.push(block), push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push2({ type: "text", value });
            continue;
          }
          block = stack2.pop(), push2({ type: "text", value }), block = stack2[stack2.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open2 = value;
          let next;
          for (options2.keepQuotes !== !0 && (value = ""); index < length && (next = advance()); ) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open2) {
              options2.keepQuotes === !0 && (value += next);
              break;
            }
            value += next;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const brace = {
            type: "brace",
            open: !0,
            close: !1,
            dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === !0,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace), stack2.push(block), push2({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push2({ type: "text", value });
            continue;
          }
          const type2 = "close";
          block = stack2.pop(), block.close = !0, push2({ type: type2, value }), depth--, block = stack2[stack2.length - 1];
          continue;
        }
        if (value === CHAR_COMMA2 && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify3(block) }];
          }
          push2({ type: "comma", value }), block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push2({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = !0, block.ranges = 0, prev.type = "text";
              continue;
            }
            block.ranges++, block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value, prev = before, block.ranges--;
            continue;
          }
          push2({ type: "dot", value });
          continue;
        }
        push2({ type: "text", value });
      }
    do
      if (block = stack2.pop(), block.type !== "root") {
        block.nodes.forEach((node) => {
          node.nodes || (node.type === "open" && (node.isOpen = !0), node.type === "close" && (node.isClose = !0), node.nodes || (node.type = "text"), node.invalid = !0);
        });
        const parent = stack2[stack2.length - 1], index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    while (stack2.length > 0);
    return push2({ type: "eos" }), ast;
  }, parse_1$1;
}
var braces_1, hasRequiredBraces;
function requireBraces() {
  if (hasRequiredBraces) return braces_1;
  hasRequiredBraces = 1;
  const stringify3 = requireStringify(), compile = requireCompile(), expand2 = requireExpand$1(), parse3 = requireParse$2(), braces = (input2, options2 = {}) => {
    let output = [];
    if (Array.isArray(input2))
      for (const pattern of input2) {
        const result = braces.create(pattern, options2);
        Array.isArray(result) ? output.push(...result) : output.push(result);
      }
    else
      output = [].concat(braces.create(input2, options2));
    return options2 && options2.expand === !0 && options2.nodupes === !0 && (output = [...new Set(output)]), output;
  };
  return braces.parse = (input2, options2 = {}) => parse3(input2, options2), braces.stringify = (input2, options2 = {}) => stringify3(typeof input2 == "string" ? braces.parse(input2, options2) : input2, options2), braces.compile = (input2, options2 = {}) => (typeof input2 == "string" && (input2 = braces.parse(input2, options2)), compile(input2, options2)), braces.expand = (input2, options2 = {}) => {
    typeof input2 == "string" && (input2 = braces.parse(input2, options2));
    let result = expand2(input2, options2);
    return options2.noempty === !0 && (result = result.filter(Boolean)), options2.nodupes === !0 && (result = [...new Set(result)]), result;
  }, braces.create = (input2, options2 = {}) => input2 === "" || input2.length < 3 ? [input2] : options2.expand !== !0 ? braces.compile(input2, options2) : braces.expand(input2, options2), braces_1 = braces, braces_1;
}
var utils$1 = {}, constants$1, hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const path2 = require$$0__default.default, WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  }, WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  }, POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  return constants$1 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: path2.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(win32) {
      return win32 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
    }
  }, constants$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(exports2) {
    const path2 = require$$0__default.default, win32 = process.platform === "win32", {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = requireConstants$1();
    exports2.isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val), exports2.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2), exports2.isRegexChar = (str2) => str2.length === 1 && exports2.hasRegexChars(str2), exports2.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1"), exports2.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/"), exports2.removeBackslashes = (str2) => str2.replace(REGEX_REMOVE_BACKSLASH, (match2) => match2 === "\\" ? "" : match2), exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
    }, exports2.isWindows = (options2) => options2 && typeof options2.windows == "boolean" ? options2.windows : win32 === !0 || path2.sep === "\\", exports2.escapeLast = (input2, char, lastIdx) => {
      const idx = input2.lastIndexOf(char, lastIdx);
      return idx === -1 ? input2 : input2[idx - 1] === "\\" ? exports2.escapeLast(input2, char, idx - 1) : `${input2.slice(0, idx)}\\${input2.slice(idx)}`;
    }, exports2.removePrefix = (input2, state = {}) => {
      let output = input2;
      return output.startsWith("./") && (output = output.slice(2), state.prefix = "./"), output;
    }, exports2.wrapOutput = (input2, state = {}, options2 = {}) => {
      const prepend = options2.contains ? "" : "^", append = options2.contains ? "" : "$";
      let output = `${prepend}(?:${input2})${append}`;
      return state.negated === !0 && (output = `(?:^(?!${output}).*$)`), output;
    };
  }(utils$1)), utils$1;
}
var scan_1, hasRequiredScan;
function requireScan() {
  if (hasRequiredScan) return scan_1;
  hasRequiredScan = 1;
  const utils2 = requireUtils$1(), {
    CHAR_ASTERISK,
    /* * */
    CHAR_AT,
    /* @ */
    CHAR_BACKWARD_SLASH,
    /* \ */
    CHAR_COMMA: CHAR_COMMA2,
    /* , */
    CHAR_DOT,
    /* . */
    CHAR_EXCLAMATION_MARK,
    /* ! */
    CHAR_FORWARD_SLASH,
    /* / */
    CHAR_LEFT_CURLY_BRACE,
    /* { */
    CHAR_LEFT_PARENTHESES,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET,
    /* [ */
    CHAR_PLUS: CHAR_PLUS2,
    /* + */
    CHAR_QUESTION_MARK,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE,
    /* } */
    CHAR_RIGHT_PARENTHESES,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET
    /* ] */
  } = requireConstants$1(), isPathSeparator = (code) => code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH, depth = (token2) => {
    token2.isPrefix !== !0 && (token2.depth = token2.isGlobstar ? 1 / 0 : 1);
  };
  return scan_1 = (input2, options2) => {
    const opts = options2 || {}, length = input2.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [];
    let str2 = input2, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces = 0, prev, code, token2 = { value: "", depth: 0, isGlob: !1 };
    const eos = () => index >= length, peek2 = () => str2.charCodeAt(index + 1), advance = () => (prev = code, str2.charCodeAt(++index));
    for (; index < length; ) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token2.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
        continue;
      }
      if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
        for (braces++; eos() !== !0 && (code = advance()); ) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token2.backslashes = !0, advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
              continue;
            break;
          }
          if (braceEscaped !== !0 && code === CHAR_COMMA2) {
            if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
              continue;
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE && (braces--, braces === 0)) {
            braceEscaped = !1, isBrace = token2.isBrace = !0, finished = !0;
            break;
          }
        }
        if (scanToEnd === !0)
          continue;
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        if (slashes.push(index), tokens.push(token2), token2 = { value: "", depth: 0, isGlob: !1 }, finished === !0) continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== !0 && (code === CHAR_PLUS2 || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK) === !0 && peek2() === CHAR_LEFT_PARENTHESES) {
        if (isGlob = token2.isGlob = !0, isExtglob = token2.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
          for (; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = !0, code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token2.isGlob = !0, finished = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK && (isGlobstar = token2.isGlobstar = !0), isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
          continue;
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        if (isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
          continue;
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        for (; eos() !== !0 && (next = advance()); ) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token2.backslashes = !0, advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token2.isBracket = !0, isGlob = token2.isGlob = !0, finished = !0;
            break;
          }
        }
        if (scanToEnd === !0)
          continue;
        break;
      }
      if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token2.negated = !0, start++;
        continue;
      }
      if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
        if (isGlob = token2.isGlob = !0, scanToEnd === !0) {
          for (; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token2.backslashes = !0, code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === !0) {
        if (finished = !0, scanToEnd === !0)
          continue;
        break;
      }
    }
    opts.noext === !0 && (isExtglob = !1, isGlob = !1);
    let base2 = str2, prefix = "", glob2 = "";
    start > 0 && (prefix = str2.slice(0, start), str2 = str2.slice(start), lastIndex -= start), base2 && isGlob === !0 && lastIndex > 0 ? (base2 = str2.slice(0, lastIndex), glob2 = str2.slice(lastIndex)) : isGlob === !0 ? (base2 = "", glob2 = str2) : base2 = str2, base2 && base2 !== "" && base2 !== "/" && base2 !== str2 && isPathSeparator(base2.charCodeAt(base2.length - 1)) && (base2 = base2.slice(0, -1)), opts.unescape === !0 && (glob2 && (glob2 = utils2.removeBackslashes(glob2)), base2 && backslashes === !0 && (base2 = utils2.removeBackslashes(base2)));
    const state = {
      prefix,
      input: input2,
      start,
      base: base2,
      glob: glob2,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === !0 && (state.maxDepth = 0, isPathSeparator(code) || tokens.push(token2), state.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
      let prevIndex;
      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start, i = slashes[idx], value = input2.slice(n, i);
        opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input2.length) {
        const value = input2.slice(prevIndex + 1);
        parts.push(value), opts.tokens && (tokens[tokens.length - 1].value = value, depth(tokens[tokens.length - 1]), state.maxDepth += tokens[tokens.length - 1].depth);
      }
      state.slashes = slashes, state.parts = parts;
    }
    return state;
  }, scan_1;
}
var parse_1, hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse_1;
  hasRequiredParse$1 = 1;
  const constants2 = requireConstants$1(), utils2 = requireUtils$1(), {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants2, expandRange = (args, options2) => {
    if (typeof options2.expandRange == "function")
      return options2.expandRange(...args, options2);
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch {
      return args.map((v) => utils2.escapeRegex(v)).join("..");
    }
    return value;
  }, syntaxError2 = (type2, char) => `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`, parse3 = (input2, options2) => {
    if (typeof input2 != "string")
      throw new TypeError("Expected a string");
    input2 = REPLACEMENTS[input2] || input2;
    const opts = { ...options2 }, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input2.length;
    if (len > max2)
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    const bos = { type: "bos", value: "", output: opts.prepend || "" }, tokens = [bos], capture = opts.capture ? "" : "?:", win32 = utils2.isWindows(options2), PLATFORM_CHARS = constants2.globChars(win32), EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS), {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS, globstar = (opts2) => `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, nodot = opts.dot ? "" : NO_DOT, qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star3 = opts.bash === !0 ? globstar(opts) : STAR;
    opts.capture && (star3 = `(${star3})`), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
    const state = {
      input: input2,
      index: -1,
      start: 0,
      dot: opts.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens
    };
    input2 = utils2.removePrefix(input2, state), len = input2.length;
    const extglobs = [], braces = [], stack2 = [];
    let prev = bos, value;
    const eos = () => state.index === len - 1, peek2 = state.peek = (n = 1) => input2[state.index + n], advance = state.advance = () => input2[++state.index] || "", remaining = () => input2.slice(state.index + 1), consume = (value2 = "", num = 0) => {
      state.consumed += value2, state.index += num;
    }, append = (token2) => {
      state.output += token2.output != null ? token2.output : token2.value, consume(token2.value);
    }, negate = () => {
      let count2 = 1;
      for (; peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?"); )
        advance(), state.start++, count2++;
      return count2 % 2 === 0 ? !1 : (state.negated = !0, state.start++, !0);
    }, increment = (type2) => {
      state[type2]++, stack2.push(type2);
    }, decrement = (type2) => {
      state[type2]--, stack2.pop();
    }, push2 = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob && (state.output = state.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star3, state.output += prev.output);
      }
      if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append(tok), prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev, tokens.push(tok), prev = tok;
    }, extglobOpen = (type2, value2) => {
      const token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token2.prev = prev, token2.parens = state.parens, token2.output = state.output;
      const output = (opts.capture ? "(" : "") + token2.open;
      increment("parens"), push2({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR }), push2({ type: "paren", extglob: !0, value: advance(), output }), extglobs.push(token2);
    }, extglobClose = (token2) => {
      let output = token2.close + (opts.capture ? ")" : ""), rest;
      if (token2.type === "negate") {
        let extglobStar = star3;
        if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) && (output = token2.close = `)$))${extglobStar}`), token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse3(rest, { ...options2, fastpaths: !1 }).output;
          output = token2.close = `)${expression})${extglobStar})`;
        }
        token2.prev.type === "bos" && (state.negatedExtglob = !0);
      }
      push2({ type: "paren", extglob: !0, value, output }), decrement("parens");
    };
    if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input2)) {
      let backslashes = !1, output = input2.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first2, rest, index) => first2 === "\\" ? (backslashes = !0, m) : first2 === "?" ? esc ? esc + first2 + (rest ? QMARK.repeat(rest.length) : "") : index === 0 ? qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "") : QMARK.repeat(chars.length) : first2 === "." ? DOT_LITERAL.repeat(chars.length) : first2 === "*" ? esc ? esc + first2 + (rest ? star3 : "") : star3 : esc ? m : `\\${m}`);
      return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, (m) => m.length % 2 === 0 ? "\\\\" : m ? "\\" : "")), output === input2 && opts.contains === !0 ? (state.output = input2, state) : (state.output = utils2.wrapOutput(output, state, options2), state);
    }
    for (; !eos(); ) {
      if (value = advance(), value === "\0")
        continue;
      if (value === "\\") {
        const next = peek2();
        if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
          continue;
        if (!next) {
          value += "\\", push2({ type: "text", value });
          continue;
        }
        const match2 = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match2 && match2[0].length > 2 && (slashes = match2[0].length, state.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state.brackets === 0) {
          push2({ type: "text", value });
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== !1 && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
            const idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest2 = prev.value.slice(idx + 2), posix2 = POSIX_REGEX_SOURCE[rest2];
            if (posix2) {
              prev.value = pre + posix2, state.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR);
              continue;
            }
          }
        }
        (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") && (value = `\\${value}`), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = `\\${value}`), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append({ value });
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils2.escapeRegex(value), prev.value += value, append({ value });
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push2({ type: "text", value });
        continue;
      }
      if (value === "(") {
        increment("parens"), push2({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError2("opening", "("));
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push2({ type: "paren", value, output: state.parens ? ")" : "\\)" }), decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === !0 || !remaining().includes("]")) {
          if (opts.nobracket !== !0 && opts.strictBrackets === !0)
            throw new SyntaxError(syntaxError2("closing", "]"));
          value = `\\${value}`;
        } else
          increment("brackets");
        push2({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
          push2({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === !0)
            throw new SyntaxError(syntaxError2("opening", "["));
          push2({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = `/${value}`), prev.value += value, append({ value }), opts.literalBrackets === !1 || utils2.hasRegexChars(prevValue))
          continue;
        const escaped = utils2.escapeRegex(prev.value);
        if (state.output = state.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
          state.output += escaped, prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`, state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== !0) {
        increment("braces");
        const open2 = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open2), push2(open2);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === !0 || !brace) {
          push2({ type: "text", value, output: value });
          continue;
        }
        let output = ")";
        if (brace.dots === !0) {
          const arr = tokens.slice(), range2 = [];
          for (let i = arr.length - 1; i >= 0 && (tokens.pop(), arr[i].type !== "brace"); i--)
            arr[i].type !== "dots" && range2.unshift(arr[i].value);
          output = expandRange(range2, opts), state.backtrack = !0;
        }
        if (brace.comma !== !0 && brace.dots !== !0) {
          const out = state.output.slice(0, brace.outputIndex), toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{", value = output = "\\}", state.output = out;
          for (const t of toks)
            state.output += t.output || t.value;
        }
        push2({ type: "brace", value, output }), decrement("braces"), braces.pop();
        continue;
      }
      if (value === "|") {
        extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push2({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        brace && stack2[stack2.length - 1] === "braces" && (brace.comma = !0, output = "|"), push2({ type: "comma", value, output });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1, state.consumed = "", state.output = "", tokens.pop(), prev = bos;
          continue;
        }
        push2({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          prev.value === "." && (prev.output = DOT_LITERAL);
          const brace = braces[braces.length - 1];
          prev.type = "dots", prev.output += value, prev.value += value, brace.dots = !0;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push2({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push2({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        if (!(prev && prev.value === "(") && opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek2();
          let output = value;
          if (next === "<" && !utils2.supportsLookbehinds())
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output = `\\${value}`), push2({ type: "text", value, output });
          continue;
        }
        if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
          push2({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push2({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== !0 && peek2() === "(" && (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3)))) {
          extglobOpen("negate", value);
          continue;
        }
        if (opts.nonegate !== !0 && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === !1) {
          push2({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push2({ type: "plus", value });
          continue;
        }
        push2({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
          push2({ type: "at", extglob: !0, value, output: "" });
          continue;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        (value === "$" || value === "^") && (value = `\\${value}`);
        const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        match2 && (value += match2[0], state.index += match2[0].length), push2({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === !0)) {
        prev.type = "star", prev.star = !0, prev.value += value, prev.output = star3, state.backtrack = !0, state.globstar = !0, consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== !0 && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === !0) {
          consume(value);
          continue;
        }
        const prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === !0 && (!isStart || rest[0] && rest[0] !== "/")) {
          push2({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push2({ type: "star", value, output: "" });
          continue;
        }
        for (; rest.slice(0, 3) === "/**"; ) {
          const after = input2[state.index + 4];
          if (after && after !== "/")
            break;
          rest = rest.slice(3), consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state.output = prev.output, state.globstar = !0, consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state.globstar = !0, state.output += prior.output + prev.output, consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`, prev.value += value, state.output += prior.output + prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar", prev.value += value, prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`, state.output = prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state.output += prev.output, state.globstar = !0, consume(value);
        continue;
      }
      const token2 = { type: "star", value, output: star3 };
      if (opts.bash === !0) {
        token2.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token2.output = nodot + token2.output), push2(token2);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
        token2.output = value, push2(token2);
        continue;
      }
      (state.index === state.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state.output += NO_DOT_SLASH, prev.output += NO_DOT_SLASH) : opts.dot === !0 ? (state.output += NO_DOTS_SLASH, prev.output += NO_DOTS_SLASH) : (state.output += nodot, prev.output += nodot), peek2() !== "*" && (state.output += ONE_CHAR, prev.output += ONE_CHAR)), push2(token2);
    }
    for (; state.brackets > 0; ) {
      if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", "]"));
      state.output = utils2.escapeLast(state.output, "["), decrement("brackets");
    }
    for (; state.parens > 0; ) {
      if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", ")"));
      state.output = utils2.escapeLast(state.output, "("), decrement("parens");
    }
    for (; state.braces > 0; ) {
      if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", "}"));
      state.output = utils2.escapeLast(state.output, "{"), decrement("braces");
    }
    if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` }), state.backtrack === !0) {
      state.output = "";
      for (const token2 of state.tokens)
        state.output += token2.output != null ? token2.output : token2.value, token2.suffix && (state.output += token2.suffix);
    }
    return state;
  };
  return parse3.fastpaths = (input2, options2) => {
    const opts = { ...options2 }, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input2.length;
    if (len > max2)
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    input2 = REPLACEMENTS[input2] || input2;
    const win32 = utils2.isWindows(options2), {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants2.globChars(win32), nodot = opts.dot ? NO_DOTS : NO_DOT, slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT, capture = opts.capture ? "" : "?:", state = { negated: !1, prefix: "" };
    let star3 = opts.bash === !0 ? ".*?" : STAR;
    opts.capture && (star3 = `(${star3})`);
    const globstar = (opts2) => opts2.noglobstar === !0 ? star3 : `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, create = (str2) => {
      switch (str2) {
        case "*":
          return `${nodot}${ONE_CHAR}${star3}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
        case "*.*":
          return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
        case "*/*":
          return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
        default: {
          const match2 = /^(.*?)\.(\w+)$/.exec(str2);
          if (!match2) return;
          const source3 = create(match2[1]);
          return source3 ? source3 + DOT_LITERAL + match2[2] : void 0;
        }
      }
    }, output = utils2.removePrefix(input2, state);
    let source2 = create(output);
    return source2 && opts.strictSlashes !== !0 && (source2 += `${SLASH_LITERAL}?`), source2;
  }, parse_1 = parse3, parse_1;
}
var picomatch_1, hasRequiredPicomatch$1;
function requirePicomatch$1() {
  if (hasRequiredPicomatch$1) return picomatch_1;
  hasRequiredPicomatch$1 = 1;
  const path2 = require$$0__default.default, scan2 = requireScan(), parse3 = requireParse$1(), utils2 = requireUtils$1(), constants2 = requireConstants$1(), isObject2 = (val) => val && typeof val == "object" && !Array.isArray(val), picomatch2 = (glob2, options2, returnState = !1) => {
    if (Array.isArray(glob2)) {
      const fns = glob2.map((input2) => picomatch2(input2, options2, returnState));
      return (str2) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str2);
          if (state2) return state2;
        }
        return !1;
      };
    }
    const isState = isObject2(glob2) && glob2.tokens && glob2.input;
    if (glob2 === "" || typeof glob2 != "string" && !isState)
      throw new TypeError("Expected pattern to be a non-empty string");
    const opts = options2 || {}, posix2 = utils2.isWindows(options2), regex2 = isState ? picomatch2.compileRe(glob2, options2) : picomatch2.makeRe(glob2, options2, !1, !0), state = regex2.state;
    delete regex2.state;
    let isIgnored = () => !1;
    if (opts.ignore) {
      const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input2, returnObject = !1) => {
      const { isMatch, match: match2, output } = picomatch2.test(input2, regex2, options2, { glob: glob2, posix: posix2 }), result = { glob: glob2, state, regex: regex2, posix: posix2, input: input2, output, match: match2, isMatch };
      return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored(input2) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
    };
    return returnState && (matcher.state = state), matcher;
  };
  return picomatch2.test = (input2, regex2, options2, { glob: glob2, posix: posix2 } = {}) => {
    if (typeof input2 != "string")
      throw new TypeError("Expected input to be a string");
    if (input2 === "")
      return { isMatch: !1, output: "" };
    const opts = options2 || {}, format = opts.format || (posix2 ? utils2.toPosixSlashes : null);
    let match2 = input2 === glob2, output = match2 && format ? format(input2) : input2;
    return match2 === !1 && (output = format ? format(input2) : input2, match2 = output === glob2), (match2 === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match2 = picomatch2.matchBase(input2, regex2, options2, posix2) : match2 = regex2.exec(output)), { isMatch: !!match2, match: match2, output };
  }, picomatch2.matchBase = (input2, glob2, options2, posix2 = utils2.isWindows(options2)) => (glob2 instanceof RegExp ? glob2 : picomatch2.makeRe(glob2, options2)).test(path2.basename(input2)), picomatch2.isMatch = (str2, patterns, options2) => picomatch2(patterns, options2)(str2), picomatch2.parse = (pattern, options2) => Array.isArray(pattern) ? pattern.map((p) => picomatch2.parse(p, options2)) : parse3(pattern, { ...options2, fastpaths: !1 }), picomatch2.scan = (input2, options2) => scan2(input2, options2), picomatch2.compileRe = (state, options2, returnOutput = !1, returnState = !1) => {
    if (returnOutput === !0)
      return state.output;
    const opts = options2 || {}, prepend = opts.contains ? "" : "^", append = opts.contains ? "" : "$";
    let source2 = `${prepend}(?:${state.output})${append}`;
    state && state.negated === !0 && (source2 = `^(?!${source2}).*$`);
    const regex2 = picomatch2.toRegex(source2, options2);
    return returnState === !0 && (regex2.state = state), regex2;
  }, picomatch2.makeRe = (input2, options2 = {}, returnOutput = !1, returnState = !1) => {
    if (!input2 || typeof input2 != "string")
      throw new TypeError("Expected a non-empty string");
    let parsed = { negated: !1, fastpaths: !0 };
    return options2.fastpaths !== !1 && (input2[0] === "." || input2[0] === "*") && (parsed.output = parse3.fastpaths(input2, options2)), parsed.output || (parsed = parse3(input2, options2)), picomatch2.compileRe(parsed, options2, returnOutput, returnState);
  }, picomatch2.toRegex = (source2, options2) => {
    try {
      const opts = options2 || {};
      return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options2 && options2.debug === !0) throw err;
      return /$^/;
    }
  }, picomatch2.constants = constants2, picomatch_1 = picomatch2, picomatch_1;
}
var picomatch, hasRequiredPicomatch;
function requirePicomatch() {
  return hasRequiredPicomatch || (hasRequiredPicomatch = 1, picomatch = requirePicomatch$1()), picomatch;
}
var micromatch_1, hasRequiredMicromatch;
function requireMicromatch() {
  if (hasRequiredMicromatch) return micromatch_1;
  hasRequiredMicromatch = 1;
  const util2 = require$$0__default$6.default, braces = requireBraces(), picomatch2 = requirePicomatch(), utils2 = requireUtils$1(), isEmptyString = (v) => v === "" || v === "./", hasBraces = (v) => {
    const index = v.indexOf("{");
    return index > -1 && v.indexOf("}", index) > -1;
  }, micromatch = (list2, patterns, options2) => {
    patterns = [].concat(patterns), list2 = [].concat(list2);
    let omit = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = (state) => {
      items.add(state.output), options2 && options2.onResult && options2.onResult(state);
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch2(String(patterns[i]), { ...options2, onResult }, !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      negated && negatives++;
      for (let item of list2) {
        let matched = isMatch(item, !0);
        (negated ? !matched.isMatch : matched.isMatch) && (negated ? omit.add(matched.output) : (omit.delete(matched.output), keep.add(matched.output)));
      }
    }
    let matches = (negatives === patterns.length ? [...items] : [...keep]).filter((item) => !omit.has(item));
    if (options2 && matches.length === 0) {
      if (options2.failglob === !0)
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      if (options2.nonull === !0 || options2.nullglob === !0)
        return options2.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
    }
    return matches;
  };
  return micromatch.match = micromatch, micromatch.matcher = (pattern, options2) => picomatch2(pattern, options2), micromatch.isMatch = (str2, patterns, options2) => picomatch2(patterns, options2)(str2), micromatch.any = micromatch.isMatch, micromatch.not = (list2, patterns, options2 = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = /* @__PURE__ */ new Set(), items = [], onResult = (state) => {
      options2.onResult && options2.onResult(state), items.push(state.output);
    }, matches = new Set(micromatch(list2, patterns, { ...options2, onResult }));
    for (let item of items)
      matches.has(item) || result.add(item);
    return [...result];
  }, micromatch.contains = (str2, pattern, options2) => {
    if (typeof str2 != "string")
      throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
    if (Array.isArray(pattern))
      return pattern.some((p) => micromatch.contains(str2, p, options2));
    if (typeof pattern == "string") {
      if (isEmptyString(str2) || isEmptyString(pattern))
        return !1;
      if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern))
        return !0;
    }
    return micromatch.isMatch(str2, pattern, { ...options2, contains: !0 });
  }, micromatch.matchKeys = (obj, patterns, options2) => {
    if (!utils2.isObject(obj))
      throw new TypeError("Expected the first argument to be an object");
    let keys = micromatch(Object.keys(obj), patterns, options2), res = {};
    for (let key2 of keys) res[key2] = obj[key2];
    return res;
  }, micromatch.some = (list2, patterns, options2) => {
    let items = [].concat(list2);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch2(String(pattern), options2);
      if (items.some((item) => isMatch(item)))
        return !0;
    }
    return !1;
  }, micromatch.every = (list2, patterns, options2) => {
    let items = [].concat(list2);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch2(String(pattern), options2);
      if (!items.every((item) => isMatch(item)))
        return !1;
    }
    return !0;
  }, micromatch.all = (str2, patterns, options2) => {
    if (typeof str2 != "string")
      throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
    return [].concat(patterns).every((p) => picomatch2(p, options2)(str2));
  }, micromatch.capture = (glob2, input2, options2) => {
    let posix2 = utils2.isWindows(options2), match2 = picomatch2.makeRe(String(glob2), { ...options2, capture: !0 }).exec(posix2 ? utils2.toPosixSlashes(input2) : input2);
    if (match2)
      return match2.slice(1).map((v) => v === void 0 ? "" : v);
  }, micromatch.makeRe = (...args) => picomatch2.makeRe(...args), micromatch.scan = (...args) => picomatch2.scan(...args), micromatch.parse = (patterns, options2) => {
    let res = [];
    for (let pattern of [].concat(patterns || []))
      for (let str2 of braces(String(pattern), options2))
        res.push(picomatch2.parse(str2, options2));
    return res;
  }, micromatch.braces = (pattern, options2) => {
    if (typeof pattern != "string") throw new TypeError("Expected a string");
    return options2 && options2.nobrace === !0 || !hasBraces(pattern) ? [pattern] : braces(pattern, options2);
  }, micromatch.braceExpand = (pattern, options2) => {
    if (typeof pattern != "string") throw new TypeError("Expected a string");
    return micromatch.braces(pattern, { ...options2, expand: !0 });
  }, micromatch.hasBraces = hasBraces, micromatch_1 = micromatch, micromatch_1;
}
var hasRequiredCore$3;
function requireCore$3() {
  if (hasRequiredCore$3) return core$3;
  hasRequiredCore$3 = 1;
  var __importDefault2 = core$3 && core$3.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(core$3, "__esModule", { value: !0 }), core$3.readPackageJSON = core$3.extractWorkspaces = core$3.isMatchWorkspaces = core$3.checkWorkspaces = core$3.findWorkspaceRoot = void 0;
  const path_1 = __importDefault2(require$$0__default.default), pkg_dir_1 = __importDefault2(pkgDir__default.default), fs_1 = require$$0__default$1.default, micromatch_12 = __importDefault2(requireMicromatch());
  function findWorkspaceRoot(initial) {
    initial || (initial = process.cwd());
    let _pkg = pkg_dir_1.default.sync(initial);
    if (!_pkg)
      return null;
    initial = path_1.default.normalize(_pkg);
    let previous = null, current = initial;
    do {
      const manifest = readPackageJSON(current);
      extractWorkspaces(manifest);
      let { done, found } = checkWorkspaces(current, initial);
      if (done)
        return found;
      previous = current, current = path_1.default.dirname(current);
    } while (current !== previous);
    return null;
  }
  core$3.findWorkspaceRoot = findWorkspaceRoot;
  function checkWorkspaces(current, initial) {
    const manifest = readPackageJSON(current), workspaces = extractWorkspaces(manifest);
    let done = !1, found, relativePath;
    return workspaces && (done = !0, relativePath = path_1.default.relative(current, initial), relativePath === "" || isMatchWorkspaces(relativePath, workspaces) ? found = current : found = null), {
      done,
      found,
      relativePath
    };
  }
  core$3.checkWorkspaces = checkWorkspaces;
  function isMatchWorkspaces(relativePath, workspaces) {
    return micromatch_12.default([relativePath], workspaces).length > 0;
  }
  core$3.isMatchWorkspaces = isMatchWorkspaces;
  function extractWorkspaces(manifest) {
    const workspaces = (manifest || {}).workspaces;
    return workspaces && workspaces.packages || (Array.isArray(workspaces) ? workspaces : null);
  }
  core$3.extractWorkspaces = extractWorkspaces;
  function readPackageJSON(dir) {
    const file = path_1.default.join(dir, "package.json");
    return fs_1.existsSync(file) ? JSON.parse(fs_1.readFileSync(file, "utf8")) : null;
  }
  return core$3.readPackageJSON = readPackageJSON, findWorkspaceRoot.findWorkspaceRoot = findWorkspaceRoot, findWorkspaceRoot.readPackageJSON = readPackageJSON, findWorkspaceRoot.extractWorkspaces = extractWorkspaces, findWorkspaceRoot.isMatchWorkspaces = isMatchWorkspaces, findWorkspaceRoot.default = findWorkspaceRoot, core$3.default = findWorkspaceRoot, core$3;
}
var findYarnWorkspaceRoot2, hasRequiredFindYarnWorkspaceRoot2;
function requireFindYarnWorkspaceRoot2() {
  return hasRequiredFindYarnWorkspaceRoot2 || (hasRequiredFindYarnWorkspaceRoot2 = 1, findYarnWorkspaceRoot2 = requireCore$3().findWorkspaceRoot), findYarnWorkspaceRoot2;
}
var findUp = { exports: {} }, locatePath = { exports: {} }, yoctoQueue, hasRequiredYoctoQueue;
function requireYoctoQueue() {
  if (hasRequiredYoctoQueue) return yoctoQueue;
  hasRequiredYoctoQueue = 1;
  class Node {
    /// value;
    /// next;
    constructor(value) {
      this.value = value, this.next = void 0;
    }
  }
  class Queue {
    // TODO: Use private class fields when targeting Node.js 12.
    // #_head;
    // #_tail;
    // #_size;
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node(value);
      this._head ? (this._tail.next = node, this._tail = node) : (this._head = node, this._tail = node), this._size++;
    }
    dequeue() {
      const current = this._head;
      if (current)
        return this._head = this._head.next, this._size--, current.value;
    }
    clear() {
      this._head = void 0, this._tail = void 0, this._size = 0;
    }
    get size() {
      return this._size;
    }
    *[Symbol.iterator]() {
      let current = this._head;
      for (; current; )
        yield current.value, current = current.next;
    }
  }
  return yoctoQueue = Queue, yoctoQueue;
}
var pLimit_1, hasRequiredPLimit;
function requirePLimit() {
  if (hasRequiredPLimit) return pLimit_1;
  hasRequiredPLimit = 1;
  const Queue = requireYoctoQueue();
  return pLimit_1 = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === 1 / 0) && concurrency > 0))
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    const queue2 = new Queue();
    let activeCount = 0;
    const next = () => {
      activeCount--, queue2.size > 0 && queue2.dequeue()();
    }, run = async (fn, resolve, ...args) => {
      activeCount++;
      const result = (async () => fn(...args))();
      resolve(result);
      try {
        await result;
      } catch {
      }
      next();
    }, enqueue = (fn, resolve, ...args) => {
      queue2.enqueue(run.bind(null, fn, resolve, ...args)), (async () => (await Promise.resolve(), activeCount < concurrency && queue2.size > 0 && queue2.dequeue()()))();
    }, generator = (fn, ...args) => new Promise((resolve) => {
      enqueue(fn, resolve, ...args);
    });
    return Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue2.size
      },
      clearQueue: {
        value: () => {
          queue2.clear();
        }
      }
    }), generator;
  }, pLimit_1;
}
var pLocate_1, hasRequiredPLocate;
function requirePLocate() {
  if (hasRequiredPLocate) return pLocate_1;
  hasRequiredPLocate = 1;
  const pLimit = requirePLimit();
  class EndError extends Error {
    constructor(value) {
      super(), this.value = value;
    }
  }
  const testElement = async (element, tester) => tester(await element), finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === !0)
      throw new EndError(values[0]);
    return !1;
  };
  return pLocate_1 = async (iterable, tester, options2) => {
    options2 = {
      concurrency: 1 / 0,
      preserveOrder: !0,
      ...options2
    };
    const limit = pLimit(options2.concurrency), items = [...iterable].map((element) => [element, limit(testElement, element, tester)]), checkLimit = pLimit(options2.preserveOrder ? 1 : 1 / 0);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error2) {
      if (error2 instanceof EndError)
        return error2.value;
      throw error2;
    }
  }, pLocate_1;
}
var hasRequiredLocatePath;
function requireLocatePath() {
  if (hasRequiredLocatePath) return locatePath.exports;
  hasRequiredLocatePath = 1;
  const path2 = require$$0__default.default, fs2 = require$$0__default$1.default, { promisify } = require$$0__default$6.default, pLocate = requirePLocate(), fsStat = promisify(fs2.stat), fsLStat = promisify(fs2.lstat), typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({ type: type2 }) {
    if (!(type2 in typeMappings))
      throw new Error(`Invalid type specified: ${type2}`);
  }
  const matchType = (type2, stat2) => type2 === void 0 || stat2[typeMappings[type2]]();
  return locatePath.exports = async (paths, options2) => {
    options2 = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: !0,
      ...options2
    }, checkType(options2);
    const statFn = options2.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat2 = await statFn(path2.resolve(options2.cwd, path_));
        return matchType(options2.type, stat2);
      } catch {
        return !1;
      }
    }, options2);
  }, locatePath.exports.sync = (paths, options2) => {
    options2 = {
      cwd: process.cwd(),
      allowSymlinks: !0,
      type: "file",
      ...options2
    }, checkType(options2);
    const statFn = options2.allowSymlinks ? fs2.statSync : fs2.lstatSync;
    for (const path_ of paths)
      try {
        const stat2 = statFn(path2.resolve(options2.cwd, path_));
        if (matchType(options2.type, stat2))
          return path_;
      } catch {
      }
  }, locatePath.exports;
}
var pathExists = { exports: {} }, hasRequiredPathExists;
function requirePathExists() {
  if (hasRequiredPathExists) return pathExists.exports;
  hasRequiredPathExists = 1;
  const fs2 = require$$0__default$1.default, { promisify } = require$$0__default$6.default, pAccess = promisify(fs2.access);
  return pathExists.exports = async (path2) => {
    try {
      return await pAccess(path2), !0;
    } catch {
      return !1;
    }
  }, pathExists.exports.sync = (path2) => {
    try {
      return fs2.accessSync(path2), !0;
    } catch {
      return !1;
    }
  }, pathExists.exports;
}
var hasRequiredFindUp;
function requireFindUp() {
  return hasRequiredFindUp || (hasRequiredFindUp = 1, function(module2) {
    const path2 = require$$0__default.default, locatePath2 = requireLocatePath(), pathExists2 = requirePathExists(), stop = Symbol("findUp.stop");
    module2.exports = async (name, options2 = {}) => {
      let directory = path2.resolve(options2.cwd || "");
      const { root: root2 } = path2.parse(directory), paths = [].concat(name), runMatcher = async (locateOptions) => {
        if (typeof name != "function")
          return locatePath2(paths, locateOptions);
        const foundPath = await name(locateOptions.cwd);
        return typeof foundPath == "string" ? locatePath2([foundPath], locateOptions) : foundPath;
      };
      for (; ; ) {
        const foundPath = await runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop)
          return;
        if (foundPath)
          return path2.resolve(directory, foundPath);
        if (directory === root2)
          return;
        directory = path2.dirname(directory);
      }
    }, module2.exports.sync = (name, options2 = {}) => {
      let directory = path2.resolve(options2.cwd || "");
      const { root: root2 } = path2.parse(directory), paths = [].concat(name), runMatcher = (locateOptions) => {
        if (typeof name != "function")
          return locatePath2.sync(paths, locateOptions);
        const foundPath = name(locateOptions.cwd);
        return typeof foundPath == "string" ? locatePath2.sync([foundPath], locateOptions) : foundPath;
      };
      for (; ; ) {
        const foundPath = runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop)
          return;
        if (foundPath)
          return path2.resolve(directory, foundPath);
        if (directory === root2)
          return;
        directory = path2.dirname(directory);
      }
    }, module2.exports.exists = pathExists2, module2.exports.sync.exists = pathExists2.sync, module2.exports.stop = stop;
  }(findUp)), findUp.exports;
}
var loadYamlFile = { exports: {} }, pify, hasRequiredPify;
function requirePify() {
  if (hasRequiredPify) return pify;
  hasRequiredPify = 1;
  const processFn = (fn, options2) => function(...args) {
    const P = options2.promiseModule;
    return new P((resolve, reject) => {
      options2.multiArgs ? args.push((...result) => {
        options2.errorFirst ? result[0] ? reject(result) : (result.shift(), resolve(result)) : resolve(result);
      }) : options2.errorFirst ? args.push((error2, result) => {
        error2 ? reject(error2) : resolve(result);
      }) : args.push(resolve), fn.apply(this, args);
    });
  };
  return pify = (input2, options2) => {
    options2 = Object.assign({
      exclude: [/.+(Sync|Stream)$/],
      errorFirst: !0,
      promiseModule: Promise
    }, options2);
    const objType = typeof input2;
    if (!(input2 !== null && (objType === "object" || objType === "function")))
      throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input2 === null ? "null" : objType}\``);
    const filter2 = (key2) => {
      const match2 = (pattern) => typeof pattern == "string" ? key2 === pattern : pattern.test(key2);
      return options2.include ? options2.include.some(match2) : !options2.exclude.some(match2);
    };
    let ret;
    objType === "function" ? ret = function(...args) {
      return options2.excludeMain ? input2(...args) : processFn(input2, options2).apply(this, args);
    } : ret = Object.create(Object.getPrototypeOf(input2));
    for (const key2 in input2) {
      const property = input2[key2];
      ret[key2] = typeof property == "function" && filter2(key2) ? processFn(property, options2) : property;
    }
    return ret;
  }, pify;
}
var stripBom, hasRequiredStripBom;
function requireStripBom() {
  return hasRequiredStripBom || (hasRequiredStripBom = 1, stripBom = (x) => {
    if (typeof x != "string")
      throw new TypeError("Expected a string, got " + typeof x);
    return x.charCodeAt(0) === 65279 ? x.slice(1) : x;
  }), stripBom;
}
var jsYaml$1 = {}, loader = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function isNothing(subject) {
    return typeof subject > "u" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject == "object" && subject !== null;
  }
  function toArray2(sequence) {
    return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
  }
  function extend(target, source2) {
    var index, length, key2, sourceKeys;
    if (source2)
      for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
        key2 = sourceKeys[index], target[key2] = source2[key2];
    return target;
  }
  function repeat2(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1)
      result += string;
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  return common.isNothing = isNothing, common.isObject = isObject2, common.toArray = toArray2, common.repeat = repeat2, common.isNegativeZero = isNegativeZero, common.extend = extend, common;
}
var exception, hasRequiredException;
function requireException() {
  if (hasRequiredException) return exception;
  hasRequiredException = 1;
  function YAMLException(reason, mark2) {
    Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return YAMLException.prototype = Object.create(Error.prototype), YAMLException.prototype.constructor = YAMLException, YAMLException.prototype.toString = function(compact) {
    var result = this.name + ": ";
    return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
  }, exception = YAMLException, exception;
}
var mark, hasRequiredMark;
function requireMark() {
  if (hasRequiredMark) return mark;
  hasRequiredMark = 1;
  var common2 = requireCommon();
  function Mark(name, buffer2, position, line3, column2) {
    this.name = name, this.buffer = buffer2, this.position = position, this.line = line3, this.column = column2;
  }
  return Mark.prototype.getSnippet = function(indent, maxLength) {
    var head, start, tail, end, snippet2;
    if (!this.buffer) return null;
    for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
      if (start -= 1, this.position - start > maxLength / 2 - 1) {
        head = " ... ", start += 5;
        break;
      }
    for (tail = "", end = this.position; end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1; )
      if (end += 1, end - this.position > maxLength / 2 - 1) {
        tail = " ... ", end -= 5;
        break;
      }
    return snippet2 = this.buffer.slice(start, end), common2.repeat(" ", indent) + head + snippet2 + tail + `
` + common2.repeat(" ", indent + this.position - start + head.length) + "^";
  }, Mark.prototype.toString = function(compact) {
    var snippet2, where = "";
    return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet2 = this.getSnippet(), snippet2 && (where += `:
` + snippet2)), where;
  }, mark = Mark, mark;
}
var type, hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  var YAMLException = requireException(), TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ], YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    return map2 !== null && Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    }), result;
  }
  function Type(tag, options2) {
    if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }), this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
      return !0;
    }, this.construct = options2.construct || function(data) {
      return data;
    }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.defaultStyle = options2.defaultStyle || null, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
  return type = Type, type;
}
var schema, hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  var common2 = requireCommon(), YAMLException = requireException(), Type = requireType();
  function compileList(schema2, name, result) {
    var exclude = [];
    return schema2.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    }), schema2[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
      }), result.push(currentType);
    }), result.filter(function(type2, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type2) {
      result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
    }
    for (index = 0, length = arguments.length; index < length; index += 1)
      arguments[index].forEach(collectType);
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type2) {
      if (type2.loadKind && type2.loadKind !== "scalar")
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  return Schema.DEFAULT = null, Schema.create = function() {
    var schemas, types2;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT, types2 = arguments[0];
        break;
      case 2:
        schemas = arguments[0], types2 = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    if (schemas = common2.toArray(schemas), types2 = common2.toArray(types2), !schemas.every(function(schema2) {
      return schema2 instanceof Schema;
    }))
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!types2.every(function(type2) {
      return type2 instanceof Type;
    }))
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new Schema({
      include: schemas,
      explicit: types2
    });
  }, schema = Schema, schema;
}
var str, hasRequiredStr;
function requireStr() {
  if (hasRequiredStr) return str;
  hasRequiredStr = 1;
  var Type = requireType();
  return str = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  }), str;
}
var seq, hasRequiredSeq;
function requireSeq() {
  if (hasRequiredSeq) return seq;
  hasRequiredSeq = 1;
  var Type = requireType();
  return seq = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  }), seq;
}
var map$1, hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map$1;
  hasRequiredMap = 1;
  var Type = requireType();
  return map$1 = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  }), map$1;
}
var failsafe, hasRequiredFailsafe;
function requireFailsafe() {
  if (hasRequiredFailsafe) return failsafe;
  hasRequiredFailsafe = 1;
  var Schema = requireSchema();
  return failsafe = new Schema({
    explicit: [
      requireStr(),
      requireSeq(),
      requireMap()
    ]
  }), failsafe;
}
var _null, hasRequired_null;
function require_null() {
  if (hasRequired_null) return _null;
  hasRequired_null = 1;
  var Type = requireType();
  function resolveYamlNull(data) {
    if (data === null) return !0;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  return _null = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  }), _null;
}
var bool, hasRequiredBool;
function requireBool() {
  if (hasRequiredBool) return bool;
  hasRequiredBool = 1;
  var Type = requireType();
  function resolveYamlBoolean(data) {
    if (data === null) return !1;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  return bool = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), bool;
}
var int, hasRequiredInt;
function requireInt() {
  if (hasRequiredInt) return int;
  hasRequiredInt = 1;
  var common2 = requireCommon(), Type = requireType();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return !1;
    var max2 = data.length, index = 0, hasDigits = !1, ch;
    if (!max2) return !1;
    if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
      if (index + 1 === max2) return !0;
      if (ch = data[++index], ch === "b") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (ch !== "0" && ch !== "1") return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isHexCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      for (; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isOctCode(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "_") return !1;
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index)))
          return !1;
        hasDigits = !0;
      }
    return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign2 = 1, ch, base2, digits = [];
    return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign2 * parseInt(value.slice(2), 2) : value[1] === "x" ? sign2 * parseInt(value, 16) : sign2 * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseInt(value, 10);
  }
  function isInteger2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common2.isNegativeZero(object);
  }
  return int = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), int;
}
var float, hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  var common2 = requireCommon(), Type = requireType(), YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_");
  }
  function constructYamlFloat(data) {
    var value, sign2, base2, digits;
    return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object))
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (common2.isNegativeZero(object))
      return "-0.0";
    return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  return float = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  }), float;
}
var json, hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var Schema = requireSchema();
  return json = new Schema({
    include: [
      requireFailsafe()
    ],
    implicit: [
      require_null(),
      requireBool(),
      requireInt(),
      requireFloat()
    ]
  }), json;
}
var core$2, hasRequiredCore$2;
function requireCore$2() {
  if (hasRequiredCore$2) return core$2;
  hasRequiredCore$2 = 1;
  var Schema = requireSchema();
  return core$2 = new Schema({
    include: [
      requireJson()
    ]
  }), core$2;
}
var timestamp$1, hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp) return timestamp$1;
  hasRequiredTimestamp = 1;
  var Type = requireType(), YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null) throw new Error("Date resolve error");
    if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
      return new Date(Date.UTC(year, month, day));
    if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
      for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
        fraction += "0";
      fraction = +fraction;
    }
    return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  return timestamp$1 = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  }), timestamp$1;
}
var merge$2, hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge$2;
  hasRequiredMerge = 1;
  var Type = requireType();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  return merge$2 = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  }), merge$2;
}
var binary$1, hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary$1;
  hasRequiredBinary = 1;
  var NodeBuffer;
  try {
    var _require = commonjsRequire;
    NodeBuffer = _require("buffer").Buffer;
  } catch {
  }
  var Type = requireType(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null) return !1;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
        if (code < 0) return !1;
        bitlen += 6;
      }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++)
      idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
    return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
    return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  return binary$1 = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  }), binary$1;
}
var omap, hasRequiredOmap;
function requireOmap() {
  if (hasRequiredOmap) return omap;
  hasRequiredOmap = 1;
  var Type = requireType(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return !0;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]") return !1;
      for (pairKey in pair)
        if (_hasOwnProperty.call(pair, pairKey))
          if (!pairHasKey) pairHasKey = !0;
          else return !1;
      if (!pairHasKey) return !1;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return !1;
    }
    return !0;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  return omap = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  }), omap;
}
var pairs$1, hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs) return pairs$1;
  hasRequiredPairs = 1;
  var Type = requireType(), _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return !0;
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return !0;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
      pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
    return result;
  }
  return pairs$1 = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  }), pairs$1;
}
var set, hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  var Type = requireType(), _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return !0;
    var key2, object = data;
    for (key2 in object)
      if (_hasOwnProperty.call(object, key2) && object[key2] !== null)
        return !1;
    return !0;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  return set = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  }), set;
}
var default_safe, hasRequiredDefault_safe;
function requireDefault_safe() {
  if (hasRequiredDefault_safe) return default_safe;
  hasRequiredDefault_safe = 1;
  var Schema = requireSchema();
  return default_safe = new Schema({
    include: [
      requireCore$2()
    ],
    implicit: [
      requireTimestamp(),
      requireMerge()
    ],
    explicit: [
      requireBinary(),
      requireOmap(),
      requirePairs(),
      requireSet()
    ]
  }), default_safe;
}
var _undefined, hasRequired_undefined;
function require_undefined() {
  if (hasRequired_undefined) return _undefined;
  hasRequired_undefined = 1;
  var Type = requireType();
  function resolveJavascriptUndefined() {
    return !0;
  }
  function constructJavascriptUndefined() {
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object > "u";
  }
  return _undefined = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  }), _undefined;
}
var regexp, hasRequiredRegexp;
function requireRegexp() {
  if (hasRequiredRegexp) return regexp;
  hasRequiredRegexp = 1;
  var Type = requireType();
  function resolveJavascriptRegExp(data) {
    if (data === null || data.length === 0) return !1;
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return !(regexp2[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp2[regexp2.length - modifiers.length - 1] !== "/"));
  }
  function constructJavascriptRegExp(data) {
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return regexp2[0] === "/" && (tail && (modifiers = tail[1]), regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1)), new RegExp(regexp2, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  return regexp = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  }), regexp;
}
var _function, hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  var esprima2;
  try {
    var _require = commonjsRequire;
    esprima2 = _require("esprima");
  } catch {
    typeof window < "u" && (esprima2 = window.esprima);
  }
  var Type = requireType();
  function resolveJavascriptFunction(data) {
    if (data === null) return !1;
    try {
      var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 });
      return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
    } catch {
      return !1;
    }
  }
  function constructJavascriptFunction(data) {
    var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
      throw new Error("Failed to resolve function");
    return ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source2.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source2.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction2(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  return _function = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction2,
    represent: representJavascriptFunction
  }), _function;
}
var default_full, hasRequiredDefault_full;
function requireDefault_full() {
  if (hasRequiredDefault_full) return default_full;
  hasRequiredDefault_full = 1;
  var Schema = requireSchema();
  return default_full = Schema.DEFAULT = new Schema({
    include: [
      requireDefault_safe()
    ],
    explicit: [
      require_undefined(),
      requireRegexp(),
      require_function()
    ]
  }), default_full;
}
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader) return loader;
  hasRequiredLoader = 1;
  var common2 = requireCommon(), YAMLException = requireException(), Mark = requireMark(), DEFAULT_SAFE_SCHEMA = requireDefault_safe(), DEFAULT_FULL_SCHEMA = requireDefault_full(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
  }
  function escapedHexLen(c2) {
    return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
  }
  function fromDecimalCode(c2) {
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  for (var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++)
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
  function State(input2, options2) {
    this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(
      message,
      new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
    );
  }
  function throwError2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    state.onWarning && state.onWarning.call(null, generateError(state, message));
  }
  var directiveHandlers = {
    YAML: function(state, name, args) {
      var match2, major2, minor2;
      state.version !== null && throwError2(state, "duplication of %YAML directive"), args.length !== 1 && throwError2(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError2(state, "ill-formed argument of the YAML directive"), major2 = parseInt(match2[1], 10), minor2 = parseInt(match2[2], 10), major2 !== 1 && throwError2(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor2 < 2, minor2 !== 1 && minor2 !== 2 && throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function(state, name, args) {
      var handle, prefix;
      args.length !== 2 && throwError2(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError2(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      if (_result = state.input.slice(start, end), checkJson)
        for (_position = 0, _length = _result.length; _position < _length; _position += 1)
          _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError2(state, "expected valid JSON character");
      else PATTERN_NON_PRINTABLE.test(_result) && throwError2(state, "the stream contains non-printable characters");
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source2, overridableKeys) {
    var sourceKeys, key2, index, quantity;
    for (common2.isObject(source2) || throwError2(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
      key2 = sourceKeys[index], _hasOwnProperty.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode))
      for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
        Array.isArray(keyNode[index]) && throwError2(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
    if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
      if (Array.isArray(valueNode))
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
          mergeMappings(state, _result, valueNode[index], overridableKeys);
      else
        mergeMappings(state, _result, valueNode, overridableKeys);
    else
      !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError2(state, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError2(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state.input.charCodeAt(++state.position);
      if (allowComments && ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 10 && ch !== 13 && ch !== 0);
      if (is_EOL(ch))
        for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      else
        break;
    }
    return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
  }
  function writeFoldedLines(state, count2) {
    count2 === 1 ? state.result += " " : count2 > 1 && (state.result += common2.repeat(`
`, count2 - 1));
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
      return !1;
    for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
      if (ch === 58) {
        if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
          break;
      } else if (ch === 35) {
        if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
          break;
      } else {
        if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
          break;
        if (is_EOL(ch))
          if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
            hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
            break;
          }
      }
      hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
    }
    return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    if (ch = state.input.charCodeAt(state.position), ch !== 39)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
      if (ch === 39)
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
          captureStart = state.position, state.position++, captureEnd = state.position;
        else
          return !0;
      else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
    throwError2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 34)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
      if (ch === 34)
        return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
      if (ch === 92) {
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
          skipSeparationSpace(state, !1, nodeIndent);
        else if (ch < 256 && simpleEscapeCheck[ch])
          state.result += simpleEscapeMap[ch], state.position++;
        else if ((tmp2 = escapedHexLen(ch)) > 0) {
          for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
            ch = state.input.charCodeAt(++state.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError2(state, "expected hexadecimal character");
          state.result += charFromCodepoint(hexResult), state.position++;
        } else
          throwError2(state, "unknown escape sequence");
        captureStart = captureEnd = state.position;
      } else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
    }
    throwError2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 91)
      terminator = 93, isMapping = !1, _result = [];
    else if (ch === 123)
      terminator = 125, isMapping = !0, _result = {};
    else
      return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
      if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
        return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
      readNext || throwError2(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
    }
    throwError2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 124)
      folding = !1;
    else if (ch === 62)
      folding = !0;
    else
      return !1;
    for (state.kind = "scalar", state.result = ""; ch !== 0; )
      if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
        CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError2(state, "repeat of a chomping mode identifier");
      else if ((tmp2 = fromDecimalCode(ch)) >= 0)
        tmp2 === 0 ? throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError2(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
      else
        break;
    if (is_WHITE_SPACE(ch)) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (is_WHITE_SPACE(ch));
      if (ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    for (; ch !== 0; ) {
      for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        chomping === CHOMPING_KEEP ? state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
        break;
      }
      for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common2.repeat(`
`, emptyLines) : state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
        ch = state.input.charCodeAt(++state.position);
      captureSegment(state, captureStart, state.position, !1);
    }
    return !0;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following))); ) {
      if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
        _result.push(null), ch = state.input.charCodeAt(state.position);
        continue;
      }
      if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a sequence entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
        ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
      else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
        if (state.line === _line) {
          for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 58)
            ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
          else if (detected)
            throwError2(state, "can not read an implicit mapping pair; a colon is missed");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        } else if (detected)
          throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      else
        break;
      if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0)
        throwError2(state, "bad indentation of a mapping entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 33) return !1;
    if (state.tag !== null && throwError2(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 0 && ch !== 62);
      state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError2(state, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch === 33 && (isNamed ? throwError2(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError2(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
      tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError2(state, "tag suffix cannot contain flow indicator characters");
    }
    return tagName && !PATTERN_TAG_URI.test(tagName) && throwError2(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError2(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 38) return !1;
    for (state.anchor !== null && throwError2(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
  }
  function readAlias(state) {
    var _position, alias, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 42) return !1;
    for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty.call(state.anchorMap, alias) || throwError2(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
    if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
      for (; readTagProperty(state) || readAnchorProperty(state); )
        skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
    if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError2(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!")
      if (state.tag === "?") {
        for (state.result !== null && state.kind !== "scalar" && throwError2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
          if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
            state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
            break;
          }
      } else _hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type2 = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type2.kind !== state.kind && throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result) ? (state.result = type2.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError2(state, "unknown tag !<" + state.tag + ">");
    return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
    for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
      for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError2(state, "directive name must not be less than one character in length"); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 35) {
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError2(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
      state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
      return;
    }
    if (state.position < state.length - 1)
      throwError2(state, "end of the stream or a document separator is expected");
    else
      return;
  }
  function loadDocuments(input2, options2) {
    input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
    var state = new State(input2, options2), nullpos = input2.indexOf("\0");
    for (nullpos !== -1 && (state.position = nullpos, throwError2(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
      state.lineIndent += 1, state.position += 1;
    for (; state.position < state.length - 1; )
      readDocument(state);
    return state.documents;
  }
  function loadAll(input2, iterator2, options2) {
    iterator2 !== null && typeof iterator2 == "object" && typeof options2 > "u" && (options2 = iterator2, iterator2 = null);
    var documents = loadDocuments(input2, options2);
    if (typeof iterator2 != "function")
      return documents;
    for (var index = 0, length = documents.length; index < length; index += 1)
      iterator2(documents[index]);
  }
  function load2(input2, options2) {
    var documents = loadDocuments(input2, options2);
    if (documents.length !== 0) {
      if (documents.length === 1)
        return documents[0];
      throw new YAMLException("expected a single document in the stream, but found more");
    }
  }
  function safeLoadAll(input2, iterator2, options2) {
    return typeof iterator2 == "object" && iterator2 !== null && typeof options2 > "u" && (options2 = iterator2, iterator2 = null), loadAll(input2, iterator2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  function safeLoad(input2, options2) {
    return load2(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return loader.loadAll = loadAll, loader.load = load2, loader.safeLoadAll = safeLoadAll, loader.safeLoad = safeLoad, loader;
}
var dumper = {}, hasRequiredDumper;
function requireDumper() {
  if (hasRequiredDumper) return dumper;
  hasRequiredDumper = 1;
  var common2 = requireCommon(), YAMLException = requireException(), DEFAULT_FULL_SCHEMA = requireDefault_full(), DEFAULT_SAFE_SCHEMA = requireDefault_safe(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA2 = 44, CHAR_MINUS = 45, CHAR_COLON2 = 58, CHAR_EQUALS2 = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
      tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    if (string = character.toString(16).toUpperCase(), character <= 255)
      handle = "x", length = 2;
    else if (character <= 65535)
      handle = "u", length = 4;
    else if (character <= 4294967295)
      handle = "U", length = 8;
    else
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  function State(options2) {
    this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common2.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    for (var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
      next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
      if (type2 = state.implicitTypes[index], type2.resolve(str2))
        return !0;
    return !1;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsChar(c2) {
    return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev) {
    return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON2 && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS2 && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i, char, prev_char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly)
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), !isPrintable(char))
          return STYLE_DOUBLE;
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
      }
    else {
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), char === CHAR_LINE_FEED)
          hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
        else if (!isPrintable(char))
          return STYLE_DOUBLE;
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0)
        return "''";
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
        return "'" + string + "'";
      var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
      var nextLF = string.indexOf(`
`);
      return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
    }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
      var prefix = match2[1], line3 = match2[2];
      moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line3, width) {
    if (line3 === "" || line3[0] === " ") return line3;
    for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line3); )
      next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line3.slice(start, end), start = end + 1), curr = next;
    return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
  }
  function escapeString(string) {
    for (var result = "", char, nextChar, escapeSeq, i = 0; i < string.length; i++) {
      if (char = string.charCodeAt(i), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i + 1), nextChar >= 56320 && nextChar <= 57343)) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i++;
        continue;
      }
      escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
    state.tag = _tag, state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
    state.tag = _tag, state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", index !== 0 && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === !0)
      objectKeyList.sort();
    else if (typeof state.sortKeys == "function")
      objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys)
      throw new YAMLException("sortKeys must be a boolean or a function");
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
      if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (state.tag = explicit ? type2.tag : "?", type2.represent) {
          if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
            _result = type2.represent(object, style);
          else if (_hasOwnProperty.call(type2.represent, style))
            _result = type2.represent[style](object, style);
          else
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          state.dump = _result;
        }
        return !0;
      }
    return !1;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
    var type2 = _toString.call(state.dump);
    block && (block = state.flowLevel < 0 || state.flowLevel > level);
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
      state.dump = "*ref_" + duplicateIndex;
    else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
        block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      } else if (type2 === "[object String]")
        state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
      else {
        if (state.skipInvalid) return !1;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
    }
    return !0;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object == "object")
      if (index = objects.indexOf(object), index !== -1)
        duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
      else if (objects.push(object), Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          inspectNode(object[index], objects, duplicatesIndexes);
      else
        for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
  }
  function dump(input2, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    return state.noRefs || getDuplicateReferences(input2, state), writeNode(state, 0, input2, !0, !0) ? state.dump + `
` : "";
  }
  function safeDump(input2, options2) {
    return dump(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return dumper.dump = dump, dumper.safeDump = safeDump, dumper;
}
var hasRequiredJsYaml$1;
function requireJsYaml$1() {
  if (hasRequiredJsYaml$1) return jsYaml$1;
  hasRequiredJsYaml$1 = 1;
  var loader2 = requireLoader(), dumper2 = requireDumper();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  return jsYaml$1.Type = requireType(), jsYaml$1.Schema = requireSchema(), jsYaml$1.FAILSAFE_SCHEMA = requireFailsafe(), jsYaml$1.JSON_SCHEMA = requireJson(), jsYaml$1.CORE_SCHEMA = requireCore$2(), jsYaml$1.DEFAULT_SAFE_SCHEMA = requireDefault_safe(), jsYaml$1.DEFAULT_FULL_SCHEMA = requireDefault_full(), jsYaml$1.load = loader2.load, jsYaml$1.loadAll = loader2.loadAll, jsYaml$1.safeLoad = loader2.safeLoad, jsYaml$1.safeLoadAll = loader2.safeLoadAll, jsYaml$1.dump = dumper2.dump, jsYaml$1.safeDump = dumper2.safeDump, jsYaml$1.YAMLException = requireException(), jsYaml$1.MINIMAL_SCHEMA = requireFailsafe(), jsYaml$1.SAFE_SCHEMA = requireDefault_safe(), jsYaml$1.DEFAULT_SCHEMA = requireDefault_full(), jsYaml$1.scan = deprecated("scan"), jsYaml$1.parse = deprecated("parse"), jsYaml$1.compose = deprecated("compose"), jsYaml$1.addConstructor = deprecated("addConstructor"), jsYaml$1;
}
var jsYaml, hasRequiredJsYaml;
function requireJsYaml() {
  if (hasRequiredJsYaml) return jsYaml;
  hasRequiredJsYaml = 1;
  var yaml = requireJsYaml$1();
  return jsYaml = yaml, jsYaml;
}
var hasRequiredLoadYamlFile;
function requireLoadYamlFile() {
  if (hasRequiredLoadYamlFile) return loadYamlFile.exports;
  hasRequiredLoadYamlFile = 1;
  const fs2 = requireGracefulFs(), pify2 = requirePify(), stripBom2 = requireStripBom(), yaml = requireJsYaml(), parse3 = (data) => yaml.safeLoad(stripBom2(data));
  return loadYamlFile.exports = (fp) => pify2(fs2.readFile)(fp, "utf8").then((data) => parse3(data)), loadYamlFile.exports.sync = (fp) => parse3(fs2.readFileSync(fp, "utf8")), loadYamlFile.exports;
}
var whichPm, hasRequiredWhichPm;
function requireWhichPm() {
  if (hasRequiredWhichPm) return whichPm;
  hasRequiredWhichPm = 1;
  const path2 = require$$0__default.default, pathExists2 = requirePathExists(), loadYamlFile2 = requireLoadYamlFile();
  whichPm = async function(pkgPath) {
    const modulesPath = path2.join(pkgPath, "node_modules");
    if (await pathExists2(path2.join(modulesPath, ".yarn-integrity"))) return { name: "yarn" };
    if (await pathExists2(path2.join(pkgPath, "bun.lockb"))) return { name: "bun" };
    try {
      const modules = await loadYamlFile2(path2.join(modulesPath, ".modules.yaml"));
      return toNameAndVersion(modules.packageManager);
    } catch (err) {
      if (err.code !== "ENOENT") throw err;
    }
    return await pathExists2(modulesPath) ? { name: "npm" } : null;
  };
  function toNameAndVersion(pkgSpec) {
    if (pkgSpec[0] === "@") {
      const parts2 = pkgSpec.substr(1).split("@");
      return {
        name: `@${parts2[0]}`,
        version: parts2[1]
      };
    }
    const parts = pkgSpec.split("@");
    return {
      name: parts[0],
      version: parts[1]
    };
  }
  return whichPm;
}
var preferredPm, hasRequiredPreferredPm;
function requirePreferredPm() {
  if (hasRequiredPreferredPm) return preferredPm;
  hasRequiredPreferredPm = 1;
  const findYarnWorkspaceRoot = requireFindYarnWorkspaceRoot2(), findUp2 = requireFindUp(), path2 = require$$0__default.default, pathExists2 = requirePathExists(), whichPM = requireWhichPm();
  return preferredPm = async function(pkgPath) {
    if (typeof pkgPath != "string")
      throw new TypeError(`pkgPath should be a string, got ${typeof pkgPath}`);
    if (await pathExists2(path2.join(pkgPath, "package-lock.json")))
      return {
        name: "npm",
        version: ">=5"
      };
    if (await pathExists2(path2.join(pkgPath, "yarn.lock")))
      return {
        name: "yarn",
        version: "*"
      };
    if (await pathExists2(path2.join(pkgPath, "pnpm-lock.yaml")))
      return {
        name: "pnpm",
        version: ">=3"
      };
    if (await pathExists2(path2.join(pkgPath, "shrinkwrap.yaml")))
      return {
        name: "pnpm",
        version: "1 || 2"
      };
    if (await pathExists2(path2.join(pkgPath, "bun.lockb")))
      return {
        name: "bun",
        version: "*"
      };
    if (await findUp2("pnpm-lock.yaml", { cwd: pkgPath }))
      return {
        name: "pnpm",
        version: ">=3"
      };
    try {
      const workspaceRoot = findYarnWorkspaceRoot(pkgPath);
      if (typeof workspaceRoot == "string")
        return await pathExists2(path2.join(workspaceRoot, "package-lock.json")) ? {
          name: "npm",
          version: ">=7"
        } : {
          name: "yarn",
          version: "*"
        };
    } catch {
    }
    const pm = await whichPM(pkgPath);
    return pm && { name: pm.name, version: pm.version || "*" };
  }, preferredPm;
}
var preferredPmExports = requirePreferredPm(), preferredPM = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(preferredPmExports), whichExports = requireWhich(), which = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(whichExports);
const isInteractive$1 = process.stdout.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env), ALLOWED_PACKAGE_MANAGERS = ["npm", "yarn", "pnpm", "bun", "manual"], allowedPackageManagersString = ALLOWED_PACKAGE_MANAGERS.map((pm) => `"${pm}"`).join(
  " | "
), EXPERIMENTAL = ["bun"];
async function getPackageManagerChoice(workDir, options2) {
  const rootDir = workDir || process.cwd(), preferred = (await preferredPM(rootDir))?.name;
  if (preferred && await hasCommand(preferred, rootDir))
    return { chosen: preferred, mostOptimal: preferred };
  const mostLikelyPM = await getMostLikelyInstalledPackageManager(rootDir);
  if (!(typeof options2.interactive == "boolean" ? options2.interactive : isInteractive$1))
    return { chosen: mostLikelyPM || await getFallback(rootDir), mostOptimal: preferred };
  if (!("prompt" in options2))
    throw new Error("Must pass `prompt` when in interactive mode");
  const messageSuffix = preferred ? ` (preferred is ${preferred}, but is not installed)` : "", installed = await getAvailablePackageManagers(rootDir);
  return { chosen: await options2.prompt.single({
    type: "list",
    choices: installed.map((pm) => ({
      value: pm,
      name: EXPERIMENTAL.includes(pm) ? `${pm} (experimental)` : pm
    })),
    default: preferred || mostLikelyPM,
    message: `Package manager to use for installing dependencies?${messageSuffix}`
  }), mostOptimal: preferred };
}
async function getFallback(cwd) {
  return await hasNpmInstalled(cwd) ? "npm" : await hasYarnInstalled(cwd) ? "yarn" : await hasPnpmInstalled(cwd) ? "pnpm" : await hasBunInstalled(cwd) ? "bun" : "manual";
}
async function getAvailablePackageManagers(cwd) {
  const [npm, yarn, pnpm, bun] = await Promise.all([
    hasNpmInstalled(cwd),
    hasYarnInstalled(cwd),
    hasPnpmInstalled(cwd),
    hasBunInstalled(cwd)
  ]);
  return [npm && "npm", yarn && "yarn", pnpm && "pnpm", bun && "bun", "manual"].filter((pm) => pm !== !1);
}
function hasNpmInstalled(cwd) {
  return hasCommand("npm", cwd);
}
function hasYarnInstalled(cwd) {
  return hasCommand("yarn", cwd);
}
function hasPnpmInstalled(cwd) {
  return hasCommand("pnpm", cwd);
}
function hasBunInstalled(cwd) {
  return hasCommand("bun", cwd);
}
function getNpmRunPath(cwd) {
  let previous, cwdPath = path__default.default.resolve(cwd);
  const result = [];
  for (; previous !== cwdPath; )
    result.push(path__default.default.join(cwdPath, "node_modules", ".bin")), previous = cwdPath, cwdPath = path__default.default.resolve(cwdPath, "..");
  result.push(path__default.default.resolve(cwd, process.execPath, ".."));
  const pathEnv = process.env[getPathEnvVarKey()];
  return [...result, pathEnv].join(path__default.default.delimiter);
}
function getPartialEnvWithNpmPath(cwd) {
  return { [getPathEnvVarKey()]: getNpmRunPath(cwd) };
}
function getPathEnvVarKey() {
  return process.platform !== "win32" ? "PATH" : Object.keys(process.env).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
}
function getCommandPath(cmd, cwd) {
  const options2 = cwd ? { path: getNpmRunPath(cwd) } : {};
  return which(cmd, options2).catch(() => null);
}
function hasCommand(cmd, cwd) {
  return getCommandPath(cmd, cwd).then((cmdPath) => cmdPath !== null);
}
async function getMostLikelyInstalledPackageManager(rootDir) {
  const installed = await getAvailablePackageManagers(rootDir), running = getRunningPackageManager();
  return running && installed.includes(running) ? running : void 0;
}
function getRunningPackageManager() {
  const agent = process.env.npm_config_user_agent || "";
  if (agent.includes("yarn"))
    return "yarn";
  if (agent.includes("pnpm"))
    return "pnpm";
  if (agent.includes("bun"))
    return "bun";
  if (/^npm\/\d/.test(agent))
    return "npm";
}
async function getInstallCommand(options2) {
  const { workDir, depType = "prod", pkgNames } = options2, { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
  if (!pkgNames || pkgNames.length === 0)
    return `${chosen} install`;
  const pkgNameString = pkgNames.join(" ");
  if (chosen === "yarn") {
    const flag = depType === "dev" || depType === "peer" ? ` --${depType}` : "";
    return `yarn add ${pkgNameString}${flag}`;
  } else if (chosen === "pnpm")
    return `pnpm add ${pkgNameString} --save-${depType}`;
  return `npm install ${pkgNameString} --save-${depType}`;
}
var globalDirs = {}, ini, hasRequiredIni;
function requireIni() {
  if (hasRequiredIni) return ini;
  hasRequiredIni = 1;
  const { hasOwnProperty: hasOwnProperty2 } = Object.prototype, eol = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`, encode = (obj, opt) => {
    const children = [];
    let out = "";
    typeof opt == "string" ? opt = {
      section: opt,
      whitespace: !1
    } : (opt = opt || /* @__PURE__ */ Object.create(null), opt.whitespace = opt.whitespace === !0);
    const separator2 = opt.whitespace ? " = " : "=";
    for (const k of Object.keys(obj)) {
      const val = obj[k];
      if (val && Array.isArray(val))
        for (const item of val)
          out += safe(k + "[]") + separator2 + safe(item) + `
`;
      else val && typeof val == "object" ? children.push(k) : out += safe(k) + separator2 + safe(val) + eol;
    }
    opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out);
    for (const k of children) {
      const nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, { whitespace } = opt, child = encode(obj[k], {
        section,
        whitespace
      });
      out.length && child.length && (out += eol), out += child;
    }
    return out;
  }, dotSplit = (str2) => str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "")), decode = (str2) => {
    const out = /* @__PURE__ */ Object.create(null);
    let p = out, section = null;
    const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines2 = str2.split(/[\r\n]+/g);
    for (const line3 of lines2) {
      if (!line3 || line3.match(/^\s*[;#]/))
        continue;
      const match2 = line3.match(re);
      if (!match2)
        continue;
      if (match2[1] !== void 0) {
        if (section = unsafe(match2[1]), section === "__proto__") {
          p = /* @__PURE__ */ Object.create(null);
          continue;
        }
        p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match2[2]), isArray2 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]", key2 = isArray2 ? keyRaw.slice(0, -2) : keyRaw;
      if (key2 === "__proto__")
        continue;
      const valueRaw = match2[3] ? unsafe(match2[4]) : !0, value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      isArray2 && (hasOwnProperty2.call(p, key2) ? Array.isArray(p[key2]) || (p[key2] = [p[key2]]) : p[key2] = []), Array.isArray(p[key2]) ? p[key2].push(value) : p[key2] = value;
    }
    const remove = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty2.call(out, k) || typeof out[k] != "object" || Array.isArray(out[k]))
        continue;
      const parts = dotSplit(k);
      let p2 = out;
      const l = parts.pop(), nl = l.replace(/\\\./g, ".");
      for (const part of parts)
        part !== "__proto__" && ((!hasOwnProperty2.call(p2, part) || typeof p2[part] != "object") && (p2[part] = /* @__PURE__ */ Object.create(null)), p2 = p2[part]);
      p2 === out && nl === l || (p2[nl] = out[k], remove.push(k));
    }
    for (const del of remove)
      delete out[del];
    return out;
  }, isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'", safe = (val) => typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#"), unsafe = (val, doUnesc) => {
    if (val = (val || "").trim(), isQuoted(val)) {
      val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
      try {
        val = JSON.parse(val);
      } catch {
      }
    } else {
      let esc = !1, unesc = "";
      for (let i = 0, l = val.length; i < l; i++) {
        const c2 = val.charAt(i);
        if (esc)
          "\\;#".indexOf(c2) !== -1 ? unesc += c2 : unesc += "\\" + c2, esc = !1;
        else {
          if (";#".indexOf(c2) !== -1)
            break;
          c2 === "\\" ? esc = !0 : unesc += c2;
        }
      }
      return esc && (unesc += "\\"), unesc.trim();
    }
    return val;
  };
  return ini = {
    parse: decode,
    decode,
    stringify: encode,
    encode,
    safe,
    unsafe
  }, ini;
}
var hasRequiredGlobalDirs;
function requireGlobalDirs() {
  return hasRequiredGlobalDirs || (hasRequiredGlobalDirs = 1, function(exports2) {
    const path2 = require$$0__default.default, os2 = require$$0__default$2.default, fs2 = require$$0__default$1.default, ini2 = requireIni(), isWindows = process.platform === "win32", readRc = (filePath) => {
      try {
        return ini2.parse(fs2.readFileSync(filePath, "utf8")).prefix;
      } catch {
      }
    }, getEnvNpmPrefix = () => Object.keys(process.env).reduce((prefix, name) => /^npm_config_prefix$/i.test(name) ? process.env[name] : prefix, void 0), getGlobalNpmrc = () => {
      if (isWindows && process.env.APPDATA)
        return path2.join(process.env.APPDATA, "/npm/etc/npmrc");
      if (process.execPath.includes("/Cellar/node")) {
        const homebrewPrefix = process.execPath.slice(0, process.execPath.indexOf("/Cellar/node"));
        return path2.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
      }
      if (process.execPath.endsWith("/bin/node")) {
        const installDir = path2.dirname(path2.dirname(process.execPath));
        return path2.join(installDir, "/etc/npmrc");
      }
    }, getDefaultNpmPrefix = () => {
      if (isWindows) {
        const { APPDATA } = process.env;
        return APPDATA ? path2.join(APPDATA, "npm") : path2.dirname(process.execPath);
      }
      return path2.dirname(path2.dirname(process.execPath));
    }, getNpmPrefix = () => {
      const envPrefix = getEnvNpmPrefix();
      if (envPrefix)
        return envPrefix;
      const homePrefix = readRc(path2.join(os2.homedir(), ".npmrc"));
      if (homePrefix)
        return homePrefix;
      if (process.env.PREFIX)
        return process.env.PREFIX;
      const globalPrefix = readRc(getGlobalNpmrc());
      return globalPrefix || getDefaultNpmPrefix();
    }, npmPrefix = path2.resolve(getNpmPrefix()), getYarnWindowsDirectory = () => {
      if (isWindows && process.env.LOCALAPPDATA) {
        const dir = path2.join(process.env.LOCALAPPDATA, "Yarn");
        if (fs2.existsSync(dir))
          return dir;
      }
      return !1;
    }, getYarnPrefix = () => {
      if (process.env.PREFIX)
        return process.env.PREFIX;
      const windowsPrefix = getYarnWindowsDirectory();
      if (windowsPrefix)
        return windowsPrefix;
      const configPrefix = path2.join(os2.homedir(), ".config/yarn");
      if (fs2.existsSync(configPrefix))
        return configPrefix;
      const homePrefix = path2.join(os2.homedir(), ".yarn-config");
      return fs2.existsSync(homePrefix) ? homePrefix : npmPrefix;
    };
    exports2.npm = {}, exports2.npm.prefix = npmPrefix, exports2.npm.packages = path2.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules"), exports2.npm.binaries = isWindows ? npmPrefix : path2.join(npmPrefix, "bin");
    const yarnPrefix = path2.resolve(getYarnPrefix());
    exports2.yarn = {}, exports2.yarn.prefix = yarnPrefix, exports2.yarn.packages = path2.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules"), exports2.yarn.binaries = path2.join(exports2.yarn.packages, ".bin");
  }(globalDirs)), globalDirs;
}
var isPathInside, hasRequiredIsPathInside;
function requireIsPathInside() {
  if (hasRequiredIsPathInside) return isPathInside;
  hasRequiredIsPathInside = 1;
  const path2 = require$$0__default.default;
  return isPathInside = (childPath, parentPath) => {
    const relation = path2.relative(parentPath, childPath);
    return !!(relation && relation !== ".." && !relation.startsWith(`..${path2.sep}`) && relation !== path2.resolve(childPath));
  }, isPathInside;
}
var isInstalledGlobally$1, hasRequiredIsInstalledGlobally;
function requireIsInstalledGlobally() {
  if (hasRequiredIsInstalledGlobally) return isInstalledGlobally$1;
  hasRequiredIsInstalledGlobally = 1;
  const fs2 = require$$0__default$1.default, globalDirs2 = requireGlobalDirs(), isPathInside2 = requireIsPathInside();
  return isInstalledGlobally$1 = (() => {
    try {
      return isPathInside2(__dirname, globalDirs2.yarn.packages) || isPathInside2(__dirname, fs2.realpathSync(globalDirs2.npm.packages));
    } catch {
      return !1;
    }
  })(), isInstalledGlobally$1;
}
var isInstalledGloballyExports = requireIsInstalledGlobally(), isInstalledGlobally = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(isInstalledGloballyExports);
const cliPkgName = "@sanity/cli";
async function getCliUpgradeCommand(options2 = {}) {
  let { cwd, workDir } = options2;
  if (cwd = path__default.default.resolve(cwd || process.cwd()), workDir = path__default.default.resolve(workDir || cwd), isInstalledGlobally && isInstalledUsingYarn())
    return loadEnv.debug("CLI is installed globally with yarn"), `yarn global add ${cliPkgName}`;
  if (isInstalledGlobally)
    return loadEnv.debug("CLI is installed globally with npm"), `npm install -g ${cliPkgName}`;
  const cmds = cwd === workDir ? [] : [`cd ${path__default.default.relative(cwd, workDir)}`], { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
  return chosen === "yarn" ? cmds.push(`yarn upgrade ${cliPkgName}`) : chosen === "pnpm" ? cmds.push(`pnpm update ${cliPkgName}`) : cmds.push(`npm update ${cliPkgName}`), cmds.join(" && ");
}
function isInstalledUsingYarn() {
  const yarnPath = process.platform === "win32" ? path__default.default.join("Yarn", "config", "global") : path__default.default.join(".config", "yarn", "global");
  return __dirname.includes(yarnPath);
}
async function installDeclaredPackages(cwd, packageManager, context) {
  const { output } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(cwd),
    cwd,
    stdio: "inherit"
  }, npmArgs = ["install", "--legacy-peer-deps"];
  let result;
  if (packageManager === "npm")
    output.print(`Running 'npm ${npmArgs.join(" ")}'`), result = await execa("npm", npmArgs, execOptions);
  else if (packageManager === "yarn") {
    const yarnArgs = ["install"];
    output.print(`Running 'yarn ${yarnArgs.join(" ")}'`), result = await execa("yarn", yarnArgs, execOptions);
  } else if (packageManager === "pnpm") {
    const pnpmArgs = ["install"];
    output.print(`Running 'pnpm ${pnpmArgs.join(" ")}'`), result = await execa("pnpm", pnpmArgs, execOptions);
  } else if (packageManager === "bun") {
    const bunArgs = ["install"];
    output.print(`Running 'bun ${bunArgs.join(" ")}'`), result = await execa("bun", bunArgs, execOptions);
  } else packageManager === "manual" && output.print(`Manual installation selected - run 'npm ${npmArgs.join(" ")}' or similar`);
  if (result?.exitCode || result?.failed)
    throw new Error("Dependency installation failed");
}
async function installNewPackages(options2, context) {
  const { packageManager, packages } = options2, { output, workDir } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(workDir),
    cwd: workDir,
    stdio: "inherit"
  }, npmArgs = ["install", "--legacy-peer-deps", "--save", ...packages];
  let result;
  if (packageManager === "npm")
    output.print(`Running 'npm ${npmArgs.join(" ")}'`), result = await execa("npm", npmArgs, execOptions);
  else if (packageManager === "yarn") {
    const yarnArgs = ["add", ...packages];
    output.print(`Running 'yarn ${yarnArgs.join(" ")}'`), result = await execa("yarn", yarnArgs, execOptions);
  } else if (packageManager === "pnpm") {
    const pnpmArgs = ["add", "--save-prod", ...packages];
    output.print(`Running 'pnpm ${pnpmArgs.join(" ")}'`), result = await execa("pnpm", pnpmArgs, execOptions);
  } else if (packageManager === "bun") {
    const bunArgs = ["add", ...packages];
    output.print(`Running 'bun ${bunArgs.join(" ")}'`), result = await execa("bun", bunArgs, execOptions);
  } else packageManager === "manual" && output.print(`Manual installation selected - run 'npm ${npmArgs.join(" ")}' or equivalent`);
  if (result?.exitCode || result?.failed)
    throw new Error("Package installation failed");
}
const cliPackageManager = {
  getInstallCommand,
  getPackageManagerChoice,
  installNewPackages
};
var gitconfiglocal, hasRequiredGitconfiglocal;
function requireGitconfiglocal() {
  if (hasRequiredGitconfiglocal) return gitconfiglocal;
  hasRequiredGitconfiglocal = 1;
  const fs2 = require$$0__default$1.default.promises, ini2 = requireIni$1(), path2 = require$$0__default.default;
  gitconfiglocal = async function(dir, options2 = {}) {
    const config2 = await findGit(dir, options2);
    if (!config2) throw new Error("no gitconfig to be found at " + dir);
    const data = await fs2.readFile(config2);
    return format(ini2.parse(data.toString()));
  };
  function format(data) {
    const out = {};
    return Object.keys(data).forEach(function(k) {
      if (k.indexOf('"') > -1) {
        const parts = k.split('"'), parentKey = parts.shift().trim(), childKey = parts.shift().trim();
        out[parentKey] || (out[parentKey] = {}), out[parentKey][childKey] = data[k];
      } else
        out[k] = { ...out[k], ...data[k] };
    }), out;
  }
  async function findGit(dir, options2) {
    const folder = path2.resolve(
      dir,
      options2.gitDir || process.env.GIT_DIR || ".git",
      "config"
    );
    return await pathExists2(folder) ? folder : dir === path2.resolve(dir, "..") ? !1 : findGit(path2.resolve(dir, ".."), options2);
  }
  function pathExists2(filePath) {
    return fs2.access(filePath).then(
      () => !0,
      () => !1
    );
  }
  return gitconfiglocal;
}
var gitconfiglocalExports = requireGitconfiglocal(), getGitConfig = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(gitconfiglocalExports);
/*!
 * fs-exists-sync (https://github.com/jonschlinkert/fs-exists-sync)
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var fsExistsSync, hasRequiredFsExistsSync;
function requireFsExistsSync() {
  if (hasRequiredFsExistsSync) return fsExistsSync;
  hasRequiredFsExistsSync = 1;
  var fs2 = require$$0__default$1.default;
  return fsExistsSync = function(filepath) {
    try {
      return (fs2.accessSync || fs2.statSync)(filepath), !0;
    } catch {
    }
    return !1;
  }, fsExistsSync;
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtendable, hasRequiredIsExtendable;
function requireIsExtendable() {
  return hasRequiredIsExtendable || (hasRequiredIsExtendable = 1, isExtendable = function(val) {
    return typeof val < "u" && val !== null && (typeof val == "object" || typeof val == "function");
  }), isExtendable;
}
var extendShallow, hasRequiredExtendShallow;
function requireExtendShallow() {
  if (hasRequiredExtendShallow) return extendShallow;
  hasRequiredExtendShallow = 1;
  var isObject2 = requireIsExtendable();
  extendShallow = function(o) {
    isObject2(o) || (o = {});
    for (var len = arguments.length, i = 1; i < len; i++) {
      var obj = arguments[i];
      isObject2(obj) && assign(o, obj);
    }
    return o;
  };
  function assign(a, b) {
    for (var key2 in b)
      hasOwn(b, key2) && (a[key2] = b[key2]);
  }
  function hasOwn(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  return extendShallow;
}
var homedirPolyfill = { exports: {} }, parsePasswd, hasRequiredParsePasswd;
function requireParsePasswd() {
  if (hasRequiredParsePasswd) return parsePasswd;
  hasRequiredParsePasswd = 1, parsePasswd = function(content) {
    if (typeof content != "string")
      throw new Error("expected a string");
    return content.split(`
`).map(user).filter(Boolean);
  };
  function user(line3, i) {
    if (!line3 || !line3.length || line3.charAt(0) === "#")
      return null;
    var fields = line3.split(":");
    return {
      username: fields[0],
      password: fields[1],
      uid: fields[2],
      gid: fields[3],
      // see https://en.wikipedia.org/wiki/Gecos_field for GECOS field descriptions
      gecos: fields[4],
      homedir: fields[5],
      shell: fields[6]
    };
  }
  return parsePasswd;
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var fs2 = require$$0__default$1.default, parse3 = requireParsePasswd();
  function homedir() {
    if (process.platform === "win32")
      return process.env.USERPROFILE ? process.env.USERPROFILE : process.env.HOMEDRIVE && process.env.HOMEPATH ? process.env.HOMEDRIVE + process.env.HOMEPATH : process.env.HOME ? process.env.HOME : null;
    if (process.env.HOME)
      return process.env.HOME;
    var passwd = tryReadFileSync("/etc/passwd"), home = find2(parse3(passwd), getuid());
    if (home)
      return home;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    return user ? process.platform === "darwin" ? "/Users/" + user : "/home/" + user : null;
  }
  function find2(arr, uid) {
    for (var len = arr.length, i = 0; i < len; i++)
      if (+arr[i].uid === uid)
        return arr[i].homedir;
  }
  function getuid() {
    return typeof process.geteuid == "function" ? process.geteuid() : process.getuid();
  }
  function tryReadFileSync(fp) {
    try {
      return fs2.readFileSync(fp, "utf8");
    } catch {
      return "";
    }
  }
  return polyfill = homedir, polyfill;
}
var hasRequiredHomedirPolyfill;
function requireHomedirPolyfill() {
  if (hasRequiredHomedirPolyfill) return homedirPolyfill.exports;
  hasRequiredHomedirPolyfill = 1;
  var os2 = require$$0__default$2.default;
  return typeof os2.homedir < "u" ? homedirPolyfill.exports = os2.homedir : homedirPolyfill.exports = requirePolyfill(), homedirPolyfill.exports;
}
/*!
 * git-config-path <https://github.com/jonschlinkert/git-config-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var gitConfigPath, hasRequiredGitConfigPath;
function requireGitConfigPath() {
  if (hasRequiredGitConfigPath) return gitConfigPath;
  hasRequiredGitConfigPath = 1;
  var path2 = require$$0__default.default, exists = requireFsExistsSync(), extend = requireExtendShallow(), homedir = requireHomedirPolyfill();
  return gitConfigPath = function(type2, options2) {
    typeof type2 != "string" && (options2 = type2, type2 = null);
    var opts = extend({ cwd: process.cwd() }, options2);
    type2 = type2 || opts.type;
    var configPath = path2.resolve(opts.cwd, ".git/config");
    if (type2 === "global" && (configPath = path2.join(homedir(), ".gitconfig")), !exists(configPath)) {
      if (typeof type2 == "string")
        return null;
      configPath = path2.join(homedir(), ".config/git/config");
    }
    return exists(configPath) ? configPath : null;
  }, gitConfigPath;
}
/*!
 * parse-git-config <https://github.com/jonschlinkert/parse-git-config>
 *
 * Copyright (c) 2015 Jon Schlinkert.
 * Licensed under the MIT license.
 */
var parseGitConfig, hasRequiredParseGitConfig;
function requireParseGitConfig() {
  if (hasRequiredParseGitConfig) return parseGitConfig;
  hasRequiredParseGitConfig = 1;
  var fs2 = require$$0__default$1.default, path2 = require$$0__default.default, exists = requireFsExistsSync(), extend = requireExtendShallow(), configPath = requireGitConfigPath(), ini2 = requireIni$1();
  function parse3(options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), typeof cb != "function")
      throw new TypeError("parse-git-config async expects a callback function.");
    options2 = options2 || {};
    var filepath = parse3.resolve(options2);
    fs2.stat(filepath, function(err, stat2) {
      if (err) return cb(err);
      fs2.readFile(filepath, "utf8", function(err2, str2) {
        if (err2) return cb(err2);
        var parsed = ini2.parse(str2);
        cb(null, parsed);
      });
    });
  }
  return parse3.sync = function(options2) {
    options2 = options2 || {};
    var filepath = parse3.resolve(options2);
    if (filepath && exists(filepath)) {
      var str2 = fs2.readFileSync(filepath, "utf8");
      return ini2.parse(str2);
    }
    return {};
  }, parse3.resolve = function(options2) {
    typeof options2 == "string" && (options2 = { type: options2 });
    var opts = extend({ cwd: process.cwd() }, options2), fp = opts.path || configPath(opts.type);
    return fp ? path2.resolve(opts.cwd, fp) : null;
  }, parse3.keys = function(config2) {
    var res = {};
    for (var key2 in config2) {
      var m = /(\S+) "(.*)"/.exec(key2);
      if (m) {
        var prop = m[1];
        res[prop] = res[prop] || {}, res[prop][m[2]] = config2[key2];
      }
    }
    return res;
  }, parseGitConfig = parse3, parseGitConfig;
}
var gitUserInfo, hasRequiredGitUserInfo;
function requireGitUserInfo() {
  if (hasRequiredGitUserInfo) return gitUserInfo;
  hasRequiredGitUserInfo = 1;
  const gitconfig = requireGitConfigPath(), parse3 = requireParseGitConfig();
  async function getGitUserInfo(options2 = {}) {
    const opts = { cwd: "/", path: gitconfig(), ...options2 }, user = await getUserFromConfig(opts);
    return user || options2.path ? user : getUserFromConfig({ ...opts, path: gitconfig("global") });
  }
  function getUserFromConfig(options2) {
    return new Promise((resolve, reject) => {
      if (typeof options2.path != "string")
        return resolve(null);
      parse3(options2, (err, config2) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(config2 && config2.user ? config2.user : null);
      });
    });
  }
  return gitUserInfo = {
    getGitUserInfo
  }, gitUserInfo;
}
var gitUserInfoExports = requireGitUserInfo();
function getProjectDefaults(workDir, { isPlugin, context }) {
  const cwd = process.cwd(), isSanityRoot = workDir === cwd;
  return promiseProps({
    license: "UNLICENSED",
    author: getUserInfo(context),
    // Don't try to use git remote from main Sanity project for plugins
    gitRemote: isPlugin && isSanityRoot ? "" : resolveGitRemote(cwd),
    // Don't try to guess plugin name if we're initing from Sanity root
    projectName: isPlugin && isSanityRoot ? "" : path__default.default.basename(cwd),
    // If we're initing a plugin, don't use description from Sanity readme
    description: getProjectDescription({ isSanityRoot, isPlugin, outputDir: cwd })
  });
}
async function resolveGitRemote(cwd) {
  try {
    await fs__default.default.stat(path__default.default.join(cwd, ".git"));
    const cfg = await getGitConfig(cwd);
    return cfg.remote && cfg.remote.origin && cfg.remote.origin.url;
  } catch {
    return;
  }
}
async function getUserInfo(context) {
  const user = await gitUserInfoExports.getGitUserInfo();
  if (!user)
    return getSanityUserInfo(context);
  if (user.name && user.email)
    return `${user.name} <${user.email}>`;
}
async function getSanityUserInfo(context) {
  if (!getCliToken())
    return;
  const client2 = context.apiClient({ requireUser: !0, requireProject: !1 });
  try {
    const user = await client2.users.getById("me");
    return user ? `${user.name} <${user.email}>` : void 0;
  } catch {
    return;
  }
}
async function getProjectDescription({
  isSanityRoot,
  isPlugin,
  outputDir
}) {
  if (!(isSanityRoot && !isPlugin))
    return Promise.resolve("");
  try {
    const readmePath = path__default.default.join(outputDir, "README.md"), match2 = (await fs__default.default.readFile(readmePath, { encoding: "utf8" })).match(/^# .*?\n+(\w.*?)(?:$|\n)/);
    return (match2 && match2[1] || "").replace(/\.$/, "") || "";
  } catch {
    return "";
  }
}
function getProviderName(provider) {
  return provider === "google" ? "Google" : provider === "github" ? "GitHub" : provider === "sanity" ? "Email" : provider.startsWith("saml-") ? "SAML" : provider;
}
var tar = {}, highLevelOpt, hasRequiredHighLevelOpt;
function requireHighLevelOpt() {
  if (hasRequiredHighLevelOpt) return highLevelOpt;
  hasRequiredHighLevelOpt = 1;
  const argmap = /* @__PURE__ */ new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"]
  ]);
  return highLevelOpt = (opt) => opt ? Object.keys(opt).map((k) => [
    argmap.has(k) ? argmap.get(k) : k,
    opt[k]
  ]).reduce((set2, kv) => (set2[kv[0]] = kv[1], set2), /* @__PURE__ */ Object.create(null)) : {}, highLevelOpt;
}
var minipass$1 = {}, hasRequiredMinipass$1;
function requireMinipass$1() {
  if (hasRequiredMinipass$1) return minipass$1;
  hasRequiredMinipass$1 = 1;
  const proc2 = typeof process == "object" && process ? process : {
    stdout: null,
    stderr: null
  }, EE = require$$0__default$7.default, Stream2 = require$$0__default$4.default, SD = require$$2__default$1.default.StringDecoder, EOF2 = Symbol("EOF"), MAYBE_EMIT_END2 = Symbol("maybeEmitEnd"), EMITTED_END2 = Symbol("emittedEnd"), EMITTING_END2 = Symbol("emittingEnd"), EMITTED_ERROR2 = Symbol("emittedError"), CLOSED2 = Symbol("closed"), READ2 = Symbol("read"), FLUSH2 = Symbol("flush"), FLUSHCHUNK2 = Symbol("flushChunk"), ENCODING2 = Symbol("encoding"), DECODER2 = Symbol("decoder"), FLOWING2 = Symbol("flowing"), PAUSED2 = Symbol("paused"), RESUME2 = Symbol("resume"), BUFFER2 = Symbol("buffer"), PIPES2 = Symbol("pipes"), BUFFERLENGTH2 = Symbol("bufferLength"), BUFFERPUSH2 = Symbol("bufferPush"), BUFFERSHIFT2 = Symbol("bufferShift"), OBJECTMODE2 = Symbol("objectMode"), DESTROYED2 = Symbol("destroyed"), ERROR2 = Symbol("error"), EMITDATA2 = Symbol("emitData"), EMITEND3 = Symbol("emitEnd"), EMITEND22 = Symbol("emitEnd2"), ASYNC2 = Symbol("async"), ABORT2 = Symbol("abort"), ABORTED2 = Symbol("aborted"), SIGNAL2 = Symbol("signal"), defer2 = (fn) => Promise.resolve().then(fn), doIter = loadEnv.commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1", ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented"), ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented"), isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  class Pipe2 {
    constructor(src2, dest, opts) {
      this.src = src2, this.dest = dest, this.opts = opts, this.ondrain = () => src2[RESUME2](), dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {
    }
    end() {
      this.unpipe(), this.opts.end && this.dest.end();
    }
  }
  class PipeProxyErrors2 extends Pipe2 {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors), super.unpipe();
    }
    constructor(src2, dest, opts) {
      super(src2, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src2.on("error", this.proxyErrors);
    }
  }
  class Minipass2 extends Stream2 {
    constructor(options2) {
      super(), this[FLOWING2] = !1, this[PAUSED2] = !1, this[PIPES2] = [], this[BUFFER2] = [], this[OBJECTMODE2] = options2 && options2.objectMode || !1, this[OBJECTMODE2] ? this[ENCODING2] = null : this[ENCODING2] = options2 && options2.encoding || null, this[ENCODING2] === "buffer" && (this[ENCODING2] = null), this[ASYNC2] = options2 && !!options2.async || !1, this[DECODER2] = this[ENCODING2] ? new SD(this[ENCODING2]) : null, this[EOF2] = !1, this[EMITTED_END2] = !1, this[EMITTING_END2] = !1, this[CLOSED2] = !1, this[EMITTED_ERROR2] = null, this.writable = !0, this.readable = !0, this[BUFFERLENGTH2] = 0, this[DESTROYED2] = !1, options2 && options2.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] }), options2 && options2.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[PIPES2] }), this[SIGNAL2] = options2 && options2.signal, this[ABORTED2] = !1, this[SIGNAL2] && (this[SIGNAL2].addEventListener("abort", () => this[ABORT2]()), this[SIGNAL2].aborted && this[ABORT2]());
    }
    get bufferLength() {
      return this[BUFFERLENGTH2];
    }
    get encoding() {
      return this[ENCODING2];
    }
    set encoding(enc) {
      if (this[OBJECTMODE2]) throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING2] && enc !== this[ENCODING2] && (this[DECODER2] && this[DECODER2].lastNeed || this[BUFFERLENGTH2]))
        throw new Error("cannot change encoding");
      this[ENCODING2] !== enc && (this[DECODER2] = enc ? new SD(enc) : null, this[BUFFER2].length && (this[BUFFER2] = this[BUFFER2].map((chunk) => this[DECODER2].write(chunk)))), this[ENCODING2] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE2];
    }
    set objectMode(om) {
      this[OBJECTMODE2] = this[OBJECTMODE2] || !!om;
    }
    get async() {
      return this[ASYNC2];
    }
    set async(a) {
      this[ASYNC2] = this[ASYNC2] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT2]() {
      this[ABORTED2] = !0, this.emit("abort", this[SIGNAL2].reason), this.destroy(this[SIGNAL2].reason);
    }
    get aborted() {
      return this[ABORTED2];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED2]) return !1;
      if (this[EOF2]) throw new Error("write after end");
      if (this[DESTROYED2])
        return this.emit(
          "error",
          Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          )
        ), !0;
      typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
      const fn = this[ASYNC2] ? defer2 : (f) => f();
      return !this[OBJECTMODE2] && !Buffer.isBuffer(chunk) && (isArrayBufferView2(chunk) ? chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength) : isArrayBuffer(chunk) ? chunk = Buffer.from(chunk) : typeof chunk != "string" && (this.objectMode = !0)), this[OBJECTMODE2] ? (this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING2] && !this[DECODER2].lastNeed) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING2] && (chunk = this[DECODER2].write(chunk)), this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : (this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing);
    }
    read(n) {
      if (this[DESTROYED2]) return null;
      if (this[BUFFERLENGTH2] === 0 || n === 0 || n > this[BUFFERLENGTH2])
        return this[MAYBE_EMIT_END2](), null;
      this[OBJECTMODE2] && (n = null), this[BUFFER2].length > 1 && !this[OBJECTMODE2] && (this.encoding ? this[BUFFER2] = [this[BUFFER2].join("")] : this[BUFFER2] = [Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])]);
      const ret = this[READ2](n || null, this[BUFFER2][0]);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [READ2](n, chunk) {
      return n === chunk.length || n === null ? this[BUFFERSHIFT2]() : (this[BUFFER2][0] = chunk.slice(n), chunk = chunk.slice(0, n), this[BUFFERLENGTH2] -= n), this.emit("data", chunk), !this[BUFFER2].length && !this[EOF2] && this.emit("drain"), chunk;
    }
    end(chunk, encoding, cb) {
      return typeof chunk == "function" && (cb = chunk, chunk = null), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF2] = !0, this.writable = !1, (this.flowing || !this[PAUSED2]) && this[MAYBE_EMIT_END2](), this;
    }
    // don't let the internal resume be overwritten
    [RESUME2]() {
      this[DESTROYED2] || (this[PAUSED2] = !1, this[FLOWING2] = !0, this.emit("resume"), this[BUFFER2].length ? this[FLUSH2]() : this[EOF2] ? this[MAYBE_EMIT_END2]() : this.emit("drain"));
    }
    resume() {
      return this[RESUME2]();
    }
    pause() {
      this[FLOWING2] = !1, this[PAUSED2] = !0;
    }
    get destroyed() {
      return this[DESTROYED2];
    }
    get flowing() {
      return this[FLOWING2];
    }
    get paused() {
      return this[PAUSED2];
    }
    [BUFFERPUSH2](chunk) {
      this[OBJECTMODE2] ? this[BUFFERLENGTH2] += 1 : this[BUFFERLENGTH2] += chunk.length, this[BUFFER2].push(chunk);
    }
    [BUFFERSHIFT2]() {
      return this[OBJECTMODE2] ? this[BUFFERLENGTH2] -= 1 : this[BUFFERLENGTH2] -= this[BUFFER2][0].length, this[BUFFER2].shift();
    }
    [FLUSH2](noDrain) {
      do
        ;
      while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
      !noDrain && !this[BUFFER2].length && !this[EOF2] && this.emit("drain");
    }
    [FLUSHCHUNK2](chunk) {
      return this.emit("data", chunk), this.flowing;
    }
    pipe(dest, opts) {
      if (this[DESTROYED2]) return;
      const ended = this[EMITTED_END2];
      return opts = opts || {}, dest === proc2.stdout || dest === proc2.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES2].push(
        opts.proxyErrors ? new PipeProxyErrors2(this, dest, opts) : new Pipe2(this, dest, opts)
      ), this[ASYNC2] ? defer2(() => this[RESUME2]()) : this[RESUME2]()), dest;
    }
    unpipe(dest) {
      const p = this[PIPES2].find((p2) => p2.dest === dest);
      p && (this[PIPES2].splice(this[PIPES2].indexOf(p), 1), p.unpipe());
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      return ev === "data" && !this[PIPES2].length && !this.flowing ? this[RESUME2]() : ev === "readable" && this[BUFFERLENGTH2] !== 0 ? super.emit("readable") : isEndish2(ev) && this[EMITTED_END2] ? (super.emit(ev), this.removeAllListeners(ev)) : ev === "error" && this[EMITTED_ERROR2] && (this[ASYNC2] ? defer2(() => fn.call(this, this[EMITTED_ERROR2])) : fn.call(this, this[EMITTED_ERROR2])), ret;
    }
    get emittedEnd() {
      return this[EMITTED_END2];
    }
    [MAYBE_EMIT_END2]() {
      !this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2] && (this[EMITTING_END2] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED2] && this.emit("close"), this[EMITTING_END2] = !1);
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2])
        return;
      if (ev === "data")
        return !this[OBJECTMODE2] && !data ? !1 : this[ASYNC2] ? defer2(() => this[EMITDATA2](data)) : this[EMITDATA2](data);
      if (ev === "end")
        return this[EMITEND3]();
      if (ev === "close") {
        if (this[CLOSED2] = !0, !this[EMITTED_END2] && !this[DESTROYED2]) return;
        const ret2 = super.emit("close");
        return this.removeAllListeners("close"), ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR2] = data, super.emit(ERROR2, data);
        const ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : !1;
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        return this.removeAllListeners(ev), ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITDATA2](data) {
      for (const p of this[PIPES2])
        p.dest.write(data) === !1 && this.pause();
      const ret = super.emit("data", data);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITEND3]() {
      this[EMITTED_END2] || (this[EMITTED_END2] = !0, this.readable = !1, this[ASYNC2] ? defer2(() => this[EMITEND22]()) : this[EMITEND22]());
    }
    [EMITEND22]() {
      if (this[DECODER2]) {
        const data = this[DECODER2].end();
        if (data) {
          for (const p of this[PIPES2])
            p.dest.write(data);
          super.emit("data", data);
        }
      }
      for (const p of this[PIPES2])
        p.end();
      const ret = super.emit("end");
      return this.removeAllListeners("end"), ret;
    }
    // const all = await stream.collect()
    collect() {
      const buf = [];
      this[OBJECTMODE2] || (buf.dataLength = 0);
      const p = this.promise();
      return this.on("data", (c2) => {
        buf.push(c2), this[OBJECTMODE2] || (buf.dataLength += c2.length);
      }), p.then(() => buf);
    }
    // const data = await stream.concat()
    concat() {
      return this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
        (buf) => this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
      );
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED2, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve());
      });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
      let stopped = !1;
      const stop = () => (this.pause(), stopped = !0, Promise.resolve({ done: !0 }));
      return {
        next: () => {
          if (stopped) return stop();
          const res = this.read();
          if (res !== null) return Promise.resolve({ done: !1, value: res });
          if (this[EOF2]) return stop();
          let resolve = null, reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata), this.removeListener("end", onend), this.removeListener(DESTROYED2, ondestroy), stop(), reject(er);
          }, ondata = (value) => {
            this.removeListener("error", onerr), this.removeListener("end", onend), this.removeListener(DESTROYED2, ondestroy), this.pause(), resolve({ value, done: !!this[EOF2] });
          }, onend = () => {
            this.removeListener("error", onerr), this.removeListener("data", ondata), this.removeListener(DESTROYED2, ondestroy), stop(), resolve({ done: !0 });
          }, ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej, resolve = res2, this.once(DESTROYED2, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
          });
        },
        throw: stop,
        return: stop,
        [ASYNCITERATOR]() {
          return this;
        }
      };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
      let stopped = !1;
      const stop = () => (this.pause(), this.removeListener(ERROR2, stop), this.removeListener(DESTROYED2, stop), this.removeListener("end", stop), stopped = !0, { done: !0 }), next = () => {
        if (stopped) return stop();
        const value = this.read();
        return value === null ? stop() : { value };
      };
      return this.once("end", stop), this.once(ERROR2, stop), this.once(DESTROYED2, stop), {
        next,
        throw: stop,
        return: stop,
        [ITERATOR]() {
          return this;
        }
      };
    }
    destroy(er) {
      return this[DESTROYED2] ? (er ? this.emit("error", er) : this.emit(DESTROYED2), this) : (this[DESTROYED2] = !0, this[BUFFER2].length = 0, this[BUFFERLENGTH2] = 0, typeof this.close == "function" && !this[CLOSED2] && this.close(), er ? this.emit("error", er) : this.emit(DESTROYED2), this);
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass2 || s instanceof Stream2 || s instanceof EE && // readable
      (typeof s.pipe == "function" || // writable
      typeof s.write == "function" && typeof s.end == "function"));
    }
  }
  return minipass$1.Minipass = Minipass2, minipass$1;
}
var minizlib = {}, constants, hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const realZlibConstants = require$$0__default$b.default.constants || /* istanbul ignore next */
  { ZLIB_VERNUM: 4736 };
  return constants = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: 1 / 0,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants)), constants;
}
var minipass, hasRequiredMinipass;
function requireMinipass() {
  if (hasRequiredMinipass) return minipass;
  hasRequiredMinipass = 1;
  const proc2 = typeof process == "object" && process ? process : {
    stdout: null,
    stderr: null
  }, EE = require$$0__default$7.default, Stream2 = require$$0__default$4.default, SD = require$$2__default$1.default.StringDecoder, EOF2 = Symbol("EOF"), MAYBE_EMIT_END2 = Symbol("maybeEmitEnd"), EMITTED_END2 = Symbol("emittedEnd"), EMITTING_END2 = Symbol("emittingEnd"), EMITTED_ERROR2 = Symbol("emittedError"), CLOSED2 = Symbol("closed"), READ2 = Symbol("read"), FLUSH2 = Symbol("flush"), FLUSHCHUNK2 = Symbol("flushChunk"), ENCODING2 = Symbol("encoding"), DECODER2 = Symbol("decoder"), FLOWING2 = Symbol("flowing"), PAUSED2 = Symbol("paused"), RESUME2 = Symbol("resume"), BUFFERLENGTH2 = Symbol("bufferLength"), BUFFERPUSH2 = Symbol("bufferPush"), BUFFERSHIFT2 = Symbol("bufferShift"), OBJECTMODE2 = Symbol("objectMode"), DESTROYED2 = Symbol("destroyed"), EMITDATA2 = Symbol("emitData"), EMITEND3 = Symbol("emitEnd"), EMITEND22 = Symbol("emitEnd2"), ASYNC2 = Symbol("async"), defer2 = (fn) => Promise.resolve().then(fn), doIter = loadEnv.commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1", ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented"), ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented"), isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  class Pipe2 {
    constructor(src2, dest, opts) {
      this.src = src2, this.dest = dest, this.opts = opts, this.ondrain = () => src2[RESUME2](), dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {
    }
    end() {
      this.unpipe(), this.opts.end && this.dest.end();
    }
  }
  class PipeProxyErrors2 extends Pipe2 {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors), super.unpipe();
    }
    constructor(src2, dest, opts) {
      super(src2, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src2.on("error", this.proxyErrors);
    }
  }
  return minipass = class Minipass2 extends Stream2 {
    constructor(options2) {
      super(), this[FLOWING2] = !1, this[PAUSED2] = !1, this.pipes = [], this.buffer = [], this[OBJECTMODE2] = options2 && options2.objectMode || !1, this[OBJECTMODE2] ? this[ENCODING2] = null : this[ENCODING2] = options2 && options2.encoding || null, this[ENCODING2] === "buffer" && (this[ENCODING2] = null), this[ASYNC2] = options2 && !!options2.async || !1, this[DECODER2] = this[ENCODING2] ? new SD(this[ENCODING2]) : null, this[EOF2] = !1, this[EMITTED_END2] = !1, this[EMITTING_END2] = !1, this[CLOSED2] = !1, this[EMITTED_ERROR2] = null, this.writable = !0, this.readable = !0, this[BUFFERLENGTH2] = 0, this[DESTROYED2] = !1;
    }
    get bufferLength() {
      return this[BUFFERLENGTH2];
    }
    get encoding() {
      return this[ENCODING2];
    }
    set encoding(enc) {
      if (this[OBJECTMODE2])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING2] && enc !== this[ENCODING2] && (this[DECODER2] && this[DECODER2].lastNeed || this[BUFFERLENGTH2]))
        throw new Error("cannot change encoding");
      this[ENCODING2] !== enc && (this[DECODER2] = enc ? new SD(enc) : null, this.buffer.length && (this.buffer = this.buffer.map((chunk) => this[DECODER2].write(chunk)))), this[ENCODING2] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE2];
    }
    set objectMode(om) {
      this[OBJECTMODE2] = this[OBJECTMODE2] || !!om;
    }
    get async() {
      return this[ASYNC2];
    }
    set async(a) {
      this[ASYNC2] = this[ASYNC2] || !!a;
    }
    write(chunk, encoding, cb) {
      if (this[EOF2])
        throw new Error("write after end");
      if (this[DESTROYED2])
        return this.emit("error", Object.assign(
          new Error("Cannot call write after a stream was destroyed"),
          { code: "ERR_STREAM_DESTROYED" }
        )), !0;
      typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
      const fn = this[ASYNC2] ? defer2 : (f) => f();
      return !this[OBJECTMODE2] && !Buffer.isBuffer(chunk) && (isArrayBufferView2(chunk) ? chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength) : isArrayBuffer(chunk) ? chunk = Buffer.from(chunk) : typeof chunk != "string" && (this.objectMode = !0)), this[OBJECTMODE2] ? (this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING2] && !this[DECODER2].lastNeed) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING2] && (chunk = this[DECODER2].write(chunk)), this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : (this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing);
    }
    read(n) {
      if (this[DESTROYED2])
        return null;
      if (this[BUFFERLENGTH2] === 0 || n === 0 || n > this[BUFFERLENGTH2])
        return this[MAYBE_EMIT_END2](), null;
      this[OBJECTMODE2] && (n = null), this.buffer.length > 1 && !this[OBJECTMODE2] && (this.encoding ? this.buffer = [this.buffer.join("")] : this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH2])]);
      const ret = this[READ2](n || null, this.buffer[0]);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [READ2](n, chunk) {
      return n === chunk.length || n === null ? this[BUFFERSHIFT2]() : (this.buffer[0] = chunk.slice(n), chunk = chunk.slice(0, n), this[BUFFERLENGTH2] -= n), this.emit("data", chunk), !this.buffer.length && !this[EOF2] && this.emit("drain"), chunk;
    }
    end(chunk, encoding, cb) {
      return typeof chunk == "function" && (cb = chunk, chunk = null), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF2] = !0, this.writable = !1, (this.flowing || !this[PAUSED2]) && this[MAYBE_EMIT_END2](), this;
    }
    // don't let the internal resume be overwritten
    [RESUME2]() {
      this[DESTROYED2] || (this[PAUSED2] = !1, this[FLOWING2] = !0, this.emit("resume"), this.buffer.length ? this[FLUSH2]() : this[EOF2] ? this[MAYBE_EMIT_END2]() : this.emit("drain"));
    }
    resume() {
      return this[RESUME2]();
    }
    pause() {
      this[FLOWING2] = !1, this[PAUSED2] = !0;
    }
    get destroyed() {
      return this[DESTROYED2];
    }
    get flowing() {
      return this[FLOWING2];
    }
    get paused() {
      return this[PAUSED2];
    }
    [BUFFERPUSH2](chunk) {
      this[OBJECTMODE2] ? this[BUFFERLENGTH2] += 1 : this[BUFFERLENGTH2] += chunk.length, this.buffer.push(chunk);
    }
    [BUFFERSHIFT2]() {
      return this.buffer.length && (this[OBJECTMODE2] ? this[BUFFERLENGTH2] -= 1 : this[BUFFERLENGTH2] -= this.buffer[0].length), this.buffer.shift();
    }
    [FLUSH2](noDrain) {
      do
        ;
      while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()));
      !noDrain && !this.buffer.length && !this[EOF2] && this.emit("drain");
    }
    [FLUSHCHUNK2](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : !1;
    }
    pipe(dest, opts) {
      if (this[DESTROYED2])
        return;
      const ended = this[EMITTED_END2];
      return opts = opts || {}, dest === proc2.stdout || dest === proc2.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this.pipes.push(opts.proxyErrors ? new PipeProxyErrors2(this, dest, opts) : new Pipe2(this, dest, opts)), this[ASYNC2] ? defer2(() => this[RESUME2]()) : this[RESUME2]()), dest;
    }
    unpipe(dest) {
      const p = this.pipes.find((p2) => p2.dest === dest);
      p && (this.pipes.splice(this.pipes.indexOf(p), 1), p.unpipe());
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      return ev === "data" && !this.pipes.length && !this.flowing ? this[RESUME2]() : ev === "readable" && this[BUFFERLENGTH2] !== 0 ? super.emit("readable") : isEndish2(ev) && this[EMITTED_END2] ? (super.emit(ev), this.removeAllListeners(ev)) : ev === "error" && this[EMITTED_ERROR2] && (this[ASYNC2] ? defer2(() => fn.call(this, this[EMITTED_ERROR2])) : fn.call(this, this[EMITTED_ERROR2])), ret;
    }
    get emittedEnd() {
      return this[EMITTED_END2];
    }
    [MAYBE_EMIT_END2]() {
      !this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this.buffer.length === 0 && this[EOF2] && (this[EMITTING_END2] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED2] && this.emit("close"), this[EMITTING_END2] = !1);
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2])
        return;
      if (ev === "data")
        return data ? this[ASYNC2] ? defer2(() => this[EMITDATA2](data)) : this[EMITDATA2](data) : !1;
      if (ev === "end")
        return this[EMITEND3]();
      if (ev === "close") {
        if (this[CLOSED2] = !0, !this[EMITTED_END2] && !this[DESTROYED2])
          return;
        const ret2 = super.emit("close");
        return this.removeAllListeners("close"), ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR2] = data;
        const ret2 = super.emit("error", data);
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        return this.removeAllListeners(ev), ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITDATA2](data) {
      for (const p of this.pipes)
        p.dest.write(data) === !1 && this.pause();
      const ret = super.emit("data", data);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITEND3]() {
      this[EMITTED_END2] || (this[EMITTED_END2] = !0, this.readable = !1, this[ASYNC2] ? defer2(() => this[EMITEND22]()) : this[EMITEND22]());
    }
    [EMITEND22]() {
      if (this[DECODER2]) {
        const data = this[DECODER2].end();
        if (data) {
          for (const p of this.pipes)
            p.dest.write(data);
          super.emit("data", data);
        }
      }
      for (const p of this.pipes)
        p.end();
      const ret = super.emit("end");
      return this.removeAllListeners("end"), ret;
    }
    // const all = await stream.collect()
    collect() {
      const buf = [];
      this[OBJECTMODE2] || (buf.dataLength = 0);
      const p = this.promise();
      return this.on("data", (c2) => {
        buf.push(c2), this[OBJECTMODE2] || (buf.dataLength += c2.length);
      }), p.then(() => buf);
    }
    // const data = await stream.concat()
    concat() {
      return this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED2, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve());
      });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
      return { next: () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: !1, value: res });
        if (this[EOF2])
          return Promise.resolve({ done: !0 });
        let resolve = null, reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata), this.removeListener("end", onend), reject(er);
        }, ondata = (value) => {
          this.removeListener("error", onerr), this.removeListener("end", onend), this.pause(), resolve({ value, done: !!this[EOF2] });
        }, onend = () => {
          this.removeListener("error", onerr), this.removeListener("data", ondata), resolve({ done: !0 });
        }, ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej, resolve = res2, this.once(DESTROYED2, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
        });
      } };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
      return { next: () => {
        const value = this.read();
        return { value, done: value === null };
      } };
    }
    destroy(er) {
      return this[DESTROYED2] ? (er ? this.emit("error", er) : this.emit(DESTROYED2), this) : (this[DESTROYED2] = !0, this.buffer.length = 0, this[BUFFERLENGTH2] = 0, typeof this.close == "function" && !this[CLOSED2] && this.close(), er ? this.emit("error", er) : this.emit(DESTROYED2), this);
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass2 || s instanceof Stream2 || s instanceof EE && (typeof s.pipe == "function" || // readable
      typeof s.write == "function" && typeof s.end == "function"));
    }
  }, minipass;
}
var hasRequiredMinizlib;
function requireMinizlib() {
  if (hasRequiredMinizlib) return minizlib;
  hasRequiredMinizlib = 1;
  const assert = require$$0__default$5.default, Buffer2 = require$$0__default$a.default.Buffer, realZlib = require$$0__default$b.default, constants2 = minizlib.constants = requireConstants(), Minipass2 = requireMinipass(), OriginalBufferConcat = Buffer2.concat, _superWrite = Symbol("_superWrite");
  class ZlibError extends Error {
    constructor(err) {
      super("zlib: " + err.message), this.code = err.code, this.errno = err.errno, this.code || (this.code = "ZLIB_ERROR"), this.message = "zlib: " + err.message, Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  }
  const _opts = Symbol("opts"), _flushFlag = Symbol("flushFlag"), _finishFlushFlag = Symbol("finishFlushFlag"), _fullFlushFlag = Symbol("fullFlushFlag"), _handle = Symbol("handle"), _onError = Symbol("onError"), _sawError = Symbol("sawError"), _level = Symbol("level"), _strategy = Symbol("strategy"), _ended = Symbol("ended");
  class ZlibBase extends Minipass2 {
    constructor(opts, mode2) {
      if (!opts || typeof opts != "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts), this[_sawError] = !1, this[_ended] = !1, this[_opts] = opts, this[_flushFlag] = opts.flush, this[_finishFlushFlag] = opts.finishFlush;
      try {
        this[_handle] = new realZlib[mode2](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this[_onError] = (err) => {
        this[_sawError] || (this[_sawError] = !0, this.close(), this.emit("error", err));
      }, this[_handle].on("error", (er) => this[_onError](new ZlibError(er))), this.once("end", () => this.close);
    }
    close() {
      this[_handle] && (this[_handle].close(), this[_handle] = null, this.emit("close"));
    }
    reset() {
      if (!this[_sawError])
        return assert(this[_handle], "zlib binding closed"), this[_handle].reset();
    }
    flush(flushFlag) {
      this.ended || (typeof flushFlag != "number" && (flushFlag = this[_fullFlushFlag]), this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag })));
    }
    end(chunk, encoding, cb) {
      return chunk && this.write(chunk, encoding), this.flush(this[_finishFlushFlag]), this[_ended] = !0, super.end(null, null, cb);
    }
    get ended() {
      return this[_ended];
    }
    write(chunk, encoding, cb) {
      if (typeof encoding == "function" && (cb = encoding, encoding = "utf8"), typeof chunk == "string" && (chunk = Buffer2.from(chunk, encoding)), this[_sawError])
        return;
      assert(this[_handle], "zlib binding closed");
      const nativeHandle = this[_handle]._handle, originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {
      };
      const originalClose = this[_handle].close;
      this[_handle].close = () => {
      }, Buffer2.concat = (args) => args;
      let result;
      try {
        const flushFlag = typeof chunk[_flushFlag] == "number" ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag), Buffer2.concat = OriginalBufferConcat;
      } catch (err) {
        Buffer2.concat = OriginalBufferConcat, this[_onError](new ZlibError(err));
      } finally {
        this[_handle] && (this[_handle]._handle = nativeHandle, nativeHandle.close = originalNativeClose, this[_handle].close = originalClose, this[_handle].removeAllListeners("error"));
      }
      this[_handle] && this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      let writeReturn;
      if (result)
        if (Array.isArray(result) && result.length > 0) {
          writeReturn = this[_superWrite](Buffer2.from(result[0]));
          for (let i = 1; i < result.length; i++)
            writeReturn = this[_superWrite](result[i]);
        } else
          writeReturn = this[_superWrite](Buffer2.from(result));
      return cb && cb(), writeReturn;
    }
    [_superWrite](data) {
      return super.write(data);
    }
  }
  class Zlib extends ZlibBase {
    constructor(opts, mode2) {
      opts = opts || {}, opts.flush = opts.flush || constants2.Z_NO_FLUSH, opts.finishFlush = opts.finishFlush || constants2.Z_FINISH, super(opts, mode2), this[_fullFlushFlag] = constants2.Z_FULL_FLUSH, this[_level] = opts.level, this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
      if (!this[_sawError]) {
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants2.Z_SYNC_FLUSH), assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag), cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          this[_handle] && (this[_level] = level, this[_strategy] = strategy);
        }
      }
    }
  }
  class Deflate extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  }
  class Inflate extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  }
  const _portable = Symbol("_portable");
  class Gzip extends Zlib {
    constructor(opts) {
      super(opts, "Gzip"), this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
      return this[_portable] ? (this[_portable] = !1, data[9] = 255, super[_superWrite](data)) : super[_superWrite](data);
    }
  }
  class Gunzip extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  }
  class DeflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  }
  class InflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  }
  class Unzip extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  }
  class Brotli extends ZlibBase {
    constructor(opts, mode2) {
      opts = opts || {}, opts.flush = opts.flush || constants2.BROTLI_OPERATION_PROCESS, opts.finishFlush = opts.finishFlush || constants2.BROTLI_OPERATION_FINISH, super(opts, mode2), this[_fullFlushFlag] = constants2.BROTLI_OPERATION_FLUSH;
    }
  }
  class BrotliCompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  }
  class BrotliDecompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  }
  return minizlib.Deflate = Deflate, minizlib.Inflate = Inflate, minizlib.Gzip = Gzip, minizlib.Gunzip = Gunzip, minizlib.DeflateRaw = DeflateRaw, minizlib.InflateRaw = InflateRaw, minizlib.Unzip = Unzip, typeof realZlib.BrotliCompress == "function" ? (minizlib.BrotliCompress = BrotliCompress, minizlib.BrotliDecompress = BrotliDecompress) : minizlib.BrotliCompress = minizlib.BrotliDecompress = class {
    constructor() {
      throw new Error("Brotli is not supported in this version of Node.js");
    }
  }, minizlib;
}
var normalizeWindowsPath, hasRequiredNormalizeWindowsPath;
function requireNormalizeWindowsPath() {
  return hasRequiredNormalizeWindowsPath || (hasRequiredNormalizeWindowsPath = 1, normalizeWindowsPath = (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform) !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/")), normalizeWindowsPath;
}
var readEntry, hasRequiredReadEntry;
function requireReadEntry() {
  if (hasRequiredReadEntry) return readEntry;
  hasRequiredReadEntry = 1;
  const { Minipass: Minipass2 } = requireMinipass$1(), normPath = requireNormalizeWindowsPath(), SLURP = Symbol("slurp");
  return readEntry = class extends Minipass2 {
    constructor(header2, ex, gex) {
      switch (super(), this.pause(), this.extended = ex, this.globalExtended = gex, this.header = header2, this.startBlockSize = 512 * Math.ceil(header2.size / 512), this.blockRemain = this.startBlockSize, this.remain = header2.size, this.type = header2.type, this.meta = !1, this.ignore = !1, this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = !0;
          break;
        // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
        // it may be worth doing the same, but with a warning.
        default:
          this.ignore = !0;
      }
      this.path = normPath(header2.path), this.mode = header2.mode, this.mode && (this.mode = this.mode & 4095), this.uid = header2.uid, this.gid = header2.gid, this.uname = header2.uname, this.gname = header2.gname, this.size = header2.size, this.mtime = header2.mtime, this.atime = header2.atime, this.ctime = header2.ctime, this.linkpath = normPath(header2.linkpath), this.uname = header2.uname, this.gname = header2.gname, ex && this[SLURP](ex), gex && this[SLURP](gex, !0);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      const r = this.remain, br = this.blockRemain;
      return this.remain = Math.max(0, r - writeLen), this.blockRemain = Math.max(0, br - writeLen), this.ignore ? !0 : r >= writeLen ? super.write(data) : super.write(data.slice(0, r));
    }
    [SLURP](ex, global2) {
      for (const k in ex)
        ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path") && (this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k]);
    }
  }, readEntry;
}
var types$2 = {}, hasRequiredTypes$1;
function requireTypes$1() {
  return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(exports2) {
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]), exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }(types$2)), types$2;
}
var largeNumbers, hasRequiredLargeNumbers;
function requireLargeNumbers() {
  if (hasRequiredLargeNumbers) return largeNumbers;
  hasRequiredLargeNumbers = 1;
  const encode = (num, buf) => {
    if (Number.isSafeInteger(num))
      num < 0 ? encodeNegative(num, buf) : encodePositive(num, buf);
    else throw Error("cannot encode number outside of javascript safe integer range");
    return buf;
  }, encodePositive = (num, buf) => {
    buf[0] = 128;
    for (var i = buf.length; i > 1; i--)
      buf[i - 1] = num & 255, num = Math.floor(num / 256);
  }, encodeNegative = (num, buf) => {
    buf[0] = 255;
    var flipped = !1;
    num = num * -1;
    for (var i = buf.length; i > 1; i--) {
      var byte = num & 255;
      num = Math.floor(num / 256), flipped ? buf[i - 1] = onesComp(byte) : byte === 0 ? buf[i - 1] = 0 : (flipped = !0, buf[i - 1] = twosComp(byte));
    }
  }, parse3 = (buf) => {
    const pre = buf[0], value = pre === 128 ? pos2(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
    if (value === null)
      throw Error("invalid base256 encoding");
    if (!Number.isSafeInteger(value))
      throw Error("parsed number outside of javascript safe integer range");
    return value;
  }, twos = (buf) => {
    for (var len = buf.length, sum = 0, flipped = !1, i = len - 1; i > -1; i--) {
      var byte = buf[i], f;
      flipped ? f = onesComp(byte) : byte === 0 ? f = byte : (flipped = !0, f = twosComp(byte)), f !== 0 && (sum -= f * Math.pow(256, len - i - 1));
    }
    return sum;
  }, pos2 = (buf) => {
    for (var len = buf.length, sum = 0, i = len - 1; i > -1; i--) {
      var byte = buf[i];
      byte !== 0 && (sum += byte * Math.pow(256, len - i - 1));
    }
    return sum;
  }, onesComp = (byte) => (255 ^ byte) & 255, twosComp = (byte) => (255 ^ byte) + 1 & 255;
  return largeNumbers = {
    encode,
    parse: parse3
  }, largeNumbers;
}
var header, hasRequiredHeader;
function requireHeader() {
  if (hasRequiredHeader) return header;
  hasRequiredHeader = 1;
  const types2 = requireTypes$1(), pathModule = require$$0__default.default.posix, large = requireLargeNumbers(), SLURP = Symbol("slurp"), TYPE = Symbol("type");
  class Header {
    constructor(data, off, ex, gex) {
      this.cksumValid = !1, this.needPax = !1, this.nullBlock = !1, this.block = null, this.path = null, this.mode = null, this.uid = null, this.gid = null, this.size = null, this.mtime = null, this.cksum = null, this[TYPE] = "0", this.linkpath = null, this.uname = null, this.gname = null, this.devmaj = 0, this.devmin = 0, this.atime = null, this.ctime = null, Buffer.isBuffer(data) ? this.decode(data, off || 0, ex, gex) : data && this.set(data);
    }
    decode(buf, off, ex, gex) {
      if (off || (off = 0), !buf || !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      if (this.path = decString(buf, off, 100), this.mode = decNumber(buf, off + 100, 8), this.uid = decNumber(buf, off + 108, 8), this.gid = decNumber(buf, off + 116, 8), this.size = decNumber(buf, off + 124, 12), this.mtime = decDate(buf, off + 136, 12), this.cksum = decNumber(buf, off + 148, 12), this[SLURP](ex), this[SLURP](gex, !0), this[TYPE] = decString(buf, off + 156, 1), this[TYPE] === "" && (this[TYPE] = "0"), this[TYPE] === "0" && this.path.slice(-1) === "/" && (this[TYPE] = "5"), this[TYPE] === "5" && (this.size = 0), this.linkpath = decString(buf, off + 157, 100), buf.slice(off + 257, off + 265).toString() === "ustar\x0000")
        if (this.uname = decString(buf, off + 265, 32), this.gname = decString(buf, off + 297, 32), this.devmaj = decNumber(buf, off + 329, 8), this.devmin = decNumber(buf, off + 337, 8), buf[off + 475] !== 0) {
          const prefix = decString(buf, off + 345, 155);
          this.path = prefix + "/" + this.path;
        } else {
          const prefix = decString(buf, off + 345, 130);
          prefix && (this.path = prefix + "/" + this.path), this.atime = decDate(buf, off + 476, 12), this.ctime = decDate(buf, off + 488, 12);
        }
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum += buf[i];
      this.cksumValid = sum === this.cksum, this.cksum === null && sum === 8 * 32 && (this.nullBlock = !0);
    }
    [SLURP](ex, global2) {
      for (const k in ex)
        ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path") && (this[k] = ex[k]);
    }
    encode(buf, off) {
      if (buf || (buf = this.block = Buffer.alloc(512), off = 0), off || (off = 0), !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      const prefixSize = this.ctime || this.atime ? 130 : 155, split = splitPrefix(this.path || "", prefixSize), path2 = split[0], prefix = split[1];
      this.needPax = split[2], this.needPax = encString(buf, off, 100, path2) || this.needPax, this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax, this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax, this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax, this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax, this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax, buf[off + 156] = this[TYPE].charCodeAt(0), this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax, buf.write("ustar\x0000", off + 257, 8), this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax, this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax, this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax, this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax, this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax, buf[off + 475] !== 0 ? this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax : (this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax, this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax, this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax);
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum += buf[i];
      return this.cksum = sum, encNumber(buf, off + 148, 8, this.cksum), this.cksumValid = !0, this.needPax;
    }
    set(data) {
      for (const i in data)
        data[i] !== null && data[i] !== void 0 && (this[i] = data[i]);
    }
    get type() {
      return types2.name.get(this[TYPE]) || this[TYPE];
    }
    get typeKey() {
      return this[TYPE];
    }
    set type(type2) {
      types2.code.has(type2) ? this[TYPE] = types2.code.get(type2) : this[TYPE] = type2;
    }
  }
  const splitPrefix = (p, prefixSize) => {
    let pp = p, prefix = "", ret;
    const root2 = pathModule.parse(p).root || ".";
    if (Buffer.byteLength(pp) < 100)
      ret = [pp, prefix, !1];
    else {
      prefix = pathModule.dirname(pp), pp = pathModule.basename(pp);
      do
        Buffer.byteLength(pp) <= 100 && Buffer.byteLength(prefix) <= prefixSize ? ret = [pp, prefix, !1] : Buffer.byteLength(pp) > 100 && Buffer.byteLength(prefix) <= prefixSize ? ret = [pp.slice(0, 99), prefix, !0] : (pp = pathModule.join(pathModule.basename(prefix), pp), prefix = pathModule.dirname(prefix));
      while (prefix !== root2 && !ret);
      ret || (ret = [p.slice(0, 99), "", !0]);
    }
    return ret;
  }, decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, ""), decDate = (buf, off, size) => numToDate(decNumber(buf, off, size)), numToDate = (num) => num === null ? null : new Date(num * 1e3), decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size), nanNull = (value) => isNaN(value) ? null : value, decSmallNumber = (buf, off, size) => nanNull(parseInt(
    buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
    8
  )), MAXNUM = {
    12: 8589934591,
    8: 2097151
  }, encNumber = (buf, off, size, number2) => number2 === null ? !1 : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), !0) : (encSmallNumber(buf, off, size, number2), !1), encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii"), octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size), padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0", encDate = (buf, off, size, date) => date === null ? !1 : encNumber(buf, off, size, date.getTime() / 1e3), NULLS = new Array(156).join("\0"), encString = (buf, off, size, string) => string === null ? !1 : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
  return header = Header, header;
}
var pax, hasRequiredPax;
function requirePax() {
  if (hasRequiredPax) return pax;
  hasRequiredPax = 1;
  const Header = requireHeader(), path2 = require$$0__default.default;
  class Pax {
    constructor(obj, global2) {
      this.atime = obj.atime || null, this.charset = obj.charset || null, this.comment = obj.comment || null, this.ctime = obj.ctime || null, this.gid = obj.gid || null, this.gname = obj.gname || null, this.linkpath = obj.linkpath || null, this.mtime = obj.mtime || null, this.path = obj.path || null, this.size = obj.size || null, this.uid = obj.uid || null, this.uname = obj.uname || null, this.dev = obj.dev || null, this.ino = obj.ino || null, this.nlink = obj.nlink || null, this.global = global2 || !1;
    }
    encode() {
      const body = this.encodeBody();
      if (body === "")
        return null;
      const bodyLen = Buffer.byteLength(body), bufLen = 512 * Math.ceil(1 + bodyLen / 512), buf = Buffer.allocUnsafe(bufLen);
      for (let i = 0; i < 512; i++)
        buf[i] = 0;
      new Header({
        // XXX split the path
        // then the path should be PaxHeader + basename, but less than 99,
        // prepend with the dirname
        path: ("PaxHeader/" + path2.basename(this.path)).slice(0, 99),
        mode: this.mode || 420,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
        linkpath: "",
        uname: this.uname || "",
        gname: this.gname || "",
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf), buf.write(body, 512, bodyLen, "utf8");
      for (let i = bodyLen + 512; i < buf.length; i++)
        buf[i] = 0;
      return buf;
    }
    encodeBody() {
      return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
    }
    encodeField(field) {
      if (this[field] === null || this[field] === void 0)
        return "";
      const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field], s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + `
`, byteLen = Buffer.byteLength(s);
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
      return byteLen + digits >= Math.pow(10, digits) && (digits += 1), digits + byteLen + s;
    }
  }
  Pax.parse = (string, ex, g) => new Pax(merge2(parseKV(string), ex), g);
  const merge2 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a, parseKV = (string) => string.replace(/\n$/, "").split(`
`).reduce(parseKVLine, /* @__PURE__ */ Object.create(null)), parseKVLine = (set2, line3) => {
    const n = parseInt(line3, 10);
    if (n !== Buffer.byteLength(line3) + 1)
      return set2;
    line3 = line3.slice((n + " ").length);
    const kv = line3.split("="), k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
    if (!k)
      return set2;
    const v = kv.join("=");
    return set2[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v, set2;
  };
  return pax = Pax, pax;
}
var stripTrailingSlashes, hasRequiredStripTrailingSlashes;
function requireStripTrailingSlashes() {
  return hasRequiredStripTrailingSlashes || (hasRequiredStripTrailingSlashes = 1, stripTrailingSlashes = (str2) => {
    let i = str2.length - 1, slashesStart = -1;
    for (; i > -1 && str2.charAt(i) === "/"; )
      slashesStart = i, i--;
    return slashesStart === -1 ? str2 : str2.slice(0, slashesStart);
  }), stripTrailingSlashes;
}
var warnMixin, hasRequiredWarnMixin;
function requireWarnMixin() {
  return hasRequiredWarnMixin || (hasRequiredWarnMixin = 1, warnMixin = (Base) => class extends Base {
    warn(code, message, data = {}) {
      this.file && (data.file = this.file), this.cwd && (data.cwd = this.cwd), data.code = message instanceof Error && message.code || code, data.tarCode = code, !this.strict && data.recoverable !== !1 ? (message instanceof Error && (data = Object.assign(message, data), message = message.message), this.emit("warn", data.tarCode, message, data)) : message instanceof Error ? this.emit("error", Object.assign(message, data)) : this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
    }
  }), warnMixin;
}
var winchars, hasRequiredWinchars;
function requireWinchars() {
  if (hasRequiredWinchars) return winchars;
  hasRequiredWinchars = 1;
  const raw = [
    "|",
    "<",
    ">",
    "?",
    ":"
  ], win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0))), toWin = new Map(raw.map((char, i) => [char, win[i]])), toRaw = new Map(win.map((char, i) => [char, raw[i]]));
  return winchars = {
    encode: (s) => raw.reduce((s2, c2) => s2.split(c2).join(toWin.get(c2)), s),
    decode: (s) => win.reduce((s2, c2) => s2.split(c2).join(toRaw.get(c2)), s)
  }, winchars;
}
var stripAbsolutePath, hasRequiredStripAbsolutePath;
function requireStripAbsolutePath() {
  if (hasRequiredStripAbsolutePath) return stripAbsolutePath;
  hasRequiredStripAbsolutePath = 1;
  const { isAbsolute, parse: parse3 } = require$$0__default.default.win32;
  return stripAbsolutePath = (path2) => {
    let r = "", parsed = parse3(path2);
    for (; isAbsolute(path2) || parsed.root; ) {
      const root2 = path2.charAt(0) === "/" && path2.slice(0, 4) !== "//?/" ? "/" : parsed.root;
      path2 = path2.slice(root2.length), r += root2, parsed = parse3(path2);
    }
    return [r, path2];
  }, stripAbsolutePath;
}
var modeFix, hasRequiredModeFix;
function requireModeFix() {
  return hasRequiredModeFix || (hasRequiredModeFix = 1, modeFix = (mode2, isDir2, portable) => (mode2 &= 4095, portable && (mode2 = (mode2 | 384) & -19), isDir2 && (mode2 & 256 && (mode2 |= 64), mode2 & 32 && (mode2 |= 8), mode2 & 4 && (mode2 |= 1)), mode2)), modeFix;
}
var writeEntry, hasRequiredWriteEntry;
function requireWriteEntry() {
  if (hasRequiredWriteEntry) return writeEntry;
  hasRequiredWriteEntry = 1;
  const { Minipass: Minipass2 } = requireMinipass$1(), Pax = requirePax(), Header = requireHeader(), fs2 = require$$0__default$1.default, path2 = require$$0__default.default, normPath = requireNormalizeWindowsPath(), stripSlash = requireStripTrailingSlashes(), prefixPath = (path3, prefix) => prefix ? (path3 = normPath(path3).replace(/^\.(\/|$)/, ""), stripSlash(prefix) + "/" + path3) : normPath(path3), maxReadSize = 16 * 1024 * 1024, PROCESS2 = Symbol("process"), FILE = Symbol("file"), DIRECTORY = Symbol("directory"), SYMLINK = Symbol("symlink"), HARDLINK = Symbol("hardlink"), HEADER = Symbol("header"), READ2 = Symbol("read"), LSTAT = Symbol("lstat"), ONLSTAT = Symbol("onlstat"), ONREAD = Symbol("onread"), ONREADLINK = Symbol("onreadlink"), OPENFILE = Symbol("openfile"), ONOPENFILE = Symbol("onopenfile"), CLOSE = Symbol("close"), MODE = Symbol("mode"), AWAITDRAIN = Symbol("awaitDrain"), ONDRAIN = Symbol("ondrain"), PREFIX = Symbol("prefix"), HAD_ERROR = Symbol("hadError"), warner = requireWarnMixin(), winchars2 = requireWinchars(), stripAbsolutePath2 = requireStripAbsolutePath(), modeFix2 = requireModeFix(), WriteEntry = warner(class extends Minipass2 {
    constructor(p, opt) {
      if (opt = opt || {}, super(opt), typeof p != "string")
        throw new TypeError("path is required");
      this.path = normPath(p), this.portable = !!opt.portable, this.myuid = process.getuid && process.getuid() || 0, this.myuser = process.env.USER || "", this.maxReadSize = opt.maxReadSize || maxReadSize, this.linkCache = opt.linkCache || /* @__PURE__ */ new Map(), this.statCache = opt.statCache || /* @__PURE__ */ new Map(), this.preservePaths = !!opt.preservePaths, this.cwd = normPath(opt.cwd || process.cwd()), this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.noMtime = !!opt.noMtime, this.mtime = opt.mtime || null, this.prefix = opt.prefix ? normPath(opt.prefix) : null, this.fd = null, this.blockLen = null, this.blockRemain = null, this.buf = null, this.offset = null, this.length = null, this.pos = null, this.remain = null, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn);
      let pathWarn = !1;
      if (!this.preservePaths) {
        const [root2, stripped] = stripAbsolutePath2(this.path);
        root2 && (this.path = stripped, pathWarn = root2);
      }
      this.win32 = !!opt.win32 || process.platform === "win32", this.win32 && (this.path = winchars2.decode(this.path.replace(/\\/g, "/")), p = p.replace(/\\/g, "/")), this.absolute = normPath(opt.absolute || path2.resolve(this.cwd, p)), this.path === "" && (this.path = "./"), pathWarn && this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      }), this.statCache.has(this.absolute) ? this[ONLSTAT](this.statCache.get(this.absolute)) : this[LSTAT]();
    }
    emit(ev, ...data) {
      return ev === "error" && (this[HAD_ERROR] = !0), super.emit(ev, ...data);
    }
    [LSTAT]() {
      fs2.lstat(this.absolute, (er, stat2) => {
        if (er)
          return this.emit("error", er);
        this[ONLSTAT](stat2);
      });
    }
    [ONLSTAT](stat2) {
      this.statCache.set(this.absolute, stat2), this.stat = stat2, stat2.isFile() || (stat2.size = 0), this.type = getType(stat2), this.emit("stat", stat2), this[PROCESS2]();
    }
    [PROCESS2]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        // unsupported types are ignored.
        default:
          return this.end();
      }
    }
    [MODE](mode2) {
      return modeFix2(mode2, this.type === "Directory", this.portable);
    }
    [PREFIX](path3) {
      return prefixPath(path3, this.prefix);
    }
    [HEADER]() {
      this.type === "Directory" && this.portable && (this.noMtime = !0), this.header = new Header({
        path: this[PREFIX](this.path),
        // only apply the prefix to hard links.
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      }), this.header.encode() && !this.noPax && super.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode()), super.write(this.header.block);
    }
    [DIRECTORY]() {
      this.path.slice(-1) !== "/" && (this.path += "/"), this.stat.size = 0, this[HEADER](), this.end();
    }
    [SYMLINK]() {
      fs2.readlink(this.absolute, (er, linkpath) => {
        if (er)
          return this.emit("error", er);
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = normPath(linkpath), this[HEADER](), this.end();
    }
    [HARDLINK](linkpath) {
      this.type = "Link", this.linkpath = normPath(path2.relative(this.cwd, linkpath)), this.stat.size = 0, this[HEADER](), this.end();
    }
    [FILE]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0)
            return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      if (this[HEADER](), this.stat.size === 0)
        return this.end();
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs2.open(this.absolute, "r", (er, fd) => {
        if (er)
          return this.emit("error", er);
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      if (this.fd = fd, this[HAD_ERROR])
        return this[CLOSE]();
      this.blockLen = 512 * Math.ceil(this.stat.size / 512), this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen), this.offset = 0, this.pos = 0, this.remain = this.stat.size, this.length = this.buf.length, this[READ2]();
    }
    [READ2]() {
      const { fd, buf, offset, length, pos: pos2 } = this;
      fs2.read(fd, buf, offset, length, pos2, (er, bytesRead) => {
        if (er)
          return this[CLOSE](() => this.emit("error", er));
        this[ONREAD](bytesRead);
      });
    }
    [CLOSE](cb) {
      fs2.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = new Error("encountered unexpected EOF");
        return er.path = this.absolute, er.syscall = "read", er.code = "EOF", this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead > this.remain) {
        const er = new Error("did not encounter expected EOF");
        return er.path = this.absolute, er.syscall = "read", er.code = "EOF", this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead === this.remain)
        for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++)
          this.buf[i + this.offset] = 0, bytesRead++, this.remain++;
      const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
      this.write(writeBuf) ? this[ONDRAIN]() : this[AWAITDRAIN](() => this[ONDRAIN]());
    }
    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }
    write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        const er = new Error("writing more data than expected");
        return er.path = this.absolute, this.emit("error", er);
      }
      return this.remain -= writeBuf.length, this.blockRemain -= writeBuf.length, this.pos += writeBuf.length, this.offset += writeBuf.length, super.write(writeBuf);
    }
    [ONDRAIN]() {
      if (!this.remain)
        return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
      this.offset >= this.length && (this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length)), this.offset = 0), this.length = this.buf.length - this.offset, this[READ2]();
    }
  });
  class WriteEntrySync extends WriteEntry {
    [LSTAT]() {
      this[ONLSTAT](fs2.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs2.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
    }
    [READ2]() {
      let threw = !0;
      try {
        const { fd, buf, offset, length, pos: pos2 } = this, bytesRead = fs2.readSync(fd, buf, offset, length, pos2);
        this[ONREAD](bytesRead), threw = !1;
      } finally {
        if (threw)
          try {
            this[CLOSE](() => {
            });
          } catch {
          }
      }
    }
    [AWAITDRAIN](cb) {
      cb();
    }
    [CLOSE](cb) {
      fs2.closeSync(this.fd), cb();
    }
  }
  const WriteEntryTar = warner(class extends Minipass2 {
    constructor(readEntry2, opt) {
      opt = opt || {}, super(opt), this.preservePaths = !!opt.preservePaths, this.portable = !!opt.portable, this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.noMtime = !!opt.noMtime, this.readEntry = readEntry2, this.type = readEntry2.type, this.type === "Directory" && this.portable && (this.noMtime = !0), this.prefix = opt.prefix || null, this.path = normPath(readEntry2.path), this.mode = this[MODE](readEntry2.mode), this.uid = this.portable ? null : readEntry2.uid, this.gid = this.portable ? null : readEntry2.gid, this.uname = this.portable ? null : readEntry2.uname, this.gname = this.portable ? null : readEntry2.gname, this.size = readEntry2.size, this.mtime = this.noMtime ? null : opt.mtime || readEntry2.mtime, this.atime = this.portable ? null : readEntry2.atime, this.ctime = this.portable ? null : readEntry2.ctime, this.linkpath = normPath(readEntry2.linkpath), typeof opt.onwarn == "function" && this.on("warn", opt.onwarn);
      let pathWarn = !1;
      if (!this.preservePaths) {
        const [root2, stripped] = stripAbsolutePath2(this.path);
        root2 && (this.path = stripped, pathWarn = root2);
      }
      this.remain = readEntry2.size, this.blockRemain = readEntry2.startBlockSize, this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      }), pathWarn && this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      }), this.header.encode() && !this.noPax && super.write(new Pax({
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
        gid: this.portable ? null : this.gid,
        mtime: this.noMtime ? null : this.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.size,
        uid: this.portable ? null : this.uid,
        uname: this.portable ? null : this.uname,
        dev: this.portable ? null : this.readEntry.dev,
        ino: this.portable ? null : this.readEntry.ino,
        nlink: this.portable ? null : this.readEntry.nlink
      }).encode()), super.write(this.header.block), readEntry2.pipe(this);
    }
    [PREFIX](path3) {
      return prefixPath(path3, this.prefix);
    }
    [MODE](mode2) {
      return modeFix2(mode2, this.type === "Directory", this.portable);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      return this.blockRemain -= writeLen, super.write(data);
    }
    end() {
      return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), super.end();
    }
  });
  WriteEntry.Sync = WriteEntrySync, WriteEntry.Tar = WriteEntryTar;
  const getType = (stat2) => stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
  return writeEntry = WriteEntry, writeEntry;
}
var iterator$1, hasRequiredIterator;
function requireIterator() {
  return hasRequiredIterator || (hasRequiredIterator = 1, iterator$1 = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next)
        yield walker.value;
    };
  }), iterator$1;
}
var yallist, hasRequiredYallist;
function requireYallist() {
  if (hasRequiredYallist) return yallist;
  hasRequiredYallist = 1, yallist = Yallist, Yallist.Node = Node, Yallist.create = Yallist;
  function Yallist(list2) {
    var self2 = this;
    if (self2 instanceof Yallist || (self2 = new Yallist()), self2.tail = null, self2.head = null, self2.length = 0, list2 && typeof list2.forEach == "function")
      list2.forEach(function(item) {
        self2.push(item);
      });
    else if (arguments.length > 0)
      for (var i = 0, l = arguments.length; i < l; i++)
        self2.push(arguments[i]);
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this)
      throw new Error("removing node which does not belong to this list");
    var next = node.next, prev = node.prev;
    return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
  }, Yallist.prototype.unshiftNode = function(node) {
    if (node !== this.head) {
      node.list && node.list.removeNode(node);
      var head = this.head;
      node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
    }
  }, Yallist.prototype.pushNode = function(node) {
    if (node !== this.tail) {
      node.list && node.list.removeNode(node);
      var tail = this.tail;
      node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
    }
  }, Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++)
      push2(this, arguments[i]);
    return this.length;
  }, Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++)
      unshift(this, arguments[i]);
    return this.length;
  }, Yallist.prototype.pop = function() {
    if (this.tail) {
      var res = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
    }
  }, Yallist.prototype.shift = function() {
    if (this.head) {
      var res = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
    }
  }, Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++)
      fn.call(thisp, walker.value, i, this), walker = walker.next;
  }, Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
      fn.call(thisp, walker.value, i, this), walker = walker.prev;
  }, Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++)
      walker = walker.next;
    if (i === n && walker !== null)
      return walker.value;
  }, Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
      walker = walker.prev;
    if (i === n && walker !== null)
      return walker.value;
  }, Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist(), walker = this.head; walker !== null; )
      res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
    return res;
  }, Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist(), walker = this.tail; walker !== null; )
      res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
    return res;
  }, Yallist.prototype.reduce = function(fn, initial) {
    var acc, walker = this.head;
    if (arguments.length > 1)
      acc = initial;
    else if (this.head)
      walker = this.head.next, acc = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = 0; walker !== null; i++)
      acc = fn(acc, walker.value, i), walker = walker.next;
    return acc;
  }, Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc, walker = this.tail;
    if (arguments.length > 1)
      acc = initial;
    else if (this.tail)
      walker = this.tail.prev, acc = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = this.length - 1; walker !== null; i--)
      acc = fn(acc, walker.value, i), walker = walker.prev;
    return acc;
  }, Yallist.prototype.toArray = function() {
    for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
      arr[i] = walker.value, walker = walker.next;
    return arr;
  }, Yallist.prototype.toArrayReverse = function() {
    for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
      arr[i] = walker.value, walker = walker.prev;
    return arr;
  }, Yallist.prototype.slice = function(from2, to) {
    to = to || this.length, to < 0 && (to += this.length), from2 = from2 || 0, from2 < 0 && (from2 += this.length);
    var ret = new Yallist();
    if (to < from2 || to < 0)
      return ret;
    from2 < 0 && (from2 = 0), to > this.length && (to = this.length);
    for (var i = 0, walker = this.head; walker !== null && i < from2; i++)
      walker = walker.next;
    for (; walker !== null && i < to; i++, walker = walker.next)
      ret.push(walker.value);
    return ret;
  }, Yallist.prototype.sliceReverse = function(from2, to) {
    to = to || this.length, to < 0 && (to += this.length), from2 = from2 || 0, from2 < 0 && (from2 += this.length);
    var ret = new Yallist();
    if (to < from2 || to < 0)
      return ret;
    from2 < 0 && (from2 = 0), to > this.length && (to = this.length);
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
      walker = walker.prev;
    for (; walker !== null && i > from2; i--, walker = walker.prev)
      ret.push(walker.value);
    return ret;
  }, Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
    for (var i = 0, walker = this.head; walker !== null && i < start; i++)
      walker = walker.next;
    for (var ret = [], i = 0; walker && i < deleteCount; i++)
      ret.push(walker.value), walker = this.removeNode(walker);
    walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
    for (var i = 0; i < nodes.length; i++)
      walker = insert(this, walker, nodes[i]);
    return ret;
  }, Yallist.prototype.reverse = function() {
    for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next, walker.next = p;
    }
    return this.head = tail, this.tail = head, this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
  }
  function push2(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
  }
  function Node(value, prev, next, list2) {
    if (!(this instanceof Node))
      return new Node(value, prev, next, list2);
    this.list = list2, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
  }
  try {
    requireIterator()(Yallist);
  } catch {
  }
  return yallist;
}
var pack, hasRequiredPack;
function requirePack() {
  if (hasRequiredPack) return pack;
  hasRequiredPack = 1;
  class PackJob {
    constructor(path3, absolute) {
      this.path = path3 || "./", this.absolute = absolute, this.entry = null, this.stat = null, this.readdir = null, this.pending = !1, this.ignore = !1, this.piped = !1;
    }
  }
  const { Minipass: Minipass2 } = requireMinipass$1(), zlib = requireMinizlib(), ReadEntry = requireReadEntry(), WriteEntry = requireWriteEntry(), WriteEntrySync = WriteEntry.Sync, WriteEntryTar = WriteEntry.Tar, Yallist = requireYallist(), EOF2 = Buffer.alloc(1024), ONSTAT = Symbol("onStat"), ENDED = Symbol("ended"), QUEUE = Symbol("queue"), CURRENT = Symbol("current"), PROCESS2 = Symbol("process"), PROCESSING = Symbol("processing"), PROCESSJOB = Symbol("processJob"), JOBS = Symbol("jobs"), JOBDONE = Symbol("jobDone"), ADDFSENTRY = Symbol("addFSEntry"), ADDTARENTRY = Symbol("addTarEntry"), STAT = Symbol("stat"), READDIR = Symbol("readdir"), ONREADDIR = Symbol("onreaddir"), PIPE = Symbol("pipe"), ENTRY = Symbol("entry"), ENTRYOPT = Symbol("entryOpt"), WRITEENTRYCLASS = Symbol("writeEntryClass"), WRITE = Symbol("write"), ONDRAIN = Symbol("ondrain"), fs2 = require$$0__default$1.default, path2 = require$$0__default.default, warner = requireWarnMixin(), normPath = requireNormalizeWindowsPath(), Pack = warner(class extends Minipass2 {
    constructor(opt) {
      if (super(opt), opt = opt || /* @__PURE__ */ Object.create(null), this.opt = opt, this.file = opt.file || "", this.cwd = opt.cwd || process.cwd(), this.maxReadSize = opt.maxReadSize, this.preservePaths = !!opt.preservePaths, this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.prefix = normPath(opt.prefix || ""), this.linkCache = opt.linkCache || /* @__PURE__ */ new Map(), this.statCache = opt.statCache || /* @__PURE__ */ new Map(), this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map(), this[WRITEENTRYCLASS] = WriteEntry, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn), this.portable = !!opt.portable, this.zip = null, opt.gzip || opt.brotli) {
        if (opt.gzip && opt.brotli)
          throw new TypeError("gzip and brotli are mutually exclusive");
        opt.gzip && (typeof opt.gzip != "object" && (opt.gzip = {}), this.portable && (opt.gzip.portable = !0), this.zip = new zlib.Gzip(opt.gzip)), opt.brotli && (typeof opt.brotli != "object" && (opt.brotli = {}), this.zip = new zlib.BrotliCompress(opt.brotli)), this.zip.on("data", (chunk) => super.write(chunk)), this.zip.on("end", (_) => super.end()), this.zip.on("drain", (_) => this[ONDRAIN]()), this.on("resume", (_) => this.zip.resume());
      } else
        this.on("drain", this[ONDRAIN]);
      this.noDirRecurse = !!opt.noDirRecurse, this.follow = !!opt.follow, this.noMtime = !!opt.noMtime, this.mtime = opt.mtime || null, this.filter = typeof opt.filter == "function" ? opt.filter : (_) => !0, this[QUEUE] = new Yallist(), this[JOBS] = 0, this.jobs = +opt.jobs || 4, this[PROCESSING] = !1, this[ENDED] = !1;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path3) {
      return this.write(path3), this;
    }
    end(path3) {
      return path3 && this.write(path3), this[ENDED] = !0, this[PROCESS2](), this;
    }
    write(path3) {
      if (this[ENDED])
        throw new Error("write after end");
      return path3 instanceof ReadEntry ? this[ADDTARENTRY](path3) : this[ADDFSENTRY](path3), this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = normPath(path2.resolve(this.cwd, p.path));
      if (!this.filter(p.path, p))
        p.resume();
      else {
        const job = new PackJob(p.path, absolute, !1);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job)), job.entry.on("end", (_) => this[JOBDONE](job)), this[JOBS] += 1, this[QUEUE].push(job);
      }
      this[PROCESS2]();
    }
    [ADDFSENTRY](p) {
      const absolute = normPath(path2.resolve(this.cwd, p));
      this[QUEUE].push(new PackJob(p, absolute)), this[PROCESS2]();
    }
    [STAT](job) {
      job.pending = !0, this[JOBS] += 1;
      const stat2 = this.follow ? "stat" : "lstat";
      fs2[stat2](job.absolute, (er, stat3) => {
        job.pending = !1, this[JOBS] -= 1, er ? this.emit("error", er) : this[ONSTAT](job, stat3);
      });
    }
    [ONSTAT](job, stat2) {
      this.statCache.set(job.absolute, stat2), job.stat = stat2, this.filter(job.path, stat2) || (job.ignore = !0), this[PROCESS2]();
    }
    [READDIR](job) {
      job.pending = !0, this[JOBS] += 1, fs2.readdir(job.absolute, (er, entries) => {
        if (job.pending = !1, this[JOBS] -= 1, er)
          return this.emit("error", er);
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries), job.readdir = entries, this[PROCESS2]();
    }
    [PROCESS2]() {
      if (!this[PROCESSING]) {
        this[PROCESSING] = !0;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next)
          if (this[PROCESSJOB](w.value), w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w), w.next = p;
          }
        this[PROCESSING] = !1, this[ENDED] && !this[QUEUE].length && this[JOBS] === 0 && (this.zip ? this.zip.end(EOF2) : (super.write(EOF2), super.end()));
      }
    }
    get [CURRENT]() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](job) {
      this[QUEUE].shift(), this[JOBS] -= 1, this[PROCESS2]();
    }
    [PROCESSJOB](job) {
      if (!job.pending) {
        if (job.entry) {
          job === this[CURRENT] && !job.piped && this[PIPE](job);
          return;
        }
        if (job.stat || (this.statCache.has(job.absolute) ? this[ONSTAT](job, this.statCache.get(job.absolute)) : this[STAT](job)), !!job.stat && !job.ignore && !(!this.noDirRecurse && job.stat.isDirectory() && !job.readdir && (this.readdirCache.has(job.absolute) ? this[ONREADDIR](job, this.readdirCache.get(job.absolute)) : this[READDIR](job), !job.readdir))) {
          if (job.entry = this[ENTRY](job), !job.entry) {
            job.ignore = !0;
            return;
          }
          job === this[CURRENT] && !job.piped && this[PIPE](job);
        }
      }
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN]() {
      this[CURRENT] && this[CURRENT].entry && this[CURRENT].entry.resume();
    }
    // like .pipe() but using super, because our write() is special
    [PIPE](job) {
      job.piped = !0, job.readdir && job.readdir.forEach((entry) => {
        const p = job.path, base2 = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base2 + entry);
      });
      const source2 = job.entry, zip2 = this.zip;
      zip2 ? source2.on("data", (chunk) => {
        zip2.write(chunk) || source2.pause();
      }) : source2.on("data", (chunk) => {
        super.write(chunk) || source2.pause();
      });
    }
    pause() {
      return this.zip && this.zip.pause(), super.pause();
    }
  });
  class PackSync extends Pack {
    constructor(opt) {
      super(opt), this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    // pause/resume are no-ops in sync streams.
    pause() {
    }
    resume() {
    }
    [STAT](job) {
      const stat2 = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs2[stat2](job.absolute));
    }
    [READDIR](job, stat2) {
      this[ONREADDIR](job, fs2.readdirSync(job.absolute));
    }
    // gotta get it all in this tick
    [PIPE](job) {
      const source2 = job.entry, zip2 = this.zip;
      job.readdir && job.readdir.forEach((entry) => {
        const p = job.path, base2 = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base2 + entry);
      }), zip2 ? source2.on("data", (chunk) => {
        zip2.write(chunk);
      }) : source2.on("data", (chunk) => {
        super[WRITE](chunk);
      });
    }
  }
  return Pack.Sync = PackSync, pack = Pack, pack;
}
var fsMinipass = {}, hasRequiredFsMinipass;
function requireFsMinipass() {
  if (hasRequiredFsMinipass) return fsMinipass;
  hasRequiredFsMinipass = 1;
  const MiniPass = requireMinipass(), EE = require$$0__default$7.default.EventEmitter, fs2 = require$$0__default$1.default;
  let writev = fs2.writev;
  if (!writev) {
    const binding = process.binding("fs"), FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos2, cb) => {
      const done = (er, bw) => cb(er, bw, iovec), req = new FSReqWrap();
      req.oncomplete = done, binding.writeBuffers(fd, iovec, pos2, req);
    };
  }
  const _autoClose = Symbol("_autoClose"), _close = Symbol("_close"), _ended = Symbol("_ended"), _fd = Symbol("_fd"), _finished = Symbol("_finished"), _flags = Symbol("_flags"), _flush = Symbol("_flush"), _handleChunk = Symbol("_handleChunk"), _makeBuf = Symbol("_makeBuf"), _mode = Symbol("_mode"), _needDrain = Symbol("_needDrain"), _onerror = Symbol("_onerror"), _onopen = Symbol("_onopen"), _onread = Symbol("_onread"), _onwrite = Symbol("_onwrite"), _open = Symbol("_open"), _path = Symbol("_path"), _pos = Symbol("_pos"), _queue = Symbol("_queue"), _read = Symbol("_read"), _readSize = Symbol("_readSize"), _reading = Symbol("_reading"), _remain = Symbol("_remain"), _size = Symbol("_size"), _write = Symbol("_write"), _writing = Symbol("_writing"), _defaultFlag = Symbol("_defaultFlag"), _errored = Symbol("_errored");
  class ReadStream extends MiniPass {
    constructor(path2, opt) {
      if (opt = opt || {}, super(opt), this.readable = !0, this.writable = !1, typeof path2 != "string")
        throw new TypeError("path must be a string");
      this[_errored] = !1, this[_fd] = typeof opt.fd == "number" ? opt.fd : null, this[_path] = path2, this[_readSize] = opt.readSize || 16 * 1024 * 1024, this[_reading] = !1, this[_size] = typeof opt.size == "number" ? opt.size : 1 / 0, this[_remain] = this[_size], this[_autoClose] = typeof opt.autoClose == "boolean" ? opt.autoClose : !0, typeof this[_fd] == "number" ? this[_read]() : this[_open]();
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_read]());
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = !0;
        const buf = this[_makeBuf]();
        if (buf.length === 0)
          return process.nextTick(() => this[_onread](null, 0, buf));
        fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = !1, er ? this[_onerror](er) : this[_handleChunk](br, buf) && this[_read]();
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = !0, this[_close](), this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = !1;
      return this[_remain] -= br, br > 0 && (ret = super.write(br < buf.length ? buf.slice(0, br) : buf)), (br === 0 || this[_remain] <= 0) && (ret = !1, this[_close](), super.end()), ret;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          typeof this[_fd] == "number" && this[_read]();
          break;
        case "error":
          return this[_errored] ? void 0 : (this[_errored] = !0, super.emit(ev, data));
        default:
          return super.emit(ev, data);
      }
    }
  }
  class ReadStreamSync extends ReadStream {
    [_open]() {
      let threw = !0;
      try {
        this[_onopen](null, fs2.openSync(this[_path], "r")), threw = !1;
      } finally {
        threw && this[_close]();
      }
    }
    [_read]() {
      let threw = !0;
      try {
        if (!this[_reading]) {
          this[_reading] = !0;
          do {
            const buf = this[_makeBuf](), br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf))
              break;
          } while (!0);
          this[_reading] = !1;
        }
        threw = !1;
      } finally {
        threw && this[_close]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.closeSync(fd), this.emit("close");
      }
    }
  }
  class WriteStream extends EE {
    constructor(path2, opt) {
      opt = opt || {}, super(opt), this.readable = !1, this.writable = !0, this[_errored] = !1, this[_writing] = !1, this[_ended] = !1, this[_needDrain] = !1, this[_queue] = [], this[_path] = path2, this[_fd] = typeof opt.fd == "number" ? opt.fd : null, this[_mode] = opt.mode === void 0 ? 438 : opt.mode, this[_pos] = typeof opt.start == "number" ? opt.start : null, this[_autoClose] = typeof opt.autoClose == "boolean" ? opt.autoClose : !0;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === void 0, this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags, this[_fd] === null && this[_open]();
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored])
          return;
        this[_errored] = !0;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close](), this[_writing] = !0, this.emit("error", er);
    }
    [_open]() {
      fs2.open(
        this[_path],
        this[_flags],
        this[_mode],
        (er, fd) => this[_onopen](er, fd)
      );
    }
    [_onopen](er, fd) {
      this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT" ? (this[_flags] = "w", this[_open]()) : er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_flush]());
    }
    end(buf, enc) {
      return buf && this.write(buf, enc), this[_ended] = !0, !this[_writing] && !this[_queue].length && typeof this[_fd] == "number" && this[_onwrite](null, 0), this;
    }
    write(buf, enc) {
      return typeof buf == "string" && (buf = Buffer.from(buf, enc)), this[_ended] ? (this.emit("error", new Error("write() after end()")), !1) : this[_fd] === null || this[_writing] || this[_queue].length ? (this[_queue].push(buf), this[_needDrain] = !0, !1) : (this[_writing] = !0, this[_write](buf), !0);
    }
    [_write](buf) {
      fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      er ? this[_onerror](er) : (this[_pos] !== null && (this[_pos] += bw), this[_queue].length ? this[_flush]() : (this[_writing] = !1, this[_ended] && !this[_finished] ? (this[_finished] = !0, this[_close](), this.emit("finish")) : this[_needDrain] && (this[_needDrain] = !1, this.emit("drain"))));
    }
    [_flush]() {
      if (this[_queue].length === 0)
        this[_ended] && this[_onwrite](null, 0);
      else if (this[_queue].length === 1)
        this[_write](this[_queue].pop());
      else {
        const iovec = this[_queue];
        this[_queue] = [], writev(
          this[_fd],
          iovec,
          this[_pos],
          (er, bw) => this[_onwrite](er, bw)
        );
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  }
  class WriteStreamSync extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+")
        try {
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT")
            return this[_flags] = "w", this[_open]();
          throw er;
        }
      else
        fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.closeSync(fd), this.emit("close");
      }
    }
    [_write](buf) {
      let threw = !0;
      try {
        this[_onwrite](
          null,
          fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
        ), threw = !1;
      } finally {
        if (threw)
          try {
            this[_close]();
          } catch {
          }
      }
    }
  }
  return fsMinipass.ReadStream = ReadStream, fsMinipass.ReadStreamSync = ReadStreamSync, fsMinipass.WriteStream = WriteStream, fsMinipass.WriteStreamSync = WriteStreamSync, fsMinipass;
}
var parse, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  const warner = requireWarnMixin(), Header = requireHeader(), EE = require$$0__default$7.default, Yallist = requireYallist(), maxMetaEntrySize = 1024 * 1024, Entry = requireReadEntry(), Pax = requirePax(), zlib = requireMinizlib(), { nextTick } = require$$7__default.default, gzipHeader = Buffer.from([31, 139]), STATE = Symbol("state"), WRITEENTRY = Symbol("writeEntry"), READENTRY = Symbol("readEntry"), NEXTENTRY = Symbol("nextEntry"), PROCESSENTRY = Symbol("processEntry"), EX = Symbol("extendedHeader"), GEX = Symbol("globalExtendedHeader"), META = Symbol("meta"), EMITMETA = Symbol("emitMeta"), BUFFER2 = Symbol("buffer"), QUEUE = Symbol("queue"), ENDED = Symbol("ended"), EMITTEDEND = Symbol("emittedEnd"), EMIT = Symbol("emit"), UNZIP = Symbol("unzip"), CONSUMECHUNK = Symbol("consumeChunk"), CONSUMECHUNKSUB = Symbol("consumeChunkSub"), CONSUMEBODY = Symbol("consumeBody"), CONSUMEMETA = Symbol("consumeMeta"), CONSUMEHEADER = Symbol("consumeHeader"), CONSUMING = Symbol("consuming"), BUFFERCONCAT = Symbol("bufferConcat"), MAYBEEND = Symbol("maybeEnd"), WRITING = Symbol("writing"), ABORTED2 = Symbol("aborted"), DONE = Symbol("onDone"), SAW_VALID_ENTRY = Symbol("sawValidEntry"), SAW_NULL_BLOCK = Symbol("sawNullBlock"), SAW_EOF = Symbol("sawEOF"), CLOSESTREAM = Symbol("closeStream"), noop2 = (_) => !0;
  return parse = warner(class extends EE {
    constructor(opt) {
      opt = opt || {}, super(opt), this.file = opt.file || "", this[SAW_VALID_ENTRY] = null, this.on(DONE, (_) => {
        (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === !1) && this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
      }), opt.ondone ? this.on(DONE, opt.ondone) : this.on(DONE, (_) => {
        this.emit("prefinish"), this.emit("finish"), this.emit("end");
      }), this.strict = !!opt.strict, this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize, this.filter = typeof opt.filter == "function" ? opt.filter : noop2;
      const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
      this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : !1, this.writable = !0, this.readable = !1, this[QUEUE] = new Yallist(), this[BUFFER2] = null, this[READENTRY] = null, this[WRITEENTRY] = null, this[STATE] = "begin", this[META] = "", this[EX] = null, this[GEX] = null, this[ENDED] = !1, this[UNZIP] = null, this[ABORTED2] = !1, this[SAW_NULL_BLOCK] = !1, this[SAW_EOF] = !1, this.on("end", () => this[CLOSESTREAM]()), typeof opt.onwarn == "function" && this.on("warn", opt.onwarn), typeof opt.onentry == "function" && this.on("entry", opt.onentry);
    }
    [CONSUMEHEADER](chunk, position) {
      this[SAW_VALID_ENTRY] === null && (this[SAW_VALID_ENTRY] = !1);
      let header2;
      try {
        header2 = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header2.nullBlock)
        this[SAW_NULL_BLOCK] ? (this[SAW_EOF] = !0, this[STATE] === "begin" && (this[STATE] = "header"), this[EMIT]("eof")) : (this[SAW_NULL_BLOCK] = !0, this[EMIT]("nullBlock"));
      else if (this[SAW_NULL_BLOCK] = !1, !header2.cksumValid)
        this.warn("TAR_ENTRY_INVALID", "checksum failure", { header: header2 });
      else if (!header2.path)
        this.warn("TAR_ENTRY_INVALID", "path is required", { header: header2 });
      else {
        const type2 = header2.type;
        if (/^(Symbolic)?Link$/.test(type2) && !header2.linkpath)
          this.warn("TAR_ENTRY_INVALID", "linkpath required", { header: header2 });
        else if (!/^(Symbolic)?Link$/.test(type2) && header2.linkpath)
          this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header: header2 });
        else {
          const entry = this[WRITEENTRY] = new Entry(header2, this[EX], this[GEX]);
          if (!this[SAW_VALID_ENTRY])
            if (entry.remain) {
              const onend = () => {
                entry.invalid || (this[SAW_VALID_ENTRY] = !0);
              };
              entry.on("end", onend);
            } else
              this[SAW_VALID_ENTRY] = !0;
          entry.meta ? entry.size > this.maxMetaEntrySize ? (entry.ignore = !0, this[EMIT]("ignoredEntry", entry), this[STATE] = "ignore", entry.resume()) : entry.size > 0 && (this[META] = "", entry.on("data", (c2) => this[META] += c2), this[STATE] = "meta") : (this[EX] = null, entry.ignore = entry.ignore || !this.filter(entry.path, entry), entry.ignore ? (this[EMIT]("ignoredEntry", entry), this[STATE] = entry.remain ? "ignore" : "header", entry.resume()) : (entry.remain ? this[STATE] = "body" : (this[STATE] = "header", entry.end()), this[READENTRY] ? this[QUEUE].push(entry) : (this[QUEUE].push(entry), this[NEXTENTRY]())));
        }
      }
    }
    [CLOSESTREAM]() {
      nextTick(() => this.emit("close"));
    }
    [PROCESSENTRY](entry) {
      let go = !0;
      return entry ? Array.isArray(entry) ? this.emit.apply(this, entry) : (this[READENTRY] = entry, this.emit("entry", entry), entry.emittedEnd || (entry.on("end", (_) => this[NEXTENTRY]()), go = !1)) : (this[READENTRY] = null, go = !1), go;
    }
    [NEXTENTRY]() {
      do
        ;
      while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        !re || re.flowing || re.size === re.remain ? this[WRITING] || this.emit("drain") : re.once("drain", (_) => this.emit("drain"));
      }
    }
    [CONSUMEBODY](chunk, position) {
      const entry = this[WRITEENTRY], br = entry.blockRemain, c2 = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
      return entry.write(c2), entry.blockRemain || (this[STATE] = "header", this[WRITEENTRY] = null, entry.end()), c2.length;
    }
    [CONSUMEMETA](chunk, position) {
      const entry = this[WRITEENTRY], ret = this[CONSUMEBODY](chunk, position);
      return this[WRITEENTRY] || this[EMITMETA](entry), ret;
    }
    [EMIT](ev, data, extra) {
      !this[QUEUE].length && !this[READENTRY] ? this.emit(ev, data, extra) : this[QUEUE].push([ev, data, extra]);
    }
    [EMITMETA](entry) {
      switch (this[EMIT]("meta", this[META]), entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], !1);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], !0);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || /* @__PURE__ */ Object.create(null), this[EX].path = this[META].replace(/\0.*/, "");
          break;
        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || /* @__PURE__ */ Object.create(null), this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;
        /* istanbul ignore next */
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error2) {
      this[ABORTED2] = !0, this.emit("abort", error2), this.warn("TAR_ABORT", error2, { recoverable: !1 });
    }
    write(chunk) {
      if (this[ABORTED2])
        return;
      if ((this[UNZIP] === null || this.brotli === void 0 && this[UNZIP] === !1) && chunk) {
        if (this[BUFFER2] && (chunk = Buffer.concat([this[BUFFER2], chunk]), this[BUFFER2] = null), chunk.length < gzipHeader.length)
          return this[BUFFER2] = chunk, !0;
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++)
          chunk[i] !== gzipHeader[i] && (this[UNZIP] = !1);
        const maybeBrotli = this.brotli === void 0;
        if (this[UNZIP] === !1 && maybeBrotli)
          if (chunk.length < 512)
            if (this[ENDED])
              this.brotli = !0;
            else
              return this[BUFFER2] = chunk, !0;
          else
            try {
              new Header(chunk.slice(0, 512)), this.brotli = !1;
            } catch {
              this.brotli = !0;
            }
        if (this[UNZIP] === null || this[UNZIP] === !1 && this.brotli) {
          const ended = this[ENDED];
          this[ENDED] = !1, this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress(), this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2)), this[UNZIP].on("error", (er) => this.abort(er)), this[UNZIP].on("end", (_) => {
            this[ENDED] = !0, this[CONSUMECHUNK]();
          }), this[WRITING] = !0;
          const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
          return this[WRITING] = !1, ret2;
        }
      }
      this[WRITING] = !0, this[UNZIP] ? this[UNZIP].write(chunk) : this[CONSUMECHUNK](chunk), this[WRITING] = !1;
      const ret = this[QUEUE].length ? !1 : this[READENTRY] ? this[READENTRY].flowing : !0;
      return !ret && !this[QUEUE].length && this[READENTRY].once("drain", (_) => this.emit("drain")), ret;
    }
    [BUFFERCONCAT](c2) {
      c2 && !this[ABORTED2] && (this[BUFFER2] = this[BUFFER2] ? Buffer.concat([this[BUFFER2], c2]) : c2);
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED2] && !this[CONSUMING]) {
        this[EMITTEDEND] = !0;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER2] ? this[BUFFER2].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry }), this[BUFFER2] && entry.write(this[BUFFER2]), entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING])
        this[BUFFERCONCAT](chunk);
      else if (!chunk && !this[BUFFER2])
        this[MAYBEEND]();
      else {
        if (this[CONSUMING] = !0, this[BUFFER2]) {
          this[BUFFERCONCAT](chunk);
          const c2 = this[BUFFER2];
          this[BUFFER2] = null, this[CONSUMECHUNKSUB](c2);
        } else
          this[CONSUMECHUNKSUB](chunk);
        for (; this[BUFFER2] && this[BUFFER2].length >= 512 && !this[ABORTED2] && !this[SAW_EOF]; ) {
          const c2 = this[BUFFER2];
          this[BUFFER2] = null, this[CONSUMECHUNKSUB](c2);
        }
        this[CONSUMING] = !1;
      }
      (!this[BUFFER2] || this[ENDED]) && this[MAYBEEND]();
    }
    [CONSUMECHUNKSUB](chunk) {
      let position = 0;
      const length = chunk.length;
      for (; position + 512 <= length && !this[ABORTED2] && !this[SAW_EOF]; )
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position), position += 512;
            break;
          case "ignore":
          case "body":
            position += this[CONSUMEBODY](chunk, position);
            break;
          case "meta":
            position += this[CONSUMEMETA](chunk, position);
            break;
          /* istanbul ignore next */
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      position < length && (this[BUFFER2] ? this[BUFFER2] = Buffer.concat([chunk.slice(position), this[BUFFER2]]) : this[BUFFER2] = chunk.slice(position));
    }
    end(chunk) {
      this[ABORTED2] || (this[UNZIP] ? this[UNZIP].end(chunk) : (this[ENDED] = !0, this.brotli === void 0 && (chunk = chunk || Buffer.alloc(0)), this.write(chunk)));
    }
  }), parse;
}
var list_1, hasRequiredList$1;
function requireList$1() {
  if (hasRequiredList$1) return list_1;
  hasRequiredList$1 = 1;
  const hlo = requireHighLevelOpt(), Parser = requireParse(), fs2 = require$$0__default$1.default, fsm = requireFsMinipass(), path2 = require$$0__default.default, stripSlash = requireStripTrailingSlashes();
  list_1 = (opt_, files, cb) => {
    typeof opt_ == "function" ? (cb = opt_, files = null, opt_ = {}) : Array.isArray(opt_) && (files = opt_, opt_ = {}), typeof files == "function" && (cb = files, files = null), files ? files = Array.from(files) : files = [];
    const opt = hlo(opt_);
    if (opt.sync && typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return files.length && filesFilter(opt, files), opt.noResume || onentryFunction(opt), opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
  };
  const onentryFunction = (opt) => {
    const onentry = opt.onentry;
    opt.onentry = onentry ? (e) => {
      onentry(e), e.resume();
    } : (e) => e.resume();
  }, filesFilter = (opt, files) => {
    const map2 = new Map(files.map((f) => [stripSlash(f), !0])), filter2 = opt.filter, mapHas = (file, r) => {
      const root2 = r || path2.parse(file).root || ".", ret = file === root2 ? !1 : map2.has(file) ? map2.get(file) : mapHas(path2.dirname(file), root2);
      return map2.set(file, ret), ret;
    };
    opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  }, listFileSync = (opt) => {
    const p = list2(opt), file = opt.file;
    let threw = !0, fd;
    try {
      const stat2 = fs2.statSync(file), readSize = opt.maxReadSize || 16 * 1024 * 1024;
      if (stat2.size < readSize)
        p.end(fs2.readFileSync(file));
      else {
        let pos2 = 0;
        const buf = Buffer.allocUnsafe(readSize);
        for (fd = fs2.openSync(file, "r"); pos2 < stat2.size; ) {
          const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos2);
          pos2 += bytesRead, p.write(buf.slice(0, bytesRead));
        }
        p.end();
      }
      threw = !1;
    } finally {
      if (threw && fd)
        try {
          fs2.closeSync(fd);
        } catch {
        }
    }
  }, listFile = (opt, cb) => {
    const parse3 = new Parser(opt), readSize = opt.maxReadSize || 16 * 1024 * 1024, file = opt.file, p = new Promise((resolve, reject) => {
      parse3.on("error", reject), parse3.on("end", resolve), fs2.stat(file, (er, stat2) => {
        if (er)
          reject(er);
        else {
          const stream2 = new fsm.ReadStream(file, {
            readSize,
            size: stat2.size
          });
          stream2.on("error", reject), stream2.pipe(parse3);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  }, list2 = (opt) => new Parser(opt);
  return list_1;
}
var create_1, hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate) return create_1;
  hasRequiredCreate = 1;
  const hlo = requireHighLevelOpt(), Pack = requirePack(), fsm = requireFsMinipass(), t = requireList$1(), path2 = require$$0__default.default;
  create_1 = (opt_, files, cb) => {
    if (typeof files == "function" && (cb = files), Array.isArray(opt_) && (files = opt_, opt_ = {}), !files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
  };
  const createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt), stream2 = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream2), addFilesSync(p, files);
  }, createFile = (opt, files, cb) => {
    const p = new Pack(opt), stream2 = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream2);
    const promise2 = new Promise((res, rej) => {
      stream2.on("error", rej), stream2.on("close", res), p.on("error", rej);
    });
    return addFilesAsync(p, files), cb ? promise2.then(cb, cb) : promise2;
  }, addFilesSync = (p, files) => {
    files.forEach((file) => {
      file.charAt(0) === "@" ? t({
        file: path2.resolve(p.cwd, file.slice(1)),
        sync: !0,
        noResume: !0,
        onentry: (entry) => p.add(entry)
      }) : p.add(file);
    }), p.end();
  }, addFilesAsync = (p, files) => {
    for (; files.length; ) {
      const file = files.shift();
      if (file.charAt(0) === "@")
        return t({
          file: path2.resolve(p.cwd, file.slice(1)),
          noResume: !0,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      p.add(file);
    }
    p.end();
  }, createSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    return addFilesSync(p, files), p;
  }, create = (opt, files) => {
    const p = new Pack(opt);
    return addFilesAsync(p, files), p;
  };
  return create_1;
}
var replace_1, hasRequiredReplace;
function requireReplace() {
  if (hasRequiredReplace) return replace_1;
  hasRequiredReplace = 1;
  const hlo = requireHighLevelOpt(), Pack = requirePack(), fs2 = require$$0__default$1.default, fsm = requireFsMinipass(), t = requireList$1(), path2 = require$$0__default.default, Header = requireHeader();
  replace_1 = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr"))
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    return files = Array.from(files), opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
  };
  const replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    let threw = !0, fd, position;
    try {
      try {
        fd = fs2.openSync(opt.file, "r+");
      } catch (er) {
        if (er.code === "ENOENT")
          fd = fs2.openSync(opt.file, "w+");
        else
          throw er;
      }
      const st = fs2.fstatSync(fd), headBuf = Buffer.alloc(512);
      POSITION: for (position = 0; position < st.size; position += 512) {
        for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
          if (bytes = fs2.readSync(
            fd,
            headBuf,
            bufPos,
            headBuf.length - bufPos,
            position + bufPos
          ), position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            throw new Error("cannot append to compressed archives");
          if (!bytes)
            break POSITION;
        }
        const h = new Header(headBuf);
        if (!h.cksumValid)
          break;
        const entryBlockSize = 512 * Math.ceil(h.size / 512);
        if (position + entryBlockSize + 512 > st.size)
          break;
        position += entryBlockSize, opt.mtimeCache && opt.mtimeCache.set(h.path, h.mtime);
      }
      threw = !1, streamSync2(opt, p, position, fd, files);
    } finally {
      if (threw)
        try {
          fs2.closeSync(fd);
        } catch {
        }
    }
  }, streamSync2 = (opt, p, position, fd, files) => {
    const stream2 = new fsm.WriteStreamSync(opt.file, {
      fd,
      start: position
    });
    p.pipe(stream2), addFilesSync(p, files);
  }, replace = (opt, files, cb) => {
    files = Array.from(files);
    const p = new Pack(opt), getPos = (fd, size, cb_) => {
      const cb2 = (er, pos2) => {
        er ? fs2.close(fd, (_) => cb_(er)) : cb_(null, pos2);
      };
      let position = 0;
      if (size === 0)
        return cb2(null, 0);
      let bufPos = 0;
      const headBuf = Buffer.alloc(512), onread = (er, bytes) => {
        if (er)
          return cb2(er);
        if (bufPos += bytes, bufPos < 512 && bytes)
          return fs2.read(
            fd,
            headBuf,
            bufPos,
            headBuf.length - bufPos,
            position + bufPos,
            onread
          );
        if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
          return cb2(new Error("cannot append to compressed archives"));
        if (bufPos < 512)
          return cb2(null, position);
        const h = new Header(headBuf);
        if (!h.cksumValid)
          return cb2(null, position);
        const entryBlockSize = 512 * Math.ceil(h.size / 512);
        if (position + entryBlockSize + 512 > size || (position += entryBlockSize + 512, position >= size))
          return cb2(null, position);
        opt.mtimeCache && opt.mtimeCache.set(h.path, h.mtime), bufPos = 0, fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      fs2.read(fd, headBuf, 0, 512, position, onread);
    }, promise2 = new Promise((resolve, reject) => {
      p.on("error", reject);
      let flag = "r+";
      const onopen = (er, fd) => {
        if (er && er.code === "ENOENT" && flag === "r+")
          return flag = "w+", fs2.open(opt.file, flag, onopen);
        if (er)
          return reject(er);
        fs2.fstat(fd, (er2, st) => {
          if (er2)
            return fs2.close(fd, () => reject(er2));
          getPos(fd, st.size, (er3, position) => {
            if (er3)
              return reject(er3);
            const stream2 = new fsm.WriteStream(opt.file, {
              fd,
              start: position
            });
            p.pipe(stream2), stream2.on("error", reject), stream2.on("close", resolve), addFilesAsync(p, files);
          });
        });
      };
      fs2.open(opt.file, flag, onopen);
    });
    return cb ? promise2.then(cb, cb) : promise2;
  }, addFilesSync = (p, files) => {
    files.forEach((file) => {
      file.charAt(0) === "@" ? t({
        file: path2.resolve(p.cwd, file.slice(1)),
        sync: !0,
        noResume: !0,
        onentry: (entry) => p.add(entry)
      }) : p.add(file);
    }), p.end();
  }, addFilesAsync = (p, files) => {
    for (; files.length; ) {
      const file = files.shift();
      if (file.charAt(0) === "@")
        return t({
          file: path2.resolve(p.cwd, file.slice(1)),
          noResume: !0,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      p.add(file);
    }
    p.end();
  };
  return replace_1;
}
var update, hasRequiredUpdate;
function requireUpdate() {
  if (hasRequiredUpdate) return update;
  hasRequiredUpdate = 1;
  const hlo = requireHighLevelOpt(), r = requireReplace();
  update = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr"))
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    return files = Array.from(files), mtimeFilter(opt), r(opt, files, cb);
  };
  const mtimeFilter = (opt) => {
    const filter2 = opt.filter;
    opt.mtimeCache || (opt.mtimeCache = /* @__PURE__ */ new Map()), opt.filter = filter2 ? (path2, stat2) => filter2(path2, stat2) && !(opt.mtimeCache.get(path2) > stat2.mtime) : (path2, stat2) => !(opt.mtimeCache.get(path2) > stat2.mtime);
  };
  return update;
}
var mkdir$1 = { exports: {} }, optsArg_1, hasRequiredOptsArg;
function requireOptsArg() {
  if (hasRequiredOptsArg) return optsArg_1;
  hasRequiredOptsArg = 1;
  const { promisify } = require$$0__default$6.default, fs2 = require$$0__default$1.default;
  return optsArg_1 = (opts) => {
    if (!opts)
      opts = { mode: 511, fs: fs2 };
    else if (typeof opts == "object")
      opts = { mode: 511, fs: fs2, ...opts };
    else if (typeof opts == "number")
      opts = { mode: opts, fs: fs2 };
    else if (typeof opts == "string")
      opts = { mode: parseInt(opts, 8), fs: fs2 };
    else
      throw new TypeError("invalid options argument");
    return opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir, opts.mkdirAsync = promisify(opts.mkdir), opts.stat = opts.stat || opts.fs.stat || fs2.stat, opts.statAsync = promisify(opts.stat), opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync, opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync, opts;
  }, optsArg_1;
}
var pathArg_1, hasRequiredPathArg;
function requirePathArg() {
  if (hasRequiredPathArg) return pathArg_1;
  hasRequiredPathArg = 1;
  const platform2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform, { resolve, parse: parse3 } = require$$0__default.default;
  return pathArg_1 = (path2) => {
    if (/\0/.test(path2))
      throw Object.assign(
        new TypeError("path must be a string without null bytes"),
        {
          path: path2,
          code: "ERR_INVALID_ARG_VALUE"
        }
      );
    if (path2 = resolve(path2), platform2 === "win32") {
      const badWinChars = /[*|"<>?:]/, { root: root2 } = parse3(path2);
      if (badWinChars.test(path2.substr(root2.length)))
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path2,
          code: "EINVAL"
        });
    }
    return path2;
  }, pathArg_1;
}
var findMade_1, hasRequiredFindMade;
function requireFindMade() {
  if (hasRequiredFindMade) return findMade_1;
  hasRequiredFindMade = 1;
  const { dirname } = require$$0__default.default, findMade = (opts, parent, path2 = void 0) => path2 === parent ? Promise.resolve() : opts.statAsync(parent).then(
    (st) => st.isDirectory() ? path2 : void 0,
    // will fail later
    (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0
  ), findMadeSync = (opts, parent, path2 = void 0) => {
    if (path2 !== parent)
      try {
        return opts.statSync(parent).isDirectory() ? path2 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
      }
  };
  return findMade_1 = { findMade, findMadeSync }, findMade_1;
}
var mkdirpManual_1, hasRequiredMkdirpManual;
function requireMkdirpManual() {
  if (hasRequiredMkdirpManual) return mkdirpManual_1;
  hasRequiredMkdirpManual = 1;
  const { dirname } = require$$0__default.default, mkdirpManual = (path2, opts, made) => {
    opts.recursive = !1;
    const parent = dirname(path2);
    return parent === path2 ? opts.mkdirAsync(path2, opts).catch((er) => {
      if (er.code !== "EISDIR")
        throw er;
    }) : opts.mkdirAsync(path2, opts).then(() => made || path2, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path2, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path2).then((st) => {
        if (st.isDirectory())
          return made;
        throw er;
      }, () => {
        throw er;
      });
    });
  }, mkdirpManualSync = (path2, opts, made) => {
    const parent = dirname(path2);
    if (opts.recursive = !1, parent === path2)
      try {
        return opts.mkdirSync(path2, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        return;
      }
    try {
      return opts.mkdirSync(path2, opts), made || path2;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path2, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path2).isDirectory())
          throw er;
      } catch {
        throw er;
      }
    }
  };
  return mkdirpManual_1 = { mkdirpManual, mkdirpManualSync }, mkdirpManual_1;
}
var mkdirpNative_1, hasRequiredMkdirpNative;
function requireMkdirpNative() {
  if (hasRequiredMkdirpNative) return mkdirpNative_1;
  hasRequiredMkdirpNative = 1;
  const { dirname } = require$$0__default.default, { findMade, findMadeSync } = requireFindMade(), { mkdirpManual, mkdirpManualSync } = requireMkdirpManual();
  return mkdirpNative_1 = { mkdirpNative: (path2, opts) => (opts.recursive = !0, dirname(path2) === path2 ? opts.mkdirAsync(path2, opts) : findMade(opts, path2).then((made) => opts.mkdirAsync(path2, opts).then(() => made).catch((er) => {
    if (er.code === "ENOENT")
      return mkdirpManual(path2, opts);
    throw er;
  }))), mkdirpNativeSync: (path2, opts) => {
    if (opts.recursive = !0, dirname(path2) === path2)
      return opts.mkdirSync(path2, opts);
    const made = findMadeSync(opts, path2);
    try {
      return opts.mkdirSync(path2, opts), made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path2, opts);
      throw er;
    }
  } }, mkdirpNative_1;
}
var useNative_1, hasRequiredUseNative;
function requireUseNative() {
  if (hasRequiredUseNative) return useNative_1;
  hasRequiredUseNative = 1;
  const fs2 = require$$0__default$1.default, versArr2 = (process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version).replace(/^v/, "").split("."), hasNative2 = +versArr2[0] > 10 || +versArr2[0] == 10 && +versArr2[1] >= 12;
  return useNative_1 = { useNative: hasNative2 ? (opts) => opts.mkdir === fs2.mkdir : () => !1, useNativeSync: hasNative2 ? (opts) => opts.mkdirSync === fs2.mkdirSync : () => !1 }, useNative_1;
}
var mkdirp_1, hasRequiredMkdirp;
function requireMkdirp() {
  if (hasRequiredMkdirp) return mkdirp_1;
  hasRequiredMkdirp = 1;
  const optsArg = requireOptsArg(), pathArg2 = requirePathArg(), { mkdirpNative, mkdirpNativeSync } = requireMkdirpNative(), { mkdirpManual, mkdirpManualSync } = requireMkdirpManual(), { useNative: useNative2, useNativeSync: useNativeSync2 } = requireUseNative(), mkdirp = (path2, opts) => (path2 = pathArg2(path2), opts = optsArg(opts), useNative2(opts) ? mkdirpNative(path2, opts) : mkdirpManual(path2, opts)), mkdirpSync = (path2, opts) => (path2 = pathArg2(path2), opts = optsArg(opts), useNativeSync2(opts) ? mkdirpNativeSync(path2, opts) : mkdirpManualSync(path2, opts));
  return mkdirp.sync = mkdirpSync, mkdirp.native = (path2, opts) => mkdirpNative(pathArg2(path2), optsArg(opts)), mkdirp.manual = (path2, opts) => mkdirpManual(pathArg2(path2), optsArg(opts)), mkdirp.nativeSync = (path2, opts) => mkdirpNativeSync(pathArg2(path2), optsArg(opts)), mkdirp.manualSync = (path2, opts) => mkdirpManualSync(pathArg2(path2), optsArg(opts)), mkdirp_1 = mkdirp, mkdirp_1;
}
var chownr_1, hasRequiredChownr;
function requireChownr() {
  if (hasRequiredChownr) return chownr_1;
  hasRequiredChownr = 1;
  const fs2 = require$$0__default$1.default, path2 = require$$0__default.default, LCHOWN = fs2.lchown ? "lchown" : "chown", LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync", needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), lchownSync = (path3, uid, gid) => {
    try {
      return fs2[LCHOWNSYNC](path3, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  }, chownSync = (path3, uid, gid) => {
    try {
      return fs2.chownSync(path3, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  }, handleEISDIR = needEISDIRHandled ? (path3, uid, gid, cb) => (er) => {
    !er || er.code !== "EISDIR" ? cb(er) : fs2.chown(path3, uid, gid, cb);
  } : (_, __, ___, cb) => cb, handleEISDirSync = needEISDIRHandled ? (path3, uid, gid) => {
    try {
      return lchownSync(path3, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path3, uid, gid);
    }
  } : (path3, uid, gid) => lchownSync(path3, uid, gid), nodeVersion = process.version;
  let readdir2 = (path3, options2, cb) => fs2.readdir(path3, options2, cb), readdirSync2 = (path3, options2) => fs2.readdirSync(path3, options2);
  /^v4\./.test(nodeVersion) && (readdir2 = (path3, options2, cb) => fs2.readdir(path3, cb));
  const chown = (cpath, uid, gid, cb) => {
    fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  }, chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child == "string")
      return fs2.lstat(path2.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child, chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory())
      chownr(path2.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path2.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    else {
      const cpath = path2.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  }, chownr = (p, uid, gid, cb) => {
    readdir2(p, { withFileTypes: !0 }, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length, errState = null;
      const then = (er2) => {
        if (!errState) {
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        }
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  }, chownrKidSync = (p, child, uid, gid) => {
    if (typeof child == "string")
      try {
        const stats = fs2.lstatSync(path2.resolve(p, child));
        stats.name = child, child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        throw er;
      }
    child.isDirectory() && chownrSync(path2.resolve(p, child.name), uid, gid), handleEISDirSync(path2.resolve(p, child.name), uid, gid);
  }, chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync2(p, { withFileTypes: !0 });
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      throw er;
    }
    return children && children.length && children.forEach((child) => chownrKidSync(p, child, uid, gid)), handleEISDirSync(p, uid, gid);
  };
  return chownr_1 = chownr, chownr.sync = chownrSync, chownr_1;
}
var hasRequiredMkdir;
function requireMkdir() {
  if (hasRequiredMkdir) return mkdir$1.exports;
  hasRequiredMkdir = 1;
  const mkdirp = requireMkdirp(), fs2 = require$$0__default$1.default, path2 = require$$0__default.default, chownr = requireChownr(), normPath = requireNormalizeWindowsPath();
  class SymlinkError extends Error {
    constructor(symlink, path3) {
      super("Cannot extract through symbolic link"), this.path = path3, this.symlink = symlink;
    }
    get name() {
      return "SylinkError";
    }
  }
  class CwdError extends Error {
    constructor(path3, code) {
      super(code + ": Cannot cd into '" + path3 + "'"), this.path = path3, this.code = code;
    }
    get name() {
      return "CwdError";
    }
  }
  const cGet = (cache, key2) => cache.get(normPath(key2)), cSet = (cache, key2, val) => cache.set(normPath(key2), val), checkCwd = (dir, cb) => {
    fs2.stat(dir, (er, st) => {
      (er || !st.isDirectory()) && (er = new CwdError(dir, er && er.code || "ENOTDIR")), cb(er);
    });
  };
  mkdir$1.exports = (dir, opt, cb) => {
    dir = normPath(dir);
    const umask = opt.umask, mode2 = opt.mode | 448, needChmod = (mode2 & umask) !== 0, uid = opt.uid, gid = opt.gid, doChown = typeof uid == "number" && typeof gid == "number" && (uid !== opt.processUid || gid !== opt.processGid), preserve = opt.preserve, unlink2 = opt.unlink, cache = opt.cache, cwd = normPath(opt.cwd), done = (er, created) => {
      er ? cb(er) : (cSet(cache, dir, !0), created && doChown ? chownr(created, uid, gid, (er2) => done(er2)) : needChmod ? fs2.chmod(dir, mode2, cb) : cb());
    };
    if (cache && cGet(cache, dir) === !0)
      return done();
    if (dir === cwd)
      return checkCwd(dir, done);
    if (preserve)
      return mkdirp(dir, { mode: mode2 }).then((made) => done(null, made), done);
    const parts = normPath(path2.relative(cwd, dir)).split("/");
    mkdir_(cwd, parts, mode2, cache, unlink2, cwd, null, done);
  };
  const mkdir_ = (base2, parts, mode2, cache, unlink2, cwd, created, cb) => {
    if (!parts.length)
      return cb(null, created);
    const p = parts.shift(), part = normPath(path2.resolve(base2 + "/" + p));
    if (cGet(cache, part))
      return mkdir_(part, parts, mode2, cache, unlink2, cwd, created, cb);
    fs2.mkdir(part, mode2, onmkdir(part, parts, mode2, cache, unlink2, cwd, created, cb));
  }, onmkdir = (part, parts, mode2, cache, unlink2, cwd, created, cb) => (er) => {
    er ? fs2.lstat(part, (statEr, st) => {
      if (statEr)
        statEr.path = statEr.path && normPath(statEr.path), cb(statEr);
      else if (st.isDirectory())
        mkdir_(part, parts, mode2, cache, unlink2, cwd, created, cb);
      else if (unlink2)
        fs2.unlink(part, (er2) => {
          if (er2)
            return cb(er2);
          fs2.mkdir(part, mode2, onmkdir(part, parts, mode2, cache, unlink2, cwd, created, cb));
        });
      else {
        if (st.isSymbolicLink())
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        cb(er);
      }
    }) : (created = created || part, mkdir_(part, parts, mode2, cache, unlink2, cwd, created, cb));
  }, checkCwdSync = (dir) => {
    let ok = !1, code = "ENOTDIR";
    try {
      ok = fs2.statSync(dir).isDirectory();
    } catch (er) {
      code = er.code;
    } finally {
      if (!ok)
        throw new CwdError(dir, code);
    }
  };
  return mkdir$1.exports.sync = (dir, opt) => {
    dir = normPath(dir);
    const umask = opt.umask, mode2 = opt.mode | 448, needChmod = (mode2 & umask) !== 0, uid = opt.uid, gid = opt.gid, doChown = typeof uid == "number" && typeof gid == "number" && (uid !== opt.processUid || gid !== opt.processGid), preserve = opt.preserve, unlink2 = opt.unlink, cache = opt.cache, cwd = normPath(opt.cwd), done = (created2) => {
      cSet(cache, dir, !0), created2 && doChown && chownr.sync(created2, uid, gid), needChmod && fs2.chmodSync(dir, mode2);
    };
    if (cache && cGet(cache, dir) === !0)
      return done();
    if (dir === cwd)
      return checkCwdSync(cwd), done();
    if (preserve)
      return done(mkdirp.sync(dir, mode2));
    const parts = normPath(path2.relative(cwd, dir)).split("/");
    let created = null;
    for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift())
      if (part = normPath(path2.resolve(part)), !cGet(cache, part))
        try {
          fs2.mkdirSync(part, mode2), created = created || part, cSet(cache, part, !0);
        } catch {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, !0);
            continue;
          } else if (unlink2) {
            fs2.unlinkSync(part), fs2.mkdirSync(part, mode2), created = created || part, cSet(cache, part, !0);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
    return done(created);
  }, mkdir$1.exports;
}
var normalizeUnicode, hasRequiredNormalizeUnicode;
function requireNormalizeUnicode() {
  if (hasRequiredNormalizeUnicode) return normalizeUnicode;
  hasRequiredNormalizeUnicode = 1;
  const normalizeCache2 = /* @__PURE__ */ Object.create(null), { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  return normalizeUnicode = (s) => (hasOwnProperty2.call(normalizeCache2, s) || (normalizeCache2[s] = s.normalize("NFD")), normalizeCache2[s]), normalizeUnicode;
}
var pathReservations, hasRequiredPathReservations;
function requirePathReservations() {
  if (hasRequiredPathReservations) return pathReservations;
  hasRequiredPathReservations = 1;
  const assert = require$$0__default$5.default, normalize2 = requireNormalizeUnicode(), stripSlashes = requireStripTrailingSlashes(), { join } = require$$0__default.default, isWindows = (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform) === "win32";
  return pathReservations = () => {
    const queues = /* @__PURE__ */ new Map(), reservations = /* @__PURE__ */ new Map(), getDirs = (path2) => path2.split("/").slice(0, -1).reduce((set2, path3) => (set2.length && (path3 = join(set2[set2.length - 1], path3)), set2.push(path3 || "/"), set2), []), running = /* @__PURE__ */ new Set(), getQueues = (fn) => {
      const res = reservations.get(fn);
      if (!res)
        throw new Error("function does not have any path reservations");
      return {
        paths: res.paths.map((path2) => queues.get(path2)),
        dirs: [...res.dirs].map((path2) => queues.get(path2))
      };
    }, check = (fn) => {
      const { paths, dirs } = getQueues(fn);
      return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
    }, run = (fn) => running.has(fn) || !check(fn) ? !1 : (running.add(fn), fn(() => clear(fn)), !0), clear = (fn) => {
      if (!running.has(fn))
        return !1;
      const { paths, dirs } = reservations.get(fn), next = /* @__PURE__ */ new Set();
      return paths.forEach((path2) => {
        const q = queues.get(path2);
        assert.equal(q[0], fn), q.length === 1 ? queues.delete(path2) : (q.shift(), typeof q[0] == "function" ? next.add(q[0]) : q[0].forEach((fn2) => next.add(fn2)));
      }), dirs.forEach((dir) => {
        const q = queues.get(dir);
        assert(q[0] instanceof Set), q[0].size === 1 && q.length === 1 ? queues.delete(dir) : q[0].size === 1 ? (q.shift(), next.add(q[0])) : q[0].delete(fn);
      }), running.delete(fn), next.forEach((fn2) => run(fn2)), !0;
    };
    return { check, reserve: (paths, fn) => {
      paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p) => stripSlashes(join(normalize2(p))).toLowerCase());
      const dirs = new Set(
        paths.map((path2) => getDirs(path2)).reduce((a, b) => a.concat(b))
      );
      return reservations.set(fn, { dirs, paths }), paths.forEach((path2) => {
        const q = queues.get(path2);
        q ? q.push(fn) : queues.set(path2, [fn]);
      }), dirs.forEach((dir) => {
        const q = queues.get(dir);
        q ? q[q.length - 1] instanceof Set ? q[q.length - 1].add(fn) : q.push(/* @__PURE__ */ new Set([fn])) : queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
      }), run(fn);
    } };
  }, pathReservations;
}
var getWriteFlag, hasRequiredGetWriteFlag;
function requireGetWriteFlag() {
  if (hasRequiredGetWriteFlag) return getWriteFlag;
  hasRequiredGetWriteFlag = 1;
  const isWindows = (process.env.__FAKE_PLATFORM__ || process.platform) === "win32", fs2 = loadEnv.commonjsGlobal.__FAKE_TESTING_FS__ || require$$0__default$1.default, { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants, fMapEnabled = isWindows && !!UV_FS_O_FILEMAP, fMapLimit = 512 * 1024, fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  return getWriteFlag = fMapEnabled ? (size) => size < fMapLimit ? fMapFlag : "w" : () => "w", getWriteFlag;
}
var unpack, hasRequiredUnpack;
function requireUnpack() {
  if (hasRequiredUnpack) return unpack;
  hasRequiredUnpack = 1;
  const assert = require$$0__default$5.default, Parser = requireParse(), fs2 = require$$0__default$1.default, fsm = requireFsMinipass(), path2 = require$$0__default.default, mkdir2 = requireMkdir(), wc = requireWinchars(), pathReservations2 = requirePathReservations(), stripAbsolutePath2 = requireStripAbsolutePath(), normPath = requireNormalizeWindowsPath(), stripSlash = requireStripTrailingSlashes(), normalize2 = requireNormalizeUnicode(), ONENTRY = Symbol("onEntry"), CHECKFS = Symbol("checkFs"), CHECKFS2 = Symbol("checkFs2"), PRUNECACHE = Symbol("pruneCache"), ISREUSABLE = Symbol("isReusable"), MAKEFS = Symbol("makeFs"), FILE = Symbol("file"), DIRECTORY = Symbol("directory"), LINK = Symbol("link"), SYMLINK = Symbol("symlink"), HARDLINK = Symbol("hardlink"), UNSUPPORTED = Symbol("unsupported"), CHECKPATH = Symbol("checkPath"), MKDIR = Symbol("mkdir"), ONERROR = Symbol("onError"), PENDING = Symbol("pending"), PEND = Symbol("pend"), UNPEND = Symbol("unpend"), ENDED = Symbol("ended"), MAYBECLOSE = Symbol("maybeClose"), SKIP = Symbol("skip"), DOCHOWN = Symbol("doChown"), UID = Symbol("uid"), GID = Symbol("gid"), CHECKED_CWD = Symbol("checkedCwd"), crypto = require$$3__default.default, getFlag = requireGetWriteFlag(), isWindows = (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform) === "win32", DEFAULT_MAX_DEPTH = 1024, unlinkFile = (path3, cb) => {
    if (!isWindows)
      return fs2.unlink(path3, cb);
    const name = path3 + ".DELETE." + crypto.randomBytes(16).toString("hex");
    fs2.rename(path3, name, (er) => {
      if (er)
        return cb(er);
      fs2.unlink(name, cb);
    });
  }, unlinkFileSync = (path3) => {
    if (!isWindows)
      return fs2.unlinkSync(path3);
    const name = path3 + ".DELETE." + crypto.randomBytes(16).toString("hex");
    fs2.renameSync(path3, name), fs2.unlinkSync(name);
  }, uint32 = (a, b, c2) => a === a >>> 0 ? a : b === b >>> 0 ? b : c2, cacheKeyNormalize = (path3) => stripSlash(normPath(normalize2(path3))).toLowerCase(), pruneCache = (cache, abs) => {
    abs = cacheKeyNormalize(abs);
    for (const path3 of cache.keys()) {
      const pnorm = cacheKeyNormalize(path3);
      (pnorm === abs || pnorm.indexOf(abs + "/") === 0) && cache.delete(path3);
    }
  }, dropCache = (cache) => {
    for (const key2 of cache.keys())
      cache.delete(key2);
  };
  class Unpack extends Parser {
    constructor(opt) {
      if (opt || (opt = {}), opt.ondone = (_) => {
        this[ENDED] = !0, this[MAYBECLOSE]();
      }, super(opt), this[CHECKED_CWD] = !1, this.reservations = pathReservations2(), this.transform = typeof opt.transform == "function" ? opt.transform : null, this.writable = !0, this.readable = !1, this[PENDING] = 0, this[ENDED] = !1, this.dirCache = opt.dirCache || /* @__PURE__ */ new Map(), typeof opt.uid == "number" || typeof opt.gid == "number") {
        if (typeof opt.uid != "number" || typeof opt.gid != "number")
          throw new TypeError("cannot set owner without number uid and gid");
        if (opt.preserveOwner)
          throw new TypeError(
            "cannot preserve owner in archive and also set owner explicitly"
          );
        this.uid = opt.uid, this.gid = opt.gid, this.setOwner = !0;
      } else
        this.uid = null, this.gid = null, this.setOwner = !1;
      opt.preserveOwner === void 0 && typeof opt.uid != "number" ? this.preserveOwner = process.getuid && process.getuid() === 0 : this.preserveOwner = !!opt.preserveOwner, this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null, this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null, this.maxDepth = typeof opt.maxDepth == "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH, this.forceChown = opt.forceChown === !0, this.win32 = !!opt.win32 || isWindows, this.newer = !!opt.newer, this.keep = !!opt.keep, this.noMtime = !!opt.noMtime, this.preservePaths = !!opt.preservePaths, this.unlink = !!opt.unlink, this.cwd = normPath(path2.resolve(opt.cwd || process.cwd())), this.strip = +opt.strip || 0, this.processUmask = opt.noChmod ? 0 : process.umask(), this.umask = typeof opt.umask == "number" ? opt.umask : this.processUmask, this.dmode = opt.dmode || 511 & ~this.umask, this.fmode = opt.fmode || 438 & ~this.umask, this.on("entry", (entry) => this[ONENTRY](entry));
    }
    // a bad or damaged archive is a warning for Parser, but an error
    // when extracting.  Mark those errors as unrecoverable, because
    // the Unpack contract cannot be met.
    warn(code, msg, data = {}) {
      return (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") && (data.recoverable = !1), super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
      this[ENDED] && this[PENDING] === 0 && (this.emit("prefinish"), this.emit("finish"), this.emit("end"));
    }
    [CHECKPATH](entry) {
      const p = normPath(entry.path), parts = p.split("/");
      if (this.strip) {
        if (parts.length < this.strip)
          return !1;
        if (entry.type === "Link") {
          const linkparts = normPath(entry.linkpath).split("/");
          if (linkparts.length >= this.strip)
            entry.linkpath = linkparts.slice(this.strip).join("/");
          else
            return !1;
        }
        parts.splice(0, this.strip), entry.path = parts.join("/");
      }
      if (isFinite(this.maxDepth) && parts.length > this.maxDepth)
        return this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
          entry,
          path: p,
          depth: parts.length,
          maxDepth: this.maxDepth
        }), !1;
      if (!this.preservePaths) {
        if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0]))
          return this.warn("TAR_ENTRY_ERROR", "path contains '..'", {
            entry,
            path: p
          }), !1;
        const [root2, stripped] = stripAbsolutePath2(p);
        root2 && (entry.path = stripped, this.warn("TAR_ENTRY_INFO", `stripping ${root2} from absolute path`, {
          entry,
          path: p
        }));
      }
      if (path2.isAbsolute(entry.path) ? entry.absolute = normPath(path2.resolve(entry.path)) : entry.absolute = normPath(path2.resolve(this.cwd, entry.path)), !this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd)
        return this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
          entry,
          path: normPath(entry.path),
          resolvedPath: entry.absolute,
          cwd: this.cwd
        }), !1;
      if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
        return !1;
      if (this.win32) {
        const { root: aRoot } = path2.win32.parse(entry.absolute);
        entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
        const { root: pRoot } = path2.win32.parse(entry.path);
        entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
      }
      return !0;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry))
        return entry.resume();
      switch (assert.equal(typeof entry.absolute, "string"), entry.type) {
        case "Directory":
        case "GNUDumpDir":
          entry.mode && (entry.mode = entry.mode | 448);
        // eslint-disable-next-line no-fallthrough
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
        default:
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      er.name === "CwdError" ? this.emit("error", er) : (this.warn("TAR_ENTRY_ERROR", er, { entry }), this[UNPEND](), entry.resume());
    }
    [MKDIR](dir, mode2, cb) {
      mkdir2(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode2,
        noChmod: this.noChmod
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid == "number" && entry.uid !== this.processUid || typeof entry.gid == "number" && entry.gid !== this.processGid) || typeof this.uid == "number" && this.uid !== this.processUid || typeof this.gid == "number" && this.gid !== this.processGid;
    }
    [UID](entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
      const mode2 = entry.mode & 4095 || this.fmode, stream2 = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode: mode2,
        autoClose: !1
      });
      stream2.on("error", (er) => {
        stream2.fd && fs2.close(stream2.fd, () => {
        }), stream2.write = () => !0, this[ONERROR](er, entry), fullyDone();
      });
      let actions = 1;
      const done = (er) => {
        if (er) {
          stream2.fd && fs2.close(stream2.fd, () => {
          }), this[ONERROR](er, entry), fullyDone();
          return;
        }
        --actions === 0 && fs2.close(stream2.fd, (er2) => {
          er2 ? this[ONERROR](er2, entry) : this[UNPEND](), fullyDone();
        });
      };
      stream2.on("finish", (_) => {
        const abs = entry.absolute, fd = stream2.fd;
        if (entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || /* @__PURE__ */ new Date(), mtime = entry.mtime;
          fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry), gid = this[GID](entry);
          fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
        }
        done();
      });
      const tx = this.transform && this.transform(entry) || entry;
      tx !== entry && (tx.on("error", (er) => {
        this[ONERROR](er, entry), fullyDone();
      }), entry.pipe(tx)), tx.pipe(stream2);
    }
    [DIRECTORY](entry, fullyDone) {
      const mode2 = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode2, (er) => {
        if (er) {
          this[ONERROR](er, entry), fullyDone();
          return;
        }
        let actions = 1;
        const done = (_) => {
          --actions === 0 && (fullyDone(), this[UNPEND](), entry.resume());
        };
        entry.mtime && !this.noMtime && (actions++, fs2.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done)), this[DOCHOWN](entry) && (actions++, fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done)), done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = !0, this.warn(
        "TAR_ENTRY_UNSUPPORTED",
        `unsupported entry type: ${entry.type}`,
        { entry }
      ), entry.resume();
    }
    [SYMLINK](entry, done) {
      this[LINK](entry, entry.linkpath, "symlink", done);
    }
    [HARDLINK](entry, done) {
      const linkpath = normPath(path2.resolve(this.cwd, entry.linkpath));
      this[LINK](entry, linkpath, "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--, this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND](), entry.resume();
    }
    // Check if we can reuse an existing filesystem entry safely and
    // overwrite it, rather than unlinking and recreating
    // Windows doesn't report a useful nlink, so we just never reuse entries
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
    }
    // check if a thing is there, and if so, try to clobber it
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      entry.linkpath && paths.push(entry.linkpath), this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [PRUNECACHE](entry) {
      entry.type === "SymbolicLink" ? dropCache(this.dirCache) : entry.type !== "Directory" && pruneCache(this.dirCache, entry.absolute);
    }
    [CHECKFS2](entry, fullyDone) {
      this[PRUNECACHE](entry);
      const done = (er) => {
        this[PRUNECACHE](entry), fullyDone(er);
      }, checkCwd = () => {
        this[MKDIR](this.cwd, this.dmode, (er) => {
          if (er) {
            this[ONERROR](er, entry), done();
            return;
          }
          this[CHECKED_CWD] = !0, start();
        });
      }, start = () => {
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path2.dirname(entry.absolute));
          if (parent !== this.cwd)
            return this[MKDIR](parent, this.dmode, (er) => {
              if (er) {
                this[ONERROR](er, entry), done();
                return;
              }
              afterMakeParent();
            });
        }
        afterMakeParent();
      }, afterMakeParent = () => {
        fs2.lstat(entry.absolute, (lstatEr, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
            this[SKIP](entry), done();
            return;
          }
          if (lstatEr || this[ISREUSABLE](entry, st))
            return this[MAKEFS](null, entry, done);
          if (st.isDirectory()) {
            if (entry.type === "Directory") {
              const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode, afterChmod = (er) => this[MAKEFS](er, entry, done);
              return needChmod ? fs2.chmod(entry.absolute, entry.mode, afterChmod) : afterChmod();
            }
            if (entry.absolute !== this.cwd)
              return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          }
          if (entry.absolute === this.cwd)
            return this[MAKEFS](null, entry, done);
          unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
        });
      };
      this[CHECKED_CWD] ? start() : checkCwd();
    }
    [MAKEFS](er, entry, done) {
      if (er) {
        this[ONERROR](er, entry), done();
        return;
      }
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE](entry, done);
        case "Link":
          return this[HARDLINK](entry, done);
        case "SymbolicLink":
          return this[SYMLINK](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY](entry, done);
      }
    }
    [LINK](entry, linkpath, link, done) {
      fs2[link](linkpath, entry.absolute, (er) => {
        er ? this[ONERROR](er, entry) : (this[UNPEND](), entry.resume()), done();
      });
    }
  }
  const callSync = (fn) => {
    try {
      return [null, fn()];
    } catch (er) {
      return [er, null];
    }
  };
  class UnpackSync extends Unpack {
    [MAKEFS](er, entry) {
      return super[MAKEFS](er, entry, () => {
      });
    }
    [CHECKFS](entry) {
      if (this[PRUNECACHE](entry), !this[CHECKED_CWD]) {
        const er2 = this[MKDIR](this.cwd, this.dmode);
        if (er2)
          return this[ONERROR](er2, entry);
        this[CHECKED_CWD] = !0;
      }
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path2.dirname(entry.absolute));
        if (parent !== this.cwd) {
          const mkParent = this[MKDIR](parent, this.dmode);
          if (mkParent)
            return this[ONERROR](mkParent, entry);
        }
      }
      const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
      if (st && (this.keep || this.newer && st.mtime > entry.mtime))
        return this[SKIP](entry);
      if (lstatEr || this[ISREUSABLE](entry, st))
        return this[MAKEFS](null, entry);
      if (st.isDirectory()) {
        if (entry.type === "Directory") {
          const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode, [er3] = needChmod ? callSync(() => {
            fs2.chmodSync(entry.absolute, entry.mode);
          }) : [];
          return this[MAKEFS](er3, entry);
        }
        const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
        this[MAKEFS](er2, entry);
      }
      const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
      this[MAKEFS](er, entry);
    }
    [FILE](entry, done) {
      const mode2 = entry.mode & 4095 || this.fmode, oner = (er) => {
        let closeError;
        try {
          fs2.closeSync(fd);
        } catch (e) {
          closeError = e;
        }
        (er || closeError) && this[ONERROR](er || closeError, entry), done();
      };
      let fd;
      try {
        fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode2);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform && this.transform(entry) || entry;
      tx !== entry && (tx.on("error", (er) => this[ONERROR](er, entry)), entry.pipe(tx)), tx.on("data", (chunk) => {
        try {
          fs2.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      }), tx.on("end", (_) => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || /* @__PURE__ */ new Date(), mtime = entry.mtime;
          try {
            fs2.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs2.utimesSync(entry.absolute, atime, mtime);
            } catch {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry), gid = this[GID](entry);
          try {
            fs2.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs2.chownSync(entry.absolute, uid, gid);
            } catch {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY](entry, done) {
      const mode2 = entry.mode & 4095 || this.dmode, er = this[MKDIR](entry.absolute, mode2);
      if (er) {
        this[ONERROR](er, entry), done();
        return;
      }
      if (entry.mtime && !this.noMtime)
        try {
          fs2.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
        } catch {
        }
      if (this[DOCHOWN](entry))
        try {
          fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch {
        }
      done(), entry.resume();
    }
    [MKDIR](dir, mode2) {
      try {
        return mkdir2.sync(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode: mode2
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link, done) {
      try {
        fs2[link + "Sync"](linkpath, entry.absolute), done(), entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  }
  return Unpack.Sync = UnpackSync, unpack = Unpack, unpack;
}
var extract_1, hasRequiredExtract;
function requireExtract() {
  if (hasRequiredExtract) return extract_1;
  hasRequiredExtract = 1;
  const hlo = requireHighLevelOpt(), Unpack = requireUnpack(), fs2 = require$$0__default$1.default, fsm = requireFsMinipass(), path2 = require$$0__default.default, stripSlash = requireStripTrailingSlashes();
  extract_1 = (opt_, files, cb) => {
    typeof opt_ == "function" ? (cb = opt_, files = null, opt_ = {}) : Array.isArray(opt_) && (files = opt_, opt_ = {}), typeof files == "function" && (cb = files, files = null), files ? files = Array.from(files) : files = [];
    const opt = hlo(opt_);
    if (opt.sync && typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return files.length && filesFilter(opt, files), opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
  };
  const filesFilter = (opt, files) => {
    const map2 = new Map(files.map((f) => [stripSlash(f), !0])), filter2 = opt.filter, mapHas = (file, r) => {
      const root2 = r || path2.parse(file).root || ".", ret = file === root2 ? !1 : map2.has(file) ? map2.get(file) : mapHas(path2.dirname(file), root2);
      return map2.set(file, ret), ret;
    };
    opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  }, extractFileSync = (opt) => {
    const u = new Unpack.Sync(opt), file = opt.file, stat2 = fs2.statSync(file), readSize = opt.maxReadSize || 16 * 1024 * 1024;
    new fsm.ReadStreamSync(file, {
      readSize,
      size: stat2.size
    }).pipe(u);
  }, extractFile = (opt, cb) => {
    const u = new Unpack(opt), readSize = opt.maxReadSize || 16 * 1024 * 1024, file = opt.file, p = new Promise((resolve, reject) => {
      u.on("error", reject), u.on("close", resolve), fs2.stat(file, (er, stat2) => {
        if (er)
          reject(er);
        else {
          const stream2 = new fsm.ReadStream(file, {
            readSize,
            size: stat2.size
          });
          stream2.on("error", reject), stream2.pipe(u);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  }, extractSync = (opt) => new Unpack.Sync(opt), extract = (opt) => new Unpack(opt);
  return extract_1;
}
var hasRequiredTar;
function requireTar() {
  return hasRequiredTar || (hasRequiredTar = 1, tar.c = tar.create = requireCreate(), tar.r = tar.replace = requireReplace(), tar.t = tar.list = requireList$1(), tar.u = tar.update = requireUpdate(), tar.x = tar.extract = requireExtract(), tar.Pack = requirePack(), tar.Unpack = requireUnpack(), tar.Parse = requireParse(), tar.ReadEntry = requireReadEntry(), tar.WriteEntry = requireWriteEntry(), tar.Header = requireHeader(), tar.Pax = requirePax(), tar.types = requireTypes$1()), tar;
}
var tarExports = requireTar();
const DISALLOWED_PATHS = [
  // Prevent security risks from unknown GitHub Actions
  "/.github/"
], ENV_VAR = {
  ...templateValidator.REQUIRED_ENV_VAR,
  READ_TOKEN: "SANITY_API_READ_TOKEN"
};
function getGitHubRawContentUrl(repoInfo) {
  const { username, name, branch, filePath } = repoInfo;
  return `https://raw.githubusercontent.com/${username}/${name}/${branch}/${filePath}`;
}
function isGithubRepoShorthand(value) {
  return URL.canParse(value) ? !1 : /^[\w-]+\/[\w-.]+(\/[@\w-.]+)*$/.test(value);
}
function isGithubRepoUrl(value) {
  if (URL.canParse(value) === !1)
    return !1;
  const url = new URL(value), pathSegments = url.pathname.slice(1).split("/");
  return url.protocol === "https:" && url.hostname === "github.com" && // The pathname must have at least 2 segments. If it has more than 2, the
  // third must be "tree" and it must have at least 4 segments.
  // https://github.com/:owner/:repo
  // https://github.com/:owner/:repo/tree/:ref
  pathSegments.length >= 2 && (pathSegments.length > 2 ? pathSegments[2] === "tree" && pathSegments.length >= 4 : !0);
}
async function downloadTarStream(url, bearerToken) {
  const headers = {};
  bearerToken && (headers.Authorization = `Bearer ${bearerToken}`);
  const res = await fetch(url, { headers });
  if (!res.body)
    throw new Error(`Failed to download: ${url}`);
  return Stream.Readable.fromWeb(res.body);
}
function checkIsRemoteTemplate(templateName) {
  return templateName?.includes("/") ?? !1;
}
async function getGitHubRepoInfo(value, bearerToken) {
  let username = "", name = "", branch = "", filePath = "";
  if (isGithubRepoShorthand(value)) {
    const parts = value.split("/");
    username = parts[0], name = parts[1], parts.length > 2 && (filePath = parts.slice(2).join("/"));
  }
  if (isGithubRepoUrl(value)) {
    const pathSegments = new URL(value).pathname.slice(1).split("/");
    username = pathSegments[0], name = pathSegments[1], pathSegments[2] === "tree" && (branch = pathSegments[3], pathSegments.length > 4 && (filePath = pathSegments.slice(4).join("/")));
  }
  if (!username || !name)
    throw new Error("Invalid GitHub repository format");
  const tokenMessage = `GitHub repository not found. For private repositories, use --template-token to provide an access token.

You can generate a new token at https://github.com/settings/personal-access-tokens/new
Set the token to "read-only" with repository access and a short expiry (e.g. 7 days) for security.`;
  try {
    const headers = {};
    bearerToken && (headers.Authorization = `Bearer ${bearerToken}`);
    const infoResponse = await fetch(`https://api.github.com/repos/${username}/${name}`, {
      headers
    });
    if (infoResponse.status !== 200)
      throw infoResponse.status === 404 ? new Error(tokenMessage) : new Error("GitHub repository not found");
    const info = await infoResponse.json();
    return {
      username,
      name,
      branch: branch || info.default_branch,
      filePath
    };
  } catch {
    throw new Error(tokenMessage);
  }
}
async function downloadAndExtractRepo(root2, { username, name, branch, filePath }, bearerToken) {
  let rootPath = null;
  await promises$1.pipeline(
    await downloadTarStream(
      `https://codeload.github.com/${username}/${name}/tar.gz/${branch}`,
      bearerToken
    ),
    tarExports.x({
      cwd: root2,
      strip: filePath ? filePath.split("/").length + 1 : 1,
      filter: (p) => {
        const posixPath = p.split(path$3.sep).join(path$3.posix.sep);
        if (rootPath === null) {
          const pathSegments = posixPath.split(path$3.posix.sep);
          rootPath = pathSegments.length ? pathSegments[0] : null;
        }
        for (const disallowedPath of DISALLOWED_PATHS)
          if (posixPath.includes(disallowedPath)) return !1;
        return posixPath.startsWith(`${rootPath}${filePath ? `/${filePath}/` : "/"}`);
      }
    })
  );
}
async function getPackages(repoInfo, bearerToken) {
  const headers = {};
  return bearerToken && (headers.Authorization = `Bearer ${bearerToken}`), templateValidator.getMonoRepo(getGitHubRawContentUrl(repoInfo), headers);
}
async function validateRemoteTemplate(repoInfo, packages = [""], bearerToken) {
  const headers = {};
  bearerToken && (headers.Authorization = `Bearer ${bearerToken}`);
  const result = await templateValidator.validateSanityTemplate(getGitHubRawContentUrl(repoInfo), packages, headers);
  if (!result.isValid)
    throw new Error(result.errors.join(`
`));
}
async function checkNeedsReadToken(root2) {
  try {
    const templatePath = await Promise.any(
      templateValidator.ENV_TEMPLATE_FILES.map(async (file) => (await fs.access(path$3.join(root2, file)), file))
    );
    return (await fs.readFile(path$3.join(root2, templatePath), "utf8")).includes(ENV_VAR.READ_TOKEN);
  } catch {
    return !1;
  }
}
async function applyEnvVariables(root2, envData, targetName = ".env") {
  const templatePath = await Promise.any(
    templateValidator.ENV_TEMPLATE_FILES.map(async (file) => (await fs.access(path$3.join(root2, file)), file))
  ).catch(() => {
    throw new Error("Could not find .env.template, .env.example or .env.local.example file");
  });
  try {
    const templateContent = await fs.readFile(path$3.join(root2, templatePath), "utf8"), { projectId, dataset, readToken = "" } = envData, findAndReplaceVariable = (content, varRegex, value, useQuotes2) => {
      const pattern = varRegex instanceof RegExp ? varRegex : new RegExp(`${varRegex}=.*$`, "m"), match2 = content.match(pattern);
      if (!match2) return content;
      const varName = match2[0].split("=")[0];
      return content.replace(
        new RegExp(`${varName}=.*$`, "m"),
        `${varName}=${useQuotes2 ? `"${value}"` : value}`
      );
    };
    let envContent = templateContent;
    const vars = [
      { pattern: ENV_VAR.PROJECT_ID, value: projectId },
      { pattern: ENV_VAR.DATASET, value: dataset },
      { pattern: ENV_VAR.READ_TOKEN, value: readToken }
    ], useQuotes = templateContent.includes('="');
    for (const { pattern, value } of vars)
      envContent = findAndReplaceVariable(envContent, pattern, value, useQuotes);
    await fs.writeFile(path$3.join(root2, targetName), envContent);
  } catch {
    throw new Error(
      "Failed to set environment variables. This could be due to file permissions or the .env file format. See https://www.sanity.io/docs/environment-variables for details on environment variable setup."
    );
  }
}
async function tryApplyPackageName(root2, name) {
  try {
    const packageJson = await fs.readFile(path$3.join(root2, "package.json"), "utf8"), pkg = JSON.parse(packageJson);
    pkg.name = name, await fs.writeFile(path$3.join(root2, "package.json"), JSON.stringify(pkg, null, 2));
  } catch {
  }
}
async function generateSanityApiReadToken(label, projectId, apiClient) {
  return (await apiClient({ requireProject: !1, requireUser: !0 }).config({ apiVersion: "v2021-06-07" }).request({
    uri: `/projects/${projectId}/tokens`,
    method: "POST",
    body: {
      label: `${label} (${Date.now()})`,
      // Add timestamp to ensure uniqueness
      roleName: "viewer"
    }
  })).key;
}
async function setCorsOrigin(origin, projectId, apiClient) {
  try {
    await apiClient({ api: { projectId } }).request({
      method: "POST",
      url: "/cors",
      body: { origin, allowCredentials: !1 }
    });
  } catch (error2) {
    loadEnv.debug("Failed to set CORS origin", error2);
  }
}
function canLaunchBrowser() {
  return ["win32", "darwin"].includes(os__default.default.platform()) ? !0 : !!(process.env.XDG_CURRENT_DESKTOP || process.env.GDMSESSION);
}
function createExpiringConfig({
  key: key2,
  ttl,
  store,
  fetchValue,
  onRevalidate = () => null,
  onFetch = () => null,
  onCacheHit = () => null
}) {
  let currentFetch = null;
  return {
    async get() {
      const { value, updatedAt } = store.get(key2) ?? {};
      if (value && updatedAt) {
        if (!(Date.now() - updatedAt > ttl))
          return onCacheHit(), value;
        onRevalidate();
      }
      if (currentFetch)
        return currentFetch;
      onFetch(), currentFetch = Promise.resolve(fetchValue());
      const nextValue = await currentFetch;
      return currentFetch = null, store.set(key2, {
        value: nextValue,
        updatedAt: Date.now()
      }), nextValue;
    },
    delete() {
      store.delete(key2);
    }
  };
}
function isTrueish(value) {
  if (value === void 0) return !1;
  if (value.toLowerCase() === "true") return !0;
  if (value.toLowerCase() === "false") return !1;
  const number2 = parseInt(value, 10);
  return isNaN(number2) ? !1 : number2 > 0;
}
const isCi = isTrueish(process.env.CI) || // Travis CI, CircleCI, Gitlab CI, Appveyor, CodeShip
isTrueish(process.env.CONTINUOUS_INTEGRATION) || // Travis CI
process.env.BUILD_NUMBER, debug$1 = loadEnv.debug.extend("telemetry"), FIVE_MINUTES = 1e3 * 60 * 5, LOG_FILE_NAME = "telemetry-events.ndjson", TELEMETRY_CONSENT_CONFIG_KEY = "telemetryConsent", VALID_API_STATUSES = ["granted", "denied", "unset"];
function isValidApiConsentStatus(status) {
  return VALID_API_STATUSES.includes(status);
}
function parseApiConsentStatus(value) {
  if (typeof value == "string" && isValidApiConsentStatus(value))
    return value;
  throw new Error(`Invalid consent status. Must be one of: ${VALID_API_STATUSES.join(", ")}`);
}
function createTelemetryClient(token2) {
  return getClientWrapper(null, "sanity.cli.js")({ requireUser: !1, requireProject: !1 }).config({
    apiVersion: "2023-12-18",
    token: token2,
    useCdn: !1,
    useProjectHostname: !1
  });
}
let _client = null;
function getCachedClient(token2) {
  return _client || (_client = createTelemetryClient(token2)), _client;
}
function resolveConsent({ env }) {
  if (debug$1("Resolving consent\u2026"), isCi)
    return debug$1("CI environment detected, treating telemetry consent as denied"), Promise.resolve({ status: "denied" });
  if (isTrueish(env.DO_NOT_TRACK))
    return debug$1("DO_NOT_TRACK is set, consent is denied"), Promise.resolve({
      status: "denied",
      reason: "localOverride"
    });
  const token2 = getCliToken();
  if (!token2)
    return debug$1("User is not logged in, consent is undetermined"), Promise.resolve({
      status: "undetermined",
      reason: "unauthenticated"
    });
  const client2 = getCachedClient(token2);
  function fetchConsent() {
    return createExpiringConfig({
      store: getUserConfig(),
      key: TELEMETRY_CONSENT_CONFIG_KEY,
      ttl: FIVE_MINUTES,
      fetchValue: () => client2.request({ uri: "/intake/telemetry-status", tag: "telemetry-consent.cli" }),
      onRevalidate() {
        debug$1("Revalidating cached telemetry consent status...");
      },
      onFetch() {
        debug$1("Fetching telemetry consent status...");
      },
      onCacheHit() {
        debug$1("Retrieved telemetry consent status from cache");
      }
    }).get();
  }
  return fetchConsent().then((response) => (debug$1("User consent status is %s", response.status), { status: parseApiConsentStatus(response.status) })).catch((err) => (debug$1('Failed to fetch user consent status, treating it as "undetermined": %s', err.stack), {
    status: "undetermined",
    reason: "fetchError"
  }));
}
function createTelemetryStore({
  env,
  projectId
}) {
  debug$1("Initializing telemetry");
  async function sendEvents(batch) {
    const token2 = getCliToken();
    if (!token2)
      return debug$1("No user token found. Something is not quite right"), Promise.reject(new Error("User is not logged in"));
    isTrueish(env.SANITY_TELEMETRY_INSPECT) && (console.info(`SANITY_TELEMETRY_INSPECT is set, appending events to "${LOG_FILE_NAME}"`), await fs.appendFile(LOG_FILE_NAME, `${batch.map((entry) => JSON.stringify(entry)).join(`
`)}
`));
    const client2 = getCachedClient(token2);
    debug$1("Submitting %s telemetry events", batch.length);
    try {
      return await client2.request({
        uri: "/intake/batch",
        method: "POST",
        json: !0,
        body: { projectId, batch }
      });
    } catch (err) {
      const statusCode = err.response && err.response.statusCode;
      throw debug$1(
        "Failed to send telemetry events%s: %s",
        statusCode ? ` (HTTP ${statusCode})` : "",
        err.stack
      ), err;
    }
  }
  const sessionId = telemetry.createSessionId();
  debug$1("session id: %s", sessionId);
  const store = telemetry.createBatchedStore(sessionId, {
    resolveConsent: () => resolveConsent({ env }),
    sendEvents
  });
  return process.once("SIGINT", () => store.flush().finally(() => process.exit(0))), process.once("beforeExit", () => store.flush()), process.once("unhandledRejection", () => store.flush()), process.once("uncaughtException", () => store.flush()), store;
}
const LoginTrace = telemetry.defineTrace({
  name: "CLI Login Step Completed",
  version: 1,
  description: "User completed a step in the CLI login flow"
}), callbackEndpoint = "/callback", debug = loadEnv.debug.extend("auth"), callbackPorts = [4321, 4e3, 3003, 1234, 8080, 13333], platformNames = {
  aix: "AIX",
  android: "Android",
  darwin: "MacOS",
  freebsd: "FreeBSD",
  linux: "Linux",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
async function login(args, context) {
  const { prompt: prompt2, output, apiClient, telemetry: telemetry2 } = context, { sso, experimental, open: openFlag, provider: specifiedProvider } = args.extOptions, previousToken = getCliToken(), hasExistingToken = !!previousToken, trace = telemetry2.trace(LoginTrace);
  trace.start();
  const client2 = apiClient({ requireUser: !1, requireProject: !1 }).clone().config({ token: void 0 }), provider = await getProvider({ client: client2, sso, experimental, output, prompt: prompt2, specifiedProvider });
  if (trace.log({ step: "selectProvider", provider: provider?.name }), provider === void 0)
    throw new Error("No authentication providers found");
  const apiHost = client2.config().apiHost || "https://api.sanity.io", { server, token: tokenPromise } = await startServerForTokenCallback({ apiHost, apiClient });
  trace.log({ step: "waitForToken" });
  const serverUrl = server.address();
  if (!serverUrl || typeof serverUrl == "string")
    throw new Error("Failed to start auth callback server");
  const loginUrl = new URL(provider.url), platformName = os__default.default.platform(), platform2 = platformName in platformNames ? platformNames[platformName] : platformName, hostname = os__default.default.hostname().replace(/\.(local|lan)$/g, "");
  loginUrl.searchParams.set("type", "token"), loginUrl.searchParams.set("label", `${hostname} / ${platform2}`), loginUrl.searchParams.set("origin", `http://localhost:${serverUrl.port}${callbackEndpoint}`);
  const shouldLaunchBrowser = canLaunchBrowser() && openFlag !== !1, actionText = shouldLaunchBrowser ? "Opening browser at" : "Please open a browser at";
  output.print(`
${actionText} ${loginUrl.href}
`);
  const spin = output.spinner("Waiting for browser login to complete... Press Ctrl + C to cancel").start();
  shouldLaunchBrowser && open(loginUrl.href);
  let authToken;
  try {
    authToken = (await tokenPromise).token, spin.stop();
  } catch (err) {
    throw spin.stop(), trace.error(err), err.message = `Login failed: ${err.message}`, err;
  } finally {
    server.close(), server.unref();
  }
  getUserConfig().set({
    authToken,
    authType: "normal"
  }), getUserConfig().delete(TELEMETRY_CONSENT_CONFIG_KEY), hasExistingToken && await apiClient({ requireUser: !0, requireProject: !1 }).clone().config({ token: previousToken }).request({ uri: "/auth/logout", method: "POST" }).catch((err) => {
    (err && err.response && err.response.statusCode) !== 401 && output.warn("[warn] Failed to log out existing session");
  }), output.success("Login successful"), trace.complete();
}
function startServerForTokenCallback(options2) {
  const { apiHost, apiClient } = options2, domain = apiHost.includes(".sanity.work") ? "www.sanity.work" : "www.sanity.io", attemptPorts = callbackPorts.slice();
  let callbackPort = attemptPorts.shift(), resolveToken, rejectToken;
  const tokenPromise = new Promise((resolve, reject) => {
    resolveToken = resolve, rejectToken = reject;
  });
  return new Promise((resolve, reject) => {
    const server = http__default.default.createServer(async function(req, res) {
      function failLoginRequest(code = "") {
        res.writeHead(303, "See Other", {
          Location: `https://${domain}/login/error${code ? `?error=${code}` : ""}`
        }), res.end(), server.close();
      }
      const url = new URL(req.url || "/", `http://localhost:${callbackPort}`);
      if (url.pathname !== callbackEndpoint) {
        res.writeHead(404, "Not Found", { "Content-Type": "text/plain" }), res.write("404 Not Found"), res.end();
        return;
      }
      const absoluteTokenUrl = url.searchParams.get("url");
      if (!absoluteTokenUrl) {
        failLoginRequest();
        return;
      }
      const tokenUrl = new URL(absoluteTokenUrl);
      if (!tokenUrl.searchParams.has("sid")) {
        failLoginRequest("NO_SESSION_ID");
        return;
      }
      let token2;
      try {
        token2 = await apiClient({ requireUser: !1, requireProject: !1 }).clone().request({ uri: `/auth/fetch${tokenUrl.search}` });
      } catch (err) {
        failLoginRequest("UNRESOLVED_SESSION"), rejectToken(err);
        return;
      }
      res.writeHead(303, "See Other", { Location: `https://${domain}/login/success` }), res.end(), server.close(), resolveToken(token2);
    });
    server.on("listening", function() {
      resolve({ token: tokenPromise, server });
    }), server.on("error", function(err) {
      if ("code" in err && err.code === "EADDRINUSE") {
        if (callbackPort = attemptPorts.shift(), !callbackPort) {
          reject(new Error("Failed to find port number to bind auth callback server to"));
          return;
        }
        debug("Port busy, trying %d", callbackPort), server.listen(callbackPort);
      } else
        reject(err);
    }), debug("Starting callback server on port %d", callbackPort), server.listen(callbackPort);
  });
}
async function getProvider({
  output,
  client: client2,
  sso,
  experimental,
  prompt: prompt2,
  specifiedProvider
}) {
  if (sso)
    return getSSOProvider({ client: client2, prompt: prompt2, slug: sso });
  const spin = output.spinner("Fetching providers...").start();
  let { providers } = await client2.request({ uri: "/auth/providers" });
  experimental && (providers = [...providers, { name: "sso", title: "SSO", url: "_not_used_" }]), spin.stop();
  const providerNames = providers.map((prov) => prov.name);
  if (specifiedProvider && providerNames.includes(specifiedProvider)) {
    const provider2 = providers.find((prov) => prov.name === specifiedProvider);
    if (!provider2)
      throw new Error(`Cannot find login provider with name "${specifiedProvider}"`);
    return provider2;
  }
  const provider = await promptProviders(prompt2, providers);
  if (provider.name === "sso") {
    const slug = await prompt2.single({
      type: "input",
      message: "Organization slug:"
    });
    return getSSOProvider({ client: client2, prompt: prompt2, slug });
  }
  return provider;
}
async function getSSOProvider({
  client: client2,
  prompt: prompt2,
  slug
}) {
  const enabledProviders = (await client2.withConfig({ apiVersion: "2021-10-01" }).request({
    uri: `/auth/organizations/by-slug/${slug}/providers`
  })).filter((candidate) => !candidate.disabled);
  if (enabledProviders.length === 0)
    return;
  if (enabledProviders.length === 1)
    return samlProviderToLoginProvider(enabledProviders[0]);
  const choice2 = await prompt2.single({
    type: "list",
    message: "Select SSO provider",
    choices: enabledProviders.map((provider) => provider.name)
  }), foundProvider = enabledProviders.find((provider) => provider.name === choice2);
  return foundProvider ? samlProviderToLoginProvider(foundProvider) : void 0;
}
async function promptProviders(prompt2, providers) {
  if (providers.length === 1)
    return providers[0];
  const provider = await prompt2.single({
    type: "list",
    message: "Please log in or create a new account",
    choices: providers.map((choice2) => choice2.title)
  });
  return providers.find((prov) => prov.title === provider) || providers[0];
}
function samlProviderToLoginProvider(saml) {
  return {
    name: saml.name,
    title: saml.name,
    url: saml.loginUrl
  };
}
function createProject(apiClient, options2) {
  return apiClient({
    requireUser: !0,
    requireProject: !1
  }).request({
    method: "POST",
    uri: "/projects",
    body: {
      ...options2,
      metadata: {
        ...options2?.metadata,
        integration: "cli"
      }
    }
  }).then((response) => ({
    projectId: response.projectId || response.id,
    displayName: options2.displayName || ""
  }));
}
const studioDependencies = {
  // Dependencies for a default Sanity installation
  dependencies: {
    // Official studio dependencies
    sanity: "latest",
    // Official studio plugin dependencies
    "@sanity/vision": "latest",
    // Non-Sanity dependencies
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "styled-components": "^6.1.8"
  },
  devDependencies: {
    // Linting/tooling
    "@sanity/eslint-config-studio": "latest",
    // When using typescript, we'll want the these types too, so might as well install them
    "@types/react": "^18.0.25",
    eslint: "^9.9.0",
    prettier: "^3.0.2",
    typescript: "^5.1.6"
    // Peer dependency of eslint-config-studio (implicitly)
  }
};
async function readdirRecursive(dir) {
  let content = [];
  const currentPath = path__default.default.resolve(dir), dirContent = (await fs__default.default.readdir(currentPath)).map((item) => path__default.default.join(currentPath, item));
  for (const subPath of dirContent) {
    const isDir2 = (await fs__default.default.stat(subPath)).isDirectory();
    content.push({ path: subPath, isDir: isDir2 }), isDir2 && (content = content.concat(await readdirRecursive(subPath)));
  }
  return content;
}
async function copy(srcPath, dstPath, options2) {
  const rename2 = options2?.rename, content = (await fs__default.default.stat(srcPath)).isDirectory() ? await readdirRecursive(srcPath) : [{ path: srcPath, isDir: !1 }], directories = content.filter((entry) => entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map((entry) => entry.path);
  for (const subDir of directories) {
    const relativePath = path__default.default.relative(srcPath, subDir), fullDstPath = path__default.default.join(dstPath, relativePath);
    await fs__default.default.mkdir(fullDstPath, { recursive: !0 });
  }
  const files = content.filter((entry) => !entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map((entry) => {
    const relativePath = path__default.default.relative(srcPath, entry.path), baseName = path__default.default.basename(relativePath), dirName = path__default.default.dirname(relativePath), dstName = rename2 ? rename2(baseName) : baseName, fullDstPath = path__default.default.join(dstPath, dirName, dstName);
    return { from: entry.path, to: fullDstPath };
  });
  for (const file of files)
    await fs__default.default.copyFile(file.from, file.to);
  return files.length;
}
function resolveLatestVersions(pkgs) {
  const lookups = {};
  for (const [packageName, range2] of Object.entries(pkgs))
    lookups[packageName] = range2 === "latest" ? latestVersion(packageName, { range: range2 }).then(caretify) : range2;
  return promiseProps(lookups);
}
function caretify(version2) {
  return version2 ? `^${version2}` : "latest";
}
var main$2 = {}, extendStatics$1 = function(d, b) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
  }, extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b != "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  return t;
}
function __decorate(decorators, target, key2, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(decorators, target, key2, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key2, r) : d(target, key2)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key2, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f != "function") throw new TypeError("Function expected");
    return f;
  }
  for (var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor2 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _, done = !1, i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor2.get, set: descriptor2.set } : descriptor2[key2], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result != "object") throw new TypeError("Object expected");
      (_ = accept(result.get)) && (descriptor2.get = _), (_ = accept(result.set)) && (descriptor2.set = _), (_ = accept(result.init)) && initializers.unshift(_);
    } else (_ = accept(result)) && (kind === "field" ? initializers.unshift(_) : descriptor2[key2] = _);
  }
  target && Object.defineProperty(target, contextIn.name, descriptor2), done = !0;
}
function __runInitializers(thisArg, initializers, value) {
  for (var useValue = arguments.length > 2, i = 0; i < initializers.length; i++)
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x == "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  return typeof name == "symbol" && (name = name.description ? "[".concat(name.description, "]") : ""), Object.defineProperty(f, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g.throw = verb(1), g.return = verb(2), typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; g && (g = 0, op[0] && (_ = 0)), _; ) try {
      if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          return _.label++, { value: op[1], done: !1 };
        case 5:
          _.label++, y = op[1], op = [0];
          continue;
        case 7:
          op = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1], t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2], _.ops.push(op);
            break;
          }
          t[2] && _.ops.pop(), _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e], y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: !0 };
  }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
  k2 === void 0 && (k2 = k);
  var desc = Object.getOwnPropertyDescriptor(m, k);
  (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
    return m[k];
  } }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  k2 === void 0 && (k2 = k), o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(o, p) && __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length == "number") return {
    next: function() {
      return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol == "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      r && !r.done && (m = i.return) && m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++)
    (ar || !(i in from2)) && (ar || (ar = Array.prototype.slice.call(from2, 0, i)), ar[i] = from2[i]);
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    g[n] && (i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    }, f && (i[n] = f(i[n])));
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values == "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: !0, value: v });
} : function(o, v) {
  o.default = v;
}, ownKeys = function(o) {
  return ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) Object.prototype.hasOwnProperty.call(o2, k) && (ar[ar.length] = k);
    return ar;
  }, ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) k[i] !== "default" && __createBinding(result, mod, k[i]);
  return __setModuleDefault(result, mod), result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver != "object" && typeof receiver != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state == "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async2) {
  if (value != null) {
    if (typeof value != "object" && typeof value != "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async2) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose], async2 && (inner = dispose);
    }
    if (typeof dispose != "function") throw new TypeError("Object not disposable.");
    inner && (dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    }), env.stack.push({ value, dispose, async: async2 });
  } else async2 && env.stack.push({ async: !0 });
  return value;
}
var _SuppressedError = typeof SuppressedError == "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, env.hasError = !0;
  }
  var r, s = 0;
  function next() {
    for (; r = env.stack.pop(); )
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            return fail(e), next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path2, preserveJsx) {
  return typeof path2 == "string" && /^\.\.?\//.test(path2) ? path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext2, cm) {
    return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext2 || !cm) ? m : d + ext2 + "." + cm.toLowerCase() + "js";
  }) : path2;
}
var tslib_es6 = {
  __extends: __extends$1,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
}, tslib_es6$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends: __extends$1,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}), require$$0$3 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(tslib_es6$1), main$1 = {}, fork = { exports: {} }, types$1 = { exports: {} }, shared = {}, hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1, Object.defineProperty(shared, "__esModule", { value: !0 }), shared.maybeSetModuleExports = void 0;
  var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes());
  function default_1(fork2) {
    var types2 = fork2.use(types_1.default), Type = types2.Type, builtin = types2.builtInTypes, isNumber2 = builtin.number;
    function geq(than) {
      return Type.from(function(value) {
        return isNumber2.check(value) && value >= than;
      }, isNumber2 + " >= " + than);
    }
    var defaults2 = {
      // Functions were used because (among other reasons) that's the most
      // elegant way to allow for the emptyArray one always to give a new
      // array instance.
      null: function() {
        return null;
      },
      emptyArray: function() {
        return [];
      },
      false: function() {
        return !1;
      },
      true: function() {
        return !0;
      },
      undefined: function() {
      },
      "use strict": function() {
        return "use strict";
      }
    }, naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined), isPrimitive = Type.from(function(value) {
      if (value === null)
        return !0;
      var type2 = typeof value;
      return !(type2 === "object" || type2 === "function");
    }, naiveIsPrimitive.toString());
    return {
      geq,
      defaults: defaults2,
      isPrimitive
    };
  }
  shared.default = default_1;
  function maybeSetModuleExports(moduleGetter) {
    try {
      var nodeModule = moduleGetter(), originalExports = nodeModule.exports, defaultExport = originalExports.default;
    } catch {
      return;
    }
    defaultExport && defaultExport !== originalExports && typeof originalExports == "object" && (Object.assign(defaultExport, originalExports, { default: defaultExport }), originalExports.__esModule && Object.defineProperty(defaultExport, "__esModule", { value: !0 }), nodeModule.exports = defaultExport);
  }
  return shared.maybeSetModuleExports = maybeSetModuleExports, shared;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.Def = void 0;
    var tslib_1 = require$$0$3, shared_1 = requireShared(), Op = Object.prototype, objToStr = Op.toString, hasOwn = Op.hasOwnProperty, BaseType = (
      /** @class */
      function() {
        function BaseType2() {
        }
        return BaseType2.prototype.assert = function(value, deep) {
          if (!this.check(value, deep)) {
            var str2 = shallowStringify(value);
            throw new Error(str2 + " does not match type " + this);
          }
          return !0;
        }, BaseType2.prototype.arrayOf = function() {
          var elemType = this;
          return new ArrayType(elemType);
        }, BaseType2;
      }()
    ), ArrayType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ArrayType2, _super);
        function ArrayType2(elemType) {
          var _this = _super.call(this) || this;
          return _this.elemType = elemType, _this.kind = "ArrayType", _this;
        }
        return ArrayType2.prototype.toString = function() {
          return "[" + this.elemType + "]";
        }, ArrayType2.prototype.check = function(value, deep) {
          var _this = this;
          return Array.isArray(value) && value.every(function(elem) {
            return _this.elemType.check(elem, deep);
          });
        }, ArrayType2;
      }(BaseType)
    ), IdentityType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(IdentityType2, _super);
        function IdentityType2(value) {
          var _this = _super.call(this) || this;
          return _this.value = value, _this.kind = "IdentityType", _this;
        }
        return IdentityType2.prototype.toString = function() {
          return String(this.value);
        }, IdentityType2.prototype.check = function(value, deep) {
          var result = value === this.value;
          return !result && typeof deep == "function" && deep(this, value), result;
        }, IdentityType2;
      }(BaseType)
    ), ObjectType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ObjectType2, _super);
        function ObjectType2(fields) {
          var _this = _super.call(this) || this;
          return _this.fields = fields, _this.kind = "ObjectType", _this;
        }
        return ObjectType2.prototype.toString = function() {
          return "{ " + this.fields.join(", ") + " }";
        }, ObjectType2.prototype.check = function(value, deep) {
          return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
            return field.type.check(value[field.name], deep);
          });
        }, ObjectType2;
      }(BaseType)
    ), OrType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(OrType2, _super);
        function OrType2(types2) {
          var _this = _super.call(this) || this;
          return _this.types = types2, _this.kind = "OrType", _this;
        }
        return OrType2.prototype.toString = function() {
          return this.types.join(" | ");
        }, OrType2.prototype.check = function(value, deep) {
          return this.types.some(function(type2) {
            return type2.check(value, !!deep);
          }) ? !0 : (typeof deep == "function" && deep(this, value), !1);
        }, OrType2;
      }(BaseType)
    ), PredicateType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PredicateType2, _super);
        function PredicateType2(name, predicate) {
          var _this = _super.call(this) || this;
          return _this.name = name, _this.predicate = predicate, _this.kind = "PredicateType", _this;
        }
        return PredicateType2.prototype.toString = function() {
          return this.name;
        }, PredicateType2.prototype.check = function(value, deep) {
          var result = this.predicate(value, deep);
          return !result && typeof deep == "function" && deep(this, value), result;
        }, PredicateType2;
      }(BaseType)
    ), Def = (
      /** @class */
      function() {
        function Def2(type2, typeName) {
          this.type = type2, this.typeName = typeName, this.baseNames = [], this.ownFields = /* @__PURE__ */ Object.create(null), this.allSupertypes = /* @__PURE__ */ Object.create(null), this.supertypeList = [], this.allFields = /* @__PURE__ */ Object.create(null), this.fieldNames = [], this.finalized = !1, this.buildable = !1, this.buildParams = [];
        }
        return Def2.prototype.isSupertypeOf = function(that) {
          if (that instanceof Def2) {
            if (this.finalized !== !0 || that.finalized !== !0)
              throw new Error("");
            return hasOwn.call(that.allSupertypes, this.typeName);
          } else
            throw new Error(that + " is not a Def");
        }, Def2.prototype.checkAllFields = function(value, deep) {
          var allFields = this.allFields;
          if (this.finalized !== !0)
            throw new Error("" + this.typeName);
          function checkFieldByName(name) {
            var field = allFields[name], type2 = field.type, child = field.getValue(value);
            return type2.check(child, deep);
          }
          return value !== null && typeof value == "object" && Object.keys(allFields).every(checkFieldByName);
        }, Def2.prototype.bases = function() {
          for (var supertypeNames = [], _i = 0; _i < arguments.length; _i++)
            supertypeNames[_i] = arguments[_i];
          var bases = this.baseNames;
          if (this.finalized) {
            if (supertypeNames.length !== bases.length)
              throw new Error("");
            for (var i = 0; i < supertypeNames.length; i++)
              if (supertypeNames[i] !== bases[i])
                throw new Error("");
            return this;
          }
          return supertypeNames.forEach(function(baseName) {
            bases.indexOf(baseName) < 0 && bases.push(baseName);
          }), this;
        }, Def2;
      }()
    );
    exports2.Def = Def;
    var Field = (
      /** @class */
      function() {
        function Field2(name, type2, defaultFn, hidden) {
          this.name = name, this.type = type2, this.defaultFn = defaultFn, this.hidden = !!hidden;
        }
        return Field2.prototype.toString = function() {
          return JSON.stringify(this.name) + ": " + this.type;
        }, Field2.prototype.getValue = function(obj) {
          var value = obj[this.name];
          return typeof value < "u" || typeof this.defaultFn == "function" && (value = this.defaultFn.call(obj)), value;
        }, Field2;
      }()
    );
    function shallowStringify(value) {
      return Array.isArray(value) ? "[" + value.map(shallowStringify).join(", ") + "]" : value && typeof value == "object" ? "{ " + Object.keys(value).map(function(key2) {
        return key2 + ": " + value[key2];
      }).join(", ") + " }" : JSON.stringify(value);
    }
    function typesPlugin(_fork) {
      var Type = {
        or: function() {
          for (var types2 = [], _i = 0; _i < arguments.length; _i++)
            types2[_i] = arguments[_i];
          return new OrType(types2.map(function(type2) {
            return Type.from(type2);
          }));
        },
        from: function(value, name) {
          if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType)
            return value;
          if (value instanceof Def)
            return value.type;
          if (isArray2.check(value)) {
            if (value.length !== 1)
              throw new Error("only one element type is permitted for typed arrays");
            return new ArrayType(Type.from(value[0]));
          }
          if (isObject2.check(value))
            return new ObjectType(Object.keys(value).map(function(name2) {
              return new Field(name2, Type.from(value[name2], name2));
            }));
          if (typeof value == "function") {
            var bicfIndex = builtInCtorFns.indexOf(value);
            if (bicfIndex >= 0)
              return builtInCtorTypes[bicfIndex];
            if (typeof name != "string")
              throw new Error("missing name");
            return new PredicateType(name, value);
          }
          return new IdentityType(value);
        },
        // Define a type whose name is registered in a namespace (the defCache) so
        // that future definitions will return the same type given the same name.
        // In particular, this system allows for circular and forward definitions.
        // The Def object d returned from Type.def may be used to configure the
        // type d.type by calling methods such as d.bases, d.build, and d.field.
        def: function(typeName) {
          return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
        },
        hasDef: function(typeName) {
          return hasOwn.call(defCache, typeName);
        }
      }, builtInCtorFns = [], builtInCtorTypes = [];
      function defBuiltInType(name, example) {
        var objStr = objToStr.call(example), type2 = new PredicateType(name, function(value) {
          return objToStr.call(value) === objStr;
        });
        return example && typeof example.constructor == "function" && (builtInCtorFns.push(example.constructor), builtInCtorTypes.push(type2)), type2;
      }
      var isString = defBuiltInType("string", "truthy"), isFunction2 = defBuiltInType("function", function() {
      }), isArray2 = defBuiltInType("array", []), isObject2 = defBuiltInType("object", {}), isRegExp = defBuiltInType("RegExp", /./), isDate2 = defBuiltInType("Date", /* @__PURE__ */ new Date()), isNumber2 = defBuiltInType("number", 3), isBoolean = defBuiltInType("boolean", !0), isNull = defBuiltInType("null", null), isUndefined = defBuiltInType("undefined", void 0), isBigInt = typeof BigInt == "function" ? defBuiltInType("BigInt", BigInt(1234)) : new PredicateType("BigInt", function() {
        return !1;
      }), builtInTypes = {
        string: isString,
        function: isFunction2,
        array: isArray2,
        object: isObject2,
        RegExp: isRegExp,
        Date: isDate2,
        number: isNumber2,
        boolean: isBoolean,
        null: isNull,
        undefined: isUndefined,
        BigInt: isBigInt
      }, defCache = /* @__PURE__ */ Object.create(null);
      function defFromValue(value) {
        if (value && typeof value == "object") {
          var type2 = value.type;
          if (typeof type2 == "string" && hasOwn.call(defCache, type2)) {
            var d = defCache[type2];
            if (d.finalized)
              return d;
          }
        }
        return null;
      }
      var DefImpl = (
        /** @class */
        function(_super) {
          tslib_1.__extends(DefImpl2, _super);
          function DefImpl2(typeName) {
            var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
              return _this.check(value, deep);
            }), typeName) || this;
            return _this;
          }
          return DefImpl2.prototype.check = function(value, deep) {
            if (this.finalized !== !0)
              throw new Error("prematurely checking unfinalized type " + this.typeName);
            if (value === null || typeof value != "object")
              return !1;
            var vDef = defFromValue(value);
            return vDef ? deep && vDef === this ? this.checkAllFields(value, deep) : this.isSupertypeOf(vDef) ? deep ? vDef.checkAllFields(value, deep) && this.checkAllFields(value, !1) : !0 : !1 : this.typeName === "SourceLocation" || this.typeName === "Position" ? this.checkAllFields(value, deep) : !1;
          }, DefImpl2.prototype.build = function() {
            for (var _this = this, buildParams = [], _i = 0; _i < arguments.length; _i++)
              buildParams[_i] = arguments[_i];
            if (this.buildParams = buildParams, this.buildable)
              return this;
            this.field("type", String, function() {
              return _this.typeName;
            }), this.buildable = !0;
            var addParam = function(built, param, arg, isArgAvailable) {
              if (!hasOwn.call(built, param)) {
                var all = _this.allFields;
                if (!hasOwn.call(all, param))
                  throw new Error("" + param);
                var field = all[param], type2 = field.type, value;
                if (isArgAvailable)
                  value = arg;
                else if (field.defaultFn)
                  value = field.defaultFn.call(built);
                else {
                  var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
                    return all[name];
                  }).join(", ") + ")";
                  throw new Error(message);
                }
                if (!type2.check(value))
                  throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
                built[param] = value;
              }
            }, builder = function() {
              for (var args = [], _i2 = 0; _i2 < arguments.length; _i2++)
                args[_i2] = arguments[_i2];
              var argc = args.length;
              if (!_this.finalized)
                throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
              var built = Object.create(nodePrototype);
              if (_this.buildParams.forEach(function(param, i) {
                i < argc ? addParam(built, param, args[i], !0) : addParam(built, param, null, !1);
              }), Object.keys(_this.allFields).forEach(function(param) {
                addParam(built, param, null, !1);
              }), built.type !== _this.typeName)
                throw new Error("");
              return built;
            };
            return builder.from = function(obj) {
              if (!_this.finalized)
                throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
              var built = Object.create(nodePrototype);
              if (Object.keys(_this.allFields).forEach(function(param) {
                hasOwn.call(obj, param) ? addParam(built, param, obj[param], !0) : addParam(built, param, null, !1);
              }), built.type !== _this.typeName)
                throw new Error("");
              return built;
            }, Object.defineProperty(builders, getBuilderName(this.typeName), {
              enumerable: !0,
              value: builder
            }), this;
          }, DefImpl2.prototype.field = function(name, type2, defaultFn, hidden) {
            return this.finalized ? (console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName)), this) : (this.ownFields[name] = new Field(name, Type.from(type2), defaultFn, hidden), this);
          }, DefImpl2.prototype.finalize = function() {
            var _this = this;
            if (!this.finalized) {
              var allFields = this.allFields, allSupertypes = this.allSupertypes;
              this.baseNames.forEach(function(name) {
                var def = defCache[name];
                if (def instanceof Def)
                  def.finalize(), extend(allFields, def.allFields), extend(allSupertypes, def.allSupertypes);
                else {
                  var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
                  throw new Error(message);
                }
              }), extend(allFields, this.ownFields), allSupertypes[this.typeName] = this, this.fieldNames.length = 0;
              for (var fieldName in allFields)
                hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden && this.fieldNames.push(fieldName);
              Object.defineProperty(namedTypes2, this.typeName, {
                enumerable: !0,
                value: this.type
              }), this.finalized = !0, populateSupertypeList(this.typeName, this.supertypeList), this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0 && wrapExpressionBuilderWithStatement(this.typeName);
            }
          }, DefImpl2;
        }(Def)
      );
      function getSupertypeNames(typeName) {
        if (!hasOwn.call(defCache, typeName))
          throw new Error("");
        var d = defCache[typeName];
        if (d.finalized !== !0)
          throw new Error("");
        return d.supertypeList.slice(1);
      }
      function computeSupertypeLookupTable(candidates) {
        for (var table = {}, typeNames = Object.keys(defCache), typeNameCount = typeNames.length, i = 0; i < typeNameCount; ++i) {
          var typeName = typeNames[i], d = defCache[typeName];
          if (d.finalized !== !0)
            throw new Error("" + typeName);
          for (var j = 0; j < d.supertypeList.length; ++j) {
            var superTypeName = d.supertypeList[j];
            if (hasOwn.call(candidates, superTypeName)) {
              table[typeName] = superTypeName;
              break;
            }
          }
        }
        return table;
      }
      var builders = /* @__PURE__ */ Object.create(null), nodePrototype = {};
      function defineMethod(name, func) {
        var old2 = nodePrototype[name];
        return isUndefined.check(func) ? delete nodePrototype[name] : (isFunction2.assert(func), Object.defineProperty(nodePrototype, name, {
          enumerable: !0,
          configurable: !0,
          value: func
        })), old2;
      }
      function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
          var len = upperCasePrefix.length;
          switch (len) {
            case 0:
              return "";
            // If there's only one initial capital letter, just lower-case it.
            case 1:
              return upperCasePrefix.toLowerCase();
            default:
              return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
          }
        });
      }
      function getStatementBuilderName(typeName) {
        return typeName = getBuilderName(typeName), typeName.replace(/(Expression)?$/, "Statement");
      }
      var namedTypes2 = {};
      function getFieldNames(object) {
        var d = defFromValue(object);
        if (d)
          return d.fieldNames.slice(0);
        if ("type" in object)
          throw new Error("did not recognize object of type " + JSON.stringify(object.type));
        return Object.keys(object);
      }
      function getFieldValue(object, fieldName) {
        var d = defFromValue(object);
        if (d) {
          var field = d.allFields[fieldName];
          if (field)
            return field.getValue(object);
        }
        return object && object[fieldName];
      }
      function eachField(object, callback, context) {
        getFieldNames(object).forEach(function(name) {
          callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function someField(object, callback, context) {
        return getFieldNames(object).some(function(name) {
          return callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);
        if (!builders[wrapperName]) {
          var wrapped = builders[getBuilderName(typeName)];
          if (wrapped) {
            var builder = function() {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return builders.expressionStatement(wrapped.apply(builders, args));
            };
            builder.from = function() {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return builders.expressionStatement(wrapped.from.apply(builders, args));
            }, builders[wrapperName] = builder;
          }
        }
      }
      function populateSupertypeList(typeName, list2) {
        list2.length = 0, list2.push(typeName);
        for (var lastSeen = /* @__PURE__ */ Object.create(null), pos2 = 0; pos2 < list2.length; ++pos2) {
          typeName = list2[pos2];
          var d = defCache[typeName];
          if (d.finalized !== !0)
            throw new Error("");
          hasOwn.call(lastSeen, typeName) && delete list2[lastSeen[typeName]], lastSeen[typeName] = pos2, list2.push.apply(list2, d.baseNames);
        }
        for (var to = 0, from2 = to, len = list2.length; from2 < len; ++from2)
          hasOwn.call(list2, from2) && (list2[to++] = list2[from2]);
        list2.length = to;
      }
      function extend(into, from2) {
        return Object.keys(from2).forEach(function(name) {
          into[name] = from2[name];
        }), into;
      }
      function finalize2() {
        Object.keys(defCache).forEach(function(name) {
          defCache[name].finalize();
        });
      }
      return {
        Type,
        builtInTypes,
        getSupertypeNames,
        computeSupertypeLookupTable,
        builders,
        defineMethod,
        getBuilderName,
        getStatementBuilderName,
        namedTypes: namedTypes2,
        getFieldNames,
        getFieldValue,
        eachField,
        someField,
        finalize: finalize2
      };
    }
    exports2.default = typesPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(types$1, types$1.exports)), types$1.exports;
}
var pathVisitor = { exports: {} }, nodePath = { exports: {} }, path$1 = { exports: {} }, hasRequiredPath;
function requirePath() {
  return hasRequiredPath || (hasRequiredPath = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_1.__importDefault(requireTypes()), Op = Object.prototype, hasOwn = Op.hasOwnProperty;
    function pathPlugin(fork2) {
      var types2 = fork2.use(types_1.default), isArray2 = types2.builtInTypes.array, isNumber2 = types2.builtInTypes.number, Path = function Path2(value, parentPath, name) {
        if (!(this instanceof Path2))
          throw new Error("Path constructor cannot be invoked without 'new'");
        if (parentPath) {
          if (!(parentPath instanceof Path2))
            throw new Error("");
        } else
          parentPath = null, name = null;
        this.value = value, this.parentPath = parentPath, this.name = name, this.__childCache = null;
      }, Pp = Path.prototype;
      function getChildCache(path2) {
        return path2.__childCache || (path2.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function getChildPath(path2, name) {
        var cache = getChildCache(path2), actualChildValue = path2.getValueProperty(name), childPath = cache[name];
        return (!hasOwn.call(cache, name) || // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) && (childPath = cache[name] = new path2.constructor(actualChildValue, path2, name)), childPath;
      }
      Pp.getValueProperty = function(name) {
        return this.value[name];
      }, Pp.get = function() {
        for (var names = [], _i = 0; _i < arguments.length; _i++)
          names[_i] = arguments[_i];
        for (var path2 = this, count2 = names.length, i = 0; i < count2; ++i)
          path2 = getChildPath(path2, names[i]);
        return path2;
      }, Pp.each = function(callback, context) {
        for (var childPaths = [], len = this.value.length, i = 0, i = 0; i < len; ++i)
          hasOwn.call(this.value, i) && (childPaths[i] = this.get(i));
        for (context = context || this, i = 0; i < len; ++i)
          hasOwn.call(childPaths, i) && callback.call(context, childPaths[i]);
      }, Pp.map = function(callback, context) {
        var result = [];
        return this.each(function(childPath) {
          result.push(callback.call(this, childPath));
        }, context), result;
      }, Pp.filter = function(callback, context) {
        var result = [];
        return this.each(function(childPath) {
          callback.call(this, childPath) && result.push(childPath);
        }, context), result;
      };
      function emptyMoves() {
      }
      function getMoves(path2, offset, start, end) {
        if (isArray2.assert(path2.value), offset === 0)
          return emptyMoves;
        var length = path2.value.length;
        if (length < 1)
          return emptyMoves;
        var argc = arguments.length;
        argc === 2 ? (start = 0, end = length) : argc === 3 ? (start = Math.max(start, 0), end = length) : (start = Math.max(start, 0), end = Math.min(end, length)), isNumber2.assert(start), isNumber2.assert(end);
        for (var moves = /* @__PURE__ */ Object.create(null), cache = getChildCache(path2), i = start; i < end; ++i)
          if (hasOwn.call(path2.value, i)) {
            var childPath = path2.get(i);
            if (childPath.name !== i)
              throw new Error("");
            var newIndex = i + offset;
            childPath.name = newIndex, moves[newIndex] = childPath, delete cache[i];
          }
        return delete cache.length, function() {
          for (var newIndex2 in moves) {
            var childPath2 = moves[newIndex2];
            if (childPath2.name !== +newIndex2)
              throw new Error("");
            cache[newIndex2] = childPath2, path2.value[newIndex2] = childPath2.value;
          }
        };
      }
      Pp.shift = function() {
        var move = getMoves(this, -1), result = this.value.shift();
        return move(), result;
      }, Pp.unshift = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        var move = getMoves(this, args.length), result = this.value.unshift.apply(this.value, args);
        return move(), result;
      }, Pp.push = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return isArray2.assert(this.value), delete getChildCache(this).length, this.value.push.apply(this.value, args);
      }, Pp.pop = function() {
        isArray2.assert(this.value);
        var cache = getChildCache(this);
        return delete cache[this.value.length - 1], delete cache.length, this.value.pop();
      }, Pp.insertAt = function(index) {
        var argc = arguments.length, move = getMoves(this, argc - 1, index);
        if (move === emptyMoves && argc <= 1)
          return this;
        index = Math.max(index, 0);
        for (var i = 1; i < argc; ++i)
          this.value[index + i - 1] = arguments[i];
        return move(), this;
      }, Pp.insertBefore = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        for (var pp = this.parentPath, argc = args.length, insertAtArgs = [this.name], i = 0; i < argc; ++i)
          insertAtArgs.push(args[i]);
        return pp.insertAt.apply(pp, insertAtArgs);
      }, Pp.insertAfter = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        for (var pp = this.parentPath, argc = args.length, insertAtArgs = [this.name + 1], i = 0; i < argc; ++i)
          insertAtArgs.push(args[i]);
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      function repairRelationshipWithParent(path2) {
        if (!(path2 instanceof Path))
          throw new Error("");
        var pp = path2.parentPath;
        if (!pp)
          return path2;
        var parentValue = pp.value, parentCache = getChildCache(pp);
        if (parentValue[path2.name] === path2.value)
          parentCache[path2.name] = path2;
        else if (isArray2.check(parentValue)) {
          var i = parentValue.indexOf(path2.value);
          i >= 0 && (parentCache[path2.name = i] = path2);
        } else
          parentValue[path2.name] = path2.value, parentCache[path2.name] = path2;
        if (parentValue[path2.name] !== path2.value)
          throw new Error("");
        if (path2.parentPath.get(path2.name) !== path2)
          throw new Error("");
        return path2;
      }
      return Pp.replace = function(replacement) {
        var results = [], parentValue = this.parentPath.value, parentCache = getChildCache(this.parentPath), count2 = arguments.length;
        if (repairRelationshipWithParent(this), isArray2.check(parentValue)) {
          for (var originalLength = parentValue.length, move = getMoves(this.parentPath, count2 - 1, this.name + 1), spliceArgs = [this.name, 1], i = 0; i < count2; ++i)
            spliceArgs.push(arguments[i]);
          var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
          if (splicedOut[0] !== this.value)
            throw new Error("");
          if (parentValue.length !== originalLength - 1 + count2)
            throw new Error("");
          if (move(), count2 === 0)
            delete this.value, delete parentCache[this.name], this.__childCache = null;
          else {
            if (parentValue[this.name] !== replacement)
              throw new Error("");
            for (this.value !== replacement && (this.value = replacement, this.__childCache = null), i = 0; i < count2; ++i)
              results.push(this.parentPath.get(this.name + i));
            if (results[0] !== this)
              throw new Error("");
          }
        } else if (count2 === 1)
          this.value !== replacement && (this.__childCache = null), this.value = parentValue[this.name] = replacement, results.push(this);
        else if (count2 === 0)
          delete parentValue[this.name], delete this.value, this.__childCache = null;
        else
          throw new Error("Could not replace path");
        return results;
      }, Path;
    }
    exports2.default = pathPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(path$1, path$1.exports)), path$1.exports;
}
var scope = { exports: {} }, hasRequiredScope;
function requireScope() {
  return hasRequiredScope || (hasRequiredScope = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_1.__importDefault(requireTypes()), hasOwn = Object.prototype.hasOwnProperty;
    function scopePlugin(fork2) {
      var types2 = fork2.use(types_1.default), Type = types2.Type, namedTypes2 = types2.namedTypes, Node = namedTypes2.Node, Expression = namedTypes2.Expression, isArray2 = types2.builtInTypes.array, b = types2.builders, Scope = function Scope2(path2, parentScope) {
        if (!(this instanceof Scope2))
          throw new Error("Scope constructor cannot be invoked without 'new'");
        TypeParameterScopeType.check(path2.value) || ScopeType.assert(path2.value);
        var depth;
        if (parentScope) {
          if (!(parentScope instanceof Scope2))
            throw new Error("");
          depth = parentScope.depth + 1;
        } else
          parentScope = null, depth = 0;
        Object.defineProperties(this, {
          path: { value: path2 },
          node: { value: path2.value },
          isGlobal: { value: !parentScope, enumerable: !0 },
          depth: { value: depth },
          parent: { value: parentScope },
          bindings: { value: {} },
          types: { value: {} }
        });
      }, ScopeType = Type.or(
        // Program nodes introduce global scopes.
        namedTypes2.Program,
        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes2.Function,
        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes2.CatchClause
      ), TypeParameterScopeType = Type.or(namedTypes2.Function, namedTypes2.ClassDeclaration, namedTypes2.ClassExpression, namedTypes2.InterfaceDeclaration, namedTypes2.TSInterfaceDeclaration, namedTypes2.TypeAlias, namedTypes2.TSTypeAliasDeclaration), FlowOrTSTypeParameterType = Type.or(namedTypes2.TypeParameter, namedTypes2.TSTypeParameter);
      Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node) || TypeParameterScopeType.check(node);
      };
      var Sp = Scope.prototype;
      Sp.didScan = !1, Sp.declares = function(name) {
        return this.scan(), hasOwn.call(this.bindings, name);
      }, Sp.declaresType = function(name) {
        return this.scan(), hasOwn.call(this.types, name);
      }, Sp.declareTemporary = function(prefix) {
        if (prefix) {
          if (!/^[a-z$_]/i.test(prefix))
            throw new Error("");
        } else
          prefix = "t$";
        prefix += this.depth.toString(36) + "$", this.scan();
        for (var index = 0; this.declares(prefix + index); )
          ++index;
        var name = prefix + index;
        return this.bindings[name] = types2.builders.identifier(name);
      }, Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());
        var bodyPath = this.path.get("body");
        return namedTypes2.BlockStatement.check(bodyPath.value) && (bodyPath = bodyPath.get("body")), bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init || null)])), identifier;
      }, Sp.scan = function(force) {
        if (force || !this.didScan) {
          for (var name in this.bindings)
            delete this.bindings[name];
          for (var name in this.types)
            delete this.types[name];
          scanScope(this.path, this.bindings, this.types), this.didScan = !0;
        }
      }, Sp.getBindings = function() {
        return this.scan(), this.bindings;
      }, Sp.getTypes = function() {
        return this.scan(), this.types;
      };
      function scanScope(path2, bindings, scopeTypes) {
        var node = path2.value;
        if (TypeParameterScopeType.check(node)) {
          var params = path2.get("typeParameters", "params");
          isArray2.check(params.value) && params.each(function(childPath) {
            addTypeParameter(childPath, scopeTypes);
          });
        }
        ScopeType.check(node) && (namedTypes2.CatchClause.check(node) ? addPattern(path2.get("param"), bindings) : recursiveScanScope(path2, bindings, scopeTypes));
      }
      function recursiveScanScope(path2, bindings, scopeTypes) {
        var node = path2.value;
        path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id && addPattern(path2.parent.get("id"), bindings), node && (isArray2.check(node) ? path2.each(function(childPath) {
          recursiveScanChild(childPath, bindings, scopeTypes);
        }) : namedTypes2.Function.check(node) ? (path2.get("params").each(function(paramPath) {
          addPattern(paramPath, bindings);
        }), recursiveScanChild(path2.get("body"), bindings, scopeTypes), recursiveScanScope(path2.get("typeParameters"), bindings, scopeTypes)) : namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node) ? addTypePattern(path2.get("id"), scopeTypes) : namedTypes2.VariableDeclarator.check(node) ? (addPattern(path2.get("id"), bindings), recursiveScanChild(path2.get("init"), bindings, scopeTypes)) : node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier" ? addPattern(
          // Esprima used to use the .name field to refer to the local
          // binding identifier for ImportSpecifier nodes, but .id for
          // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
          // ESTree/Acorn/ESpree use .local for all three node types.
          path2.get(node.local ? "local" : node.name ? "name" : "id"),
          bindings
        ) : Node.check(node) && !Expression.check(node) && types2.eachField(node, function(name, child) {
          var childPath = path2.get(name);
          if (!pathHasValue(childPath, child))
            throw new Error("");
          recursiveScanChild(childPath, bindings, scopeTypes);
        }));
      }
      function pathHasValue(path2, value) {
        return !!(path2.value === value || Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0);
      }
      function recursiveScanChild(path2, bindings, scopeTypes) {
        var node = path2.value;
        if (!(!node || Expression.check(node))) if (namedTypes2.FunctionDeclaration.check(node) && node.id !== null)
          addPattern(path2.get("id"), bindings);
        else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node) && node.id !== null)
          addPattern(path2.get("id"), bindings), recursiveScanScope(path2.get("typeParameters"), bindings, scopeTypes);
        else if (namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node))
          addTypePattern(path2.get("id"), scopeTypes);
        else if (ScopeType.check(node)) {
          if (namedTypes2.CatchClause.check(node) && // TODO Broaden this to accept any pattern.
          namedTypes2.Identifier.check(node.param)) {
            var catchParamName = node.param.name, hadBinding = hasOwn.call(bindings, catchParamName);
            recursiveScanScope(path2.get("body"), bindings, scopeTypes), hadBinding || delete bindings[catchParamName];
          }
        } else
          recursiveScanScope(path2, bindings, scopeTypes);
      }
      function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern), namedTypes2.Identifier.check(pattern) ? hasOwn.call(bindings, pattern.name) ? bindings[pattern.name].push(patternPath) : bindings[pattern.name] = [patternPath] : namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern) ? addPattern(patternPath.get("left"), bindings) : namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern) ? patternPath.get("properties").each(function(propertyPath) {
          var property = propertyPath.value;
          namedTypes2.Pattern.check(property) ? addPattern(propertyPath, bindings) : namedTypes2.Property.check(property) || namedTypes2.ObjectProperty && namedTypes2.ObjectProperty.check(property) ? addPattern(propertyPath.get("value"), bindings) : namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property) && addPattern(propertyPath.get("argument"), bindings);
        }) : namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern) ? patternPath.get("elements").each(function(elementPath) {
          var element = elementPath.value;
          namedTypes2.Pattern.check(element) ? addPattern(elementPath, bindings) : namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element) && addPattern(elementPath.get("argument"), bindings);
        }) : namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern) ? addPattern(patternPath.get("pattern"), bindings) : (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.RestElement && namedTypes2.RestElement.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) && addPattern(patternPath.get("argument"), bindings);
      }
      function addTypePattern(patternPath, types3) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern), namedTypes2.Identifier.check(pattern) && (hasOwn.call(types3, pattern.name) ? types3[pattern.name].push(patternPath) : types3[pattern.name] = [patternPath]);
      }
      function addTypeParameter(parameterPath, types3) {
        var parameter = parameterPath.value;
        FlowOrTSTypeParameterType.assert(parameter), hasOwn.call(types3, parameter.name) ? types3[parameter.name].push(parameterPath) : types3[parameter.name] = [parameterPath];
      }
      return Sp.lookup = function(name) {
        for (var scope2 = this; scope2 && !scope2.declares(name); scope2 = scope2.parent)
          ;
        return scope2;
      }, Sp.lookupType = function(name) {
        for (var scope2 = this; scope2 && !scope2.declaresType(name); scope2 = scope2.parent)
          ;
        return scope2;
      }, Sp.getGlobalScope = function() {
        for (var scope2 = this; !scope2.isGlobal; )
          scope2 = scope2.parent;
        return scope2;
      }, Scope;
    }
    exports2.default = scopePlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(scope, scope.exports)), scope.exports;
}
var hasRequiredNodePath;
function requireNodePath() {
  return hasRequiredNodePath || (hasRequiredNodePath = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), path_1 = tslib_1.__importDefault(requirePath()), scope_1 = tslib_1.__importDefault(requireScope()), shared_1 = requireShared();
    function nodePathPlugin(fork2) {
      var types2 = fork2.use(types_1.default), n = types2.namedTypes, b = types2.builders, isNumber2 = types2.builtInTypes.number, isArray2 = types2.builtInTypes.array, Path = fork2.use(path_1.default), Scope = fork2.use(scope_1.default), NodePath = function NodePath2(value, parentPath, name) {
        if (!(this instanceof NodePath2))
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        Path.call(this, value, parentPath, name);
      }, NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
          value: NodePath,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
      Object.defineProperties(NPp, {
        node: {
          get: function() {
            return Object.defineProperty(this, "node", {
              configurable: !0,
              value: this._computeNode()
            }), this.node;
          }
        },
        parent: {
          get: function() {
            return Object.defineProperty(this, "parent", {
              configurable: !0,
              value: this._computeParent()
            }), this.parent;
          }
        },
        scope: {
          get: function() {
            return Object.defineProperty(this, "scope", {
              configurable: !0,
              value: this._computeScope()
            }), this.scope;
          }
        }
      }), NPp.replace = function() {
        return delete this.node, delete this.parent, delete this.scope, Path.prototype.replace.apply(this, arguments);
      }, NPp.prune = function() {
        var remainingNodePath = this.parent;
        return this.replace(), cleanUpNodesAfterPrune(remainingNodePath);
      }, NPp._computeNode = function() {
        var value = this.value;
        if (n.Node.check(value))
          return value;
        var pp = this.parentPath;
        return pp && pp.node || null;
      }, NPp._computeParent = function() {
        var value = this.value, pp = this.parentPath;
        if (!n.Node.check(value)) {
          for (; pp && !n.Node.check(pp.value); )
            pp = pp.parentPath;
          pp && (pp = pp.parentPath);
        }
        for (; pp && !n.Node.check(pp.value); )
          pp = pp.parentPath;
        return pp || null;
      }, NPp._computeScope = function() {
        var value = this.value, pp = this.parentPath, scope2 = pp && pp.scope;
        return n.Node.check(value) && Scope.isEstablishedBy(value) && (scope2 = new Scope(this, scope2)), scope2 || null;
      }, NPp.getValueProperty = function(name) {
        return types2.getFieldValue(this.value, name);
      }, NPp.needsParens = function(assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp)
          return !1;
        var node = this.value;
        if (!n.Expression.check(node) || node.type === "Identifier")
          return !1;
        for (; !n.Node.check(pp.value); )
          if (pp = pp.parentPath, !pp)
            return !1;
        var parent = pp.value;
        switch (node.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent.type === "MemberExpression" && this.name === "object" && parent.object === node;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent.type) {
              case "CallExpression":
                return this.name === "callee" && parent.callee === node;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return !0;
              case "MemberExpression":
                return this.name === "object" && parent.object === node;
              case "BinaryExpression":
              case "LogicalExpression": {
                var n_1 = node, po = parent.operator, pp_1 = PRECEDENCE[po], no = n_1.operator, np = PRECEDENCE[no];
                if (pp_1 > np)
                  return !0;
                if (pp_1 === np && this.name === "right") {
                  if (parent.right !== n_1)
                    throw new Error("Nodes must be equal");
                  return !0;
                }
              }
              default:
                return !1;
            }
          case "SequenceExpression":
            switch (parent.type) {
              case "ForStatement":
                return !1;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return !0;
            }
          case "YieldExpression":
            switch (parent.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return !0;
              default:
                return !1;
            }
          case "Literal":
            return parent.type === "MemberExpression" && isNumber2.check(node.value) && this.name === "object" && parent.object === node;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return !0;
              case "CallExpression":
                return this.name === "callee" && parent.callee === node;
              case "ConditionalExpression":
                return this.name === "test" && parent.test === node;
              case "MemberExpression":
                return this.name === "object" && parent.object === node;
              default:
                return !1;
            }
          default:
            if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node)
              return containsCallExpression(node);
        }
        return !!(assumeExpressionContext !== !0 && !this.canBeFirstInStatement() && this.firstInStatement());
      };
      function isBinary(node) {
        return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(tier, i) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i;
        });
      });
      function containsCallExpression(node) {
        return n.CallExpression.check(node) ? !0 : isArray2.check(node) ? node.some(containsCallExpression) : n.Node.check(node) ? types2.someField(node, function(_name, child) {
          return containsCallExpression(child);
        }) : !1;
      }
      NPp.canBeFirstInStatement = function() {
        var node = this.node;
        return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
      }, NPp.firstInStatement = function() {
        return firstInStatement(this);
      };
      function firstInStatement(path2) {
        for (var node, parent; path2.parent; path2 = path2.parent) {
          if (node = path2.node, parent = path2.parent.node, n.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
            if (parent.body[0] !== node)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (n.ExpressionStatement.check(parent) && path2.name === "expression") {
            if (parent.expression !== node)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (n.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
            if (parent.expressions[0] !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.CallExpression.check(parent) && path2.name === "callee") {
            if (parent.callee !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.MemberExpression.check(parent) && path2.name === "object") {
            if (parent.object !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.ConditionalExpression.check(parent) && path2.name === "test") {
            if (parent.test !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (isBinary(parent) && path2.name === "left") {
            if (parent.left !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
            if (parent.argument !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          return !1;
        }
        return !0;
      }
      function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
          var declarations = remainingNodePath.get("declarations").value;
          if (!declarations || declarations.length === 0)
            return remainingNodePath.prune();
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
          if (!remainingNodePath.get("expression").value)
            return remainingNodePath.prune();
        } else n.IfStatement.check(remainingNodePath.node) && cleanUpIfStatementAfterPrune(remainingNodePath);
        return remainingNodePath;
      }
      function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get("test").value, alternate = ifStatement.get("alternate").value, consequent = ifStatement.get("consequent").value;
        if (!consequent && !alternate) {
          var testExpressionStatement = b.expressionStatement(testExpression);
          ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
          var negatedTestExpression = b.unaryExpression("!", testExpression, !0);
          n.UnaryExpression.check(testExpression) && testExpression.operator === "!" && (negatedTestExpression = testExpression.argument), ifStatement.get("test").replace(negatedTestExpression), ifStatement.get("consequent").replace(alternate), ifStatement.get("alternate").replace();
        }
      }
      return NodePath;
    }
    exports2.default = nodePathPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(nodePath, nodePath.exports)), nodePath.exports;
}
var hasRequiredPathVisitor;
function requirePathVisitor() {
  return hasRequiredPathVisitor || (hasRequiredPathVisitor = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), node_path_1 = tslib_1.__importDefault(requireNodePath()), shared_1 = requireShared(), hasOwn = Object.prototype.hasOwnProperty;
    function pathVisitorPlugin(fork2) {
      var types2 = fork2.use(types_1.default), NodePath = fork2.use(node_path_1.default), isArray2 = types2.builtInTypes.array, isObject2 = types2.builtInTypes.object, isFunction2 = types2.builtInTypes.function, undefined$1, PathVisitor = function PathVisitor2() {
        if (!(this instanceof PathVisitor2))
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        this._reusableContextStack = [], this._methodNameTable = computeMethodNameTable(this), this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line"), this.Context = makeContextConstructor(this), this._visiting = !1, this._changeReported = !1;
      };
      function computeMethodNameTable(visitor) {
        var typeNames = /* @__PURE__ */ Object.create(null);
        for (var methodName in visitor)
          /^visit[A-Z]/.test(methodName) && (typeNames[methodName.slice(5)] = !0);
        for (var supertypeTable = types2.computeSupertypeLookupTable(typeNames), methodNameTable = /* @__PURE__ */ Object.create(null), typeNameKeys = Object.keys(supertypeTable), typeNameCount = typeNameKeys.length, i = 0; i < typeNameCount; ++i) {
          var typeName = typeNameKeys[i];
          methodName = "visit" + supertypeTable[typeName], isFunction2.check(visitor[methodName]) && (methodNameTable[typeName] = methodName);
        }
        return methodNameTable;
      }
      PathVisitor.fromMethodsObject = function(methods) {
        if (methods instanceof PathVisitor)
          return methods;
        if (!isObject2.check(methods))
          return new PathVisitor();
        var Visitor = function Visitor2() {
          if (!(this instanceof Visitor2))
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          PathVisitor.call(this);
        }, Vp = Visitor.prototype = Object.create(PVp);
        return Vp.constructor = Visitor, extend(Vp, methods), extend(Visitor, PathVisitor), isFunction2.assert(Visitor.fromMethodsObject), isFunction2.assert(Visitor.visit), new Visitor();
      };
      function extend(target, source2) {
        for (var property in source2)
          hasOwn.call(source2, property) && (target[property] = source2[property]);
        return target;
      }
      PathVisitor.visit = function(node, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node);
      };
      var PVp = PathVisitor.prototype;
      PVp.visit = function() {
        if (this._visiting)
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        this._visiting = !0, this._changeReported = !1, this._abortRequested = !1;
        for (var argc = arguments.length, args = new Array(argc), i = 0; i < argc; ++i)
          args[i] = arguments[i];
        args[0] instanceof NodePath || (args[0] = new NodePath({ root: args[0] }).get("root")), this.reset.apply(this, args);
        var didNotThrow;
        try {
          var root2 = this.visitWithoutReset(args[0]);
          didNotThrow = !0;
        } finally {
          if (this._visiting = !1, !didNotThrow && this._abortRequested)
            return args[0].value;
        }
        return root2;
      }, PVp.AbortRequest = function() {
      }, PVp.abort = function() {
        var visitor = this;
        visitor._abortRequested = !0;
        var request = new visitor.AbortRequest();
        throw request.cancel = function() {
          visitor._abortRequested = !1;
        }, request;
      }, PVp.reset = function(_path) {
      }, PVp.visitWithoutReset = function(path2) {
        if (this instanceof this.Context)
          return this.visitor.visitWithoutReset(path2);
        if (!(path2 instanceof NodePath))
          throw new Error("");
        var value = path2.value, methodName = value && typeof value == "object" && typeof value.type == "string" && this._methodNameTable[value.type];
        if (methodName) {
          var context = this.acquireContext(path2);
          try {
            return context.invokeVisitorMethod(methodName);
          } finally {
            this.releaseContext(context);
          }
        } else
          return visitChildren(path2, this);
      };
      function visitChildren(path2, visitor) {
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(visitor instanceof PathVisitor))
          throw new Error("");
        var value = path2.value;
        if (isArray2.check(value))
          path2.each(visitor.visitWithoutReset, visitor);
        else if (isObject2.check(value)) {
          var childNames = types2.getFieldNames(value);
          visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0 && childNames.push("comments");
          for (var childCount = childNames.length, childPaths = [], i = 0; i < childCount; ++i) {
            var childName = childNames[i];
            hasOwn.call(value, childName) || (value[childName] = types2.getFieldValue(value, childName)), childPaths.push(path2.get(childName));
          }
          for (var i = 0; i < childCount; ++i)
            visitor.visitWithoutReset(childPaths[i]);
        }
        return path2.value;
      }
      PVp.acquireContext = function(path2) {
        return this._reusableContextStack.length === 0 ? new this.Context(path2) : this._reusableContextStack.pop().reset(path2);
      }, PVp.releaseContext = function(context) {
        if (!(context instanceof this.Context))
          throw new Error("");
        this._reusableContextStack.push(context), context.currentPath = null;
      }, PVp.reportChanged = function() {
        this._changeReported = !0;
      }, PVp.wasChangeReported = function() {
        return this._changeReported;
      };
      function makeContextConstructor(visitor) {
        function Context2(path2) {
          if (!(this instanceof Context2))
            throw new Error("");
          if (!(this instanceof PathVisitor))
            throw new Error("");
          if (!(path2 instanceof NodePath))
            throw new Error("");
          Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: !1,
            enumerable: !0,
            configurable: !1
          }), this.currentPath = path2, this.needToCallTraverse = !0, Object.seal(this);
        }
        if (!(visitor instanceof PathVisitor))
          throw new Error("");
        var Cp = Context2.prototype = Object.create(visitor);
        return Cp.constructor = Context2, extend(Cp, sharedContextProtoMethods), Context2;
      }
      var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
      return sharedContextProtoMethods.reset = function(path2) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        return this.currentPath = path2, this.needToCallTraverse = !0, this;
      }, sharedContextProtoMethods.invokeVisitorMethod = function(methodName) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        var result = this.visitor[methodName].call(this, this.currentPath);
        if (result === !1 ? this.needToCallTraverse = !1 : result !== undefined$1 && (this.currentPath = this.currentPath.replace(result)[0], this.needToCallTraverse && this.traverse(this.currentPath)), this.needToCallTraverse !== !1)
          throw new Error("Must either call this.traverse or return false in " + methodName);
        var path2 = this.currentPath;
        return path2 && path2.value;
      }, sharedContextProtoMethods.traverse = function(path2, newVisitor) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        return this.needToCallTraverse = !1, visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
      }, sharedContextProtoMethods.visit = function(path2, newVisitor) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        return this.needToCallTraverse = !1, PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
      }, sharedContextProtoMethods.reportChanged = function() {
        this.visitor.reportChanged();
      }, sharedContextProtoMethods.abort = function() {
        this.needToCallTraverse = !1, this.visitor.abort();
      }, PathVisitor;
    }
    exports2.default = pathVisitorPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(pathVisitor, pathVisitor.exports)), pathVisitor.exports;
}
var equiv = { exports: {} }, hasRequiredEquiv;
function requireEquiv() {
  return hasRequiredEquiv || (hasRequiredEquiv = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_1.__importDefault(requireTypes());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), getFieldNames = types2.getFieldNames, getFieldValue = types2.getFieldValue, isArray2 = types2.builtInTypes.array, isObject2 = types2.builtInTypes.object, isDate2 = types2.builtInTypes.Date, isRegExp = types2.builtInTypes.RegExp, hasOwn = Object.prototype.hasOwnProperty;
      function astNodesAreEquivalent(a, b, problemPath) {
        return isArray2.check(problemPath) ? problemPath.length = 0 : problemPath = null, areEquivalent(a, b, problemPath);
      }
      astNodesAreEquivalent.assert = function(a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath))
          if (problemPath.length === 0) {
            if (a !== b)
              throw new Error("Nodes must be equal");
          } else
            throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
      };
      function subscriptForProperty(property) {
        return /[_$a-z][_$a-z0-9]*/i.test(property) ? "." + property : "[" + JSON.stringify(property) + "]";
      }
      function areEquivalent(a, b, problemPath) {
        return a === b ? !0 : isArray2.check(a) ? arraysAreEquivalent(a, b, problemPath) : isObject2.check(a) ? objectsAreEquivalent(a, b, problemPath) : isDate2.check(a) ? isDate2.check(b) && +a == +b : isRegExp.check(a) ? isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase : a == b;
      }
      function arraysAreEquivalent(a, b, problemPath) {
        isArray2.assert(a);
        var aLength = a.length;
        if (!isArray2.check(b) || b.length !== aLength)
          return problemPath && problemPath.push("length"), !1;
        for (var i = 0; i < aLength; ++i) {
          if (problemPath && problemPath.push(i), i in a != i in b || !areEquivalent(a[i], b[i], problemPath))
            return !1;
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== i)
              throw new Error("" + problemPathTail);
          }
        }
        return !0;
      }
      function objectsAreEquivalent(a, b, problemPath) {
        if (isObject2.assert(a), !isObject2.check(b))
          return !1;
        if (a.type !== b.type)
          return problemPath && problemPath.push("type"), !1;
        var aNames = getFieldNames(a), aNameCount = aNames.length, bNames = getFieldNames(b), bNameCount = bNames.length;
        if (aNameCount === bNameCount) {
          for (var i = 0; i < aNameCount; ++i) {
            var name = aNames[i], aChild = getFieldValue(a, name), bChild = getFieldValue(b, name);
            if (problemPath && problemPath.push(name), !areEquivalent(aChild, bChild, problemPath))
              return !1;
            if (problemPath) {
              var problemPathTail = problemPath.pop();
              if (problemPathTail !== name)
                throw new Error("" + problemPathTail);
            }
          }
          return !0;
        }
        if (!problemPath)
          return !1;
        var seenNames = /* @__PURE__ */ Object.create(null);
        for (i = 0; i < aNameCount; ++i)
          seenNames[aNames[i]] = !0;
        for (i = 0; i < bNameCount; ++i) {
          if (name = bNames[i], !hasOwn.call(seenNames, name))
            return problemPath.push(name), !1;
          delete seenNames[name];
        }
        for (name in seenNames) {
          problemPath.push(name);
          break;
        }
        return !1;
      }
      return astNodesAreEquivalent;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(equiv, equiv.exports)), equiv.exports;
}
var hasRequiredFork;
function requireFork() {
  return hasRequiredFork || (hasRequiredFork = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), path_visitor_1 = tslib_1.__importDefault(requirePathVisitor()), equiv_1 = tslib_1.__importDefault(requireEquiv()), path_1 = tslib_1.__importDefault(requirePath()), node_path_1 = tslib_1.__importDefault(requireNodePath()), shared_1 = requireShared();
    function default_1(plugins) {
      var fork2 = createFork(), types2 = fork2.use(types_1.default);
      plugins.forEach(fork2.use), types2.finalize();
      var PathVisitor = fork2.use(path_visitor_1.default);
      return {
        Type: types2.Type,
        builtInTypes: types2.builtInTypes,
        namedTypes: types2.namedTypes,
        builders: types2.builders,
        defineMethod: types2.defineMethod,
        getFieldNames: types2.getFieldNames,
        getFieldValue: types2.getFieldValue,
        eachField: types2.eachField,
        someField: types2.someField,
        getSupertypeNames: types2.getSupertypeNames,
        getBuilderName: types2.getBuilderName,
        astNodesAreEquivalent: fork2.use(equiv_1.default),
        finalize: types2.finalize,
        Path: fork2.use(path_1.default),
        NodePath: fork2.use(node_path_1.default),
        PathVisitor,
        use: fork2.use,
        visit: PathVisitor.visit
      };
    }
    exports2.default = default_1;
    function createFork() {
      var used = [], usedResult = [];
      function use(plugin) {
        var idx = used.indexOf(plugin);
        return idx === -1 && (idx = used.length, used.push(plugin), usedResult[idx] = plugin(fork2)), usedResult[idx];
      }
      var fork2 = { use };
      return fork2;
    }
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(fork, fork.exports)), fork.exports;
}
var esProposals = { exports: {} }, es2022 = { exports: {} }, es2021$1 = { exports: {} }, es2021 = { exports: {} }, es2020$1 = { exports: {} }, es2016$1 = { exports: {} }, core$1 = { exports: {} }, hasRequiredCore$1;
function requireCore$1() {
  return hasRequiredCore$1 || (hasRequiredCore$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var shared_1 = requireShared();
    function default_1() {
      return {
        BinaryOperators: [
          "==",
          "!=",
          "===",
          "!==",
          "<",
          "<=",
          ">",
          ">=",
          "<<",
          ">>",
          ">>>",
          "+",
          "-",
          "*",
          "/",
          "%",
          "&",
          "|",
          "^",
          "in",
          "instanceof"
        ],
        AssignmentOperators: [
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "|=",
          "^=",
          "&="
        ],
        LogicalOperators: [
          "||",
          "&&"
        ]
      };
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(core$1, core$1.exports)), core$1.exports;
}
var hasRequiredEs2016$1;
function requireEs2016$1() {
  return hasRequiredEs2016$1 || (hasRequiredEs2016$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), core_1 = tslib_1.__importDefault(requireCore$1());
    function default_1(fork2) {
      var result = fork2.use(core_1.default);
      return result.BinaryOperators.indexOf("**") < 0 && result.BinaryOperators.push("**"), result.AssignmentOperators.indexOf("**=") < 0 && result.AssignmentOperators.push("**="), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2016$1, es2016$1.exports)), es2016$1.exports;
}
var hasRequiredEs2020$1;
function requireEs2020$1() {
  return hasRequiredEs2020$1 || (hasRequiredEs2020$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), es2016_1 = tslib_1.__importDefault(requireEs2016$1());
    function default_1(fork2) {
      var result = fork2.use(es2016_1.default);
      return result.LogicalOperators.indexOf("??") < 0 && result.LogicalOperators.push("??"), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2020$1, es2020$1.exports)), es2020$1.exports;
}
var hasRequiredEs2021$1;
function requireEs2021$1() {
  return hasRequiredEs2021$1 || (hasRequiredEs2021$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), es2020_1 = tslib_1.__importDefault(requireEs2020$1());
    function default_1(fork2) {
      var result = fork2.use(es2020_1.default);
      return result.LogicalOperators.forEach(function(op) {
        var assignOp = op + "=";
        result.AssignmentOperators.indexOf(assignOp) < 0 && result.AssignmentOperators.push(assignOp);
      }), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2021, es2021.exports)), es2021.exports;
}
var es2020 = { exports: {} }, es2019 = { exports: {} }, es2018 = { exports: {} }, es2017 = { exports: {} }, es2016 = { exports: {} }, es6 = { exports: {} }, core = { exports: {} }, hasRequiredCore;
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, core_1 = tslib_1.__importDefault(requireCore$1()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), Type = types2.Type, def = Type.def, or = Type.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults, geq = shared2.geq, _a = fork2.use(core_1.default), BinaryOperators = _a.BinaryOperators, AssignmentOperators = _a.AssignmentOperators, LogicalOperators = _a.LogicalOperators;
      def("Printable").field("loc", or(def("SourceLocation"), null), defaults2.null, !0), def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults2.null, !0), def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults2.null), def("Position").field("line", geq(1)).field("column", geq(0)), def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults2.null), def("Program").bases("Node").build("body").field("body", [def("Statement")]), def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults2.null).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults2.false).field("async", Boolean, defaults2.false), def("Statement").bases("Node"), def("EmptyStatement").bases("Statement").build(), def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]), def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression")), def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults2.null), def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement")), def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2.null), def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2.null), def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement")), def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults2.false), def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null)), def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression")), def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, !0).field("guardedHandlers", [def("CatchClause")], defaults2.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults2.null), def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults2.null).field("body", def("BlockStatement")), def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement")), def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression")), def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement")), def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement")), def("DebuggerStatement").bases("Statement").build(), def("Declaration").bases("Statement"), def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier")), def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body"), def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]), def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults2.null), def("Expression").bases("Node"), def("ThisExpression").bases("Expression").build(), def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]), def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]), def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression")), def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
      var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
      def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults2.true);
      var BinaryOperator = or.apply(void 0, BinaryOperators);
      def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
      var AssignmentOperator = or.apply(void 0, AssignmentOperators);
      def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
      var UpdateOperator = or("++", "--");
      def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
      var LogicalOperator = or.apply(void 0, LogicalOperators);
      def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression")), def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression")), def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]), def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]), def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
        var type2 = this.property.type;
        return type2 === "Literal" || type2 === "MemberExpression" || type2 === "BinaryExpression";
      }), def("Pattern").bases("Node"), def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]), def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults2.false), def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp, BigInt)), def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults2.true).field("trailing", Boolean, defaults2.false);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(core, core.exports)), core.exports;
}
var hasRequiredEs6;
function requireEs6() {
  return hasRequiredEs6 || (hasRequiredEs6 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, core_1 = tslib_1.__importDefault(requireCore()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(core_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("generator", Boolean, defaults2.false).field("expression", Boolean, defaults2.false).field("defaults", [or(def("Expression"), null)], defaults2.emptyArray).field("rest", or(def("Identifier"), null), defaults2.null), def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field(
        "typeAnnotation",
        // for Babylon. Flow parser puts it on the identifier
        or(def("TypeAnnotation"), def("TSTypeAnnotation"), null),
        defaults2.null
      ), def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern")), def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def("Identifier"), null)), def("FunctionExpression").build("id", "params", "body", "generator", "expression"), def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults2.null).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", !1, defaults2.false), def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement")), def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults2.false), def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null)), def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null)), def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean), def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults2.false).field("shorthand", Boolean, defaults2.false).field("computed", Boolean, defaults2.false), def("ObjectProperty").field("shorthand", Boolean, defaults2.false), def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults2.false), def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]), def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]), def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression")), def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]), def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]), def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]), def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression")), def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults2.false).field("static", Boolean, defaults2.false);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("StaticBlock"));
      def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults2.false), def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement), def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]), def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults2.null), def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults2.null).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults2.null), def("Super").bases("Expression").build(), def("Specifier").bases("Node"), def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults2.null).field("id", or(def("Identifier"), null), defaults2.null).field("name", or(def("Identifier"), null), defaults2.null), def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier")), def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local"), def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local"), def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults2.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
        return "value";
      }), def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2.null), def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier")), def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression"))), def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal")), def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral")), def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]), def("TemplateElement").bases("Node").build("value", "tail").field("value", { cooked: String, raw: String }).field("tail", Boolean), def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es6, es6.exports)), es6.exports;
}
var hasRequiredEs2016;
function requireEs2016() {
  return hasRequiredEs2016 || (hasRequiredEs2016 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2016_1 = tslib_1.__importDefault(requireEs2016$1()), es6_1 = tslib_1.__importDefault(requireEs6()), shared_1 = requireShared();
    function default_1(fork2) {
      fork2.use(es2016_1.default), fork2.use(es6_1.default);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2016, es2016.exports)), es2016.exports;
}
var hasRequiredEs2017;
function requireEs2017() {
  return hasRequiredEs2017 || (hasRequiredEs2017 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2016_1 = tslib_1.__importDefault(requireEs2016()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2016_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("async", Boolean, defaults2.false), def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2017, es2017.exports)), es2017.exports;
}
var hasRequiredEs2018;
function requireEs2018() {
  return hasRequiredEs2018 || (hasRequiredEs2018 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2017_1 = tslib_1.__importDefault(requireEs2017()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2017_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("ForOfStatement").field("await", Boolean, defaults2.false), def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression")), def("ObjectExpression").field("properties", [or(
        def("Property"),
        def("SpreadProperty"),
        // Legacy
        def("SpreadElement")
      )]), def("TemplateElement").field("value", { cooked: or(String, null), raw: String }), def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern")), def("ObjectPattern").field("properties", [or(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2018, es2018.exports)), es2018.exports;
}
var hasRequiredEs2019;
function requireEs2019() {
  return hasRequiredEs2019 || (hasRequiredEs2019 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2018_1 = tslib_1.__importDefault(requireEs2018()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2018_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("CatchClause").field("param", or(def("Pattern"), null), defaults2.null);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2019, es2019.exports)), es2019.exports;
}
var hasRequiredEs2020;
function requireEs2020() {
  return hasRequiredEs2020 || (hasRequiredEs2020 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2020_1 = tslib_1.__importDefault(requireEs2020$1()), es2019_1 = tslib_1.__importDefault(requireEs2019()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2020_1.default), fork2.use(es2019_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults;
      def("ImportExpression").bases("Expression").build("source").field("source", def("Expression")), def("ExportAllDeclaration").bases("Declaration").build("source", "exported").field("source", def("Literal")).field("exported", or(def("Identifier"), null, void 0), defaults2.null), def("ChainElement").bases("Node").field("optional", Boolean, defaults2.false), def("CallExpression").bases("Expression", "ChainElement"), def("MemberExpression").bases("Expression", "ChainElement"), def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement")), def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults2.true), def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults2.true);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2020, es2020.exports)), es2020.exports;
}
var hasRequiredEs2021;
function requireEs2021() {
  return hasRequiredEs2021 || (hasRequiredEs2021 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2021_1 = tslib_1.__importDefault(requireEs2021$1()), es2020_1 = tslib_1.__importDefault(requireEs2020()), shared_1 = requireShared();
    function default_1(fork2) {
      fork2.use(es2021_1.default), fork2.use(es2020_1.default);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2021$1, es2021$1.exports)), es2021$1.exports;
}
var hasRequiredEs2022;
function requireEs2022() {
  return hasRequiredEs2022 || (hasRequiredEs2022 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es2021_1 = tslib_1.__importDefault(requireEs2021()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = requireShared();
    function default_1(fork2) {
      fork2.use(es2021_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def;
      def("StaticBlock").bases("Declaration").build("body").field("body", [def("Statement")]);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2022, es2022.exports)), es2022.exports;
}
var hasRequiredEsProposals;
function requireEsProposals() {
  return hasRequiredEsProposals || (hasRequiredEsProposals = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared()), es2022_1 = tslib_1.__importDefault(requireEs2022());
    function default_1(fork2) {
      fork2.use(es2022_1.default);
      var types2 = fork2.use(types_1.default), Type = types2.Type, def = types2.Type.def, or = Type.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults;
      def("AwaitExpression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults2.false), def("Decorator").bases("Node").build("expression").field("expression", def("Expression")), def("Property").field("decorators", or([def("Decorator")], null), defaults2.null), def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults2.null), def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier")), def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults2.null), def("ImportAttribute").bases("Node").build("key", "value").field("key", or(def("Identifier"), def("Literal"))).field("value", def("Expression")), [
        "ImportDeclaration",
        "ExportAllDeclaration",
        "ExportNamedDeclaration"
      ].forEach(function(decl) {
        def(decl).field("assertions", [def("ImportAttribute")], defaults2.emptyArray);
      }), def("RecordExpression").bases("Expression").build("properties").field("properties", [or(def("ObjectProperty"), def("ObjectMethod"), def("SpreadElement"))]), def("TupleExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), def("SpreadElement"), null)]), def("ModuleExpression").bases("Node").build("body").field("body", def("Program"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(esProposals, esProposals.exports)), esProposals.exports;
}
var jsx = { exports: {} }, hasRequiredJsx;
function requireJsx() {
  return hasRequiredJsx || (hasRequiredJsx = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es_proposals_1 = tslib_1.__importDefault(requireEsProposals()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es_proposals_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(
        def("Literal"),
        // attr="value"
        def("JSXExpressionContainer"),
        // attr={value}
        def("JSXElement"),
        // attr=<div />
        def("JSXFragment"),
        // attr=<></>
        null
        // attr= or just attr
      ), defaults2.null), def("JSXIdentifier").bases("Identifier").build("name").field("name", String), def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier")), def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults2.false);
      var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
      def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
      var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
      def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or(def("Expression"), def("JSXEmptyExpression")));
      var JSXChildren = [or(
        def("JSXText"),
        def("JSXExpressionContainer"),
        def("JSXSpreadChild"),
        def("JSXElement"),
        def("JSXFragment"),
        def("Literal")
        // Legacy: Esprima should return JSXText instead.
      )];
      def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults2.null).field("children", JSXChildren, defaults2.emptyArray).field("name", JSXElementName, function() {
        return this.openingElement.name;
      }, !0).field("selfClosing", Boolean, function() {
        return this.openingElement.selfClosing;
      }, !0).field("attributes", JSXAttributes, function() {
        return this.openingElement.attributes;
      }, !0), def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults2.emptyArray).field("selfClosing", Boolean, defaults2.false), def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName), def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults2.emptyArray), def("JSXOpeningFragment").bases("Node").build(), def("JSXClosingFragment").bases("Node").build(), def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
        return this.value;
      }), def("JSXEmptyExpression").bases("Node").build(), def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(jsx, jsx.exports)), jsx.exports;
}
var flow = { exports: {} }, typeAnnotations = { exports: {} }, hasRequiredTypeAnnotations;
function requireTypeAnnotations() {
  return hasRequiredTypeAnnotations || (hasRequiredTypeAnnotations = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults, TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null), TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
      def("Identifier").field("typeAnnotation", TypeAnnotation, defaults2.null), def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults2.null), def("Function").field("returnType", TypeAnnotation, defaults2.null).field("typeParameters", TypeParamDecl, defaults2.null), def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults2.false).field("typeAnnotation", TypeAnnotation, defaults2.null), [
        "ClassDeclaration",
        "ClassExpression"
      ].forEach(function(typeName) {
        def(typeName).field("typeParameters", TypeParamDecl, defaults2.null).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults2.null).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults2.emptyArray);
      });
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(typeAnnotations, typeAnnotations.exports)), typeAnnotations.exports;
}
var hasRequiredFlow;
function requireFlow() {
  return hasRequiredFlow || (hasRequiredFlow = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es_proposals_1 = tslib_1.__importDefault(requireEsProposals()), type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es_proposals_1.default), fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("Flow").bases("Node"), def("FlowType").bases("Flow"), def("AnyTypeAnnotation").bases("FlowType").build(), def("EmptyTypeAnnotation").bases("FlowType").build(), def("MixedTypeAnnotation").bases("FlowType").build(), def("VoidTypeAnnotation").bases("FlowType").build(), def("SymbolTypeAnnotation").bases("FlowType").build(), def("NumberTypeAnnotation").bases("FlowType").build(), def("BigIntTypeAnnotation").bases("FlowType").build(), def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String), def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String), def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String), def("StringTypeAnnotation").bases("FlowType").build(), def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String), def("BooleanTypeAnnotation").bases("FlowType").build(), def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String), def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType")), def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType")), def("NullLiteralTypeAnnotation").bases("FlowType").build(), def("NullTypeAnnotation").bases("FlowType").build(), def("ThisTypeAnnotation").bases("FlowType").build(), def("ExistsTypeAnnotation").bases("FlowType").build(), def("ExistentialTypeParam").bases("FlowType").build(), def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null)), def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean), def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType")), def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
        or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))
      ]).field("indexers", [def("ObjectTypeIndexer")], defaults2.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults2.emptyArray).field("inexact", or(Boolean, void 0), defaults2.undefined).field("exact", Boolean, defaults2.false).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults2.emptyArray), def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
      var LegacyVariance = or(def("Variance"), "plus", "minus", null);
      def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults2.null), def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults2.null).field("static", Boolean, defaults2.false), def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults2.false), def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier")), def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null)), def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation"))), def("IndexedAccessType").bases("FlowType").build("objectType", "indexType").field("objectType", def("FlowType")).field("indexType", def("FlowType")), def("OptionalIndexedAccessType").bases("FlowType").build("objectType", "indexType", "optional").field("objectType", def("FlowType")).field("indexType", def("FlowType")).field("optional", Boolean), def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]), def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]), def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType")), def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType")), def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean), def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]), def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]), def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults2.null).field("bound", or(def("TypeAnnotation"), null), defaults2.null).field("default", or(def("FlowType"), null), defaults2.null), def("ClassProperty").field("variance", LegacyVariance, defaults2.null), def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults2.null).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults2.null), def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults2.null), def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults2.null).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]), def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends"), def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults2.null), def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType")), def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right"), def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or(def("FlowType"), null)), def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or(def("FlowType"), null)), def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation")), def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]), def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier")), def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or(def("FlowPredicate"), null), defaults2.null), def("DeclareClass").bases("InterfaceDeclaration").build("id"), def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement")), def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation")), def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("FlowType"),
        // Implies default.
        def("TypeAlias"),
        // Implies named type
        def("DeclareOpaqueType"),
        // Implies named opaque type
        def("InterfaceDeclaration"),
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2.null), def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults2.null), def("ImportDeclaration").field("importKind", or("value", "type", "typeof"), function() {
        return "value";
      }), def("FlowPredicate").bases("Flow"), def("InferredPredicate").bases("FlowPredicate").build(), def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression")), def("Function").field("predicate", or(def("FlowPredicate"), null), defaults2.null), def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults2.null), def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults2.null), def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody"))), def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean), def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean), def("EnumStringBody").build("members", "explicitType").field("members", or([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean), def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]), def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or(def("Literal"), Boolean)), def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal")), def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal")), def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(flow, flow.exports)), flow.exports;
}
var esprima$3 = { exports: {} }, hasRequiredEsprima$2;
function requireEsprima$2() {
  return hasRequiredEsprima$2 || (hasRequiredEsprima$2 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es_proposals_1 = tslib_1.__importDefault(requireEsProposals()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es_proposals_1.default);
      var types2 = fork2.use(types_1.default), defaults2 = fork2.use(shared_1.default).defaults, def = types2.Type.def, or = types2.Type.or;
      def("VariableDeclaration").field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier")
        // Esprima deviation.
      )]), def("Property").field("value", or(
        def("Expression"),
        def("Pattern")
        // Esprima deviation.
      )), def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]), def("ObjectPattern").field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty")
        // Used by Esprima.
      )]), def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name"), def("ExportBatchSpecifier").bases("Specifier").build(), def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("Declaration"),
        def("Expression"),
        // Implies default.
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2.null), def("Block").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), def("Line").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(esprima$3, esprima$3.exports)), esprima$3.exports;
}
var babel$1 = { exports: {} }, babelCore = { exports: {} }, hasRequiredBabelCore;
function requireBabelCore() {
  return hasRequiredBabelCore || (hasRequiredBabelCore = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, es_proposals_1 = tslib_1.__importDefault(requireEsProposals()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      var _a, _b, _c, _d, _e;
      fork2.use(es_proposals_1.default);
      var types2 = fork2.use(types_1.default), defaults2 = fork2.use(shared_1.default).defaults, def = types2.Type.def, or = types2.Type.or, isUndefined = types2.builtInTypes.undefined;
      def("Noop").bases("Statement").build(), def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]), def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression")), def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression")), def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier")), def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier")), def("CommentBlock").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), def("CommentLine").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral")), def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults2["use strict"]), def("InterpreterDirective").bases("Node").build("value").field("value", String), def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults2.emptyArray), def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults2.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults2.null);
      function makeLiteralExtra(rawValueType, toRaw) {
        return rawValueType === void 0 && (rawValueType = String), [
          "extra",
          {
            rawValue: rawValueType,
            raw: String
          },
          function() {
            var value = types2.getFieldValue(this, "value");
            return {
              rawValue: value,
              raw: toRaw ? toRaw(value) : String(value)
            };
          }
        ];
      }
      (_a = def("StringLiteral").bases("Literal").build("value").field("value", String)).field.apply(_a, makeLiteralExtra(String, function(val) {
        return JSON.stringify(val);
      })), (_b = def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults2.null)).field.apply(_b, makeLiteralExtra(Number)), (_c = def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number))).field.apply(_c, makeLiteralExtra(String, function(val) {
        return val + "n";
      })), (_d = def("DecimalLiteral").bases("Literal").build("value").field("value", String)).field.apply(_d, makeLiteralExtra(String, function(val) {
        return val + "m";
      })), def("NullLiteral").bases("Literal").build().field("value", null, defaults2.null), def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean), (_e = def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
        return new RegExp(this.pattern, this.flags);
      })).field.apply(_e, makeLiteralExtra(or(RegExp, isUndefined), function(exp) {
        return "/".concat(exp.pattern, "/").concat(exp.flags || "");
      })).field("regex", {
        pattern: String,
        flags: String
      }, function() {
        return {
          pattern: this.pattern,
          flags: this.flags
        };
      });
      var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]), def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults2.false).field("generator", Boolean, defaults2.false).field("async", Boolean, defaults2.false).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults2.null
      ).field("decorators", or([def("Decorator")], null), defaults2.null), def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults2.null
      ).field("computed", Boolean, defaults2.false);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("ClassAccessorProperty"), def("StaticBlock"));
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]), def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression"))), def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName")), def("ClassAccessorProperty").bases("Declaration").build("key", "value", "decorators", "computed", "static").field("key", or(
        def("Literal"),
        def("Identifier"),
        def("PrivateName"),
        // Only when .computed is true (TODO enforce this)
        def("Expression")
      )).field("value", or(def("Expression"), null), defaults2.null), [
        "ClassMethod",
        "ClassPrivateMethod"
      ].forEach(function(typeName) {
        def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
          return "method";
        }).field("body", def("BlockStatement")).field("access", or("public", "private", "protected", null), defaults2.null);
      }), [
        "ClassMethod",
        "ClassPrivateMethod",
        "ClassAccessorProperty"
      ].forEach(function(typeName) {
        def(typeName).field("computed", Boolean, defaults2.false).field("static", Boolean, defaults2.false).field("abstract", Boolean, defaults2.false).field("accessibility", or("public", "private", "protected", null), defaults2.null).field("decorators", or([def("Decorator")], null), defaults2.null).field("definite", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("override", Boolean, defaults2.false).field("readonly", Boolean, defaults2.false);
      });
      var ObjectPatternProperty = or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty"),
        // Used by Esprima
        def("ObjectProperty"),
        // Babel 6
        def("RestProperty"),
        // Babel 6
        def("RestElement")
      );
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults2.null), def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression")), def("RestProperty").bases("Node").build("argument").field("argument", def("Expression")), def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement")), def("Import").bases("Expression").build();
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(babelCore, babelCore.exports)), babelCore.exports;
}
var hasRequiredBabel$1;
function requireBabel$1() {
  return hasRequiredBabel$1 || (hasRequiredBabel$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), babel_core_1 = tslib_1.__importDefault(requireBabelCore()), flow_1 = tslib_1.__importDefault(requireFlow()), shared_1 = requireShared();
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), def = types2.Type.def;
      fork2.use(babel_core_1.default), fork2.use(flow_1.default), def("V8IntrinsicIdentifier").bases("Expression").build("name").field("name", String), def("TopicReference").bases("Expression").build();
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(babel$1, babel$1.exports)), babel$1.exports;
}
var typescript$2 = { exports: {} }, hasRequiredTypescript$1;
function requireTypescript$1() {
  return hasRequiredTypescript$1 || (hasRequiredTypescript$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, babel_core_1 = tslib_1.__importDefault(requireBabelCore()), type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(babel_core_1.default), fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default), n = types2.namedTypes, def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults, StringLiteral = types2.Type.from(function(value, deep) {
        return !!(n.StringLiteral && n.StringLiteral.check(value, deep) || n.Literal && n.Literal.check(value, deep) && typeof value.value == "string");
      }, "StringLiteral");
      def("TSType").bases("Node");
      var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
      def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName), def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults2.null), def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults2.null), def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults2.null), def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName), def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults2.null), def("TSTypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")), def("TSSatisfiesExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")), def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression")), [
        "TSAnyKeyword",
        "TSBigIntKeyword",
        "TSBooleanKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword",
        "TSIntrinsicKeyword",
        "TSThisType"
      ].forEach(function(keywordType) {
        def(keywordType).bases("TSType").build();
      }), def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType")), def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression"), def("BigIntLiteral"))), def("TemplateLiteral").field("expressions", or([def("Expression")], [def("TSType")])), [
        "TSUnionType",
        "TSIntersectionType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
      }), def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType")), def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter")), def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
      [
        "TSFunctionType",
        "TSConstructorType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
      }), def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults2.false).field("async", Boolean, defaults2.false).field("generator", Boolean, defaults2.false).field("id", or(def("Identifier"), null), defaults2.null).field("params", [def("Pattern")]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults2.null), def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults2.false).field("generator", Boolean, defaults2.false).field("params", [def("Pattern")]).field("abstract", Boolean, defaults2.false).field("accessibility", or("public", "private", "protected", void 0), defaults2.undefined).field("static", Boolean, defaults2.false).field("computed", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("key", or(
        def("Identifier"),
        def("StringLiteral"),
        def("NumericLiteral"),
        // Only allowed if .computed is true.
        def("Expression")
      )).field("kind", or("get", "set", "method", "constructor"), function() {
        return "method";
      }).field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults2.undefined
      ).field("decorators", or([def("Decorator")], null), defaults2.null).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults2.null), def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults2.false).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults2.false).field("typeAnnotation", or(def("TSType"), null), defaults2.null), def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]), def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults2.false).field("elementType", def("TSType")), def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType")), def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType")), def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType")), def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType")), def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation"))), def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults2.false), def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults2.false).field("readonly", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("initializer", or(def("Expression"), null), defaults2.null), def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("parameters", ParametersType), def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults2.null).field("asserts", Boolean, defaults2.false), [
        "TSCallSignatureDeclaration",
        "TSConstructSignatureDeclaration"
      ].forEach(function(typeName) {
        def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
      }), def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults2.null), def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
      var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
      def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]), def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", or(def("Identifier"), String)).field("constraint", or(def("TSType"), void 0), defaults2.undefined).field("default", or(def("TSType"), void 0), defaults2.undefined), def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults2.null), def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]), def("TSInstantiationExpression").bases("Expression", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", def("Expression")), def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]), def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults2.false).field("declare", Boolean, defaults2.false).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults2.null), def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults2.false).field("typeAnnotation", def("TSType")), def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]), def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults2.false).field("global", Boolean, defaults2.false).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults2.null), def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults2.undefined), def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults2.false).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference"))), def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral), def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression")), def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier")), def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]), def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName), def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults2.false).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults2.null).field("body", def("TSInterfaceBody")), def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults2.undefined).field("readonly", Boolean, defaults2.false).field("parameter", or(def("Identifier"), def("AssignmentPattern"))), def("ClassProperty").field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults2.undefined
      ), def("ClassAccessorProperty").bases("Declaration", "TSHasOptionalTypeAnnotation"), def("ClassBody").field("body", [or(
        def("MethodDefinition"),
        def("VariableDeclarator"),
        def("ClassPropertyDefinition"),
        def("ClassProperty"),
        def("ClassPrivateProperty"),
        def("ClassAccessorProperty"),
        def("ClassMethod"),
        def("ClassPrivateMethod"),
        def("StaticBlock"),
        // Just need to add these types:
        def("TSDeclareMethod"),
        TSTypeMember
      )]);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(typescript$2, typescript$2.exports)), typescript$2.exports;
}
var namedTypes = {}, hasRequiredNamedTypes;
function requireNamedTypes() {
  return hasRequiredNamedTypes || (hasRequiredNamedTypes = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.namedTypes = void 0, exports2.namedTypes || (exports2.namedTypes = {});
  }(namedTypes)), namedTypes;
}
var hasRequiredMain$2;
function requireMain$2() {
  return hasRequiredMain$2 || (hasRequiredMain$2 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.visit = exports2.use = exports2.Type = exports2.someField = exports2.PathVisitor = exports2.Path = exports2.NodePath = exports2.namedTypes = exports2.getSupertypeNames = exports2.getFieldValue = exports2.getFieldNames = exports2.getBuilderName = exports2.finalize = exports2.eachField = exports2.defineMethod = exports2.builtInTypes = exports2.builders = exports2.astNodesAreEquivalent = void 0;
    var tslib_1 = require$$0$3, fork_1 = tslib_1.__importDefault(requireFork()), es_proposals_1 = tslib_1.__importDefault(requireEsProposals()), jsx_1 = tslib_1.__importDefault(requireJsx()), flow_1 = tslib_1.__importDefault(requireFlow()), esprima_1 = tslib_1.__importDefault(requireEsprima$2()), babel_1 = tslib_1.__importDefault(requireBabel$1()), typescript_1 = tslib_1.__importDefault(requireTypescript$1()), namedTypes_1 = requireNamedTypes();
    Object.defineProperty(exports2, "namedTypes", { enumerable: !0, get: function() {
      return namedTypes_1.namedTypes;
    } });
    var _a = (0, fork_1.default)([
      // Feel free to add to or remove from this list of extension modules to
      // configure the precise type hierarchy that you need.
      es_proposals_1.default,
      jsx_1.default,
      flow_1.default,
      esprima_1.default,
      babel_1.default,
      typescript_1.default
    ]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize2 = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use = _a.use, visit = _a.visit;
    exports2.astNodesAreEquivalent = astNodesAreEquivalent, exports2.builders = builders, exports2.builtInTypes = builtInTypes, exports2.defineMethod = defineMethod, exports2.eachField = eachField, exports2.finalize = finalize2, exports2.getBuilderName = getBuilderName, exports2.getFieldNames = getFieldNames, exports2.getFieldValue = getFieldValue, exports2.getSupertypeNames = getSupertypeNames, exports2.NodePath = NodePath, exports2.Path = Path, exports2.PathVisitor = PathVisitor, exports2.someField = someField, exports2.Type = Type, exports2.use = use, exports2.visit = visit, Object.assign(namedTypes_1.namedTypes, n);
  }(main$1)), main$1;
}
var parser$1 = {}, tinyInvariant_cjs, hasRequiredTinyInvariant_cjs;
function requireTinyInvariant_cjs() {
  if (hasRequiredTinyInvariant_cjs) return tinyInvariant_cjs;
  hasRequiredTinyInvariant_cjs = 1;
  var isProduction = process.env.NODE_ENV === "production", prefix = "Invariant failed";
  function invariant(condition, message) {
    if (!condition) {
      if (isProduction)
        throw new Error(prefix);
      var provided = typeof message == "function" ? message() : message, value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
    }
  }
  return tinyInvariant_cjs = invariant, tinyInvariant_cjs;
}
var options$1 = {}, util$1 = {}, sourceMap = {}, sourceMapGenerator = {}, base64Vlq = {}, base64 = {}, hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return base64.encode = function(number2) {
    if (0 <= number2 && number2 < intToCharMap.length)
      return intToCharMap[number2];
    throw new TypeError("Must be between 0 and 63: " + number2);
  }, base64.decode = function(charCode) {
    var bigA = 65, bigZ = 90, littleA = 97, littleZ = 122, zero = 48, nine = 57, plus = 43, slash = 47, littleOffset = 26, numberOffset = 52;
    return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
  }, base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base642 = requireBase64(), VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1, shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  return base64Vlq.encode = function(aValue) {
    var encoded = "", digit, vlq = toVLQSigned(aValue);
    do
      digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base642.encode(digit);
    while (vlq > 0);
    return encoded;
  }, base64Vlq.decode = function(aStr, aIndex, aOutParam) {
    var strLen = aStr.length, result = 0, shift = 0, continuation, digit;
    do {
      if (aIndex >= strLen)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (digit = base642.decode(aStr.charCodeAt(aIndex++)), digit === -1)
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
  }, base64Vlq;
}
var util = {}, hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs)
        return aArgs[aName];
      if (arguments.length === 3)
        return aDefaultValue;
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      return match2 ? {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      } : null;
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize2(aPath) {
      var path2 = aPath, url = urlParse(aPath);
      if (url) {
        if (!url.path)
          return aPath;
        path2 = url.path;
      }
      for (var isAbsolute = exports2.isAbsolute(path2), parts = path2.split(/\/+/), part, up = 0, i = parts.length - 1; i >= 0; i--)
        part = parts[i], part === "." ? parts.splice(i, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i + 1, up), up = 0) : (parts.splice(i, 2), up--));
      return path2 = parts.join("/"), path2 === "" && (path2 = isAbsolute ? "/" : "."), url ? (url.path = path2, urlGenerate(url)) : path2;
    }
    exports2.normalize = normalize2;
    function join(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
      var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
      if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
        return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
      if (aPathUrl || aPath.match(dataUrlRegexp))
        return aPath;
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
        return aRootUrl.host = aPath, urlGenerate(aRootUrl);
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
    }
    exports2.join = join, exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
      for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/)))
          return aPath;
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity2(s) {
      return s;
    }
    function toSetString(aStr) {
      return isProtoString(aStr) ? "$" + aStr : aStr;
    }
    exports2.toSetString = supportsNullProto ? identity2 : toSetString;
    function fromSetString(aStr) {
      return isProtoString(aStr) ? aStr.slice(1) : aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity2 : fromSetString;
    function isProtoString(s) {
      if (!s)
        return !1;
      var length = s.length;
      if (length < 9 || s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95)
        return !1;
      for (var i = length - 10; i >= 0; i--)
        if (s.charCodeAt(i) !== 36)
          return !1;
      return !0;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str2) {
      return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed)
          throw new Error("sourceMapURL could not be parsed");
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }(util)), util;
}
var arraySet = {}, hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util2 = requireUtil$1(), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
  function ArraySet() {
    this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return ArraySet.fromArray = function(aArray, aAllowDuplicates) {
    for (var set2 = new ArraySet(), i = 0, len = aArray.length; i < len; i++)
      set2.add(aArray[i], aAllowDuplicates);
    return set2;
  }, ArraySet.prototype.size = function() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
    (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
  }, ArraySet.prototype.has = function(aStr) {
    if (hasNativeMap)
      return this._set.has(aStr);
    var sStr = util2.toSetString(aStr);
    return has.call(this._set, sStr);
  }, ArraySet.prototype.indexOf = function(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0)
        return idx;
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr))
        return this._set[sStr];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }, ArraySet.prototype.at = function(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length)
      return this._array[aIdx];
    throw new Error("No element indexed by " + aIdx);
  }, ArraySet.prototype.toArray = function() {
    return this._array.slice();
  }, arraySet.ArraySet = ArraySet, arraySet;
}
var mappingList = {}, hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util2 = requireUtil$1();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }, MappingList.prototype.add = function(aMapping) {
    generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
  }, MappingList.prototype.toArray = function() {
    return this._sorted || (this._array.sort(util2.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, mappingList.MappingList = MappingList, mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq(), util2 = requireUtil$1(), ArraySet = requireArraySet().ArraySet, MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    aArgs || (aArgs = {}), this._file = util2.getArg(aArgs, "file", null), this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null), this._skipValidation = util2.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
  }
  return SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    return aSourceMapConsumer.eachMapping(function(mapping2) {
      var newMapping = {
        generated: {
          line: mapping2.generatedLine,
          column: mapping2.generatedColumn
        }
      };
      mapping2.source != null && (newMapping.source = mapping2.source, sourceRoot != null && (newMapping.source = util2.relative(sourceRoot, newMapping.source)), newMapping.original = {
        line: mapping2.originalLine,
        column: mapping2.originalColumn
      }, mapping2.name != null && (newMapping.name = mapping2.name)), generator.addMapping(newMapping);
    }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      sourceRoot !== null && (sourceRelative = util2.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && generator.setSourceContent(sourceFile, content);
    }), generator;
  }, SourceMapGenerator.prototype.addMapping = function(aArgs) {
    var generated = util2.getArg(aArgs, "generated"), original = util2.getArg(aArgs, "original", null), source2 = util2.getArg(aArgs, "source", null), name = util2.getArg(aArgs, "name", null);
    this._skipValidation || this._validateMapping(generated, original, source2, name), source2 != null && (source2 = String(source2), this._sources.has(source2) || this._sources.add(source2)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source2,
      name
    });
  }, SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
    var source2 = aSourceFile;
    this._sourceRoot != null && (source2 = util2.relative(this._sourceRoot, source2)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util2.toSetString(source2)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util2.toSetString(source2)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    sourceRoot != null && (sourceFile = util2.relative(sourceRoot, sourceFile));
    var newSources = new ArraySet(), newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping2) {
      if (mapping2.source === sourceFile && mapping2.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping2.originalLine,
          column: mapping2.originalColumn
        });
        original.source != null && (mapping2.source = original.source, aSourceMapPath != null && (mapping2.source = util2.join(aSourceMapPath, mapping2.source)), sourceRoot != null && (mapping2.source = util2.relative(sourceRoot, mapping2.source)), mapping2.originalLine = original.line, mapping2.originalColumn = original.column, original.name != null && (mapping2.name = original.name));
      }
      var source2 = mapping2.source;
      source2 != null && !newSources.has(source2) && newSources.add(source2);
      var name = mapping2.name;
      name != null && !newNames.has(name) && newNames.add(name);
    }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      content != null && (aSourceMapPath != null && (sourceFile2 = util2.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util2.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
    }, this);
  }, SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }, SourceMapGenerator.prototype._serializeMappings = function() {
    for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping2, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
      if (mapping2 = mappings[i], next = "", mapping2.generatedLine !== previousGeneratedLine)
        for (previousGeneratedColumn = 0; mapping2.generatedLine !== previousGeneratedLine; )
          next += ";", previousGeneratedLine++;
      else if (i > 0) {
        if (!util2.compareByGeneratedPositionsInflated(mapping2, mappings[i - 1]))
          continue;
        next += ",";
      }
      next += base64VLQ.encode(mapping2.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping2.generatedColumn, mapping2.source != null && (sourceIdx = this._sources.indexOf(mapping2.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping2.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping2.originalLine - 1, next += base64VLQ.encode(mapping2.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping2.originalColumn, mapping2.name != null && (nameIdx = this._names.indexOf(mapping2.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
    }
    return result;
  }, SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
    return aSources.map(function(source2) {
      if (!this._sourcesContents)
        return null;
      aSourceRoot != null && (source2 = util2.relative(aSourceRoot, source2));
      var key2 = util2.toSetString(source2);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key2) ? this._sourcesContents[key2] : null;
    }, this);
  }, SourceMapGenerator.prototype.toJSON = function() {
    var map2 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (map2.file = this._file), this._sourceRoot != null && (map2.sourceRoot = this._sourceRoot), this._sourcesContents && (map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot)), map2;
  }, SourceMapGenerator.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, sourceMapGenerator.SourceMapGenerator = SourceMapGenerator, sourceMapGenerator;
}
var sourceMapConsumer = {}, binarySearch = {}, hasRequiredBinarySearch;
function requireBinarySearch() {
  return hasRequiredBinarySearch || (hasRequiredBinarySearch = 1, function(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1, exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], !0);
      return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }
    exports2.search = function(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0)
        return -1;
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0)
        return -1;
      for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0; )
        --index;
      return index;
    };
  }(binarySearch)), binarySearch;
}
var quickSort = {}, hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y], ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r), i = p - 1;
      swap(ary, pivotIndex, r);
      for (var pivot = ary[r], j = p; j < r; j++)
        comparator(ary[j], pivot) <= 0 && (i += 1, swap(ary, i, j));
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
    }
  }
  return quickSort.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  }, quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util2 = requireUtil$1(), binarySearch2 = requireBinarySearch(), ArraySet = requireArraySet().ArraySet, base64VLQ = requireBase64Vlq(), quickSort2 = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    return typeof aSourceMap == "string" && (sourceMap2 = util2.parseSourceMapInput(aSourceMap)), sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
    var c2 = aStr.charAt(index);
    return c2 === ";" || c2 === ",";
  }, SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }, SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
    var context = aContext || null, order = aOrder || SourceMapConsumer.GENERATED_ORDER, mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping2) {
      var source2 = mapping2.source === null ? null : this._sources.at(mapping2.source);
      return source2 = util2.computeSourceURL(sourceRoot, source2, this._sourceMapURL), {
        source: source2,
        generatedLine: mapping2.generatedLine,
        generatedColumn: mapping2.generatedColumn,
        originalLine: mapping2.originalLine,
        originalColumn: mapping2.originalColumn,
        name: mapping2.name === null ? null : this._names.at(mapping2.name)
      };
    }, this).forEach(aCallback, context);
  }, SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
    var line3 = util2.getArg(aArgs, "line"), needle = {
      source: util2.getArg(aArgs, "source"),
      originalLine: line3,
      originalColumn: util2.getArg(aArgs, "column", 0)
    };
    if (needle.source = this._findSourceIndex(needle.source), needle.source < 0)
      return [];
    var mappings = [], index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      binarySearch2.LEAST_UPPER_BOUND
    );
    if (index >= 0) {
      var mapping2 = this._originalMappings[index];
      if (aArgs.column === void 0)
        for (var originalLine = mapping2.originalLine; mapping2 && mapping2.originalLine === originalLine; )
          mappings.push({
            line: util2.getArg(mapping2, "generatedLine", null),
            column: util2.getArg(mapping2, "generatedColumn", null),
            lastColumn: util2.getArg(mapping2, "lastGeneratedColumn", null)
          }), mapping2 = this._originalMappings[++index];
      else
        for (var originalColumn = mapping2.originalColumn; mapping2 && mapping2.originalLine === line3 && mapping2.originalColumn == originalColumn; )
          mappings.push({
            line: util2.getArg(mapping2, "generatedLine", null),
            column: util2.getArg(mapping2, "generatedColumn", null),
            lastColumn: util2.getArg(mapping2, "lastGeneratedColumn", null)
          }), mapping2 = this._originalMappings[++index];
    }
    return mappings;
  }, sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    typeof aSourceMap == "string" && (sourceMap2 = util2.parseSourceMapInput(aSourceMap));
    var version2 = util2.getArg(sourceMap2, "version"), sources = util2.getArg(sourceMap2, "sources"), names = util2.getArg(sourceMap2, "names", []), sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null), sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null), mappings = util2.getArg(sourceMap2, "mappings"), file = util2.getArg(sourceMap2, "file", null);
    if (version2 != this._version)
      throw new Error("Unsupported version: " + version2);
    sourceRoot && (sourceRoot = util2.normalize(sourceRoot)), sources = sources.map(String).map(util2.normalize).map(function(source2) {
      return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source2) ? util2.relative(sourceRoot, source2) : source2;
    }), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function(s) {
      return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
    }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null && (relativeSource = util2.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource))
      return this._sources.indexOf(relativeSource);
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i)
      if (this._absoluteSources[i] == aSource)
        return i;
    return -1;
  }, BasicSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
    smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(
      smc._sources.toArray(),
      smc.sourceRoot
    ), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i], destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
    }
    return quickSort2(smc.__originalMappings, util2.compareByOriginalPositions), smc;
  }, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping2, str2, segment, end, value; index < length; )
      if (aStr.charAt(index) === ";")
        generatedLine++, index++, previousGeneratedColumn = 0;
      else if (aStr.charAt(index) === ",")
        index++;
      else {
        for (mapping2 = new Mapping(), mapping2.generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++)
          ;
        if (str2 = aStr.slice(index, end), segment = cachedSegments[str2], segment)
          index += str2.length;
        else {
          for (segment = []; index < end; )
            base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
          if (segment.length === 2)
            throw new Error("Found a source, but no line and column");
          if (segment.length === 3)
            throw new Error("Found a source and line, but no column");
          cachedSegments[str2] = segment;
        }
        mapping2.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping2.generatedColumn, segment.length > 1 && (mapping2.source = previousSource + segment[1], previousSource += segment[1], mapping2.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping2.originalLine, mapping2.originalLine += 1, mapping2.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping2.originalColumn, segment.length > 4 && (mapping2.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping2), typeof mapping2.originalLine == "number" && originalMappings.push(mapping2);
      }
    quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort2(originalMappings, util2.compareByOriginalPositions), this.__originalMappings = originalMappings;
  }, BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    if (aNeedle[aColumnName] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
  }, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping2 = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping2.generatedLine === nextMapping.generatedLine) {
          mapping2.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping2.lastGeneratedColumn = 1 / 0;
    }
  }, BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    }, index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util2.compareByGeneratedPositionsDeflated,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index >= 0) {
      var mapping2 = this._generatedMappings[index];
      if (mapping2.generatedLine === needle.generatedLine) {
        var source2 = util2.getArg(mapping2, "source", null);
        source2 !== null && (source2 = this._sources.at(source2), source2 = util2.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL));
        var name = util2.getArg(mapping2, "name", null);
        return name !== null && (name = this._names.at(name)), {
          source: source2,
          line: util2.getArg(mapping2, "originalLine", null),
          column: util2.getArg(mapping2, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    }) : !1;
  }, BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
    if (!this.sourcesContent)
      return null;
    var index = this._findSourceIndex(aSource);
    if (index >= 0)
      return this.sourcesContent[index];
    var relativeSource = aSource;
    this.sourceRoot != null && (relativeSource = util2.relative(this.sourceRoot, relativeSource));
    var url;
    if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath))
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource))
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
    if (nullOnMissing)
      return null;
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }, BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
    var source2 = util2.getArg(aArgs, "source");
    if (source2 = this._findSourceIndex(source2), source2 < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var needle = {
      source: source2,
      originalLine: util2.getArg(aArgs, "line"),
      originalColumn: util2.getArg(aArgs, "column")
    }, index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index >= 0) {
      var mapping2 = this._originalMappings[index];
      if (mapping2.source === needle.source)
        return {
          line: util2.getArg(mapping2, "generatedLine", null),
          column: util2.getArg(mapping2, "generatedColumn", null),
          lastColumn: util2.getArg(mapping2, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    typeof aSourceMap == "string" && (sourceMap2 = util2.parseSourceMapInput(aSourceMap));
    var version2 = util2.getArg(sourceMap2, "version"), sections = util2.getArg(sourceMap2, "sections");
    if (version2 != this._version)
      throw new Error("Unsupported version: " + version2);
    this._sources = new ArraySet(), this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url)
        throw new Error("Support for url field in sections not implemented.");
      var offset = util2.getArg(s, "offset"), offsetLine = util2.getArg(offset, "line"), offsetColumn = util2.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return lastOffset = offset, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  return IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      for (var sources = [], i = 0; i < this._sections.length; i++)
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++)
          sources.push(this._sections[i].consumer.sources[j]);
      return sources;
    }
  }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    }, sectionIndex = binarySearch2.search(
      needle,
      this._sections,
      function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      }
    ), section = this._sections[sectionIndex];
    return section ? section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  }, IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i], content = section.consumer.sourceContentFor(aSource, !0);
      if (content)
        return content;
    }
    if (nullOnMissing)
      return null;
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) !== -1) {
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++)
      for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
        var mapping2 = sectionMappings[j], source2 = section.consumer._sources.at(mapping2.source);
        source2 = util2.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL), this._sources.add(source2), source2 = this._sources.indexOf(source2);
        var name = null;
        mapping2.name && (name = section.consumer._names.at(mapping2.name), this._names.add(name), name = this._names.indexOf(name));
        var adjustedMapping = {
          source: source2,
          generatedLine: mapping2.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping2.generatedColumn + (section.generatedOffset.generatedLine === mapping2.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping2.originalLine,
          originalColumn: mapping2.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
      }
    quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated), quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
  }, sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer, sourceMapConsumer;
}
var sourceNode = {}, hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator, util2 = requireUtil$1(), REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
  }
  return SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
      var lineContents = getNextLine(), newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
    return aSourceMapConsumer.eachMapping(function(mapping2) {
      if (lastMapping !== null)
        if (lastGeneratedLine < mapping2.generatedLine)
          addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
        else {
          var nextLine = remainingLines[remainingLinesIndex] || "", code = nextLine.substr(0, mapping2.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping2.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping2;
          return;
        }
      for (; lastGeneratedLine < mapping2.generatedLine; )
        node.add(shiftNextLine()), lastGeneratedLine++;
      if (lastGeneratedColumn < mapping2.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping2.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn), lastGeneratedColumn = mapping2.generatedColumn;
      }
      lastMapping = mapping2;
    }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && (aRelativePath != null && (sourceFile = util2.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
    }), node;
    function addMappingWithCode(mapping2, code) {
      if (mapping2 === null || mapping2.source === void 0)
        node.add(code);
      else {
        var source2 = aRelativePath ? util2.join(aRelativePath, mapping2.source) : mapping2.source;
        node.add(new SourceNode(
          mapping2.originalLine,
          mapping2.originalColumn,
          source2,
          code,
          mapping2.name
        ));
      }
    }
  }, SourceNode.prototype.add = function(aChunk) {
    if (Array.isArray(aChunk))
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    else if (aChunk[isSourceNode] || typeof aChunk == "string")
      aChunk && this.children.push(aChunk);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    return this;
  }, SourceNode.prototype.prepend = function(aChunk) {
    if (Array.isArray(aChunk))
      for (var i = aChunk.length - 1; i >= 0; i--)
        this.prepend(aChunk[i]);
    else if (aChunk[isSourceNode] || typeof aChunk == "string")
      this.children.unshift(aChunk);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    return this;
  }, SourceNode.prototype.walk = function(aFn) {
    for (var chunk, i = 0, len = this.children.length; i < len; i++)
      chunk = this.children[i], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, SourceNode.prototype.join = function(aSep) {
    var newChildren, i, len = this.children.length;
    if (len > 0) {
      for (newChildren = [], i = 0; i < len - 1; i++)
        newChildren.push(this.children[i]), newChildren.push(aSep);
      newChildren.push(this.children[i]), this.children = newChildren;
    }
    return this;
  }, SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
  }, SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
    this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
  }, SourceNode.prototype.walkSourceContents = function(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++)
      this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
    for (var sources = Object.keys(this.sourceContents), i = 0, len = sources.length; i < len; i++)
      aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }, SourceNode.prototype.toString = function() {
    var str2 = "";
    return this.walk(function(chunk) {
      str2 += chunk;
    }), str2;
  }, SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    }, map2 = new SourceMapGenerator(aArgs), sourceMappingActive = !1, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
    return this.walk(function(chunk, original) {
      generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map2.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map2.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      }), lastOriginalSource = null, sourceMappingActive = !1);
      for (var idx = 0, length = chunk.length; idx < length; idx++)
        chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map2.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        })) : generated.column++;
    }), this.walkSourceContents(function(sourceFile, sourceContent) {
      map2.setSourceContent(sourceFile, sourceContent);
    }), { code: generated.code, map: map2 };
  }, sourceNode.SourceNode = SourceNode, sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  return hasRequiredSourceMap || (hasRequiredSourceMap = 1, sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator, sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer, sourceMap.SourceNode = requireSourceNode().SourceNode), sourceMap;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$1;
  hasRequiredUtil = 1, Object.defineProperty(util$1, "__esModule", { value: !0 }), util$1.isTrailingCommaEnabled = util$1.getParentExportDeclaration = util$1.isExportDeclaration = util$1.fixFaultyLocations = util$1.getTrueLoc = util$1.composeSourceMaps = util$1.copyPos = util$1.comparePos = util$1.getUnionOfKeys = util$1.getOption = util$1.isBrowser = util$1.getLineTerminator = void 0;
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), types2 = tslib_1.__importStar(requireMain$2()), n = types2.namedTypes, source_map_1 = tslib_1.__importDefault(requireSourceMap()), SourceMapConsumer = source_map_1.default.SourceMapConsumer, SourceMapGenerator = source_map_1.default.SourceMapGenerator, hasOwn = Object.prototype.hasOwnProperty;
  function getLineTerminator() {
    return isBrowser() ? `
` : require$$0__default$2.default.EOL || `
`;
  }
  util$1.getLineTerminator = getLineTerminator;
  function isBrowser() {
    return typeof window < "u" && typeof window.document < "u";
  }
  util$1.isBrowser = isBrowser;
  function getOption(options2, key2, defaultValue) {
    return options2 && hasOwn.call(options2, key2) ? options2[key2] : defaultValue;
  }
  util$1.getOption = getOption;
  function getUnionOfKeys() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    for (var result = {}, argc = args.length, i = 0; i < argc; ++i)
      for (var keys = Object.keys(args[i]), keyCount = keys.length, j = 0; j < keyCount; ++j)
        result[keys[j]] = !0;
    return result;
  }
  util$1.getUnionOfKeys = getUnionOfKeys;
  function comparePos(pos1, pos2) {
    return pos1.line - pos2.line || pos1.column - pos2.column;
  }
  util$1.comparePos = comparePos;
  function copyPos(pos2) {
    return {
      line: pos2.line,
      column: pos2.column
    };
  }
  util$1.copyPos = copyPos;
  function composeSourceMaps(formerMap, latterMap) {
    if (formerMap) {
      if (!latterMap)
        return formerMap;
    } else
      return latterMap || null;
    var smcFormer = new SourceMapConsumer(formerMap), smcLatter = new SourceMapConsumer(latterMap), smg = new SourceMapGenerator({
      file: latterMap.file,
      sourceRoot: latterMap.sourceRoot
    }), sourcesToContents = {};
    return smcLatter.eachMapping(function(mapping2) {
      var origPos = smcFormer.originalPositionFor({
        line: mapping2.originalLine,
        column: mapping2.originalColumn
      }), sourceName = origPos.source;
      if (sourceName !== null) {
        smg.addMapping({
          source: sourceName,
          original: copyPos(origPos),
          generated: {
            line: mapping2.generatedLine,
            column: mapping2.generatedColumn
          },
          name: mapping2.name
        });
        var sourceContent = smcFormer.sourceContentFor(sourceName);
        sourceContent && !hasOwn.call(sourcesToContents, sourceName) && (sourcesToContents[sourceName] = sourceContent, smg.setSourceContent(sourceName, sourceContent));
      }
    }), smg.toJSON();
  }
  util$1.composeSourceMaps = composeSourceMaps;
  function getTrueLoc(node, lines2) {
    if (!node.loc)
      return null;
    var result = {
      start: node.loc.start,
      end: node.loc.end
    };
    function include(node2) {
      expandLoc(result, node2.loc);
    }
    return node.declaration && node.declaration.decorators && isExportDeclaration(node) && node.declaration.decorators.forEach(include), comparePos(result.start, result.end) < 0 && (result.start = copyPos(result.start), lines2.skipSpaces(result.start, !1, !0), comparePos(result.start, result.end) < 0 && (result.end = copyPos(result.end), lines2.skipSpaces(result.end, !0, !0))), node.comments && node.comments.forEach(include), result;
  }
  util$1.getTrueLoc = getTrueLoc;
  function expandLoc(parentLoc, childLoc) {
    parentLoc && childLoc && (comparePos(childLoc.start, parentLoc.start) < 0 && (parentLoc.start = childLoc.start), comparePos(parentLoc.end, childLoc.end) < 0 && (parentLoc.end = childLoc.end));
  }
  function fixFaultyLocations(node, lines2) {
    var loc = node.loc;
    if (loc && (loc.start.line < 1 && (loc.start.line = 1), loc.end.line < 1 && (loc.end.line = 1)), node.type === "File" && (loc.start = lines2.firstPos(), loc.end = lines2.lastPos()), fixForLoopHead(node, lines2), fixTemplateLiteral(node, lines2), loc && node.decorators)
      node.decorators.forEach(function(decorator) {
        expandLoc(loc, decorator.loc);
      });
    else if (node.declaration && isExportDeclaration(node)) {
      node.declaration.loc = null;
      var decorators = node.declaration.decorators;
      decorators && decorators.forEach(function(decorator) {
        expandLoc(loc, decorator.loc);
      });
    } else if (n.MethodDefinition && n.MethodDefinition.check(node) || n.Property.check(node) && (node.method || node.shorthand))
      node.value.loc = null, n.FunctionExpression.check(node.value) && (node.value.id = null);
    else if (node.type === "ObjectTypeProperty") {
      var loc_1 = node.loc, end = loc_1 && loc_1.end;
      end && (end = copyPos(end), lines2.prevPos(end) && lines2.charAt(end) === "," && (end = lines2.skipSpaces(end, !0, !0)) && (loc_1.end = end));
    }
  }
  util$1.fixFaultyLocations = fixFaultyLocations;
  function fixForLoopHead(node, lines2) {
    if (node.type !== "ForStatement")
      return;
    function fix(child) {
      for (var loc = child && child.loc, start = loc && loc.start, end = loc && copyPos(loc.end); start && end && comparePos(start, end) < 0 && (lines2.prevPos(end), lines2.charAt(end) === ";"); )
        loc.end.line = end.line, loc.end.column = end.column;
    }
    fix(node.init), fix(node.test), fix(node.update);
  }
  function fixTemplateLiteral(node, lines2) {
    if (node.type === "TemplateLiteral" && node.quasis.length !== 0) {
      if (node.loc) {
        var afterLeftBackTickPos = copyPos(node.loc.start);
        (0, tiny_invariant_1.default)(lines2.charAt(afterLeftBackTickPos) === "`"), (0, tiny_invariant_1.default)(lines2.nextPos(afterLeftBackTickPos));
        var firstQuasi = node.quasis[0];
        comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0 && (firstQuasi.loc.start = afterLeftBackTickPos);
        var rightBackTickPos = copyPos(node.loc.end);
        (0, tiny_invariant_1.default)(lines2.prevPos(rightBackTickPos)), (0, tiny_invariant_1.default)(lines2.charAt(rightBackTickPos) === "`");
        var lastQuasi = node.quasis[node.quasis.length - 1];
        comparePos(rightBackTickPos, lastQuasi.loc.end) < 0 && (lastQuasi.loc.end = rightBackTickPos);
      }
      node.expressions.forEach(function(expr, i) {
        var dollarCurlyPos = lines2.skipSpaces(expr.loc.start, !0, !1);
        if (lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "{" && lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "$") {
          var quasiBefore = node.quasis[i];
          comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0 && (quasiBefore.loc.end = dollarCurlyPos);
        }
        var rightCurlyPos = lines2.skipSpaces(expr.loc.end, !1, !1);
        if (lines2.charAt(rightCurlyPos) === "}") {
          (0, tiny_invariant_1.default)(lines2.nextPos(rightCurlyPos));
          var quasiAfter = node.quasis[i + 1];
          comparePos(quasiAfter.loc.start, rightCurlyPos) < 0 && (quasiAfter.loc.start = rightCurlyPos);
        }
      });
    }
  }
  function isExportDeclaration(node) {
    if (node)
      switch (node.type) {
        case "ExportDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportDefaultSpecifier":
        case "DeclareExportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration":
          return !0;
      }
    return !1;
  }
  util$1.isExportDeclaration = isExportDeclaration;
  function getParentExportDeclaration(path2) {
    var parentNode = path2.getParentNode();
    return path2.getName() === "declaration" && isExportDeclaration(parentNode) ? parentNode : null;
  }
  util$1.getParentExportDeclaration = getParentExportDeclaration;
  function isTrailingCommaEnabled(options2, context) {
    var trailingComma = options2.trailingComma;
    return typeof trailingComma == "object" ? !!trailingComma[context] : !!trailingComma;
  }
  return util$1.isTrailingCommaEnabled = isTrailingCommaEnabled, util$1;
}
var esprima$2 = {}, esprima$1 = { exports: {} }, esprima = esprima$1.exports, hasRequiredEsprima$1;
function requireEsprima$1() {
  return hasRequiredEsprima$1 || (hasRequiredEsprima$1 = 1, function(module2, exports2) {
    (function(root2, factory) {
      module2.exports = factory();
    })(esprima, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: !1
              /******/
            };
            return modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__), module3.loaded = !0, module3.exports;
          }
          return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var comment_handler_1 = __webpack_require__(1), jsx_parser_1 = __webpack_require__(3), parser_1 = __webpack_require__(8), tokenizer_1 = __webpack_require__(15);
            function parse3(code, options2, delegate) {
              var commentHandler = null, proxyDelegate = function(node, metadata) {
                delegate && delegate(node, metadata), commentHandler && commentHandler.visit(node, metadata);
              }, parserDelegate = typeof delegate == "function" ? proxyDelegate : null, collectComment = !1;
              if (options2) {
                collectComment = typeof options2.comment == "boolean" && options2.comment;
                var attachComment = typeof options2.attachComment == "boolean" && options2.attachComment;
                (collectComment || attachComment) && (commentHandler = new comment_handler_1.CommentHandler(), commentHandler.attach = attachComment, options2.comment = !0, parserDelegate = proxyDelegate);
              }
              var isModule = !1;
              options2 && typeof options2.sourceType == "string" && (isModule = options2.sourceType === "module");
              var parser2;
              options2 && typeof options2.jsx == "boolean" && options2.jsx ? parser2 = new jsx_parser_1.JSXParser(code, options2, parserDelegate) : parser2 = new parser_1.Parser(code, options2, parserDelegate);
              var program = isModule ? parser2.parseModule() : parser2.parseScript(), ast = program;
              return collectComment && commentHandler && (ast.comments = commentHandler.comments), parser2.config.tokens && (ast.tokens = parser2.tokens), parser2.config.tolerant && (ast.errors = parser2.errorHandler.errors), ast;
            }
            exports3.parse = parse3;
            function parseModule(code, options2, delegate) {
              var parsingOptions = options2 || {};
              return parsingOptions.sourceType = "module", parse3(code, parsingOptions, delegate);
            }
            exports3.parseModule = parseModule;
            function parseScript(code, options2, delegate) {
              var parsingOptions = options2 || {};
              return parsingOptions.sourceType = "script", parse3(code, parsingOptions, delegate);
            }
            exports3.parseScript = parseScript;
            function tokenize(code, options2, delegate) {
              var tokenizer = new tokenizer_1.Tokenizer(code, options2), tokens;
              tokens = [];
              try {
                for (; ; ) {
                  var token2 = tokenizer.getNextToken();
                  if (!token2)
                    break;
                  delegate && (token2 = delegate(token2)), tokens.push(token2);
                }
              } catch (e) {
                tokenizer.errorHandler.tolerate(e);
              }
              return tokenizer.errorHandler.tolerant && (tokens.errors = tokenizer.errors()), tokens;
            }
            exports3.tokenize = tokenize;
            var syntax_1 = __webpack_require__(2);
            exports3.Syntax = syntax_1.Syntax, exports3.version = "4.0.1";
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var syntax_1 = __webpack_require__(2), CommentHandler = function() {
              function CommentHandler2() {
                this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
              }
              return CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
                if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                  for (var innerComments = [], i = this.leading.length - 1; i >= 0; --i) {
                    var entry = this.leading[i];
                    metadata.end.offset >= entry.start && (innerComments.unshift(entry.comment), this.leading.splice(i, 1), this.trailing.splice(i, 1));
                  }
                  innerComments.length && (node.innerComments = innerComments);
                }
              }, CommentHandler2.prototype.findTrailingComments = function(metadata) {
                var trailingComments = [];
                if (this.trailing.length > 0) {
                  for (var i = this.trailing.length - 1; i >= 0; --i) {
                    var entry_1 = this.trailing[i];
                    entry_1.start >= metadata.end.offset && trailingComments.unshift(entry_1.comment);
                  }
                  return this.trailing.length = 0, trailingComments;
                }
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.node.trailingComments) {
                  var firstComment = entry.node.trailingComments[0];
                  firstComment && firstComment.range[0] >= metadata.end.offset && (trailingComments = entry.node.trailingComments, delete entry.node.trailingComments);
                }
                return trailingComments;
              }, CommentHandler2.prototype.findLeadingComments = function(metadata) {
                for (var leadingComments = [], target; this.stack.length > 0; ) {
                  var entry = this.stack[this.stack.length - 1];
                  if (entry && entry.start >= metadata.start.offset)
                    target = entry.node, this.stack.pop();
                  else
                    break;
                }
                if (target) {
                  for (var count2 = target.leadingComments ? target.leadingComments.length : 0, i = count2 - 1; i >= 0; --i) {
                    var comment = target.leadingComments[i];
                    comment.range[1] <= metadata.start.offset && (leadingComments.unshift(comment), target.leadingComments.splice(i, 1));
                  }
                  return target.leadingComments && target.leadingComments.length === 0 && delete target.leadingComments, leadingComments;
                }
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  entry.start <= metadata.start.offset && (leadingComments.unshift(entry.comment), this.leading.splice(i, 1));
                }
                return leadingComments;
              }, CommentHandler2.prototype.visitNode = function(node, metadata) {
                if (!(node.type === syntax_1.Syntax.Program && node.body.length > 0)) {
                  this.insertInnerComments(node, metadata);
                  var trailingComments = this.findTrailingComments(metadata), leadingComments = this.findLeadingComments(metadata);
                  leadingComments.length > 0 && (node.leadingComments = leadingComments), trailingComments.length > 0 && (node.trailingComments = trailingComments), this.stack.push({
                    node,
                    start: metadata.start.offset
                  });
                }
              }, CommentHandler2.prototype.visitComment = function(node, metadata) {
                var type2 = node.type[0] === "L" ? "Line" : "Block", comment = {
                  type: type2,
                  value: node.value
                };
                if (node.range && (comment.range = node.range), node.loc && (comment.loc = node.loc), this.comments.push(comment), this.attach) {
                  var entry = {
                    comment: {
                      type: type2,
                      value: node.value,
                      range: [metadata.start.offset, metadata.end.offset]
                    },
                    start: metadata.start.offset
                  };
                  node.loc && (entry.comment.loc = node.loc), node.type = type2, this.leading.push(entry), this.trailing.push(entry);
                }
              }, CommentHandler2.prototype.visit = function(node, metadata) {
                node.type === "LineComment" ? this.visitComment(node, metadata) : node.type === "BlockComment" ? this.visitComment(node, metadata) : this.attach && this.visitNode(node, metadata);
              }, CommentHandler2;
            }();
            exports3.CommentHandler = CommentHandler;
          },
          /* 2 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.Syntax = {
              AssignmentExpression: "AssignmentExpression",
              AssignmentPattern: "AssignmentPattern",
              ArrayExpression: "ArrayExpression",
              ArrayPattern: "ArrayPattern",
              ArrowFunctionExpression: "ArrowFunctionExpression",
              AwaitExpression: "AwaitExpression",
              BlockStatement: "BlockStatement",
              BinaryExpression: "BinaryExpression",
              BreakStatement: "BreakStatement",
              CallExpression: "CallExpression",
              CatchClause: "CatchClause",
              ClassBody: "ClassBody",
              ClassDeclaration: "ClassDeclaration",
              ClassExpression: "ClassExpression",
              ConditionalExpression: "ConditionalExpression",
              ContinueStatement: "ContinueStatement",
              DoWhileStatement: "DoWhileStatement",
              DebuggerStatement: "DebuggerStatement",
              EmptyStatement: "EmptyStatement",
              ExportAllDeclaration: "ExportAllDeclaration",
              ExportDefaultDeclaration: "ExportDefaultDeclaration",
              ExportNamedDeclaration: "ExportNamedDeclaration",
              ExportSpecifier: "ExportSpecifier",
              ExpressionStatement: "ExpressionStatement",
              ForStatement: "ForStatement",
              ForOfStatement: "ForOfStatement",
              ForInStatement: "ForInStatement",
              FunctionDeclaration: "FunctionDeclaration",
              FunctionExpression: "FunctionExpression",
              Identifier: "Identifier",
              IfStatement: "IfStatement",
              ImportDeclaration: "ImportDeclaration",
              ImportDefaultSpecifier: "ImportDefaultSpecifier",
              ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
              ImportSpecifier: "ImportSpecifier",
              Literal: "Literal",
              LabeledStatement: "LabeledStatement",
              LogicalExpression: "LogicalExpression",
              MemberExpression: "MemberExpression",
              MetaProperty: "MetaProperty",
              MethodDefinition: "MethodDefinition",
              NewExpression: "NewExpression",
              ObjectExpression: "ObjectExpression",
              ObjectPattern: "ObjectPattern",
              Program: "Program",
              Property: "Property",
              RestElement: "RestElement",
              ReturnStatement: "ReturnStatement",
              SequenceExpression: "SequenceExpression",
              SpreadElement: "SpreadElement",
              Super: "Super",
              SwitchCase: "SwitchCase",
              SwitchStatement: "SwitchStatement",
              TaggedTemplateExpression: "TaggedTemplateExpression",
              TemplateElement: "TemplateElement",
              TemplateLiteral: "TemplateLiteral",
              ThisExpression: "ThisExpression",
              ThrowStatement: "ThrowStatement",
              TryStatement: "TryStatement",
              UnaryExpression: "UnaryExpression",
              UpdateExpression: "UpdateExpression",
              VariableDeclaration: "VariableDeclaration",
              VariableDeclarator: "VariableDeclarator",
              WhileStatement: "WhileStatement",
              WithStatement: "WithStatement",
              YieldExpression: "YieldExpression"
            };
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            var __extends2 = this && this.__extends || function() {
              var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
              };
              return function(d, b) {
                extendStatics2(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var character_1 = __webpack_require__(4), JSXNode = __webpack_require__(5), jsx_syntax_1 = __webpack_require__(6), Node = __webpack_require__(7), parser_1 = __webpack_require__(8), token_1 = __webpack_require__(13), xhtml_entities_1 = __webpack_require__(14);
            token_1.TokenName[
              100
              /* Identifier */
            ] = "JSXIdentifier", token_1.TokenName[
              101
              /* Text */
            ] = "JSXText";
            function getQualifiedElementName(elementName) {
              var qualifiedName;
              switch (elementName.type) {
                case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                  var id = elementName;
                  qualifiedName = id.name;
                  break;
                case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                  var ns = elementName;
                  qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                  break;
                case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                  var expr = elementName;
                  qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                  break;
              }
              return qualifiedName;
            }
            var JSXParser = function(_super) {
              __extends2(JSXParser2, _super);
              function JSXParser2(code, options2, delegate) {
                return _super.call(this, code, options2, delegate) || this;
              }
              return JSXParser2.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
              }, JSXParser2.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              }, JSXParser2.prototype.finishJSX = function() {
                this.nextToken();
              }, JSXParser2.prototype.reenterJSX = function() {
                this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
              }, JSXParser2.prototype.createJSXNode = function() {
                return this.collectComments(), {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }, JSXParser2.prototype.createJSXChildNode = function() {
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }, JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                for (var result = "&", valid = !0, terminated = !1, numeric = !1, hex = !1; !this.scanner.eof() && valid && !terminated; ) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === quote)
                    break;
                  if (terminated = ch === ";", result += ch, ++this.scanner.index, !terminated)
                    switch (result.length) {
                      case 2:
                        numeric = ch === "#";
                        break;
                      case 3:
                        numeric && (hex = ch === "x", valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0)), numeric = numeric && !hex);
                        break;
                      default:
                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0))), valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                        break;
                    }
                }
                if (valid && terminated && result.length > 2) {
                  var str2 = result.substr(1, result.length - 2);
                  numeric && str2.length > 1 ? result = String.fromCharCode(parseInt(str2.substr(1), 10)) : hex && str2.length > 2 ? result = String.fromCharCode(parseInt("0" + str2.substr(1), 16)) : !numeric && !hex && xhtml_entities_1.XHTMLEntities[str2] && (result = xhtml_entities_1.XHTMLEntities[str2]);
                }
                return result;
              }, JSXParser2.prototype.lexJSX = function() {
                var cp = this.scanner.source.charCodeAt(this.scanner.index);
                if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                  var value = this.scanner.source[this.scanner.index++];
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index - 1,
                    end: this.scanner.index
                  };
                }
                if (cp === 34 || cp === 39) {
                  for (var start = this.scanner.index, quote = this.scanner.source[this.scanner.index++], str2 = ""; !this.scanner.eof(); ) {
                    var ch = this.scanner.source[this.scanner.index++];
                    if (ch === quote)
                      break;
                    ch === "&" ? str2 += this.scanXHTMLEntity(quote) : str2 += ch;
                  }
                  return {
                    type: 8,
                    value: str2,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 46) {
                  var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1), n2 = this.scanner.source.charCodeAt(this.scanner.index + 2), value = n1 === 46 && n2 === 46 ? "..." : ".", start = this.scanner.index;
                  return this.scanner.index += value.length, {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 96)
                  return {
                    type: 10,
                    value: "",
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index,
                    end: this.scanner.index
                  };
                if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                  var start = this.scanner.index;
                  for (++this.scanner.index; !this.scanner.eof(); ) {
                    var ch = this.scanner.source.charCodeAt(this.scanner.index);
                    if (character_1.Character.isIdentifierPart(ch) && ch !== 92)
                      ++this.scanner.index;
                    else if (ch === 45)
                      ++this.scanner.index;
                    else
                      break;
                  }
                  var id = this.scanner.source.slice(start, this.scanner.index);
                  return {
                    type: 100,
                    value: id,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                return this.scanner.lex();
              }, JSXParser2.prototype.nextJSXToken = function() {
                this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var token2 = this.lexJSX();
                return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(token2)), token2;
              }, JSXParser2.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                for (var start = this.scanner.index, text = ""; !this.scanner.eof(); ) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === "{" || ch === "<")
                    break;
                  ++this.scanner.index, text += ch, character_1.Character.isLineTerminator(ch.charCodeAt(0)) && (++this.scanner.lineNumber, ch === "\r" && this.scanner.source[this.scanner.index] === `
` && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
                }
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var token2 = {
                  type: 101,
                  value: text,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
                return text.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(token2)), token2;
              }, JSXParser2.prototype.peekJSXToken = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.lexJSX();
                return this.scanner.restoreState(state), next;
              }, JSXParser2.prototype.expectJSX = function(value) {
                var token2 = this.nextJSXToken();
                (token2.type !== 7 || token2.value !== value) && this.throwUnexpectedToken(token2);
              }, JSXParser2.prototype.matchJSX = function(value) {
                var next = this.peekJSXToken();
                return next.type === 7 && next.value === value;
              }, JSXParser2.prototype.parseJSXIdentifier = function() {
                var node = this.createJSXNode(), token2 = this.nextJSXToken();
                return token2.type !== 100 && this.throwUnexpectedToken(token2), this.finalize(node, new JSXNode.JSXIdentifier(token2.value));
              }, JSXParser2.prototype.parseJSXElementName = function() {
                var node = this.createJSXNode(), elementName = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = elementName;
                  this.expectJSX(":");
                  var name_1 = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
                } else if (this.matchJSX("."))
                  for (; this.matchJSX("."); ) {
                    var object = elementName;
                    this.expectJSX(".");
                    var property = this.parseJSXIdentifier();
                    elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                  }
                return elementName;
              }, JSXParser2.prototype.parseJSXAttributeName = function() {
                var node = this.createJSXNode(), attributeName, identifier = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = identifier;
                  this.expectJSX(":");
                  var name_2 = this.parseJSXIdentifier();
                  attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
                } else
                  attributeName = identifier;
                return attributeName;
              }, JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                var node = this.createJSXNode(), token2 = this.nextJSXToken();
                token2.type !== 8 && this.throwUnexpectedToken(token2);
                var raw = this.getTokenRaw(token2);
                return this.finalize(node, new Node.Literal(token2.value, raw));
              }, JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                var expression = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              }, JSXParser2.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              }, JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                var node = this.createJSXNode(), name = this.parseJSXAttributeName(), value = null;
                return this.matchJSX("=") && (this.expectJSX("="), value = this.parseJSXAttributeValue()), this.finalize(node, new JSXNode.JSXAttribute(name, value));
              }, JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
                var argument = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
              }, JSXParser2.prototype.parseJSXAttributes = function() {
                for (var attributes = []; !this.matchJSX("/") && !this.matchJSX(">"); ) {
                  var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  attributes.push(attribute);
                }
                return attributes;
              }, JSXParser2.prototype.parseJSXOpeningElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                var name = this.parseJSXElementName(), attributes = this.parseJSXAttributes(), selfClosing = this.matchJSX("/");
                return selfClosing && this.expectJSX("/"), this.expectJSX(">"), this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              }, JSXParser2.prototype.parseJSXBoundaryElement = function() {
                var node = this.createJSXNode();
                if (this.expectJSX("<"), this.matchJSX("/")) {
                  this.expectJSX("/");
                  var name_3 = this.parseJSXElementName();
                  return this.expectJSX(">"), this.finalize(node, new JSXNode.JSXClosingElement(name_3));
                }
                var name = this.parseJSXElementName(), attributes = this.parseJSXAttributes(), selfClosing = this.matchJSX("/");
                return selfClosing && this.expectJSX("/"), this.expectJSX(">"), this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              }, JSXParser2.prototype.parseJSXEmptyExpression = function() {
                var node = this.createJSXChildNode();
                return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(node, new JSXNode.JSXEmptyExpression());
              }, JSXParser2.prototype.parseJSXExpressionContainer = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                var expression;
                return this.matchJSX("}") ? (expression = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), expression = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              }, JSXParser2.prototype.parseJSXChildren = function() {
                for (var children = []; !this.scanner.eof(); ) {
                  var node = this.createJSXChildNode(), token2 = this.nextJSXText();
                  if (token2.start < token2.end) {
                    var raw = this.getTokenRaw(token2), child = this.finalize(node, new JSXNode.JSXText(token2.value, raw));
                    children.push(child);
                  }
                  if (this.scanner.source[this.scanner.index] === "{") {
                    var container = this.parseJSXExpressionContainer();
                    children.push(container);
                  } else
                    break;
                }
                return children;
              }, JSXParser2.prototype.parseComplexJSXElement = function(el) {
                for (var stack2 = []; !this.scanner.eof(); ) {
                  el.children = el.children.concat(this.parseJSXChildren());
                  var node = this.createJSXChildNode(), element = this.parseJSXBoundaryElement();
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                    var opening = element;
                    if (opening.selfClosing) {
                      var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                      el.children.push(child);
                    } else
                      stack2.push(el), el = { node, opening, closing: null, children: [] };
                  }
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                    el.closing = element;
                    var open_12 = getQualifiedElementName(el.opening.name), close_1 = getQualifiedElementName(el.closing.name);
                    if (open_12 !== close_1 && this.tolerateError("Expected corresponding JSX closing tag for %0", open_12), stack2.length > 0) {
                      var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                      el = stack2[stack2.length - 1], el.children.push(child), stack2.pop();
                    } else
                      break;
                  }
                }
                return el;
              }, JSXParser2.prototype.parseJSXElement = function() {
                var node = this.createJSXNode(), opening = this.parseJSXOpeningElement(), children = [], closing = null;
                if (!opening.selfClosing) {
                  var el = this.parseComplexJSXElement({ node, opening, closing, children });
                  children = el.children, closing = el.closing;
                }
                return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
              }, JSXParser2.prototype.parseJSXRoot = function() {
                this.config.tokens && this.tokens.pop(), this.startJSX();
                var element = this.parseJSXElement();
                return this.finishJSX(), element;
              }, JSXParser2.prototype.isStartOfExpression = function() {
                return _super.prototype.isStartOfExpression.call(this) || this.match("<");
              }, JSXParser2;
            }(parser_1.Parser);
            exports3.JSXParser = JSXParser;
          },
          /* 4 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var Regex = {
              // Unicode v8.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              // Unicode v8.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports3.Character = {
              /* tslint:disable:no-bitwise */
              fromCodePoint: function(cp) {
                return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
              },
              // https://tc39.github.io/ecma262/#sec-white-space
              isWhiteSpace: function(cp) {
                return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
              },
              // https://tc39.github.io/ecma262/#sec-line-terminators
              isLineTerminator: function(cp) {
                return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
              },
              // https://tc39.github.io/ecma262/#sec-names-and-keywords
              isIdentifierStart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp));
              },
              isIdentifierPart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp));
              },
              // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
              isDecimalDigit: function(cp) {
                return cp >= 48 && cp <= 57;
              },
              isHexDigit: function(cp) {
                return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
              },
              isOctalDigit: function(cp) {
                return cp >= 48 && cp <= 55;
              }
            };
          },
          /* 5 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var jsx_syntax_1 = __webpack_require__(6), JSXClosingElement = /* @__PURE__ */ function() {
              function JSXClosingElement2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement, this.name = name;
              }
              return JSXClosingElement2;
            }();
            exports3.JSXClosingElement = JSXClosingElement;
            var JSXElement = /* @__PURE__ */ function() {
              function JSXElement2(openingElement, children, closingElement) {
                this.type = jsx_syntax_1.JSXSyntax.JSXElement, this.openingElement = openingElement, this.children = children, this.closingElement = closingElement;
              }
              return JSXElement2;
            }();
            exports3.JSXElement = JSXElement;
            var JSXEmptyExpression = /* @__PURE__ */ function() {
              function JSXEmptyExpression2() {
                this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
              }
              return JSXEmptyExpression2;
            }();
            exports3.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = /* @__PURE__ */ function() {
              function JSXExpressionContainer2(expression) {
                this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer, this.expression = expression;
              }
              return JSXExpressionContainer2;
            }();
            exports3.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = /* @__PURE__ */ function() {
              function JSXIdentifier2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier, this.name = name;
              }
              return JSXIdentifier2;
            }();
            exports3.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = /* @__PURE__ */ function() {
              function JSXMemberExpression2(object, property) {
                this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression, this.object = object, this.property = property;
              }
              return JSXMemberExpression2;
            }();
            exports3.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = /* @__PURE__ */ function() {
              function JSXAttribute2(name, value) {
                this.type = jsx_syntax_1.JSXSyntax.JSXAttribute, this.name = name, this.value = value;
              }
              return JSXAttribute2;
            }();
            exports3.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = /* @__PURE__ */ function() {
              function JSXNamespacedName2(namespace, name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName, this.namespace = namespace, this.name = name;
              }
              return JSXNamespacedName2;
            }();
            exports3.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = /* @__PURE__ */ function() {
              function JSXOpeningElement2(name, selfClosing, attributes) {
                this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement, this.name = name, this.selfClosing = selfClosing, this.attributes = attributes;
              }
              return JSXOpeningElement2;
            }();
            exports3.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = /* @__PURE__ */ function() {
              function JSXSpreadAttribute2(argument) {
                this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute, this.argument = argument;
              }
              return JSXSpreadAttribute2;
            }();
            exports3.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = /* @__PURE__ */ function() {
              function JSXText2(value, raw) {
                this.type = jsx_syntax_1.JSXSyntax.JSXText, this.value = value, this.raw = raw;
              }
              return JSXText2;
            }();
            exports3.JSXText = JSXText;
          },
          /* 6 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.JSXSyntax = {
              JSXAttribute: "JSXAttribute",
              JSXClosingElement: "JSXClosingElement",
              JSXElement: "JSXElement",
              JSXEmptyExpression: "JSXEmptyExpression",
              JSXExpressionContainer: "JSXExpressionContainer",
              JSXIdentifier: "JSXIdentifier",
              JSXMemberExpression: "JSXMemberExpression",
              JSXNamespacedName: "JSXNamespacedName",
              JSXOpeningElement: "JSXOpeningElement",
              JSXSpreadAttribute: "JSXSpreadAttribute",
              JSXText: "JSXText"
            };
          },
          /* 7 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var syntax_1 = __webpack_require__(2), ArrayExpression = /* @__PURE__ */ function() {
              function ArrayExpression2(elements) {
                this.type = syntax_1.Syntax.ArrayExpression, this.elements = elements;
              }
              return ArrayExpression2;
            }();
            exports3.ArrayExpression = ArrayExpression;
            var ArrayPattern = /* @__PURE__ */ function() {
              function ArrayPattern2(elements) {
                this.type = syntax_1.Syntax.ArrayPattern, this.elements = elements;
              }
              return ArrayPattern2;
            }();
            exports3.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = /* @__PURE__ */ function() {
              function ArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression, this.id = null, this.params = params, this.body = body, this.generator = !1, this.expression = expression, this.async = !1;
              }
              return ArrowFunctionExpression2;
            }();
            exports3.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = /* @__PURE__ */ function() {
              function AssignmentExpression2(operator, left, right) {
                this.type = syntax_1.Syntax.AssignmentExpression, this.operator = operator, this.left = left, this.right = right;
              }
              return AssignmentExpression2;
            }();
            exports3.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = /* @__PURE__ */ function() {
              function AssignmentPattern2(left, right) {
                this.type = syntax_1.Syntax.AssignmentPattern, this.left = left, this.right = right;
              }
              return AssignmentPattern2;
            }();
            exports3.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
              function AsyncArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression, this.id = null, this.params = params, this.body = body, this.generator = !1, this.expression = expression, this.async = !0;
              }
              return AsyncArrowFunctionExpression2;
            }();
            exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
              function AsyncFunctionDeclaration2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionDeclaration, this.id = id, this.params = params, this.body = body, this.generator = !1, this.expression = !1, this.async = !0;
              }
              return AsyncFunctionDeclaration2;
            }();
            exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = /* @__PURE__ */ function() {
              function AsyncFunctionExpression2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionExpression, this.id = id, this.params = params, this.body = body, this.generator = !1, this.expression = !1, this.async = !0;
              }
              return AsyncFunctionExpression2;
            }();
            exports3.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = /* @__PURE__ */ function() {
              function AwaitExpression2(argument) {
                this.type = syntax_1.Syntax.AwaitExpression, this.argument = argument;
              }
              return AwaitExpression2;
            }();
            exports3.AwaitExpression = AwaitExpression;
            var BinaryExpression = /* @__PURE__ */ function() {
              function BinaryExpression2(operator, left, right) {
                var logical = operator === "||" || operator === "&&";
                this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression, this.operator = operator, this.left = left, this.right = right;
              }
              return BinaryExpression2;
            }();
            exports3.BinaryExpression = BinaryExpression;
            var BlockStatement = /* @__PURE__ */ function() {
              function BlockStatement2(body) {
                this.type = syntax_1.Syntax.BlockStatement, this.body = body;
              }
              return BlockStatement2;
            }();
            exports3.BlockStatement = BlockStatement;
            var BreakStatement = /* @__PURE__ */ function() {
              function BreakStatement2(label) {
                this.type = syntax_1.Syntax.BreakStatement, this.label = label;
              }
              return BreakStatement2;
            }();
            exports3.BreakStatement = BreakStatement;
            var CallExpression = /* @__PURE__ */ function() {
              function CallExpression2(callee, args) {
                this.type = syntax_1.Syntax.CallExpression, this.callee = callee, this.arguments = args;
              }
              return CallExpression2;
            }();
            exports3.CallExpression = CallExpression;
            var CatchClause = /* @__PURE__ */ function() {
              function CatchClause2(param, body) {
                this.type = syntax_1.Syntax.CatchClause, this.param = param, this.body = body;
              }
              return CatchClause2;
            }();
            exports3.CatchClause = CatchClause;
            var ClassBody = /* @__PURE__ */ function() {
              function ClassBody2(body) {
                this.type = syntax_1.Syntax.ClassBody, this.body = body;
              }
              return ClassBody2;
            }();
            exports3.ClassBody = ClassBody;
            var ClassDeclaration = /* @__PURE__ */ function() {
              function ClassDeclaration2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassDeclaration, this.id = id, this.superClass = superClass, this.body = body;
              }
              return ClassDeclaration2;
            }();
            exports3.ClassDeclaration = ClassDeclaration;
            var ClassExpression = /* @__PURE__ */ function() {
              function ClassExpression2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassExpression, this.id = id, this.superClass = superClass, this.body = body;
              }
              return ClassExpression2;
            }();
            exports3.ClassExpression = ClassExpression;
            var ComputedMemberExpression = /* @__PURE__ */ function() {
              function ComputedMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression, this.computed = !0, this.object = object, this.property = property;
              }
              return ComputedMemberExpression2;
            }();
            exports3.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = /* @__PURE__ */ function() {
              function ConditionalExpression2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.ConditionalExpression, this.test = test, this.consequent = consequent, this.alternate = alternate;
              }
              return ConditionalExpression2;
            }();
            exports3.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = /* @__PURE__ */ function() {
              function ContinueStatement2(label) {
                this.type = syntax_1.Syntax.ContinueStatement, this.label = label;
              }
              return ContinueStatement2;
            }();
            exports3.ContinueStatement = ContinueStatement;
            var DebuggerStatement = /* @__PURE__ */ function() {
              function DebuggerStatement2() {
                this.type = syntax_1.Syntax.DebuggerStatement;
              }
              return DebuggerStatement2;
            }();
            exports3.DebuggerStatement = DebuggerStatement;
            var Directive = /* @__PURE__ */ function() {
              function Directive2(expression, directive) {
                this.type = syntax_1.Syntax.ExpressionStatement, this.expression = expression, this.directive = directive;
              }
              return Directive2;
            }();
            exports3.Directive = Directive;
            var DoWhileStatement = /* @__PURE__ */ function() {
              function DoWhileStatement2(body, test) {
                this.type = syntax_1.Syntax.DoWhileStatement, this.body = body, this.test = test;
              }
              return DoWhileStatement2;
            }();
            exports3.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = /* @__PURE__ */ function() {
              function EmptyStatement2() {
                this.type = syntax_1.Syntax.EmptyStatement;
              }
              return EmptyStatement2;
            }();
            exports3.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = /* @__PURE__ */ function() {
              function ExportAllDeclaration2(source2) {
                this.type = syntax_1.Syntax.ExportAllDeclaration, this.source = source2;
              }
              return ExportAllDeclaration2;
            }();
            exports3.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = /* @__PURE__ */ function() {
              function ExportDefaultDeclaration2(declaration) {
                this.type = syntax_1.Syntax.ExportDefaultDeclaration, this.declaration = declaration;
              }
              return ExportDefaultDeclaration2;
            }();
            exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = /* @__PURE__ */ function() {
              function ExportNamedDeclaration2(declaration, specifiers, source2) {
                this.type = syntax_1.Syntax.ExportNamedDeclaration, this.declaration = declaration, this.specifiers = specifiers, this.source = source2;
              }
              return ExportNamedDeclaration2;
            }();
            exports3.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = /* @__PURE__ */ function() {
              function ExportSpecifier2(local, exported) {
                this.type = syntax_1.Syntax.ExportSpecifier, this.exported = exported, this.local = local;
              }
              return ExportSpecifier2;
            }();
            exports3.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = /* @__PURE__ */ function() {
              function ExpressionStatement2(expression) {
                this.type = syntax_1.Syntax.ExpressionStatement, this.expression = expression;
              }
              return ExpressionStatement2;
            }();
            exports3.ExpressionStatement = ExpressionStatement;
            var ForInStatement = /* @__PURE__ */ function() {
              function ForInStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForInStatement, this.left = left, this.right = right, this.body = body, this.each = !1;
              }
              return ForInStatement2;
            }();
            exports3.ForInStatement = ForInStatement;
            var ForOfStatement = /* @__PURE__ */ function() {
              function ForOfStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForOfStatement, this.left = left, this.right = right, this.body = body;
              }
              return ForOfStatement2;
            }();
            exports3.ForOfStatement = ForOfStatement;
            var ForStatement = /* @__PURE__ */ function() {
              function ForStatement2(init, test, update2, body) {
                this.type = syntax_1.Syntax.ForStatement, this.init = init, this.test = test, this.update = update2, this.body = body;
              }
              return ForStatement2;
            }();
            exports3.ForStatement = ForStatement;
            var FunctionDeclaration = /* @__PURE__ */ function() {
              function FunctionDeclaration2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionDeclaration, this.id = id, this.params = params, this.body = body, this.generator = generator, this.expression = !1, this.async = !1;
              }
              return FunctionDeclaration2;
            }();
            exports3.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = /* @__PURE__ */ function() {
              function FunctionExpression2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionExpression, this.id = id, this.params = params, this.body = body, this.generator = generator, this.expression = !1, this.async = !1;
              }
              return FunctionExpression2;
            }();
            exports3.FunctionExpression = FunctionExpression;
            var Identifier = /* @__PURE__ */ function() {
              function Identifier2(name) {
                this.type = syntax_1.Syntax.Identifier, this.name = name;
              }
              return Identifier2;
            }();
            exports3.Identifier = Identifier;
            var IfStatement = /* @__PURE__ */ function() {
              function IfStatement2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.IfStatement, this.test = test, this.consequent = consequent, this.alternate = alternate;
              }
              return IfStatement2;
            }();
            exports3.IfStatement = IfStatement;
            var ImportDeclaration = /* @__PURE__ */ function() {
              function ImportDeclaration2(specifiers, source2) {
                this.type = syntax_1.Syntax.ImportDeclaration, this.specifiers = specifiers, this.source = source2;
              }
              return ImportDeclaration2;
            }();
            exports3.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = /* @__PURE__ */ function() {
              function ImportDefaultSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportDefaultSpecifier, this.local = local;
              }
              return ImportDefaultSpecifier2;
            }();
            exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
              function ImportNamespaceSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportNamespaceSpecifier, this.local = local;
              }
              return ImportNamespaceSpecifier2;
            }();
            exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = /* @__PURE__ */ function() {
              function ImportSpecifier2(local, imported) {
                this.type = syntax_1.Syntax.ImportSpecifier, this.local = local, this.imported = imported;
              }
              return ImportSpecifier2;
            }();
            exports3.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = /* @__PURE__ */ function() {
              function LabeledStatement2(label, body) {
                this.type = syntax_1.Syntax.LabeledStatement, this.label = label, this.body = body;
              }
              return LabeledStatement2;
            }();
            exports3.LabeledStatement = LabeledStatement;
            var Literal = /* @__PURE__ */ function() {
              function Literal2(value, raw) {
                this.type = syntax_1.Syntax.Literal, this.value = value, this.raw = raw;
              }
              return Literal2;
            }();
            exports3.Literal = Literal;
            var MetaProperty = /* @__PURE__ */ function() {
              function MetaProperty2(meta, property) {
                this.type = syntax_1.Syntax.MetaProperty, this.meta = meta, this.property = property;
              }
              return MetaProperty2;
            }();
            exports3.MetaProperty = MetaProperty;
            var MethodDefinition = /* @__PURE__ */ function() {
              function MethodDefinition2(key2, computed, value, kind, isStatic) {
                this.type = syntax_1.Syntax.MethodDefinition, this.key = key2, this.computed = computed, this.value = value, this.kind = kind, this.static = isStatic;
              }
              return MethodDefinition2;
            }();
            exports3.MethodDefinition = MethodDefinition;
            var Module = /* @__PURE__ */ function() {
              function Module2(body) {
                this.type = syntax_1.Syntax.Program, this.body = body, this.sourceType = "module";
              }
              return Module2;
            }();
            exports3.Module = Module;
            var NewExpression = /* @__PURE__ */ function() {
              function NewExpression2(callee, args) {
                this.type = syntax_1.Syntax.NewExpression, this.callee = callee, this.arguments = args;
              }
              return NewExpression2;
            }();
            exports3.NewExpression = NewExpression;
            var ObjectExpression = /* @__PURE__ */ function() {
              function ObjectExpression2(properties) {
                this.type = syntax_1.Syntax.ObjectExpression, this.properties = properties;
              }
              return ObjectExpression2;
            }();
            exports3.ObjectExpression = ObjectExpression;
            var ObjectPattern = /* @__PURE__ */ function() {
              function ObjectPattern2(properties) {
                this.type = syntax_1.Syntax.ObjectPattern, this.properties = properties;
              }
              return ObjectPattern2;
            }();
            exports3.ObjectPattern = ObjectPattern;
            var Property = /* @__PURE__ */ function() {
              function Property2(kind, key2, computed, value, method, shorthand) {
                this.type = syntax_1.Syntax.Property, this.key = key2, this.computed = computed, this.value = value, this.kind = kind, this.method = method, this.shorthand = shorthand;
              }
              return Property2;
            }();
            exports3.Property = Property;
            var RegexLiteral = /* @__PURE__ */ function() {
              function RegexLiteral2(value, raw, pattern, flags) {
                this.type = syntax_1.Syntax.Literal, this.value = value, this.raw = raw, this.regex = { pattern, flags };
              }
              return RegexLiteral2;
            }();
            exports3.RegexLiteral = RegexLiteral;
            var RestElement = /* @__PURE__ */ function() {
              function RestElement2(argument) {
                this.type = syntax_1.Syntax.RestElement, this.argument = argument;
              }
              return RestElement2;
            }();
            exports3.RestElement = RestElement;
            var ReturnStatement = /* @__PURE__ */ function() {
              function ReturnStatement2(argument) {
                this.type = syntax_1.Syntax.ReturnStatement, this.argument = argument;
              }
              return ReturnStatement2;
            }();
            exports3.ReturnStatement = ReturnStatement;
            var Script = /* @__PURE__ */ function() {
              function Script2(body) {
                this.type = syntax_1.Syntax.Program, this.body = body, this.sourceType = "script";
              }
              return Script2;
            }();
            exports3.Script = Script;
            var SequenceExpression = /* @__PURE__ */ function() {
              function SequenceExpression2(expressions) {
                this.type = syntax_1.Syntax.SequenceExpression, this.expressions = expressions;
              }
              return SequenceExpression2;
            }();
            exports3.SequenceExpression = SequenceExpression;
            var SpreadElement = /* @__PURE__ */ function() {
              function SpreadElement2(argument) {
                this.type = syntax_1.Syntax.SpreadElement, this.argument = argument;
              }
              return SpreadElement2;
            }();
            exports3.SpreadElement = SpreadElement;
            var StaticMemberExpression = /* @__PURE__ */ function() {
              function StaticMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression, this.computed = !1, this.object = object, this.property = property;
              }
              return StaticMemberExpression2;
            }();
            exports3.StaticMemberExpression = StaticMemberExpression;
            var Super = /* @__PURE__ */ function() {
              function Super2() {
                this.type = syntax_1.Syntax.Super;
              }
              return Super2;
            }();
            exports3.Super = Super;
            var SwitchCase = /* @__PURE__ */ function() {
              function SwitchCase2(test, consequent) {
                this.type = syntax_1.Syntax.SwitchCase, this.test = test, this.consequent = consequent;
              }
              return SwitchCase2;
            }();
            exports3.SwitchCase = SwitchCase;
            var SwitchStatement = /* @__PURE__ */ function() {
              function SwitchStatement2(discriminant, cases) {
                this.type = syntax_1.Syntax.SwitchStatement, this.discriminant = discriminant, this.cases = cases;
              }
              return SwitchStatement2;
            }();
            exports3.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = /* @__PURE__ */ function() {
              function TaggedTemplateExpression2(tag, quasi) {
                this.type = syntax_1.Syntax.TaggedTemplateExpression, this.tag = tag, this.quasi = quasi;
              }
              return TaggedTemplateExpression2;
            }();
            exports3.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = /* @__PURE__ */ function() {
              function TemplateElement2(value, tail) {
                this.type = syntax_1.Syntax.TemplateElement, this.value = value, this.tail = tail;
              }
              return TemplateElement2;
            }();
            exports3.TemplateElement = TemplateElement;
            var TemplateLiteral = /* @__PURE__ */ function() {
              function TemplateLiteral2(quasis, expressions) {
                this.type = syntax_1.Syntax.TemplateLiteral, this.quasis = quasis, this.expressions = expressions;
              }
              return TemplateLiteral2;
            }();
            exports3.TemplateLiteral = TemplateLiteral;
            var ThisExpression = /* @__PURE__ */ function() {
              function ThisExpression2() {
                this.type = syntax_1.Syntax.ThisExpression;
              }
              return ThisExpression2;
            }();
            exports3.ThisExpression = ThisExpression;
            var ThrowStatement = /* @__PURE__ */ function() {
              function ThrowStatement2(argument) {
                this.type = syntax_1.Syntax.ThrowStatement, this.argument = argument;
              }
              return ThrowStatement2;
            }();
            exports3.ThrowStatement = ThrowStatement;
            var TryStatement = /* @__PURE__ */ function() {
              function TryStatement2(block, handler, finalizer) {
                this.type = syntax_1.Syntax.TryStatement, this.block = block, this.handler = handler, this.finalizer = finalizer;
              }
              return TryStatement2;
            }();
            exports3.TryStatement = TryStatement;
            var UnaryExpression = /* @__PURE__ */ function() {
              function UnaryExpression2(operator, argument) {
                this.type = syntax_1.Syntax.UnaryExpression, this.operator = operator, this.argument = argument, this.prefix = !0;
              }
              return UnaryExpression2;
            }();
            exports3.UnaryExpression = UnaryExpression;
            var UpdateExpression = /* @__PURE__ */ function() {
              function UpdateExpression2(operator, argument, prefix) {
                this.type = syntax_1.Syntax.UpdateExpression, this.operator = operator, this.argument = argument, this.prefix = prefix;
              }
              return UpdateExpression2;
            }();
            exports3.UpdateExpression = UpdateExpression;
            var VariableDeclaration = /* @__PURE__ */ function() {
              function VariableDeclaration2(declarations, kind) {
                this.type = syntax_1.Syntax.VariableDeclaration, this.declarations = declarations, this.kind = kind;
              }
              return VariableDeclaration2;
            }();
            exports3.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = /* @__PURE__ */ function() {
              function VariableDeclarator2(id, init) {
                this.type = syntax_1.Syntax.VariableDeclarator, this.id = id, this.init = init;
              }
              return VariableDeclarator2;
            }();
            exports3.VariableDeclarator = VariableDeclarator;
            var WhileStatement = /* @__PURE__ */ function() {
              function WhileStatement2(test, body) {
                this.type = syntax_1.Syntax.WhileStatement, this.test = test, this.body = body;
              }
              return WhileStatement2;
            }();
            exports3.WhileStatement = WhileStatement;
            var WithStatement = /* @__PURE__ */ function() {
              function WithStatement2(object, body) {
                this.type = syntax_1.Syntax.WithStatement, this.object = object, this.body = body;
              }
              return WithStatement2;
            }();
            exports3.WithStatement = WithStatement;
            var YieldExpression = /* @__PURE__ */ function() {
              function YieldExpression2(argument, delegate) {
                this.type = syntax_1.Syntax.YieldExpression, this.argument = argument, this.delegate = delegate;
              }
              return YieldExpression2;
            }();
            exports3.YieldExpression = YieldExpression;
          },
          /* 8 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var assert_1 = __webpack_require__(9), error_handler_1 = __webpack_require__(10), messages_1 = __webpack_require__(11), Node = __webpack_require__(7), scanner_1 = __webpack_require__(12), syntax_1 = __webpack_require__(2), token_1 = __webpack_require__(13), ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder", Parser = function() {
              function Parser2(code, options2, delegate) {
                options2 === void 0 && (options2 = {}), this.config = {
                  range: typeof options2.range == "boolean" && options2.range,
                  loc: typeof options2.loc == "boolean" && options2.loc,
                  source: null,
                  tokens: typeof options2.tokens == "boolean" && options2.tokens,
                  comment: typeof options2.comment == "boolean" && options2.comment,
                  tolerant: typeof options2.tolerant == "boolean" && options2.tolerant
                }, this.config.loc && options2.source && options2.source !== null && (this.config.source = String(options2.source)), this.delegate = delegate, this.errorHandler = new error_handler_1.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new scanner_1.Scanner(code, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = {
                  ")": 0,
                  ";": 0,
                  ",": 0,
                  "=": 0,
                  "]": 0,
                  "||": 1,
                  "&&": 2,
                  "|": 3,
                  "^": 4,
                  "&": 5,
                  "==": 6,
                  "!=": 6,
                  "===": 6,
                  "!==": 6,
                  "<": 7,
                  ">": 7,
                  "<=": 7,
                  ">=": 7,
                  "<<": 8,
                  ">>": 8,
                  ">>>": 8,
                  "+": 9,
                  "-": 9,
                  "*": 11,
                  "/": 11,
                  "%": 11
                }, this.lookahead = {
                  type: 2,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: 0,
                  start: 0,
                  end: 0
                }, this.hasLineTerminator = !1, this.context = {
                  isModule: !1,
                  await: !1,
                  allowIn: !0,
                  allowStrictDirective: !0,
                  allowYield: !0,
                  firstCoverInitializedNameError: null,
                  isAssignmentTarget: !1,
                  isBindingElement: !1,
                  inFunctionBody: !1,
                  inIteration: !1,
                  inSwitch: !1,
                  labelSet: {},
                  strict: !1
                }, this.tokens = [], this.startMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                }, this.lastMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                }, this.nextToken(), this.lastMarker = {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }
              return Parser2.prototype.throwError = function(messageFormat) {
                var args = Array.prototype.slice.call(arguments, 1), msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                  return assert_1.assert(idx < args.length, "Message reference must be in range"), args[idx];
                }), index = this.lastMarker.index, line3 = this.lastMarker.line, column2 = this.lastMarker.column + 1;
                throw this.errorHandler.createError(index, line3, column2, msg);
              }, Parser2.prototype.tolerateError = function(messageFormat) {
                var args = Array.prototype.slice.call(arguments, 1), msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                  return assert_1.assert(idx < args.length, "Message reference must be in range"), args[idx];
                }), index = this.lastMarker.index, line3 = this.scanner.lineNumber, column2 = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(index, line3, column2, msg);
              }, Parser2.prototype.unexpectedTokenError = function(token2, message) {
                var msg = message || messages_1.Messages.UnexpectedToken, value;
                if (token2 ? (message || (msg = token2.type === 2 ? messages_1.Messages.UnexpectedEOS : token2.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token2.type === 6 ? messages_1.Messages.UnexpectedNumber : token2.type === 8 ? messages_1.Messages.UnexpectedString : token2.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken, token2.type === 4 && (this.scanner.isFutureReservedWord(token2.value) ? msg = messages_1.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(token2.value) && (msg = messages_1.Messages.StrictReservedWord))), value = token2.value) : value = "ILLEGAL", msg = msg.replace("%0", value), token2 && typeof token2.lineNumber == "number") {
                  var index = token2.start, line3 = token2.lineNumber, lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column, column2 = token2.start - lastMarkerLineStart + 1;
                  return this.errorHandler.createError(index, line3, column2, msg);
                } else {
                  var index = this.lastMarker.index, line3 = this.lastMarker.line, column2 = this.lastMarker.column + 1;
                  return this.errorHandler.createError(index, line3, column2, msg);
                }
              }, Parser2.prototype.throwUnexpectedToken = function(token2, message) {
                throw this.unexpectedTokenError(token2, message);
              }, Parser2.prototype.tolerateUnexpectedToken = function(token2, message) {
                this.errorHandler.tolerate(this.unexpectedTokenError(token2, message));
              }, Parser2.prototype.collectComments = function() {
                if (!this.config.comment)
                  this.scanner.scanComments();
                else {
                  var comments2 = this.scanner.scanComments();
                  if (comments2.length > 0 && this.delegate)
                    for (var i = 0; i < comments2.length; ++i) {
                      var e = comments2[i], node = void 0;
                      node = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
                      }, this.config.range && (node.range = e.range), this.config.loc && (node.loc = e.loc);
                      var metadata = {
                        start: {
                          line: e.loc.start.line,
                          column: e.loc.start.column,
                          offset: e.range[0]
                        },
                        end: {
                          line: e.loc.end.line,
                          column: e.loc.end.column,
                          offset: e.range[1]
                        }
                      };
                      this.delegate(node, metadata);
                    }
                }
              }, Parser2.prototype.getTokenRaw = function(token2) {
                return this.scanner.source.slice(token2.start, token2.end);
              }, Parser2.prototype.convertToken = function(token2) {
                var t = {
                  type: token_1.TokenName[token2.type],
                  value: this.getTokenRaw(token2)
                };
                if (this.config.range && (t.range = [token2.start, token2.end]), this.config.loc && (t.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                }), token2.type === 9) {
                  var pattern = token2.pattern, flags = token2.flags;
                  t.regex = { pattern, flags };
                }
                return t;
              }, Parser2.prototype.nextToken = function() {
                var token2 = this.lookahead;
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
                var next = this.scanner.lex();
                return this.hasLineTerminator = token2.lineNumber !== next.lineNumber, next && this.context.strict && next.type === 3 && this.scanner.isStrictModeReservedWord(next.value) && (next.type = 4), this.lookahead = next, this.config.tokens && next.type !== 2 && this.tokens.push(this.convertToken(next)), token2;
              }, Parser2.prototype.nextRegexToken = function() {
                this.collectComments();
                var token2 = this.scanner.scanRegExp();
                return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(token2))), this.lookahead = token2, this.nextToken(), token2;
              }, Parser2.prototype.createNode = function() {
                return {
                  index: this.startMarker.index,
                  line: this.startMarker.line,
                  column: this.startMarker.column
                };
              }, Parser2.prototype.startNode = function(token2, lastLineStart) {
                lastLineStart === void 0 && (lastLineStart = 0);
                var column2 = token2.start - token2.lineStart, line3 = token2.lineNumber;
                return column2 < 0 && (column2 += lastLineStart, line3--), {
                  index: token2.start,
                  line: line3,
                  column: column2
                };
              }, Parser2.prototype.finalize = function(marker, node) {
                if (this.config.range && (node.range = [marker.index, this.lastMarker.index]), this.config.loc && (node.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                }, this.config.source && (node.loc.source = this.config.source)), this.delegate) {
                  var metadata = {
                    start: {
                      line: marker.line,
                      column: marker.column,
                      offset: marker.index
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column,
                      offset: this.lastMarker.index
                    }
                  };
                  this.delegate(node, metadata);
                }
                return node;
              }, Parser2.prototype.expect = function(value) {
                var token2 = this.nextToken();
                (token2.type !== 7 || token2.value !== value) && this.throwUnexpectedToken(token2);
              }, Parser2.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var token2 = this.lookahead;
                  token2.type === 7 && token2.value === "," ? this.nextToken() : token2.type === 7 && token2.value === ";" ? (this.nextToken(), this.tolerateUnexpectedToken(token2)) : this.tolerateUnexpectedToken(token2, messages_1.Messages.UnexpectedToken);
                } else
                  this.expect(",");
              }, Parser2.prototype.expectKeyword = function(keyword) {
                var token2 = this.nextToken();
                (token2.type !== 4 || token2.value !== keyword) && this.throwUnexpectedToken(token2);
              }, Parser2.prototype.match = function(value) {
                return this.lookahead.type === 7 && this.lookahead.value === value;
              }, Parser2.prototype.matchKeyword = function(keyword) {
                return this.lookahead.type === 4 && this.lookahead.value === keyword;
              }, Parser2.prototype.matchContextualKeyword = function(keyword) {
                return this.lookahead.type === 3 && this.lookahead.value === keyword;
              }, Parser2.prototype.matchAssign = function() {
                if (this.lookahead.type !== 7)
                  return !1;
                var op = this.lookahead.value;
                return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
              }, Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement, previousIsAssignmentTarget = this.context.isAssignmentTarget, previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                return this.context.firstCoverInitializedNameError !== null && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = previousIsBindingElement, this.context.isAssignmentTarget = previousIsAssignmentTarget, this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError, result;
              }, Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement, previousIsAssignmentTarget = this.context.isAssignmentTarget, previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                return this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement, this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget, this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError, result;
              }, Parser2.prototype.consumeSemicolon = function() {
                this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type !== 2 && !this.match("}") && this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
              }, Parser2.prototype.parsePrimaryExpression = function() {
                var node = this.createNode(), expr, token2, raw;
                switch (this.lookahead.type) {
                  case 3:
                    (this.context.isModule || this.context.await) && this.lookahead.value === "await" && this.tolerateUnexpectedToken(this.lookahead), expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token2 = this.nextToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node, new Node.Literal(token2.value, raw));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token2 = this.nextToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node, new Node.Literal(token2.value === "true", raw));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token2 = this.nextToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node, new Node.Literal(null, raw));
                    break;
                  case 10:
                    expr = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = !1, expr = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index, token2 = this.nextRegexToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node, new Node.RegexLiteral(token2.regex, raw, token2.pattern, token2.flags));
                        break;
                      default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? expr = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? expr = this.finalize(node, new Node.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.matchKeyword("function") ? expr = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), expr = this.finalize(node, new Node.ThisExpression())) : this.matchKeyword("class") ? expr = this.parseClassExpression() : expr = this.throwUnexpectedToken(this.nextToken()));
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                return expr;
              }, Parser2.prototype.parseSpreadElement = function() {
                var node = this.createNode();
                this.expect("...");
                var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(node, new Node.SpreadElement(arg));
              }, Parser2.prototype.parseArrayInitializer = function() {
                var node = this.createNode(), elements = [];
                for (this.expect("["); !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), elements.push(null);
                  else if (this.match("...")) {
                    var element = this.parseSpreadElement();
                    this.match("]") || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(",")), elements.push(element);
                  } else
                    elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
                return this.expect("]"), this.finalize(node, new Node.ArrayExpression(elements));
              }, Parser2.prototype.parsePropertyMethod = function(params) {
                this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = params.simple;
                var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                return this.context.strict && params.firstRestricted && this.tolerateUnexpectedToken(params.firstRestricted, params.message), this.context.strict && params.stricted && this.tolerateUnexpectedToken(params.stricted, params.message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, body;
              }, Parser2.prototype.parsePropertyMethodFunction = function() {
                var isGenerator = !1, node = this.createNode(), previousAllowYield = this.context.allowYield;
                this.context.allowYield = !0;
                var params = this.parseFormalParameters(), method = this.parsePropertyMethod(params);
                return this.context.allowYield = previousAllowYield, this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              }, Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
                var node = this.createNode(), previousAllowYield = this.context.allowYield, previousAwait = this.context.await;
                this.context.allowYield = !1, this.context.await = !0;
                var params = this.parseFormalParameters(), method = this.parsePropertyMethod(params);
                return this.context.allowYield = previousAllowYield, this.context.await = previousAwait, this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
              }, Parser2.prototype.parseObjectPropertyKey = function() {
                var node = this.createNode(), token2 = this.nextToken(), key2;
                switch (token2.type) {
                  case 8:
                  case 6:
                    this.context.strict && token2.octal && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictOctalLiteral);
                    var raw = this.getTokenRaw(token2);
                    key2 = this.finalize(node, new Node.Literal(token2.value, raw));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    key2 = this.finalize(node, new Node.Identifier(token2.value));
                    break;
                  case 7:
                    token2.value === "[" ? (key2 = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : key2 = this.throwUnexpectedToken(token2);
                    break;
                  default:
                    key2 = this.throwUnexpectedToken(token2);
                }
                return key2;
              }, Parser2.prototype.isPropertyKey = function(key2, value) {
                return key2.type === syntax_1.Syntax.Identifier && key2.name === value || key2.type === syntax_1.Syntax.Literal && key2.value === value;
              }, Parser2.prototype.parseObjectProperty = function(hasProto) {
                var node = this.createNode(), token2 = this.lookahead, kind, key2 = null, value = null, computed = !1, method = !1, shorthand = !1, isAsync = !1;
                if (token2.type === 3) {
                  var id = token2.value;
                  this.nextToken(), computed = this.match("["), isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(","), key2 = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
                } else this.match("*") ? this.nextToken() : (computed = this.match("["), key2 = this.parseObjectPropertyKey());
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token2.type === 3 && !isAsync && token2.value === "get" && lookaheadPropertyKey)
                  kind = "get", computed = this.match("["), key2 = this.parseObjectPropertyKey(), this.context.allowYield = !1, value = this.parseGetterMethod();
                else if (token2.type === 3 && !isAsync && token2.value === "set" && lookaheadPropertyKey)
                  kind = "set", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseSetterMethod();
                else if (token2.type === 7 && token2.value === "*" && lookaheadPropertyKey)
                  kind = "init", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseGeneratorMethod(), method = !0;
                else if (key2 || this.throwUnexpectedToken(this.lookahead), kind = "init", this.match(":") && !isAsync)
                  !computed && this.isPropertyKey(key2, "__proto__") && (hasProto.value && this.tolerateError(messages_1.Messages.DuplicateProtoProperty), hasProto.value = !0), this.nextToken(), value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                else if (this.match("("))
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), method = !0;
                else if (token2.type === 3) {
                  var id = this.finalize(node, new Node.Identifier(token2.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), shorthand = !0;
                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
                  } else
                    shorthand = !0, value = id;
                } else
                  this.throwUnexpectedToken(this.nextToken());
                return this.finalize(node, new Node.Property(kind, key2, computed, value, method, shorthand));
              }, Parser2.prototype.parseObjectInitializer = function() {
                var node = this.createNode();
                this.expect("{");
                for (var properties = [], hasProto = { value: !1 }; !this.match("}"); )
                  properties.push(this.parseObjectProperty(hasProto)), this.match("}") || this.expectCommaSeparator();
                return this.expect("}"), this.finalize(node, new Node.ObjectExpression(properties));
              }, Parser2.prototype.parseTemplateHead = function() {
                assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                var node = this.createNode(), token2 = this.nextToken(), raw = token2.value, cooked = token2.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token2.tail));
              }, Parser2.prototype.parseTemplateElement = function() {
                this.lookahead.type !== 10 && this.throwUnexpectedToken();
                var node = this.createNode(), token2 = this.nextToken(), raw = token2.value, cooked = token2.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token2.tail));
              }, Parser2.prototype.parseTemplateLiteral = function() {
                var node = this.createNode(), expressions = [], quasis = [], quasi = this.parseTemplateHead();
                for (quasis.push(quasi); !quasi.tail; )
                  expressions.push(this.parseExpression()), quasi = this.parseTemplateElement(), quasis.push(quasi);
                return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
              }, Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                  case syntax_1.Syntax.MemberExpression:
                  case syntax_1.Syntax.RestElement:
                  case syntax_1.Syntax.AssignmentPattern:
                    break;
                  case syntax_1.Syntax.SpreadElement:
                    expr.type = syntax_1.Syntax.RestElement, this.reinterpretExpressionAsPattern(expr.argument);
                    break;
                  case syntax_1.Syntax.ArrayExpression:
                    expr.type = syntax_1.Syntax.ArrayPattern;
                    for (var i = 0; i < expr.elements.length; i++)
                      expr.elements[i] !== null && this.reinterpretExpressionAsPattern(expr.elements[i]);
                    break;
                  case syntax_1.Syntax.ObjectExpression:
                    expr.type = syntax_1.Syntax.ObjectPattern;
                    for (var i = 0; i < expr.properties.length; i++)
                      this.reinterpretExpressionAsPattern(expr.properties[i].value);
                    break;
                  case syntax_1.Syntax.AssignmentExpression:
                    expr.type = syntax_1.Syntax.AssignmentPattern, delete expr.operator, this.reinterpretExpressionAsPattern(expr.left);
                    break;
                }
              }, Parser2.prototype.parseGroupExpression = function() {
                var expr;
                if (this.expect("("), this.match(")"))
                  this.nextToken(), this.match("=>") || this.expect("=>"), expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [],
                    async: !1
                  };
                else {
                  var startToken = this.lookahead, params = [];
                  if (this.match("..."))
                    expr = this.parseRestElement(params), this.expect(")"), this.match("=>") || this.expect("=>"), expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [expr],
                      async: !1
                    };
                  else {
                    var arrow4 = !1;
                    if (this.context.isBindingElement = !0, expr = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
                      var expressions = [];
                      for (this.context.isAssignmentTarget = !1, expressions.push(expr); this.lookahead.type !== 2 && this.match(","); ) {
                        if (this.nextToken(), this.match(")")) {
                          this.nextToken();
                          for (var i = 0; i < expressions.length; i++)
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          arrow4 = !0, expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: !1
                          };
                        } else if (this.match("...")) {
                          this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), expressions.push(this.parseRestElement(params)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = !1;
                          for (var i = 0; i < expressions.length; i++)
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          arrow4 = !0, expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: !1
                          };
                        } else
                          expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (arrow4)
                          break;
                      }
                      arrow4 || (expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions)));
                    }
                    if (!arrow4) {
                      if (this.expect(")"), this.match("=>") && (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield" && (arrow4 = !0, expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [expr],
                        async: !1
                      }), !arrow4)) {
                        if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), expr.type === syntax_1.Syntax.SequenceExpression)
                          for (var i = 0; i < expr.expressions.length; i++)
                            this.reinterpretExpressionAsPattern(expr.expressions[i]);
                        else
                          this.reinterpretExpressionAsPattern(expr);
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: !1
                        };
                      }
                      this.context.isBindingElement = !1;
                    }
                  }
                }
                return expr;
              }, Parser2.prototype.parseArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (args.push(expr), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                      break;
                  }
                return this.expect(")"), args;
              }, Parser2.prototype.isIdentifierName = function(token2) {
                return token2.type === 3 || token2.type === 4 || token2.type === 1 || token2.type === 5;
              }, Parser2.prototype.parseIdentifierName = function() {
                var node = this.createNode(), token2 = this.nextToken();
                return this.isIdentifierName(token2) || this.throwUnexpectedToken(token2), this.finalize(node, new Node.Identifier(token2.value));
              }, Parser2.prototype.parseNewExpression = function() {
                var node = this.createNode(), id = this.parseIdentifierName();
                assert_1.assert(id.name === "new", "New expression must start with `new`");
                var expr;
                if (this.match("."))
                  if (this.nextToken(), this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                    var property = this.parseIdentifierName();
                    expr = new Node.MetaProperty(id, property);
                  } else
                    this.throwUnexpectedToken(this.lookahead);
                else {
                  var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression), args = this.match("(") ? this.parseArguments() : [];
                  expr = new Node.NewExpression(callee, args), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                }
                return this.finalize(node, expr);
              }, Parser2.prototype.parseAsyncArgument = function() {
                var arg = this.parseAssignmentExpression();
                return this.context.firstCoverInitializedNameError = null, arg;
              }, Parser2.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    if (args.push(expr), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                      break;
                  }
                return this.expect(")"), args;
              }, Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var startToken = this.lookahead, maybeAsync = this.matchContextualKeyword("async"), previousAllowIn = this.context.allowIn;
                this.context.allowIn = !0;
                var expr;
                for (this.matchKeyword("super") && this.context.inFunctionBody ? (expr = this.createNode(), this.nextToken(), expr = this.finalize(expr, new Node.Super()), !this.match("(") && !this.match(".") && !this.match("[") && this.throwUnexpectedToken(this.lookahead)) : expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match(".")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                  } else if (this.match("(")) {
                    var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1;
                    var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                    if (expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args)), asyncArrow && this.match("=>")) {
                      for (var i = 0; i < args.length; ++i)
                        this.reinterpretExpressionAsPattern(args[i]);
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: args,
                        async: !0
                      };
                    }
                  } else if (this.match("[")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                  } else
                    break;
                return this.context.allowIn = previousAllowIn, expr;
              }, Parser2.prototype.parseSuper = function() {
                var node = this.createNode();
                return this.expectKeyword("super"), !this.match("[") && !this.match(".") && this.throwUnexpectedToken(this.lookahead), this.finalize(node, new Node.Super());
              }, Parser2.prototype.parseLeftHandSideExpression = function() {
                assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                for (var node = this.startNode(this.lookahead), expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match("[")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                  } else if (this.match(".")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                  } else
                    break;
                return expr;
              }, Parser2.prototype.parseUpdateExpression = function() {
                var expr, startToken = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var node = this.startNode(startToken), token2 = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name) && this.tolerateError(messages_1.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  var prefix = !0;
                  expr = this.finalize(node, new Node.UpdateExpression(token2.value, expr, prefix)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                } else if (expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === 7 && (this.match("++") || this.match("--"))) {
                  this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name) && this.tolerateError(messages_1.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var operator = this.nextToken().value, prefix = !1;
                  expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                }
                return expr;
              }, Parser2.prototype.parseAwaitExpression = function() {
                var node = this.createNode();
                this.nextToken();
                var argument = this.parseUnaryExpression();
                return this.finalize(node, new Node.AwaitExpression(argument));
              }, Parser2.prototype.parseUnaryExpression = function() {
                var expr;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var node = this.startNode(this.lookahead), token2 = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression), expr = this.finalize(node, new Node.UnaryExpression(token2.value, expr)), this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier && this.tolerateError(messages_1.Messages.StrictDelete), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                } else this.context.await && this.matchContextualKeyword("await") ? expr = this.parseAwaitExpression() : expr = this.parseUpdateExpression();
                return expr;
              }, Parser2.prototype.parseExponentiationExpression = function() {
                var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var left = expr, right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
                }
                return expr;
              }, Parser2.prototype.binaryPrecedence = function(token2) {
                var op = token2.value, precedence;
                return token2.type === 7 ? precedence = this.operatorPrecedence[op] || 0 : token2.type === 4 ? precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0 : precedence = 0, precedence;
              }, Parser2.prototype.parseBinaryExpression = function() {
                var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseExponentiationExpression), token2 = this.lookahead, prec = this.binaryPrecedence(token2);
                if (prec > 0) {
                  this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  for (var markers = [startToken, this.lookahead], left = expr, right = this.isolateCoverGrammar(this.parseExponentiationExpression), stack2 = [left, token2.value, right], precedences = [prec]; prec = this.binaryPrecedence(this.lookahead), !(prec <= 0); ) {
                    for (; stack2.length > 2 && prec <= precedences[precedences.length - 1]; ) {
                      right = stack2.pop();
                      var operator = stack2.pop();
                      precedences.pop(), left = stack2.pop(), markers.pop();
                      var node = this.startNode(markers[markers.length - 1]);
                      stack2.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                    }
                    stack2.push(this.nextToken().value), precedences.push(prec), markers.push(this.lookahead), stack2.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var i = stack2.length - 1;
                  expr = stack2[i];
                  for (var lastMarker = markers.pop(); i > 1; ) {
                    var marker = markers.pop(), lastLineStart = lastMarker && lastMarker.lineStart, node = this.startNode(marker, lastLineStart), operator = stack2[i - 1];
                    expr = this.finalize(node, new Node.BinaryExpression(operator, stack2[i - 2], expr)), i -= 2, lastMarker = marker;
                  }
                }
                return expr;
              }, Parser2.prototype.parseConditionalExpression = function() {
                var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = !0;
                  var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn, this.expect(":");
                  var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                }
                return expr;
              }, Parser2.prototype.checkPatternParam = function(options2, param) {
                switch (param.type) {
                  case syntax_1.Syntax.Identifier:
                    this.validateParam(options2, param, param.name);
                    break;
                  case syntax_1.Syntax.RestElement:
                    this.checkPatternParam(options2, param.argument);
                    break;
                  case syntax_1.Syntax.AssignmentPattern:
                    this.checkPatternParam(options2, param.left);
                    break;
                  case syntax_1.Syntax.ArrayPattern:
                    for (var i = 0; i < param.elements.length; i++)
                      param.elements[i] !== null && this.checkPatternParam(options2, param.elements[i]);
                    break;
                  case syntax_1.Syntax.ObjectPattern:
                    for (var i = 0; i < param.properties.length; i++)
                      this.checkPatternParam(options2, param.properties[i].value);
                    break;
                }
                options2.simple = options2.simple && param instanceof Node.Identifier;
              }, Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
                var params = [expr], options2, asyncArrow = !1;
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                    break;
                  case ArrowParameterPlaceHolder:
                    params = expr.params, asyncArrow = expr.async;
                    break;
                  default:
                    return null;
                }
                options2 = {
                  simple: !0,
                  paramSet: {}
                };
                for (var i = 0; i < params.length; ++i) {
                  var param = params[i];
                  param.type === syntax_1.Syntax.AssignmentPattern ? param.right.type === syntax_1.Syntax.YieldExpression && (param.right.argument && this.throwUnexpectedToken(this.lookahead), param.right.type = syntax_1.Syntax.Identifier, param.right.name = "yield", delete param.right.argument, delete param.right.delegate) : asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await" && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(options2, param), params[i] = param;
                }
                if (this.context.strict || !this.context.allowYield)
                  for (var i = 0; i < params.length; ++i) {
                    var param = params[i];
                    param.type === syntax_1.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
                  }
                if (options2.message === messages_1.Messages.StrictParamDupe) {
                  var token2 = this.context.strict ? options2.stricted : options2.firstRestricted;
                  this.throwUnexpectedToken(token2, options2.message);
                }
                return {
                  simple: options2.simple,
                  params,
                  stricted: options2.stricted,
                  firstRestricted: options2.firstRestricted,
                  message: options2.message
                };
              }, Parser2.prototype.parseAssignmentExpression = function() {
                var expr;
                if (!this.context.allowYield && this.matchKeyword("yield"))
                  expr = this.parseYieldExpression();
                else {
                  var startToken = this.lookahead, token2 = startToken;
                  if (expr = this.parseConditionalExpression(), token2.type === 3 && token2.lineNumber === this.lookahead.lineNumber && token2.value === "async" && (this.lookahead.type === 3 || this.matchKeyword("yield"))) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg), expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: !0
                    };
                  }
                  if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                    var isAsync = expr.async, list2 = this.reinterpretAsCoverFormalsList(expr);
                    if (list2) {
                      this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
                      var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = list2.simple;
                      var previousAllowYield = this.context.allowYield, previousAwait = this.context.await;
                      this.context.allowYield = !0, this.context.await = isAsync;
                      var node = this.startNode(startToken);
                      this.expect("=>");
                      var body = void 0;
                      if (this.match("{")) {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = !0, body = this.parseFunctionSourceElements(), this.context.allowIn = previousAllowIn;
                      } else
                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      var expression = body.type !== syntax_1.Syntax.BlockStatement;
                      this.context.strict && list2.firstRestricted && this.throwUnexpectedToken(list2.firstRestricted, list2.message), this.context.strict && list2.stricted && this.tolerateUnexpectedToken(list2.stricted, list2.message), expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list2.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list2.params, body, expression)), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.allowYield = previousAllowYield, this.context.await = previousAwait;
                    }
                  } else if (this.matchAssign()) {
                    if (this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment), this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      this.scanner.isRestrictedWord(id.name) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(id.name) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord);
                    }
                    this.match("=") ? this.reinterpretExpressionAsPattern(expr) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1), token2 = this.nextToken();
                    var operator = token2.value, right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right)), this.context.firstCoverInitializedNameError = null;
                  }
                }
                return expr;
              }, Parser2.prototype.parseExpression = function() {
                var startToken = this.lookahead, expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  for (expressions.push(expr); this.lookahead.type !== 2 && this.match(","); )
                    this.nextToken(), expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                }
                return expr;
              }, Parser2.prototype.parseStatementListItem = function() {
                var statement;
                if (this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0, this.lookahead.type === 4)
                  switch (this.lookahead.value) {
                    case "export":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration), statement = this.parseExportDeclaration();
                      break;
                    case "import":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration), statement = this.parseImportDeclaration();
                      break;
                    case "const":
                      statement = this.parseLexicalDeclaration({ inFor: !1 });
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      statement = this.parseClassDeclaration();
                      break;
                    case "let":
                      statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement();
                      break;
                    default:
                      statement = this.parseStatement();
                      break;
                  }
                else
                  statement = this.parseStatement();
                return statement;
              }, Parser2.prototype.parseBlock = function() {
                var node = this.createNode();
                this.expect("{");
                for (var block = []; !this.match("}"); )
                  block.push(this.parseStatementListItem());
                return this.expect("}"), this.finalize(node, new Node.BlockStatement(block));
              }, Parser2.prototype.parseLexicalBinding = function(kind, options2) {
                var node = this.createNode(), params = [], id = this.parsePattern(params, kind);
                this.context.strict && id.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(id.name) && this.tolerateError(messages_1.Messages.StrictVarName);
                var init = null;
                return kind === "const" ? !this.matchKeyword("in") && !this.matchContextualKeyword("of") && (this.match("=") ? (this.nextToken(), init = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const")) : (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) && (this.expect("="), init = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(node, new Node.VariableDeclarator(id, init));
              }, Parser2.prototype.parseBindingList = function(kind, options2) {
                for (var list2 = [this.parseLexicalBinding(kind, options2)]; this.match(","); )
                  this.nextToken(), list2.push(this.parseLexicalBinding(kind, options2));
                return list2;
              }, Parser2.prototype.isLexicalDeclaration = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                return this.scanner.restoreState(state), next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
              }, Parser2.prototype.parseLexicalDeclaration = function(options2) {
                var node = this.createNode(), kind = this.nextToken().value;
                assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                var declarations = this.parseBindingList(kind, options2);
                return this.consumeSemicolon(), this.finalize(node, new Node.VariableDeclaration(declarations, kind));
              }, Parser2.prototype.parseBindingRestElement = function(params, kind) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params, kind);
                return this.finalize(node, new Node.RestElement(arg));
              }, Parser2.prototype.parseArrayPattern = function(params, kind) {
                var node = this.createNode();
                this.expect("[");
                for (var elements = []; !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), elements.push(null);
                  else {
                    if (this.match("...")) {
                      elements.push(this.parseBindingRestElement(params, kind));
                      break;
                    } else
                      elements.push(this.parsePatternWithDefault(params, kind));
                    this.match("]") || this.expect(",");
                  }
                return this.expect("]"), this.finalize(node, new Node.ArrayPattern(elements));
              }, Parser2.prototype.parsePropertyPattern = function(params, kind) {
                var node = this.createNode(), computed = !1, shorthand = !1, method = !1, key2, value;
                if (this.lookahead.type === 3) {
                  var keyToken = this.lookahead;
                  key2 = this.parseVariableIdentifier();
                  var init = this.finalize(node, new Node.Identifier(keyToken.value));
                  if (this.match("=")) {
                    params.push(keyToken), shorthand = !0, this.nextToken();
                    var expr = this.parseAssignmentExpression();
                    value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                  } else this.match(":") ? (this.expect(":"), value = this.parsePatternWithDefault(params, kind)) : (params.push(keyToken), shorthand = !0, value = init);
                } else
                  computed = this.match("["), key2 = this.parseObjectPropertyKey(), this.expect(":"), value = this.parsePatternWithDefault(params, kind);
                return this.finalize(node, new Node.Property("init", key2, computed, value, method, shorthand));
              }, Parser2.prototype.parseObjectPattern = function(params, kind) {
                var node = this.createNode(), properties = [];
                for (this.expect("{"); !this.match("}"); )
                  properties.push(this.parsePropertyPattern(params, kind)), this.match("}") || this.expect(",");
                return this.expect("}"), this.finalize(node, new Node.ObjectPattern(properties));
              }, Parser2.prototype.parsePattern = function(params, kind) {
                var pattern;
                return this.match("[") ? pattern = this.parseArrayPattern(params, kind) : this.match("{") ? pattern = this.parseObjectPattern(params, kind) : (this.matchKeyword("let") && (kind === "const" || kind === "let") && this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding), params.push(this.lookahead), pattern = this.parseVariableIdentifier(kind)), pattern;
              }, Parser2.prototype.parsePatternWithDefault = function(params, kind) {
                var startToken = this.lookahead, pattern = this.parsePattern(params, kind);
                if (this.match("=")) {
                  this.nextToken();
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = !0;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = previousAllowYield, pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
                }
                return pattern;
              }, Parser2.prototype.parseVariableIdentifier = function(kind) {
                var node = this.createNode(), token2 = this.nextToken();
                return token2.type === 4 && token2.value === "yield" ? this.context.strict ? this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(token2) : token2.type !== 3 ? this.context.strict && token2.type === 4 && this.scanner.isStrictModeReservedWord(token2.value) ? this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord) : (this.context.strict || token2.value !== "let" || kind !== "var") && this.throwUnexpectedToken(token2) : (this.context.isModule || this.context.await) && token2.type === 3 && token2.value === "await" && this.tolerateUnexpectedToken(token2), this.finalize(node, new Node.Identifier(token2.value));
              }, Parser2.prototype.parseVariableDeclaration = function(options2) {
                var node = this.createNode(), params = [], id = this.parsePattern(params, "var");
                this.context.strict && id.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(id.name) && this.tolerateError(messages_1.Messages.StrictVarName);
                var init = null;
                return this.match("=") ? (this.nextToken(), init = this.isolateCoverGrammar(this.parseAssignmentExpression)) : id.type !== syntax_1.Syntax.Identifier && !options2.inFor && this.expect("="), this.finalize(node, new Node.VariableDeclarator(id, init));
              }, Parser2.prototype.parseVariableDeclarationList = function(options2) {
                var opt = { inFor: options2.inFor }, list2 = [];
                for (list2.push(this.parseVariableDeclaration(opt)); this.match(","); )
                  this.nextToken(), list2.push(this.parseVariableDeclaration(opt));
                return list2;
              }, Parser2.prototype.parseVariableStatement = function() {
                var node = this.createNode();
                this.expectKeyword("var");
                var declarations = this.parseVariableDeclarationList({ inFor: !1 });
                return this.consumeSemicolon(), this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
              }, Parser2.prototype.parseEmptyStatement = function() {
                var node = this.createNode();
                return this.expect(";"), this.finalize(node, new Node.EmptyStatement());
              }, Parser2.prototype.parseExpressionStatement = function() {
                var node = this.createNode(), expr = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(node, new Node.ExpressionStatement(expr));
              }, Parser2.prototype.parseIfClause = function() {
                return this.context.strict && this.matchKeyword("function") && this.tolerateError(messages_1.Messages.StrictFunction), this.parseStatement();
              }, Parser2.prototype.parseIfStatement = function() {
                var node = this.createNode(), consequent, alternate = null;
                this.expectKeyword("if"), this.expect("(");
                var test = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), consequent = this.finalize(this.createNode(), new Node.EmptyStatement())) : (this.expect(")"), consequent = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), alternate = this.parseIfClause())), this.finalize(node, new Node.IfStatement(test, consequent, alternate));
              }, Parser2.prototype.parseDoWhileStatement = function() {
                var node = this.createNode();
                this.expectKeyword("do");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = !0;
                var body = this.parseStatement();
                this.context.inIteration = previousInIteration, this.expectKeyword("while"), this.expect("(");
                var test = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(";") && this.nextToken()), this.finalize(node, new Node.DoWhileStatement(body, test));
              }, Parser2.prototype.parseWhileStatement = function() {
                var node = this.createNode(), body;
                this.expectKeyword("while"), this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node.EmptyStatement());
                else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = !0, body = this.parseStatement(), this.context.inIteration = previousInIteration;
                }
                return this.finalize(node, new Node.WhileStatement(test, body));
              }, Parser2.prototype.parseForStatement = function() {
                var init = null, test = null, update2 = null, forIn = !0, left, right, node = this.createNode();
                if (this.expectKeyword("for"), this.expect("("), this.match(";"))
                  this.nextToken();
                else if (this.matchKeyword("var")) {
                  init = this.createNode(), this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = !1;
                  var declarations = this.parseVariableDeclarationList({ inFor: !0 });
                  if (this.context.allowIn = previousAllowIn, declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in"), init = this.finalize(init, new Node.VariableDeclaration(declarations, "var")), this.nextToken(), left = init, right = this.parseExpression(), init = null;
                  } else declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of") ? (init = this.finalize(init, new Node.VariableDeclaration(declarations, "var")), this.nextToken(), left = init, right = this.parseAssignmentExpression(), init = null, forIn = !1) : (init = this.finalize(init, new Node.VariableDeclaration(declarations, "var")), this.expect(";"));
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in")
                    init = this.finalize(init, new Node.Identifier(kind)), this.nextToken(), left = init, right = this.parseExpression(), init = null;
                  else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = !1;
                    var declarations = this.parseBindingList(kind, { inFor: !0 });
                    this.context.allowIn = previousAllowIn, declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in") ? (init = this.finalize(init, new Node.VariableDeclaration(declarations, kind)), this.nextToken(), left = init, right = this.parseExpression(), init = null) : declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of") ? (init = this.finalize(init, new Node.VariableDeclaration(declarations, kind)), this.nextToken(), left = init, right = this.parseAssignmentExpression(), init = null, forIn = !1) : (this.consumeSemicolon(), init = this.finalize(init, new Node.VariableDeclaration(declarations, kind)));
                  }
                } else {
                  var initStartToken = this.lookahead, previousAllowIn = this.context.allowIn;
                  if (this.context.allowIn = !1, init = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = previousAllowIn, this.matchKeyword("in"))
                    (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) && this.tolerateError(messages_1.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(init), left = init, right = this.parseExpression(), init = null;
                  else if (this.matchContextualKeyword("of"))
                    (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) && this.tolerateError(messages_1.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(init), left = init, right = this.parseAssignmentExpression(), init = null, forIn = !1;
                  else {
                    if (this.match(",")) {
                      for (var initSeq = [init]; this.match(","); )
                        this.nextToken(), initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
                typeof left > "u" && (this.match(";") || (test = this.parseExpression()), this.expect(";"), this.match(")") || (update2 = this.parseExpression()));
                var body;
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node.EmptyStatement());
                else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = !0, body = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = previousInIteration;
                }
                return typeof left > "u" ? this.finalize(node, new Node.ForStatement(init, test, update2, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
              }, Parser2.prototype.parseContinueStatement = function() {
                var node = this.createNode();
                this.expectKeyword("continue");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  label = id;
                  var key2 = "$" + id.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, key2) || this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                return this.consumeSemicolon(), label === null && !this.context.inIteration && this.throwError(messages_1.Messages.IllegalContinue), this.finalize(node, new Node.ContinueStatement(label));
              }, Parser2.prototype.parseBreakStatement = function() {
                var node = this.createNode();
                this.expectKeyword("break");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier(), key2 = "$" + id.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, key2) || this.throwError(messages_1.Messages.UnknownLabel, id.name), label = id;
                }
                return this.consumeSemicolon(), label === null && !this.context.inIteration && !this.context.inSwitch && this.throwError(messages_1.Messages.IllegalBreak), this.finalize(node, new Node.BreakStatement(label));
              }, Parser2.prototype.parseReturnStatement = function() {
                this.context.inFunctionBody || this.tolerateError(messages_1.Messages.IllegalReturn);
                var node = this.createNode();
                this.expectKeyword("return");
                var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10, argument = hasArgument ? this.parseExpression() : null;
                return this.consumeSemicolon(), this.finalize(node, new Node.ReturnStatement(argument));
              }, Parser2.prototype.parseWithStatement = function() {
                this.context.strict && this.tolerateError(messages_1.Messages.StrictModeWith);
                var node = this.createNode(), body;
                this.expectKeyword("with"), this.expect("(");
                var object = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node.EmptyStatement())) : (this.expect(")"), body = this.parseStatement()), this.finalize(node, new Node.WithStatement(object, body));
              }, Parser2.prototype.parseSwitchCase = function() {
                var node = this.createNode(), test;
                this.matchKeyword("default") ? (this.nextToken(), test = null) : (this.expectKeyword("case"), test = this.parseExpression()), this.expect(":");
                for (var consequent = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")); )
                  consequent.push(this.parseStatementListItem());
                return this.finalize(node, new Node.SwitchCase(test, consequent));
              }, Parser2.prototype.parseSwitchStatement = function() {
                var node = this.createNode();
                this.expectKeyword("switch"), this.expect("(");
                var discriminant = this.parseExpression();
                this.expect(")");
                var previousInSwitch = this.context.inSwitch;
                this.context.inSwitch = !0;
                var cases = [], defaultFound = !1;
                for (this.expect("{"); !this.match("}"); ) {
                  var clause = this.parseSwitchCase();
                  clause.test === null && (defaultFound && this.throwError(messages_1.Messages.MultipleDefaultsInSwitch), defaultFound = !0), cases.push(clause);
                }
                return this.expect("}"), this.context.inSwitch = previousInSwitch, this.finalize(node, new Node.SwitchStatement(discriminant, cases));
              }, Parser2.prototype.parseLabelledStatement = function() {
                var node = this.createNode(), expr = this.parseExpression(), statement;
                if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var id = expr, key2 = "$" + id.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, key2) && this.throwError(messages_1.Messages.Redeclaration, "Label", id.name), this.context.labelSet[key2] = !0;
                  var body = void 0;
                  if (this.matchKeyword("class"))
                    this.tolerateUnexpectedToken(this.lookahead), body = this.parseClassDeclaration();
                  else if (this.matchKeyword("function")) {
                    var token2 = this.lookahead, declaration = this.parseFunctionDeclaration();
                    this.context.strict ? this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunction) : declaration.generator && this.tolerateUnexpectedToken(token2, messages_1.Messages.GeneratorInLegacyContext), body = declaration;
                  } else
                    body = this.parseStatement();
                  delete this.context.labelSet[key2], statement = new Node.LabeledStatement(id, body);
                } else
                  this.consumeSemicolon(), statement = new Node.ExpressionStatement(expr);
                return this.finalize(node, statement);
              }, Parser2.prototype.parseThrowStatement = function() {
                var node = this.createNode();
                this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(messages_1.Messages.NewlineAfterThrow);
                var argument = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(node, new Node.ThrowStatement(argument));
              }, Parser2.prototype.parseCatchClause = function() {
                var node = this.createNode();
                this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
                for (var params = [], param = this.parsePattern(params), paramMap = {}, i = 0; i < params.length; i++) {
                  var key2 = "$" + params[i].value;
                  Object.prototype.hasOwnProperty.call(paramMap, key2) && this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value), paramMap[key2] = !0;
                }
                this.context.strict && param.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(param.name) && this.tolerateError(messages_1.Messages.StrictCatchVariable), this.expect(")");
                var body = this.parseBlock();
                return this.finalize(node, new Node.CatchClause(param, body));
              }, Parser2.prototype.parseFinallyClause = function() {
                return this.expectKeyword("finally"), this.parseBlock();
              }, Parser2.prototype.parseTryStatement = function() {
                var node = this.createNode();
                this.expectKeyword("try");
                var block = this.parseBlock(), handler = this.matchKeyword("catch") ? this.parseCatchClause() : null, finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                return !handler && !finalizer && this.throwError(messages_1.Messages.NoCatchOrFinally), this.finalize(node, new Node.TryStatement(block, handler, finalizer));
              }, Parser2.prototype.parseDebuggerStatement = function() {
                var node = this.createNode();
                return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(node, new Node.DebuggerStatement());
              }, Parser2.prototype.parseStatement = function() {
                var statement;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    statement = this.parseExpressionStatement();
                    break;
                  case 7:
                    var value = this.lookahead.value;
                    value === "{" ? statement = this.parseBlock() : value === "(" ? statement = this.parseExpressionStatement() : value === ";" ? statement = this.parseEmptyStatement() : statement = this.parseExpressionStatement();
                    break;
                  case 3:
                    statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        statement = this.parseBreakStatement();
                        break;
                      case "continue":
                        statement = this.parseContinueStatement();
                        break;
                      case "debugger":
                        statement = this.parseDebuggerStatement();
                        break;
                      case "do":
                        statement = this.parseDoWhileStatement();
                        break;
                      case "for":
                        statement = this.parseForStatement();
                        break;
                      case "function":
                        statement = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        statement = this.parseIfStatement();
                        break;
                      case "return":
                        statement = this.parseReturnStatement();
                        break;
                      case "switch":
                        statement = this.parseSwitchStatement();
                        break;
                      case "throw":
                        statement = this.parseThrowStatement();
                        break;
                      case "try":
                        statement = this.parseTryStatement();
                        break;
                      case "var":
                        statement = this.parseVariableStatement();
                        break;
                      case "while":
                        statement = this.parseWhileStatement();
                        break;
                      case "with":
                        statement = this.parseWithStatement();
                        break;
                      default:
                        statement = this.parseExpressionStatement();
                        break;
                    }
                    break;
                  default:
                    statement = this.throwUnexpectedToken(this.lookahead);
                }
                return statement;
              }, Parser2.prototype.parseFunctionSourceElements = function() {
                var node = this.createNode();
                this.expect("{");
                var body = this.parseDirectivePrologues(), previousLabelSet = this.context.labelSet, previousInIteration = this.context.inIteration, previousInSwitch = this.context.inSwitch, previousInFunctionBody = this.context.inFunctionBody;
                for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.lookahead.type !== 2 && !this.match("}"); )
                  body.push(this.parseStatementListItem());
                return this.expect("}"), this.context.labelSet = previousLabelSet, this.context.inIteration = previousInIteration, this.context.inSwitch = previousInSwitch, this.context.inFunctionBody = previousInFunctionBody, this.finalize(node, new Node.BlockStatement(body));
              }, Parser2.prototype.validateParam = function(options2, param, name) {
                var key2 = "$" + name;
                this.context.strict ? (this.scanner.isRestrictedWord(name) && (options2.stricted = param, options2.message = messages_1.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(options2.paramSet, key2) && (options2.stricted = param, options2.message = messages_1.Messages.StrictParamDupe)) : options2.firstRestricted || (this.scanner.isRestrictedWord(name) ? (options2.firstRestricted = param, options2.message = messages_1.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(name) ? (options2.firstRestricted = param, options2.message = messages_1.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(options2.paramSet, key2) && (options2.stricted = param, options2.message = messages_1.Messages.StrictParamDupe)), typeof Object.defineProperty == "function" ? Object.defineProperty(options2.paramSet, key2, { value: !0, enumerable: !0, writable: !0, configurable: !0 }) : options2.paramSet[key2] = !0;
              }, Parser2.prototype.parseRestElement = function(params) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params);
                return this.match("=") && this.throwError(messages_1.Messages.DefaultRestParameter), this.match(")") || this.throwError(messages_1.Messages.ParameterAfterRestParameter), this.finalize(node, new Node.RestElement(arg));
              }, Parser2.prototype.parseFormalParameter = function(options2) {
                for (var params = [], param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params), i = 0; i < params.length; i++)
                  this.validateParam(options2, params[i], params[i].value);
                options2.simple = options2.simple && param instanceof Node.Identifier, options2.params.push(param);
              }, Parser2.prototype.parseFormalParameters = function(firstRestricted) {
                var options2;
                if (options2 = {
                  simple: !0,
                  params: [],
                  firstRestricted
                }, this.expect("("), !this.match(")"))
                  for (options2.paramSet = {}; this.lookahead.type !== 2 && (this.parseFormalParameter(options2), !(this.match(")") || (this.expect(","), this.match(")")))); )
                    ;
                return this.expect(")"), {
                  simple: options2.simple,
                  params: options2.params,
                  stricted: options2.stricted,
                  firstRestricted: options2.firstRestricted,
                  message: options2.message
                };
              }, Parser2.prototype.matchAsyncFunction = function() {
                var match2 = this.matchContextualKeyword("async");
                if (match2) {
                  var state = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.scanner.lex();
                  this.scanner.restoreState(state), match2 = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                }
                return match2;
              }, Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                var node = this.createNode(), isAsync = this.matchContextualKeyword("async");
                isAsync && this.nextToken(), this.expectKeyword("function");
                var isGenerator = isAsync ? !1 : this.match("*");
                isGenerator && this.nextToken();
                var message, id = null, firstRestricted = null;
                if (!identifierIsOptional || !this.match("(")) {
                  var token2 = this.lookahead;
                  id = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(token2.value) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(token2.value) ? (firstRestricted = token2, message = messages_1.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(token2.value) && (firstRestricted = token2, message = messages_1.Messages.StrictReservedWord);
                }
                var previousAllowAwait = this.context.await, previousAllowYield = this.context.allowYield;
                this.context.await = isAsync, this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters(firstRestricted), params = formalParameters.params, stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted, formalParameters.message && (message = formalParameters.message);
                var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                return this.context.strict && firstRestricted && this.throwUnexpectedToken(firstRestricted, message), this.context.strict && stricted && this.tolerateUnexpectedToken(stricted, message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.await = previousAllowAwait, this.context.allowYield = previousAllowYield, isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
              }, Parser2.prototype.parseFunctionExpression = function() {
                var node = this.createNode(), isAsync = this.matchContextualKeyword("async");
                isAsync && this.nextToken(), this.expectKeyword("function");
                var isGenerator = isAsync ? !1 : this.match("*");
                isGenerator && this.nextToken();
                var message, id = null, firstRestricted, previousAllowAwait = this.context.await, previousAllowYield = this.context.allowYield;
                if (this.context.await = isAsync, this.context.allowYield = !isGenerator, !this.match("(")) {
                  var token2 = this.lookahead;
                  id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(token2.value) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(token2.value) ? (firstRestricted = token2, message = messages_1.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(token2.value) && (firstRestricted = token2, message = messages_1.Messages.StrictReservedWord);
                }
                var formalParameters = this.parseFormalParameters(firstRestricted), params = formalParameters.params, stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted, formalParameters.message && (message = formalParameters.message);
                var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                return this.context.strict && firstRestricted && this.throwUnexpectedToken(firstRestricted, message), this.context.strict && stricted && this.tolerateUnexpectedToken(stricted, message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.await = previousAllowAwait, this.context.allowYield = previousAllowYield, isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
              }, Parser2.prototype.parseDirective = function() {
                var token2 = this.lookahead, node = this.createNode(), expr = this.parseExpression(), directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token2).slice(1, -1) : null;
                return this.consumeSemicolon(), this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
              }, Parser2.prototype.parseDirectivePrologues = function() {
                for (var firstRestricted = null, body = []; ; ) {
                  var token2 = this.lookahead;
                  if (token2.type !== 8)
                    break;
                  var statement = this.parseDirective();
                  body.push(statement);
                  var directive = statement.directive;
                  if (typeof directive != "string")
                    break;
                  directive === "use strict" ? (this.context.strict = !0, firstRestricted && this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(token2, messages_1.Messages.IllegalLanguageModeDirective)) : !firstRestricted && token2.octal && (firstRestricted = token2);
                }
                return body;
              }, Parser2.prototype.qualifiedPropertyName = function(token2) {
                switch (token2.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return !0;
                  case 7:
                    return token2.value === "[";
                }
                return !1;
              }, Parser2.prototype.parseGetterMethod = function() {
                var node = this.createNode(), isGenerator = !1, previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                formalParameters.params.length > 0 && this.tolerateError(messages_1.Messages.BadGetterArity);
                var method = this.parsePropertyMethod(formalParameters);
                return this.context.allowYield = previousAllowYield, this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              }, Parser2.prototype.parseSetterMethod = function() {
                var node = this.createNode(), isGenerator = !1, previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                formalParameters.params.length !== 1 ? this.tolerateError(messages_1.Messages.BadSetterArity) : formalParameters.params[0] instanceof Node.RestElement && this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                var method = this.parsePropertyMethod(formalParameters);
                return this.context.allowYield = previousAllowYield, this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              }, Parser2.prototype.parseGeneratorMethod = function() {
                var node = this.createNode(), isGenerator = !0, previousAllowYield = this.context.allowYield;
                this.context.allowYield = !0;
                var params = this.parseFormalParameters();
                this.context.allowYield = !1;
                var method = this.parsePropertyMethod(params);
                return this.context.allowYield = previousAllowYield, this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              }, Parser2.prototype.isStartOfExpression = function() {
                var start = !0, value = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                    break;
                  case 4:
                    start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                    break;
                }
                return start;
              }, Parser2.prototype.parseYieldExpression = function() {
                var node = this.createNode();
                this.expectKeyword("yield");
                var argument = null, delegate = !1;
                if (!this.hasLineTerminator) {
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = !1, delegate = this.match("*"), delegate ? (this.nextToken(), argument = this.parseAssignmentExpression()) : this.isStartOfExpression() && (argument = this.parseAssignmentExpression()), this.context.allowYield = previousAllowYield;
                }
                return this.finalize(node, new Node.YieldExpression(argument, delegate));
              }, Parser2.prototype.parseClassElement = function(hasConstructor) {
                var token2 = this.lookahead, node = this.createNode(), kind = "", key2 = null, value = null, computed = !1, method = !1, isStatic = !1, isAsync = !1;
                if (this.match("*"))
                  this.nextToken();
                else {
                  computed = this.match("["), key2 = this.parseObjectPropertyKey();
                  var id = key2;
                  if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (token2 = this.lookahead, isStatic = !0, computed = this.match("["), this.match("*") ? this.nextToken() : key2 = this.parseObjectPropertyKey()), token2.type === 3 && !this.hasLineTerminator && token2.value === "async") {
                    var punctuator = this.lookahead.value;
                    punctuator !== ":" && punctuator !== "(" && punctuator !== "*" && (isAsync = !0, token2 = this.lookahead, key2 = this.parseObjectPropertyKey(), token2.type === 3 && token2.value === "constructor" && this.tolerateUnexpectedToken(token2, messages_1.Messages.ConstructorIsAsync));
                  }
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                return token2.type === 3 ? token2.value === "get" && lookaheadPropertyKey ? (kind = "get", computed = this.match("["), key2 = this.parseObjectPropertyKey(), this.context.allowYield = !1, value = this.parseGetterMethod()) : token2.value === "set" && lookaheadPropertyKey && (kind = "set", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseSetterMethod()) : token2.type === 7 && token2.value === "*" && lookaheadPropertyKey && (kind = "init", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseGeneratorMethod(), method = !0), !kind && key2 && this.match("(") && (kind = "init", value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), method = !0), kind || this.throwUnexpectedToken(this.lookahead), kind === "init" && (kind = "method"), computed || (isStatic && this.isPropertyKey(key2, "prototype") && this.throwUnexpectedToken(token2, messages_1.Messages.StaticPrototype), !isStatic && this.isPropertyKey(key2, "constructor") && ((kind !== "method" || !method || value && value.generator) && this.throwUnexpectedToken(token2, messages_1.Messages.ConstructorSpecialMethod), hasConstructor.value ? this.throwUnexpectedToken(token2, messages_1.Messages.DuplicateConstructor) : hasConstructor.value = !0, kind = "constructor")), this.finalize(node, new Node.MethodDefinition(key2, computed, value, kind, isStatic));
              }, Parser2.prototype.parseClassElementList = function() {
                var body = [], hasConstructor = { value: !1 };
                for (this.expect("{"); !this.match("}"); )
                  this.match(";") ? this.nextToken() : body.push(this.parseClassElement(hasConstructor));
                return this.expect("}"), body;
              }, Parser2.prototype.parseClassBody = function() {
                var node = this.createNode(), elementList = this.parseClassElementList();
                return this.finalize(node, new Node.ClassBody(elementList));
              }, Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
                var node = this.createNode(), previousStrict = this.context.strict;
                this.context.strict = !0, this.expectKeyword("class");
                var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier(), superClass = null;
                this.matchKeyword("extends") && (this.nextToken(), superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var classBody = this.parseClassBody();
                return this.context.strict = previousStrict, this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
              }, Parser2.prototype.parseClassExpression = function() {
                var node = this.createNode(), previousStrict = this.context.strict;
                this.context.strict = !0, this.expectKeyword("class");
                var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null, superClass = null;
                this.matchKeyword("extends") && (this.nextToken(), superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var classBody = this.parseClassBody();
                return this.context.strict = previousStrict, this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
              }, Parser2.prototype.parseModule = function() {
                this.context.strict = !0, this.context.isModule = !0, this.scanner.isModule = !0;
                for (var node = this.createNode(), body = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                  body.push(this.parseStatementListItem());
                return this.finalize(node, new Node.Module(body));
              }, Parser2.prototype.parseScript = function() {
                for (var node = this.createNode(), body = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                  body.push(this.parseStatementListItem());
                return this.finalize(node, new Node.Script(body));
              }, Parser2.prototype.parseModuleSpecifier = function() {
                var node = this.createNode();
                this.lookahead.type !== 8 && this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                var token2 = this.nextToken(), raw = this.getTokenRaw(token2);
                return this.finalize(node, new Node.Literal(token2.value, raw));
              }, Parser2.prototype.parseImportSpecifier = function() {
                var node = this.createNode(), imported, local;
                return this.lookahead.type === 3 ? (imported = this.parseVariableIdentifier(), local = imported, this.matchContextualKeyword("as") && (this.nextToken(), local = this.parseVariableIdentifier())) : (imported = this.parseIdentifierName(), local = imported, this.matchContextualKeyword("as") ? (this.nextToken(), local = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(node, new Node.ImportSpecifier(local, imported));
              }, Parser2.prototype.parseNamedImports = function() {
                this.expect("{");
                for (var specifiers = []; !this.match("}"); )
                  specifiers.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
                return this.expect("}"), specifiers;
              }, Parser2.prototype.parseImportDefaultSpecifier = function() {
                var node = this.createNode(), local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportDefaultSpecifier(local));
              }, Parser2.prototype.parseImportNamespaceSpecifier = function() {
                var node = this.createNode();
                this.expect("*"), this.matchContextualKeyword("as") || this.throwError(messages_1.Messages.NoAsAfterImportNamespace), this.nextToken();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
              }, Parser2.prototype.parseImportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(messages_1.Messages.IllegalImportDeclaration);
                var node = this.createNode();
                this.expectKeyword("import");
                var src2, specifiers = [];
                if (this.lookahead.type === 8)
                  src2 = this.parseModuleSpecifier();
                else {
                  if (this.match("{") ? specifiers = specifiers.concat(this.parseNamedImports()) : this.match("*") ? specifiers.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (specifiers.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? specifiers.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? specifiers = specifiers.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken(), src2 = this.parseModuleSpecifier();
                }
                return this.consumeSemicolon(), this.finalize(node, new Node.ImportDeclaration(specifiers, src2));
              }, Parser2.prototype.parseExportSpecifier = function() {
                var node = this.createNode(), local = this.parseIdentifierName(), exported = local;
                return this.matchContextualKeyword("as") && (this.nextToken(), exported = this.parseIdentifierName()), this.finalize(node, new Node.ExportSpecifier(local, exported));
              }, Parser2.prototype.parseExportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(messages_1.Messages.IllegalExportDeclaration);
                var node = this.createNode();
                this.expectKeyword("export");
                var exportDeclaration;
                if (this.matchKeyword("default"))
                  if (this.nextToken(), this.matchKeyword("function")) {
                    var declaration = this.parseFunctionDeclaration(!0);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchKeyword("class")) {
                    var declaration = this.parseClassDeclaration(!0);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchContextualKeyword("async")) {
                    var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else {
                    this.matchContextualKeyword("from") && this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                    var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                    this.consumeSemicolon(), exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  }
                else if (this.match("*")) {
                  if (this.nextToken(), !this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  var src2 = this.parseModuleSpecifier();
                  this.consumeSemicolon(), exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src2));
                } else if (this.lookahead.type === 4) {
                  var declaration = void 0;
                  switch (this.lookahead.value) {
                    case "let":
                    case "const":
                      declaration = this.parseLexicalDeclaration({ inFor: !1 });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      declaration = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else if (this.matchAsyncFunction()) {
                  var declaration = this.parseFunctionDeclaration();
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else {
                  var specifiers = [], source2 = null, isExportFromIdentifier = !1;
                  for (this.expect("{"); !this.match("}"); )
                    isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default"), specifiers.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
                  if (this.expect("}"), this.matchContextualKeyword("from"))
                    this.nextToken(), source2 = this.parseModuleSpecifier(), this.consumeSemicolon();
                  else if (isExportFromIdentifier) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  } else
                    this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source2));
                }
                return exportDeclaration;
              }, Parser2;
            }();
            exports3.Parser = Parser;
          },
          /* 9 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            function assert(condition, message) {
              if (!condition)
                throw new Error("ASSERT: " + message);
            }
            exports3.assert = assert;
          },
          /* 10 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var ErrorHandler = function() {
              function ErrorHandler2() {
                this.errors = [], this.tolerant = !1;
              }
              return ErrorHandler2.prototype.recordError = function(error2) {
                this.errors.push(error2);
              }, ErrorHandler2.prototype.tolerate = function(error2) {
                if (this.tolerant)
                  this.recordError(error2);
                else
                  throw error2;
              }, ErrorHandler2.prototype.constructError = function(msg, column2) {
                var error2 = new Error(msg);
                try {
                  throw error2;
                } catch (base2) {
                  Object.create && Object.defineProperty && (error2 = Object.create(base2), Object.defineProperty(error2, "column", { value: column2 }));
                }
                return error2;
              }, ErrorHandler2.prototype.createError = function(index, line3, col, description2) {
                var msg = "Line " + line3 + ": " + description2, error2 = this.constructError(msg, col);
                return error2.index = index, error2.lineNumber = line3, error2.description = description2, error2;
              }, ErrorHandler2.prototype.throwError = function(index, line3, col, description2) {
                throw this.createError(index, line3, col, description2);
              }, ErrorHandler2.prototype.tolerateError = function(index, line3, col, description2) {
                var error2 = this.createError(index, line3, col, description2);
                if (this.tolerant)
                  this.recordError(error2);
                else
                  throw error2;
              }, ErrorHandler2;
            }();
            exports3.ErrorHandler = ErrorHandler;
          },
          /* 11 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.Messages = {
              BadGetterArity: "Getter must not have any formal parameters",
              BadSetterArity: "Setter must have exactly one formal parameter",
              BadSetterRestParameter: "Setter function argument must not be a rest parameter",
              ConstructorIsAsync: "Class constructor may not be an async method",
              ConstructorSpecialMethod: "Class constructor may not be an accessor",
              DeclarationMissingInitializer: "Missing initializer in %0 declaration",
              DefaultRestParameter: "Unexpected token =",
              DuplicateBinding: "Duplicate binding %0",
              DuplicateConstructor: "A class may only have one constructor",
              DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
              ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
              GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
              IllegalBreak: "Illegal break statement",
              IllegalContinue: "Illegal continue statement",
              IllegalExportDeclaration: "Unexpected token",
              IllegalImportDeclaration: "Unexpected token",
              IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
              IllegalReturn: "Illegal return statement",
              InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
              InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
              InvalidLHSInAssignment: "Invalid left-hand side in assignment",
              InvalidLHSInForIn: "Invalid left-hand side in for-in",
              InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
              InvalidModuleSpecifier: "Unexpected token",
              InvalidRegExp: "Invalid regular expression",
              LetInLexicalBinding: "let is disallowed as a lexically bound name",
              MissingFromClause: "Unexpected token",
              MultipleDefaultsInSwitch: "More than one default clause in switch statement",
              NewlineAfterThrow: "Illegal newline after throw",
              NoAsAfterImportNamespace: "Unexpected token",
              NoCatchOrFinally: "Missing catch or finally after try",
              ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
              Redeclaration: "%0 '%1' has already been declared",
              StaticPrototype: "Classes may not have static property named prototype",
              StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
              StrictDelete: "Delete of an unqualified identifier in strict mode.",
              StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
              StrictFunctionName: "Function name may not be eval or arguments in strict mode",
              StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
              StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
              StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
              StrictModeWith: "Strict mode code may not include a with statement",
              StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
              StrictParamDupe: "Strict mode function may not have duplicate parameter names",
              StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
              StrictReservedWord: "Use of future reserved word in strict mode",
              StrictVarName: "Variable name may not be eval or arguments in strict mode",
              TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
              UnexpectedEOS: "Unexpected end of input",
              UnexpectedIdentifier: "Unexpected identifier",
              UnexpectedNumber: "Unexpected number",
              UnexpectedReserved: "Unexpected reserved word",
              UnexpectedString: "Unexpected string",
              UnexpectedTemplate: "Unexpected quasi %0",
              UnexpectedToken: "Unexpected token %0",
              UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
              UnknownLabel: "Undefined label '%0'",
              UnterminatedRegExp: "Invalid regular expression: missing /"
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var assert_1 = __webpack_require__(9), character_1 = __webpack_require__(4), messages_1 = __webpack_require__(11);
            function hexValue(ch) {
              return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
              return "01234567".indexOf(ch);
            }
            var Scanner = function() {
              function Scanner2(code, handler) {
                this.source = code, this.errorHandler = handler, this.trackComment = !1, this.isModule = !1, this.length = code.length, this.index = 0, this.lineNumber = code.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
              }
              return Scanner2.prototype.saveState = function() {
                return {
                  index: this.index,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart
                };
              }, Scanner2.prototype.restoreState = function(state) {
                this.index = state.index, this.lineNumber = state.lineNumber, this.lineStart = state.lineStart;
              }, Scanner2.prototype.eof = function() {
                return this.index >= this.length;
              }, Scanner2.prototype.throwUnexpectedToken = function(message) {
                return message === void 0 && (message = messages_1.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              }, Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                message === void 0 && (message = messages_1.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              }, Scanner2.prototype.skipSingleLineComment = function(offset) {
                var comments2 = [], start, loc;
                for (this.trackComment && (comments2 = [], start = this.index - offset, loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                }); !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (++this.index, character_1.Character.isLineTerminator(ch)) {
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                      };
                      var entry = {
                        multiLine: !1,
                        slice: [start + offset, this.index - 1],
                        range: [start, this.index - 1],
                        loc
                      };
                      comments2.push(entry);
                    }
                    return ch === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, comments2;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: !1,
                    slice: [start + offset, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments2.push(entry);
                }
                return comments2;
              }, Scanner2.prototype.skipMultiLineComment = function() {
                var comments2 = [], start, loc;
                for (this.trackComment && (comments2 = [], start = this.index - 2, loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                }); !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isLineTerminator(ch))
                    ch === 13 && this.source.charCodeAt(this.index + 1) === 10 && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
                  else if (ch === 42) {
                    if (this.source.charCodeAt(this.index + 1) === 47) {
                      if (this.index += 2, this.trackComment) {
                        loc.end = {
                          line: this.lineNumber,
                          column: this.index - this.lineStart
                        };
                        var entry = {
                          multiLine: !0,
                          slice: [start + 2, this.index - 2],
                          range: [start, this.index],
                          loc
                        };
                        comments2.push(entry);
                      }
                      return comments2;
                    }
                    ++this.index;
                  } else
                    ++this.index;
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: !0,
                    slice: [start + 2, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments2.push(entry);
                }
                return this.tolerateUnexpectedToken(), comments2;
              }, Scanner2.prototype.scanComments = function() {
                var comments2;
                this.trackComment && (comments2 = []);
                for (var start = this.index === 0; !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isWhiteSpace(ch))
                    ++this.index;
                  else if (character_1.Character.isLineTerminator(ch))
                    ++this.index, ch === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, start = !0;
                  else if (ch === 47)
                    if (ch = this.source.charCodeAt(this.index + 1), ch === 47) {
                      this.index += 2;
                      var comment = this.skipSingleLineComment(2);
                      this.trackComment && (comments2 = comments2.concat(comment)), start = !0;
                    } else if (ch === 42) {
                      this.index += 2;
                      var comment = this.skipMultiLineComment();
                      this.trackComment && (comments2 = comments2.concat(comment));
                    } else
                      break;
                  else if (start && ch === 45)
                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                      this.index += 3;
                      var comment = this.skipSingleLineComment(3);
                      this.trackComment && (comments2 = comments2.concat(comment));
                    } else
                      break;
                  else if (ch === 60 && !this.isModule)
                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                      this.index += 4;
                      var comment = this.skipSingleLineComment(4);
                      this.trackComment && (comments2 = comments2.concat(comment));
                    } else
                      break;
                  else
                    break;
                }
                return comments2;
              }, Scanner2.prototype.isFutureReservedWord = function(id) {
                switch (id) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return !0;
                  default:
                    return !1;
                }
              }, Scanner2.prototype.isStrictModeReservedWord = function(id) {
                switch (id) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return !0;
                  default:
                    return !1;
                }
              }, Scanner2.prototype.isRestrictedWord = function(id) {
                return id === "eval" || id === "arguments";
              }, Scanner2.prototype.isKeyword = function(id) {
                switch (id.length) {
                  case 2:
                    return id === "if" || id === "in" || id === "do";
                  case 3:
                    return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                  case 4:
                    return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                  case 5:
                    return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                  case 6:
                    return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                  case 7:
                    return id === "default" || id === "finally" || id === "extends";
                  case 8:
                    return id === "function" || id === "continue" || id === "debugger";
                  case 10:
                    return id === "instanceof";
                  default:
                    return !1;
                }
              }, Scanner2.prototype.codePointAt = function(i) {
                var cp = this.source.charCodeAt(i);
                if (cp >= 55296 && cp <= 56319) {
                  var second = this.source.charCodeAt(i + 1);
                  if (second >= 56320 && second <= 57343) {
                    var first2 = cp;
                    cp = (first2 - 55296) * 1024 + second - 56320 + 65536;
                  }
                }
                return cp;
              }, Scanner2.prototype.scanHexEscape = function(prefix) {
                for (var len = prefix === "u" ? 4 : 2, code = 0, i = 0; i < len; ++i)
                  if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index)))
                    code = code * 16 + hexValue(this.source[this.index++]);
                  else
                    return null;
                return String.fromCharCode(code);
              }, Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                var ch = this.source[this.index], code = 0;
                for (ch === "}" && this.throwUnexpectedToken(); !this.eof() && (ch = this.source[this.index++], !!character_1.Character.isHexDigit(ch.charCodeAt(0))); )
                  code = code * 16 + hexValue(ch);
                return (code > 1114111 || ch !== "}") && this.throwUnexpectedToken(), character_1.Character.fromCodePoint(code);
              }, Scanner2.prototype.getIdentifier = function() {
                for (var start = this.index++; !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (ch === 92)
                    return this.index = start, this.getComplexIdentifier();
                  if (ch >= 55296 && ch < 57343)
                    return this.index = start, this.getComplexIdentifier();
                  if (character_1.Character.isIdentifierPart(ch))
                    ++this.index;
                  else
                    break;
                }
                return this.source.slice(start, this.index);
              }, Scanner2.prototype.getComplexIdentifier = function() {
                var cp = this.codePointAt(this.index), id = character_1.Character.fromCodePoint(cp);
                this.index += id.length;
                var ch;
                for (cp === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, ch = this.scanUnicodeCodePointEscape()) : (ch = this.scanHexEscape("u"), (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) && this.throwUnexpectedToken()), id = ch); !this.eof() && (cp = this.codePointAt(this.index), !!character_1.Character.isIdentifierPart(cp)); )
                  ch = character_1.Character.fromCodePoint(cp), id += ch, this.index += ch.length, cp === 92 && (id = id.substr(0, id.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, ch = this.scanUnicodeCodePointEscape()) : (ch = this.scanHexEscape("u"), (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) && this.throwUnexpectedToken()), id += ch);
                return id;
              }, Scanner2.prototype.octalToDecimal = function(ch) {
                var octal = ch !== "0", code = octalValue(ch);
                return !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (octal = !0, code = code * 8 + octalValue(this.source[this.index++]), "0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (code = code * 8 + octalValue(this.source[this.index++]))), {
                  code,
                  octal
                };
              }, Scanner2.prototype.scanIdentifier = function() {
                var type2, start = this.index, id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                if (id.length === 1 ? type2 = 3 : this.isKeyword(id) ? type2 = 4 : id === "null" ? type2 = 5 : id === "true" || id === "false" ? type2 = 1 : type2 = 3, type2 !== 3 && start + id.length !== this.index) {
                  var restore = this.index;
                  this.index = start, this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord), this.index = restore;
                }
                return {
                  type: type2,
                  value: id,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanPunctuator = function() {
                var start = this.index, str2 = this.source[this.index];
                switch (str2) {
                  case "(":
                  case "{":
                    str2 === "{" && this.curlyStack.push("{"), ++this.index;
                    break;
                  case ".":
                    ++this.index, this.source[this.index] === "." && this.source[this.index + 1] === "." && (this.index += 2, str2 = "...");
                    break;
                  case "}":
                    ++this.index, this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    str2 = this.source.substr(this.index, 4), str2 === ">>>=" ? this.index += 4 : (str2 = str2.substr(0, 3), str2 === "===" || str2 === "!==" || str2 === ">>>" || str2 === "<<=" || str2 === ">>=" || str2 === "**=" ? this.index += 3 : (str2 = str2.substr(0, 2), str2 === "&&" || str2 === "||" || str2 === "==" || str2 === "!=" || str2 === "+=" || str2 === "-=" || str2 === "*=" || str2 === "/=" || str2 === "++" || str2 === "--" || str2 === "<<" || str2 === ">>" || str2 === "&=" || str2 === "|=" || str2 === "^=" || str2 === "%=" || str2 === "<=" || str2 === ">=" || str2 === "=>" || str2 === "**" ? this.index += 2 : (str2 = this.source[this.index], "<>=!+-*%&|^/".indexOf(str2) >= 0 && ++this.index)));
                }
                return this.index === start && this.throwUnexpectedToken(), {
                  type: 7,
                  value: str2,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanHexLiteral = function(start) {
                for (var num = ""; !this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index)); )
                  num += this.source[this.index++];
                return num.length === 0 && this.throwUnexpectedToken(), character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseInt("0x" + num, 16),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanBinaryLiteral = function(start) {
                for (var num = "", ch; !this.eof() && (ch = this.source[this.index], !(ch !== "0" && ch !== "1")); )
                  num += this.source[this.index++];
                return num.length === 0 && this.throwUnexpectedToken(), this.eof() || (ch = this.source.charCodeAt(this.index), (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) && this.throwUnexpectedToken()), {
                  type: 6,
                  value: parseInt(num, 2),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
                var num = "", octal = !1;
                for (character_1.Character.isOctalDigit(prefix.charCodeAt(0)) ? (octal = !0, num = "0" + this.source[this.index++]) : ++this.index; !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)); )
                  num += this.source[this.index++];
                return !octal && num.length === 0 && this.throwUnexpectedToken(), (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseInt(num, 8),
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.isImplicitOctalLiteral = function() {
                for (var i = this.index + 1; i < this.length; ++i) {
                  var ch = this.source[i];
                  if (ch === "8" || ch === "9")
                    return !1;
                  if (!character_1.Character.isOctalDigit(ch.charCodeAt(0)))
                    return !0;
                }
                return !0;
              }, Scanner2.prototype.scanNumericLiteral = function() {
                var start = this.index, ch = this.source[start];
                assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                var num = "";
                if (ch !== ".") {
                  if (num = this.source[this.index++], ch = this.source[this.index], num === "0") {
                    if (ch === "x" || ch === "X")
                      return ++this.index, this.scanHexLiteral(start);
                    if (ch === "b" || ch === "B")
                      return ++this.index, this.scanBinaryLiteral(start);
                    if (ch === "o" || ch === "O")
                      return this.scanOctalLiteral(ch, start);
                    if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0)) && this.isImplicitOctalLiteral())
                      return this.scanOctalLiteral(ch, start);
                  }
                  for (; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    num += this.source[this.index++];
                  ch = this.source[this.index];
                }
                if (ch === ".") {
                  for (num += this.source[this.index++]; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    num += this.source[this.index++];
                  ch = this.source[this.index];
                }
                if (ch === "e" || ch === "E")
                  if (num += this.source[this.index++], ch = this.source[this.index], (ch === "+" || ch === "-") && (num += this.source[this.index++]), character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)))
                    for (; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                      num += this.source[this.index++];
                  else
                    this.throwUnexpectedToken();
                return character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseFloat(num),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanStringLiteral = function() {
                var start = this.index, quote = this.source[start];
                assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote"), ++this.index;
                for (var octal = !1, str2 = ""; !this.eof(); ) {
                  var ch = this.source[this.index++];
                  if (ch === quote) {
                    quote = "";
                    break;
                  } else if (ch === "\\")
                    if (ch = this.source[this.index++], !ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                      switch (ch) {
                        case "u":
                          if (this.source[this.index] === "{")
                            ++this.index, str2 += this.scanUnicodeCodePointEscape();
                          else {
                            var unescaped_1 = this.scanHexEscape(ch);
                            unescaped_1 === null && this.throwUnexpectedToken(), str2 += unescaped_1;
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          unescaped === null && this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence), str2 += unescaped;
                          break;
                        case "n":
                          str2 += `
`;
                          break;
                        case "r":
                          str2 += "\r";
                          break;
                        case "t":
                          str2 += "	";
                          break;
                        case "b":
                          str2 += "\b";
                          break;
                        case "f":
                          str2 += "\f";
                          break;
                        case "v":
                          str2 += "\v";
                          break;
                        case "8":
                        case "9":
                          str2 += ch, this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            var octToDec = this.octalToDecimal(ch);
                            octal = octToDec.octal || octal, str2 += String.fromCharCode(octToDec.code);
                          } else
                            str2 += ch;
                          break;
                      }
                    else
                      ++this.lineNumber, ch === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                  else {
                    if (character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                      break;
                    str2 += ch;
                  }
                }
                return quote !== "" && (this.index = start, this.throwUnexpectedToken()), {
                  type: 8,
                  value: str2,
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanTemplate = function() {
                var cooked = "", terminated = !1, start = this.index, head = this.source[start] === "`", tail = !1, rawOffset = 2;
                for (++this.index; !this.eof(); ) {
                  var ch = this.source[this.index++];
                  if (ch === "`") {
                    rawOffset = 1, tail = !0, terminated = !0;
                    break;
                  } else if (ch === "$") {
                    if (this.source[this.index] === "{") {
                      this.curlyStack.push("${"), ++this.index, terminated = !0;
                      break;
                    }
                    cooked += ch;
                  } else if (ch === "\\")
                    if (ch = this.source[this.index++], character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                      ++this.lineNumber, ch === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                    else
                      switch (ch) {
                        case "n":
                          cooked += `
`;
                          break;
                        case "r":
                          cooked += "\r";
                          break;
                        case "t":
                          cooked += "	";
                          break;
                        case "u":
                          if (this.source[this.index] === "{")
                            ++this.index, cooked += this.scanUnicodeCodePointEscape();
                          else {
                            var restore = this.index, unescaped_2 = this.scanHexEscape(ch);
                            unescaped_2 !== null ? cooked += unescaped_2 : (this.index = restore, cooked += ch);
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          unescaped === null && this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence), cooked += unescaped;
                          break;
                        case "b":
                          cooked += "\b";
                          break;
                        case "f":
                          cooked += "\f";
                          break;
                        case "v":
                          cooked += "\v";
                          break;
                        default:
                          ch === "0" ? (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral), cooked += "\0") : character_1.Character.isOctalDigit(ch.charCodeAt(0)) ? this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral) : cooked += ch;
                          break;
                      }
                  else character_1.Character.isLineTerminator(ch.charCodeAt(0)) ? (++this.lineNumber, ch === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index, cooked += `
`) : cooked += ch;
                }
                return terminated || this.throwUnexpectedToken(), head || this.curlyStack.pop(), {
                  type: 10,
                  value: this.source.slice(start + 1, this.index - rawOffset),
                  cooked,
                  head,
                  tail,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.testRegExp = function(pattern, flags) {
                var astralSubstitute = "\uFFFF", tmp2 = pattern, self2 = this;
                flags.indexOf("u") >= 0 && (tmp2 = tmp2.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                  var codePoint = parseInt($1 || $2, 16);
                  return codePoint > 1114111 && self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp), codePoint <= 65535 ? String.fromCharCode(codePoint) : astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute));
                try {
                  RegExp(tmp2);
                } catch {
                  this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(pattern, flags);
                } catch {
                  return null;
                }
              }, Scanner2.prototype.scanRegExpBody = function() {
                var ch = this.source[this.index];
                assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                for (var str2 = this.source[this.index++], classMarker = !1, terminated = !1; !this.eof(); )
                  if (ch = this.source[this.index++], str2 += ch, ch === "\\")
                    ch = this.source[this.index++], character_1.Character.isLineTerminator(ch.charCodeAt(0)) && this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp), str2 += ch;
                  else if (character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  else if (classMarker)
                    ch === "]" && (classMarker = !1);
                  else if (ch === "/") {
                    terminated = !0;
                    break;
                  } else ch === "[" && (classMarker = !0);
                return terminated || this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp), str2.substr(1, str2.length - 2);
              }, Scanner2.prototype.scanRegExpFlags = function() {
                for (var str2 = "", flags = ""; !this.eof(); ) {
                  var ch = this.source[this.index];
                  if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0)))
                    break;
                  if (++this.index, ch === "\\" && !this.eof())
                    if (ch = this.source[this.index], ch === "u") {
                      ++this.index;
                      var restore = this.index, char = this.scanHexEscape("u");
                      if (char !== null)
                        for (flags += char, str2 += "\\u"; restore < this.index; ++restore)
                          str2 += this.source[restore];
                      else
                        this.index = restore, flags += "u", str2 += "\\u";
                      this.tolerateUnexpectedToken();
                    } else
                      str2 += "\\", this.tolerateUnexpectedToken();
                  else
                    flags += ch, str2 += ch;
                }
                return flags;
              }, Scanner2.prototype.scanRegExp = function() {
                var start = this.index, pattern = this.scanRegExpBody(), flags = this.scanRegExpFlags(), value = this.testRegExp(pattern, flags);
                return {
                  type: 9,
                  value: "",
                  pattern,
                  flags,
                  regex: value,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.lex = function() {
                if (this.eof())
                  return {
                    type: 2,
                    value: "",
                    lineNumber: this.lineNumber,
                    lineStart: this.lineStart,
                    start: this.index,
                    end: this.index
                  };
                var cp = this.source.charCodeAt(this.index);
                return character_1.Character.isIdentifierStart(cp) ? this.scanIdentifier() : cp === 40 || cp === 41 || cp === 59 ? this.scanPunctuator() : cp === 39 || cp === 34 ? this.scanStringLiteral() : cp === 46 ? character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : character_1.Character.isDecimalDigit(cp) ? this.scanNumericLiteral() : cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : cp >= 55296 && cp < 57343 && character_1.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
              }, Scanner2;
            }();
            exports3.Scanner = Scanner;
          },
          /* 13 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.TokenName = {}, exports3.TokenName[
              1
              /* BooleanLiteral */
            ] = "Boolean", exports3.TokenName[
              2
              /* EOF */
            ] = "<end>", exports3.TokenName[
              3
              /* Identifier */
            ] = "Identifier", exports3.TokenName[
              4
              /* Keyword */
            ] = "Keyword", exports3.TokenName[
              5
              /* NullLiteral */
            ] = "Null", exports3.TokenName[
              6
              /* NumericLiteral */
            ] = "Numeric", exports3.TokenName[
              7
              /* Punctuator */
            ] = "Punctuator", exports3.TokenName[
              8
              /* StringLiteral */
            ] = "String", exports3.TokenName[
              9
              /* RegularExpression */
            ] = "RegularExpression", exports3.TokenName[
              10
              /* Template */
            ] = "Template";
          },
          /* 14 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.XHTMLEntities = {
              quot: '"',
              amp: "&",
              apos: "'",
              gt: ">",
              nbsp: "\xA0",
              iexcl: "\xA1",
              cent: "\xA2",
              pound: "\xA3",
              curren: "\xA4",
              yen: "\xA5",
              brvbar: "\xA6",
              sect: "\xA7",
              uml: "\xA8",
              copy: "\xA9",
              ordf: "\xAA",
              laquo: "\xAB",
              not: "\xAC",
              shy: "\xAD",
              reg: "\xAE",
              macr: "\xAF",
              deg: "\xB0",
              plusmn: "\xB1",
              sup2: "\xB2",
              sup3: "\xB3",
              acute: "\xB4",
              micro: "\xB5",
              para: "\xB6",
              middot: "\xB7",
              cedil: "\xB8",
              sup1: "\xB9",
              ordm: "\xBA",
              raquo: "\xBB",
              frac14: "\xBC",
              frac12: "\xBD",
              frac34: "\xBE",
              iquest: "\xBF",
              Agrave: "\xC0",
              Aacute: "\xC1",
              Acirc: "\xC2",
              Atilde: "\xC3",
              Auml: "\xC4",
              Aring: "\xC5",
              AElig: "\xC6",
              Ccedil: "\xC7",
              Egrave: "\xC8",
              Eacute: "\xC9",
              Ecirc: "\xCA",
              Euml: "\xCB",
              Igrave: "\xCC",
              Iacute: "\xCD",
              Icirc: "\xCE",
              Iuml: "\xCF",
              ETH: "\xD0",
              Ntilde: "\xD1",
              Ograve: "\xD2",
              Oacute: "\xD3",
              Ocirc: "\xD4",
              Otilde: "\xD5",
              Ouml: "\xD6",
              times: "\xD7",
              Oslash: "\xD8",
              Ugrave: "\xD9",
              Uacute: "\xDA",
              Ucirc: "\xDB",
              Uuml: "\xDC",
              Yacute: "\xDD",
              THORN: "\xDE",
              szlig: "\xDF",
              agrave: "\xE0",
              aacute: "\xE1",
              acirc: "\xE2",
              atilde: "\xE3",
              auml: "\xE4",
              aring: "\xE5",
              aelig: "\xE6",
              ccedil: "\xE7",
              egrave: "\xE8",
              eacute: "\xE9",
              ecirc: "\xEA",
              euml: "\xEB",
              igrave: "\xEC",
              iacute: "\xED",
              icirc: "\xEE",
              iuml: "\xEF",
              eth: "\xF0",
              ntilde: "\xF1",
              ograve: "\xF2",
              oacute: "\xF3",
              ocirc: "\xF4",
              otilde: "\xF5",
              ouml: "\xF6",
              divide: "\xF7",
              oslash: "\xF8",
              ugrave: "\xF9",
              uacute: "\xFA",
              ucirc: "\xFB",
              uuml: "\xFC",
              yacute: "\xFD",
              thorn: "\xFE",
              yuml: "\xFF",
              OElig: "\u0152",
              oelig: "\u0153",
              Scaron: "\u0160",
              scaron: "\u0161",
              Yuml: "\u0178",
              fnof: "\u0192",
              circ: "\u02C6",
              tilde: "\u02DC",
              Alpha: "\u0391",
              Beta: "\u0392",
              Gamma: "\u0393",
              Delta: "\u0394",
              Epsilon: "\u0395",
              Zeta: "\u0396",
              Eta: "\u0397",
              Theta: "\u0398",
              Iota: "\u0399",
              Kappa: "\u039A",
              Lambda: "\u039B",
              Mu: "\u039C",
              Nu: "\u039D",
              Xi: "\u039E",
              Omicron: "\u039F",
              Pi: "\u03A0",
              Rho: "\u03A1",
              Sigma: "\u03A3",
              Tau: "\u03A4",
              Upsilon: "\u03A5",
              Phi: "\u03A6",
              Chi: "\u03A7",
              Psi: "\u03A8",
              Omega: "\u03A9",
              alpha: "\u03B1",
              beta: "\u03B2",
              gamma: "\u03B3",
              delta: "\u03B4",
              epsilon: "\u03B5",
              zeta: "\u03B6",
              eta: "\u03B7",
              theta: "\u03B8",
              iota: "\u03B9",
              kappa: "\u03BA",
              lambda: "\u03BB",
              mu: "\u03BC",
              nu: "\u03BD",
              xi: "\u03BE",
              omicron: "\u03BF",
              pi: "\u03C0",
              rho: "\u03C1",
              sigmaf: "\u03C2",
              sigma: "\u03C3",
              tau: "\u03C4",
              upsilon: "\u03C5",
              phi: "\u03C6",
              chi: "\u03C7",
              psi: "\u03C8",
              omega: "\u03C9",
              thetasym: "\u03D1",
              upsih: "\u03D2",
              piv: "\u03D6",
              ensp: "\u2002",
              emsp: "\u2003",
              thinsp: "\u2009",
              zwnj: "\u200C",
              zwj: "\u200D",
              lrm: "\u200E",
              rlm: "\u200F",
              ndash: "\u2013",
              mdash: "\u2014",
              lsquo: "\u2018",
              rsquo: "\u2019",
              sbquo: "\u201A",
              ldquo: "\u201C",
              rdquo: "\u201D",
              bdquo: "\u201E",
              dagger: "\u2020",
              Dagger: "\u2021",
              bull: "\u2022",
              hellip: "\u2026",
              permil: "\u2030",
              prime: "\u2032",
              Prime: "\u2033",
              lsaquo: "\u2039",
              rsaquo: "\u203A",
              oline: "\u203E",
              frasl: "\u2044",
              euro: "\u20AC",
              image: "\u2111",
              weierp: "\u2118",
              real: "\u211C",
              trade: "\u2122",
              alefsym: "\u2135",
              larr: "\u2190",
              uarr: "\u2191",
              rarr: "\u2192",
              darr: "\u2193",
              harr: "\u2194",
              crarr: "\u21B5",
              lArr: "\u21D0",
              uArr: "\u21D1",
              rArr: "\u21D2",
              dArr: "\u21D3",
              hArr: "\u21D4",
              forall: "\u2200",
              part: "\u2202",
              exist: "\u2203",
              empty: "\u2205",
              nabla: "\u2207",
              isin: "\u2208",
              notin: "\u2209",
              ni: "\u220B",
              prod: "\u220F",
              sum: "\u2211",
              minus: "\u2212",
              lowast: "\u2217",
              radic: "\u221A",
              prop: "\u221D",
              infin: "\u221E",
              ang: "\u2220",
              and: "\u2227",
              or: "\u2228",
              cap: "\u2229",
              cup: "\u222A",
              int: "\u222B",
              there4: "\u2234",
              sim: "\u223C",
              cong: "\u2245",
              asymp: "\u2248",
              ne: "\u2260",
              equiv: "\u2261",
              le: "\u2264",
              ge: "\u2265",
              sub: "\u2282",
              sup: "\u2283",
              nsub: "\u2284",
              sube: "\u2286",
              supe: "\u2287",
              oplus: "\u2295",
              otimes: "\u2297",
              perp: "\u22A5",
              sdot: "\u22C5",
              lceil: "\u2308",
              rceil: "\u2309",
              lfloor: "\u230A",
              rfloor: "\u230B",
              loz: "\u25CA",
              spades: "\u2660",
              clubs: "\u2663",
              hearts: "\u2665",
              diams: "\u2666",
              lang: "\u27E8",
              rang: "\u27E9"
            };
          },
          /* 15 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var error_handler_1 = __webpack_require__(10), scanner_1 = __webpack_require__(12), token_1 = __webpack_require__(13), Reader = function() {
              function Reader2() {
                this.values = [], this.curly = this.paren = -1;
              }
              return Reader2.prototype.beforeFunctionExpression = function(t) {
                return [
                  "(",
                  "{",
                  "[",
                  "in",
                  "typeof",
                  "instanceof",
                  "new",
                  "return",
                  "case",
                  "delete",
                  "throw",
                  "void",
                  // assignment operators
                  "=",
                  "+=",
                  "-=",
                  "*=",
                  "**=",
                  "/=",
                  "%=",
                  "<<=",
                  ">>=",
                  ">>>=",
                  "&=",
                  "|=",
                  "^=",
                  ",",
                  // binary/unary operators
                  "+",
                  "-",
                  "*",
                  "**",
                  "/",
                  "%",
                  "++",
                  "--",
                  "<<",
                  ">>",
                  ">>>",
                  "&",
                  "|",
                  "^",
                  "!",
                  "~",
                  "&&",
                  "||",
                  "?",
                  ":",
                  "===",
                  "==",
                  ">=",
                  "<=",
                  "<",
                  ">",
                  "!=",
                  "!=="
                ].indexOf(t) >= 0;
              }, Reader2.prototype.isRegexStart = function() {
                var previous = this.values[this.values.length - 1], regex2 = previous !== null;
                switch (previous) {
                  case "this":
                  case "]":
                    regex2 = !1;
                    break;
                  case ")":
                    var keyword = this.values[this.paren - 1];
                    regex2 = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                    break;
                  case "}":
                    if (regex2 = !1, this.values[this.curly - 3] === "function") {
                      var check = this.values[this.curly - 4];
                      regex2 = check ? !this.beforeFunctionExpression(check) : !1;
                    } else if (this.values[this.curly - 4] === "function") {
                      var check = this.values[this.curly - 5];
                      regex2 = check ? !this.beforeFunctionExpression(check) : !0;
                    }
                    break;
                }
                return regex2;
              }, Reader2.prototype.push = function(token2) {
                token2.type === 7 || token2.type === 4 ? (token2.value === "{" ? this.curly = this.values.length : token2.value === "(" && (this.paren = this.values.length), this.values.push(token2.value)) : this.values.push(null);
              }, Reader2;
            }(), Tokenizer = function() {
              function Tokenizer2(code, config2) {
                this.errorHandler = new error_handler_1.ErrorHandler(), this.errorHandler.tolerant = config2 ? typeof config2.tolerant == "boolean" && config2.tolerant : !1, this.scanner = new scanner_1.Scanner(code, this.errorHandler), this.scanner.trackComment = config2 ? typeof config2.comment == "boolean" && config2.comment : !1, this.trackRange = config2 ? typeof config2.range == "boolean" && config2.range : !1, this.trackLoc = config2 ? typeof config2.loc == "boolean" && config2.loc : !1, this.buffer = [], this.reader = new Reader();
              }
              return Tokenizer2.prototype.errors = function() {
                return this.errorHandler.errors;
              }, Tokenizer2.prototype.getNextToken = function() {
                if (this.buffer.length === 0) {
                  var comments2 = this.scanner.scanComments();
                  if (this.scanner.trackComment)
                    for (var i = 0; i < comments2.length; ++i) {
                      var e = comments2[i], value = this.scanner.source.slice(e.slice[0], e.slice[1]), comment = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value
                      };
                      this.trackRange && (comment.range = e.range), this.trackLoc && (comment.loc = e.loc), this.buffer.push(comment);
                    }
                  if (!this.scanner.eof()) {
                    var loc = void 0;
                    this.trackLoc && (loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    });
                    var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart(), token2 = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(token2);
                    var entry = {
                      type: token_1.TokenName[token2.type],
                      value: this.scanner.source.slice(token2.start, token2.end)
                    };
                    if (this.trackRange && (entry.range = [token2.start, token2.end]), this.trackLoc && (loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    }, entry.loc = loc), token2.type === 9) {
                      var pattern = token2.pattern, flags = token2.flags;
                      entry.regex = { pattern, flags };
                    }
                    this.buffer.push(entry);
                  }
                }
                return this.buffer.shift();
              }, Tokenizer2;
            }();
            exports3.Tokenizer = Tokenizer;
          }
          /******/
        ])
      );
    });
  }(esprima$1)), esprima$1.exports;
}
var hasRequiredEsprima;
function requireEsprima() {
  if (hasRequiredEsprima) return esprima$2;
  hasRequiredEsprima = 1, Object.defineProperty(esprima$2, "__esModule", { value: !0 }), esprima$2.parse = void 0;
  var util_1 = requireUtil();
  function parse3(source2, options2) {
    var comments2 = [], ast = requireEsprima$1().parse(source2, {
      loc: !0,
      locations: !0,
      comment: !0,
      onComment: comments2,
      range: (0, util_1.getOption)(options2, "range", !1),
      tolerant: (0, util_1.getOption)(options2, "tolerant", !0),
      tokens: !0,
      jsx: (0, util_1.getOption)(options2, "jsx", !1),
      sourceType: (0, util_1.getOption)(options2, "sourceType", "module")
    });
    return Array.isArray(ast.comments) || (ast.comments = comments2), ast;
  }
  return esprima$2.parse = parse3, esprima$2;
}
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options$1;
  hasRequiredOptions = 1, Object.defineProperty(options$1, "__esModule", { value: !0 }), options$1.normalize = void 0;
  var util_1 = requireUtil(), defaults2 = {
    parser: requireEsprima(),
    tabWidth: 4,
    useTabs: !1,
    reuseWhitespace: !0,
    lineTerminator: (0, util_1.getLineTerminator)(),
    wrapColumn: 74,
    sourceFileName: null,
    sourceMapName: null,
    sourceRoot: null,
    inputSourceMap: null,
    range: !1,
    tolerant: !0,
    quote: null,
    trailingComma: !1,
    arrayBracketSpacing: !1,
    objectCurlySpacing: !0,
    arrowParensAlways: !1,
    flowObjectCommas: !0,
    tokens: !0
  }, hasOwn = defaults2.hasOwnProperty;
  function normalize2(opts) {
    var options2 = opts || defaults2;
    function get(key2) {
      return hasOwn.call(options2, key2) ? options2[key2] : defaults2[key2];
    }
    return {
      tabWidth: +get("tabWidth"),
      useTabs: !!get("useTabs"),
      reuseWhitespace: !!get("reuseWhitespace"),
      lineTerminator: get("lineTerminator"),
      wrapColumn: Math.max(get("wrapColumn"), 0),
      sourceFileName: get("sourceFileName"),
      sourceMapName: get("sourceMapName"),
      sourceRoot: get("sourceRoot"),
      inputSourceMap: get("inputSourceMap"),
      parser: get("esprima") || get("parser"),
      range: get("range"),
      tolerant: get("tolerant"),
      quote: get("quote"),
      trailingComma: get("trailingComma"),
      arrayBracketSpacing: get("arrayBracketSpacing"),
      objectCurlySpacing: get("objectCurlySpacing"),
      arrowParensAlways: get("arrowParensAlways"),
      flowObjectCommas: get("flowObjectCommas"),
      tokens: !!get("tokens")
    };
  }
  return options$1.normalize = normalize2, options$1;
}
var lines = {}, mapping = {}, hasRequiredMapping;
function requireMapping() {
  if (hasRequiredMapping) return mapping;
  hasRequiredMapping = 1, Object.defineProperty(mapping, "__esModule", { value: !0 });
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), util_1 = requireUtil(), Mapping = (
    /** @class */
    function() {
      function Mapping2(sourceLines, sourceLoc, targetLoc) {
        targetLoc === void 0 && (targetLoc = sourceLoc), this.sourceLines = sourceLines, this.sourceLoc = sourceLoc, this.targetLoc = targetLoc;
      }
      return Mapping2.prototype.slice = function(lines2, start, end) {
        end === void 0 && (end = lines2.lastPos());
        var sourceLines = this.sourceLines, sourceLoc = this.sourceLoc, targetLoc = this.targetLoc;
        function skip2(name) {
          var sourceFromPos = sourceLoc[name], targetFromPos = targetLoc[name], targetToPos = start;
          return name === "end" ? targetToPos = end : (0, tiny_invariant_1.default)(name === "start"), skipChars(sourceLines, sourceFromPos, lines2, targetFromPos, targetToPos);
        }
        if ((0, util_1.comparePos)(start, targetLoc.start) <= 0)
          if ((0, util_1.comparePos)(targetLoc.end, end) <= 0)
            targetLoc = {
              start: subtractPos(targetLoc.start, start.line, start.column),
              end: subtractPos(targetLoc.end, start.line, start.column)
            };
          else {
            if ((0, util_1.comparePos)(end, targetLoc.start) <= 0)
              return null;
            sourceLoc = {
              start: sourceLoc.start,
              end: skip2("end")
            }, targetLoc = {
              start: subtractPos(targetLoc.start, start.line, start.column),
              end: subtractPos(end, start.line, start.column)
            };
          }
        else {
          if ((0, util_1.comparePos)(targetLoc.end, start) <= 0)
            return null;
          (0, util_1.comparePos)(targetLoc.end, end) <= 0 ? (sourceLoc = {
            start: skip2("start"),
            end: sourceLoc.end
          }, targetLoc = {
            // Same as subtractPos(start, start.line, start.column):
            start: { line: 1, column: 0 },
            end: subtractPos(targetLoc.end, start.line, start.column)
          }) : (sourceLoc = {
            start: skip2("start"),
            end: skip2("end")
          }, targetLoc = {
            // Same as subtractPos(start, start.line, start.column):
            start: { line: 1, column: 0 },
            end: subtractPos(end, start.line, start.column)
          });
        }
        return new Mapping2(this.sourceLines, sourceLoc, targetLoc);
      }, Mapping2.prototype.add = function(line3, column2) {
        return new Mapping2(this.sourceLines, this.sourceLoc, {
          start: addPos(this.targetLoc.start, line3, column2),
          end: addPos(this.targetLoc.end, line3, column2)
        });
      }, Mapping2.prototype.subtract = function(line3, column2) {
        return new Mapping2(this.sourceLines, this.sourceLoc, {
          start: subtractPos(this.targetLoc.start, line3, column2),
          end: subtractPos(this.targetLoc.end, line3, column2)
        });
      }, Mapping2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
        if (skipFirstLine === void 0 && (skipFirstLine = !1), noNegativeColumns === void 0 && (noNegativeColumns = !1), by === 0)
          return this;
        var targetLoc = this.targetLoc, startLine = targetLoc.start.line, endLine = targetLoc.end.line;
        if (skipFirstLine && startLine === 1 && endLine === 1)
          return this;
        if (targetLoc = {
          start: targetLoc.start,
          end: targetLoc.end
        }, !skipFirstLine || startLine > 1) {
          var startColumn = targetLoc.start.column + by;
          targetLoc.start = {
            line: startLine,
            column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
          };
        }
        if (!skipFirstLine || endLine > 1) {
          var endColumn = targetLoc.end.column + by;
          targetLoc.end = {
            line: endLine,
            column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
          };
        }
        return new Mapping2(this.sourceLines, this.sourceLoc, targetLoc);
      }, Mapping2;
    }()
  );
  mapping.default = Mapping;
  function addPos(toPos, line3, column2) {
    return {
      line: toPos.line + line3 - 1,
      column: toPos.line === 1 ? toPos.column + column2 : toPos.column
    };
  }
  function subtractPos(fromPos, line3, column2) {
    return {
      line: fromPos.line - line3 + 1,
      column: fromPos.line === line3 ? fromPos.column - column2 : fromPos.column
    };
  }
  function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
    var targetComparison = (0, util_1.comparePos)(targetFromPos, targetToPos);
    if (targetComparison === 0)
      return sourceFromPos;
    var sourceCursor, targetCursor;
    if (targetComparison < 0) {
      sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos(), targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
      var lineDiff = targetToPos.line - targetCursor.line;
      for (sourceCursor.line += lineDiff, targetCursor.line += lineDiff, lineDiff > 0 ? (sourceCursor.column = 0, targetCursor.column = 0) : (0, tiny_invariant_1.default)(lineDiff === 0); (0, util_1.comparePos)(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, !0); )
        (0, tiny_invariant_1.default)(sourceLines.nextPos(sourceCursor, !0)), (0, tiny_invariant_1.default)(sourceLines.charAt(sourceCursor) === targetLines.charAt(targetCursor));
    } else {
      sourceCursor = sourceLines.skipSpaces(sourceFromPos, !0) || sourceLines.firstPos(), targetCursor = targetLines.skipSpaces(targetFromPos, !0) || targetLines.firstPos();
      var lineDiff = targetToPos.line - targetCursor.line;
      for (sourceCursor.line += lineDiff, targetCursor.line += lineDiff, lineDiff < 0 ? (sourceCursor.column = sourceLines.getLineLength(sourceCursor.line), targetCursor.column = targetLines.getLineLength(targetCursor.line)) : (0, tiny_invariant_1.default)(lineDiff === 0); (0, util_1.comparePos)(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, !0); )
        (0, tiny_invariant_1.default)(sourceLines.prevPos(sourceCursor, !0)), (0, tiny_invariant_1.default)(sourceLines.charAt(sourceCursor) === targetLines.charAt(targetCursor));
    }
    return sourceCursor;
  }
  return mapping;
}
var hasRequiredLines;
function requireLines() {
  if (hasRequiredLines) return lines;
  hasRequiredLines = 1, Object.defineProperty(lines, "__esModule", { value: !0 }), lines.concat = lines.fromString = lines.countSpaces = lines.Lines = void 0;
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), source_map_1 = tslib_1.__importDefault(requireSourceMap()), options_1 = requireOptions(), util_1 = requireUtil(), mapping_1 = tslib_1.__importDefault(requireMapping()), Lines = (
    /** @class */
    function() {
      function Lines2(infos, sourceFileName) {
        sourceFileName === void 0 && (sourceFileName = null), this.infos = infos, this.mappings = [], this.cachedSourceMap = null, this.cachedTabWidth = void 0, (0, tiny_invariant_1.default)(infos.length > 0), this.length = infos.length, this.name = sourceFileName || null, this.name && this.mappings.push(new mapping_1.default(this, {
          start: this.firstPos(),
          end: this.lastPos()
        }));
      }
      return Lines2.prototype.toString = function(options2) {
        return this.sliceString(this.firstPos(), this.lastPos(), options2);
      }, Lines2.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
        if (!sourceMapName)
          return null;
        var targetLines = this;
        function updateJSON(json2) {
          return json2 = json2 || {}, json2.file = sourceMapName, sourceRoot && (json2.sourceRoot = sourceRoot), json2;
        }
        if (targetLines.cachedSourceMap)
          return updateJSON(targetLines.cachedSourceMap.toJSON());
        var smg = new source_map_1.default.SourceMapGenerator(updateJSON()), sourcesToContents = {};
        return targetLines.mappings.forEach(function(mapping2) {
          for (var sourceCursor = mapping2.sourceLines.skipSpaces(mapping2.sourceLoc.start) || mapping2.sourceLines.lastPos(), targetCursor = targetLines.skipSpaces(mapping2.targetLoc.start) || targetLines.lastPos(); (0, util_1.comparePos)(sourceCursor, mapping2.sourceLoc.end) < 0 && (0, util_1.comparePos)(targetCursor, mapping2.targetLoc.end) < 0; ) {
            var sourceChar = mapping2.sourceLines.charAt(sourceCursor), targetChar = targetLines.charAt(targetCursor);
            (0, tiny_invariant_1.default)(sourceChar === targetChar);
            var sourceName = mapping2.sourceLines.name;
            if (smg.addMapping({
              source: sourceName,
              original: { line: sourceCursor.line, column: sourceCursor.column },
              generated: { line: targetCursor.line, column: targetCursor.column }
            }), !hasOwn.call(sourcesToContents, sourceName)) {
              var sourceContent = mapping2.sourceLines.toString();
              smg.setSourceContent(sourceName, sourceContent), sourcesToContents[sourceName] = sourceContent;
            }
            targetLines.nextPos(targetCursor, !0), mapping2.sourceLines.nextPos(sourceCursor, !0);
          }
        }), targetLines.cachedSourceMap = smg, smg.toJSON();
      }, Lines2.prototype.bootstrapCharAt = function(pos2) {
        (0, tiny_invariant_1.default)(typeof pos2 == "object"), (0, tiny_invariant_1.default)(typeof pos2.line == "number"), (0, tiny_invariant_1.default)(typeof pos2.column == "number");
        var line3 = pos2.line, column2 = pos2.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line3 - 1];
        return typeof string > "u" ? "" : column2 === string.length && line3 < strings.length ? `
` : column2 >= string.length ? "" : string.charAt(column2);
      }, Lines2.prototype.charAt = function(pos2) {
        (0, tiny_invariant_1.default)(typeof pos2 == "object"), (0, tiny_invariant_1.default)(typeof pos2.line == "number"), (0, tiny_invariant_1.default)(typeof pos2.column == "number");
        var line3 = pos2.line, column2 = pos2.column, secret = this, infos = secret.infos, info = infos[line3 - 1], c2 = column2;
        if (typeof info > "u" || c2 < 0)
          return "";
        var indent = this.getIndentAt(line3);
        return c2 < indent ? " " : (c2 += info.sliceStart - indent, c2 === info.sliceEnd && line3 < this.length ? `
` : c2 >= info.sliceEnd ? "" : info.line.charAt(c2));
      }, Lines2.prototype.stripMargin = function(width, skipFirstLine) {
        if (width === 0)
          return this;
        if ((0, tiny_invariant_1.default)(width > 0, "negative margin: " + width), skipFirstLine && this.length === 1)
          return this;
        var lines2 = new Lines2(this.infos.map(function(info, i) {
          return info.line && (i > 0 || !skipFirstLine) && (info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: Math.max(0, info.indent - width) })), info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_1 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_1.length === 0), this.mappings.forEach(function(mapping2) {
            newMappings_1.push(mapping2.indent(width, skipFirstLine, !0));
          });
        }
        return lines2;
      }, Lines2.prototype.indent = function(by) {
        if (by === 0)
          return this;
        var lines2 = new Lines2(this.infos.map(function(info) {
          return info.line && !info.locked && (info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by })), info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_2 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_2.length === 0), this.mappings.forEach(function(mapping2) {
            newMappings_2.push(mapping2.indent(by));
          });
        }
        return lines2;
      }, Lines2.prototype.indentTail = function(by) {
        if (by === 0)
          return this;
        if (this.length < 2)
          return this;
        var lines2 = new Lines2(this.infos.map(function(info, i) {
          return i > 0 && info.line && !info.locked && (info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by })), info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_3 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_3.length === 0), this.mappings.forEach(function(mapping2) {
            newMappings_3.push(mapping2.indent(by, !0));
          });
        }
        return lines2;
      }, Lines2.prototype.lockIndentTail = function() {
        return this.length < 2 ? this : new Lines2(this.infos.map(function(info, i) {
          return tslib_1.__assign(tslib_1.__assign({}, info), { locked: i > 0 });
        }));
      }, Lines2.prototype.getIndentAt = function(line3) {
        return (0, tiny_invariant_1.default)(line3 >= 1, "no line " + line3 + " (line numbers start from 1)"), Math.max(this.infos[line3 - 1].indent, 0);
      }, Lines2.prototype.guessTabWidth = function() {
        if (typeof this.cachedTabWidth == "number")
          return this.cachedTabWidth;
        for (var counts = [], lastIndent = 0, line3 = 1, last2 = this.length; line3 <= last2; ++line3) {
          var info = this.infos[line3 - 1], sliced = info.line.slice(info.sliceStart, info.sliceEnd);
          if (!isOnlyWhitespace(sliced)) {
            var diff = Math.abs(info.indent - lastIndent);
            counts[diff] = ~~counts[diff] + 1, lastIndent = info.indent;
          }
        }
        for (var maxCount = -1, result = 2, tabWidth = 1; tabWidth < counts.length; tabWidth += 1)
          hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount && (maxCount = counts[tabWidth], result = tabWidth);
        return this.cachedTabWidth = result;
      }, Lines2.prototype.startsWithComment = function() {
        if (this.infos.length === 0)
          return !1;
        var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
        return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
      }, Lines2.prototype.isOnlyWhitespace = function() {
        return isOnlyWhitespace(this.toString());
      }, Lines2.prototype.isPrecededOnlyByWhitespace = function(pos2) {
        var info = this.infos[pos2.line - 1], indent = Math.max(info.indent, 0), diff = pos2.column - indent;
        if (diff <= 0)
          return !0;
        var start = info.sliceStart, end = Math.min(start + diff, info.sliceEnd), prefix = info.line.slice(start, end);
        return isOnlyWhitespace(prefix);
      }, Lines2.prototype.getLineLength = function(line3) {
        var info = this.infos[line3 - 1];
        return this.getIndentAt(line3) + info.sliceEnd - info.sliceStart;
      }, Lines2.prototype.nextPos = function(pos2, skipSpaces) {
        skipSpaces === void 0 && (skipSpaces = !1);
        var l = Math.max(pos2.line, 0), c2 = Math.max(pos2.column, 0);
        return c2 < this.getLineLength(l) ? (pos2.column += 1, skipSpaces ? !!this.skipSpaces(pos2, !1, !0) : !0) : l < this.length ? (pos2.line += 1, pos2.column = 0, skipSpaces ? !!this.skipSpaces(pos2, !1, !0) : !0) : !1;
      }, Lines2.prototype.prevPos = function(pos2, skipSpaces) {
        skipSpaces === void 0 && (skipSpaces = !1);
        var l = pos2.line, c2 = pos2.column;
        if (c2 < 1) {
          if (l -= 1, l < 1)
            return !1;
          c2 = this.getLineLength(l);
        } else
          c2 = Math.min(c2 - 1, this.getLineLength(l));
        return pos2.line = l, pos2.column = c2, skipSpaces ? !!this.skipSpaces(pos2, !0, !0) : !0;
      }, Lines2.prototype.firstPos = function() {
        return { line: 1, column: 0 };
      }, Lines2.prototype.lastPos = function() {
        return {
          line: this.length,
          column: this.getLineLength(this.length)
        };
      }, Lines2.prototype.skipSpaces = function(pos2, backward, modifyInPlace) {
        if (backward === void 0 && (backward = !1), modifyInPlace === void 0 && (modifyInPlace = !1), pos2 ? pos2 = modifyInPlace ? pos2 : {
          line: pos2.line,
          column: pos2.column
        } : backward ? pos2 = this.lastPos() : pos2 = this.firstPos(), backward) {
          for (; this.prevPos(pos2); )
            if (!isOnlyWhitespace(this.charAt(pos2)) && this.nextPos(pos2))
              return pos2;
          return null;
        } else {
          for (; isOnlyWhitespace(this.charAt(pos2)); )
            if (!this.nextPos(pos2))
              return null;
          return pos2;
        }
      }, Lines2.prototype.trimLeft = function() {
        var pos2 = this.skipSpaces(this.firstPos(), !1, !0);
        return pos2 ? this.slice(pos2) : emptyLines;
      }, Lines2.prototype.trimRight = function() {
        var pos2 = this.skipSpaces(this.lastPos(), !0, !0);
        return pos2 ? this.slice(this.firstPos(), pos2) : emptyLines;
      }, Lines2.prototype.trim = function() {
        var start = this.skipSpaces(this.firstPos(), !1, !0);
        if (start === null)
          return emptyLines;
        var end = this.skipSpaces(this.lastPos(), !0, !0);
        return end === null ? emptyLines : this.slice(start, end);
      }, Lines2.prototype.eachPos = function(callback, startPos, skipSpaces) {
        startPos === void 0 && (startPos = this.firstPos()), skipSpaces === void 0 && (skipSpaces = !1);
        var pos2 = this.firstPos();
        if (startPos && (pos2.line = startPos.line, pos2.column = startPos.column), !(skipSpaces && !this.skipSpaces(pos2, !1, !0)))
          do
            callback.call(this, pos2);
          while (this.nextPos(pos2, skipSpaces));
      }, Lines2.prototype.bootstrapSlice = function(start, end) {
        var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
        return strings.length > 0 && (strings.push(strings.pop().slice(0, end.column)), strings[0] = strings[0].slice(start.column)), fromString(strings.join(`
`));
      }, Lines2.prototype.slice = function(start, end) {
        if (!end) {
          if (!start)
            return this;
          end = this.lastPos();
        }
        if (!start)
          throw new Error("cannot slice with end but not start");
        var sliced = this.infos.slice(start.line - 1, end.line);
        start.line === end.line ? sliced[0] = sliceInfo(sliced[0], start.column, end.column) : ((0, tiny_invariant_1.default)(start.line < end.line), sliced[0] = sliceInfo(sliced[0], start.column), sliced.push(sliceInfo(sliced.pop(), 0, end.column)));
        var lines2 = new Lines2(sliced);
        if (this.mappings.length > 0) {
          var newMappings_4 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_4.length === 0), this.mappings.forEach(function(mapping2) {
            var sliced2 = mapping2.slice(this, start, end);
            sliced2 && newMappings_4.push(sliced2);
          }, this);
        }
        return lines2;
      }, Lines2.prototype.bootstrapSliceString = function(start, end, options2) {
        return this.slice(start, end).toString(options2);
      }, Lines2.prototype.sliceString = function(start, end, options2) {
        start === void 0 && (start = this.firstPos()), end === void 0 && (end = this.lastPos());
        for (var _a = (0, options_1.normalize)(options2), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator, parts = [], line3 = start.line; line3 <= end.line; ++line3) {
          var info = this.infos[line3 - 1];
          line3 === start.line ? line3 === end.line ? info = sliceInfo(info, start.column, end.column) : info = sliceInfo(info, start.column) : line3 === end.line && (info = sliceInfo(info, 0, end.column));
          var indent = Math.max(info.indent, 0), before_1 = info.line.slice(0, info.sliceStart);
          if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {
            parts.push(info.line.slice(0, info.sliceEnd));
            continue;
          }
          var tabs = 0, spaces = indent;
          useTabs && (tabs = Math.floor(indent / tabWidth), spaces -= tabs * tabWidth);
          var result = "";
          tabs > 0 && (result += new Array(tabs + 1).join("	")), spaces > 0 && (result += new Array(spaces + 1).join(" ")), result += info.line.slice(info.sliceStart, info.sliceEnd), parts.push(result);
        }
        return parts.join(lineTerminator);
      }, Lines2.prototype.isEmpty = function() {
        return this.length < 2 && this.getLineLength(1) < 1;
      }, Lines2.prototype.join = function(elements) {
        var separator2 = this, infos = [], mappings = [], prevInfo;
        function appendLines(linesOrNull) {
          if (linesOrNull !== null) {
            if (prevInfo) {
              var info = linesOrNull.infos[0], indent = new Array(info.indent + 1).join(" "), prevLine_1 = infos.length, prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
              prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd), prevInfo.locked = prevInfo.locked || info.locked, prevInfo.sliceEnd = prevInfo.line.length, linesOrNull.mappings.length > 0 && linesOrNull.mappings.forEach(function(mapping2) {
                mappings.push(mapping2.add(prevLine_1, prevColumn_1));
              });
            } else linesOrNull.mappings.length > 0 && mappings.push.apply(mappings, linesOrNull.mappings);
            linesOrNull.infos.forEach(function(info2, i) {
              (!prevInfo || i > 0) && (prevInfo = tslib_1.__assign({}, info2), infos.push(prevInfo));
            });
          }
        }
        function appendWithSeparator(linesOrNull, i) {
          i > 0 && appendLines(separator2), appendLines(linesOrNull);
        }
        if (elements.map(function(elem) {
          var lines3 = fromString(elem);
          return lines3.isEmpty() ? null : lines3;
        }).forEach(function(linesOrNull, i) {
          separator2.isEmpty() ? appendLines(linesOrNull) : appendWithSeparator(linesOrNull, i);
        }), infos.length < 1)
          return emptyLines;
        var lines2 = new Lines2(infos);
        return lines2.mappings = mappings, lines2;
      }, Lines2.prototype.concat = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        var list2 = [this];
        return list2.push.apply(list2, args), (0, tiny_invariant_1.default)(list2.length === args.length + 1), emptyLines.join(list2);
      }, Lines2;
    }()
  );
  lines.Lines = Lines;
  var fromStringCache = {}, hasOwn = fromStringCache.hasOwnProperty, maxCacheKeyLen = 10;
  function countSpaces(spaces, tabWidth) {
    for (var count2 = 0, len = spaces.length, i = 0; i < len; ++i)
      switch (spaces.charCodeAt(i)) {
        case 9: {
          (0, tiny_invariant_1.default)(typeof tabWidth == "number"), (0, tiny_invariant_1.default)(tabWidth > 0);
          var next = Math.ceil(count2 / tabWidth) * tabWidth;
          next === count2 ? count2 += tabWidth : count2 = next;
          break;
        }
        case 11:
        // '\v'
        case 12:
        // '\f'
        case 13:
        // '\r'
        case 65279:
          break;
        case 32:
        // ' '
        default:
          count2 += 1;
          break;
      }
    return count2;
  }
  lines.countSpaces = countSpaces;
  var leadingSpaceExp = /^\s*/, lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
  function fromString(string, options2) {
    if (string instanceof Lines)
      return string;
    string += "";
    var tabWidth = options2 && options2.tabWidth, tabless = string.indexOf("	") < 0, cacheable = !options2 && tabless && string.length <= maxCacheKeyLen;
    if ((0, tiny_invariant_1.default)(tabWidth || tabless, `No tab width specified but encountered tabs in string
` + string), cacheable && hasOwn.call(fromStringCache, string))
      return fromStringCache[string];
    var lines2 = new Lines(string.split(lineTerminatorSeqExp).map(function(line3) {
      var spaces = leadingSpaceExp.exec(line3)[0];
      return {
        line: line3,
        indent: countSpaces(spaces, tabWidth),
        // Boolean indicating whether this line can be reindented.
        locked: !1,
        sliceStart: spaces.length,
        sliceEnd: line3.length
      };
    }), (0, options_1.normalize)(options2).sourceFileName);
    return cacheable && (fromStringCache[string] = lines2), lines2;
  }
  lines.fromString = fromString;
  function isOnlyWhitespace(string) {
    return !/\S/.test(string);
  }
  function sliceInfo(info, startCol, endCol) {
    var sliceStart = info.sliceStart, sliceEnd = info.sliceEnd, indent = Math.max(info.indent, 0), lineLength = indent + sliceEnd - sliceStart;
    return typeof endCol > "u" && (endCol = lineLength), startCol = Math.max(startCol, 0), endCol = Math.min(endCol, lineLength), endCol = Math.max(endCol, startCol), endCol < indent ? (indent = endCol, sliceEnd = sliceStart) : sliceEnd -= lineLength - endCol, lineLength = endCol, lineLength -= startCol, startCol < indent ? indent -= startCol : (startCol -= indent, indent = 0, sliceStart += startCol), (0, tiny_invariant_1.default)(indent >= 0), (0, tiny_invariant_1.default)(sliceStart <= sliceEnd), (0, tiny_invariant_1.default)(lineLength === indent + sliceEnd - sliceStart), info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd ? info : {
      line: info.line,
      indent,
      // A destructive slice always unlocks indentation.
      locked: !1,
      sliceStart,
      sliceEnd
    };
  }
  function concat2(elements) {
    return emptyLines.join(elements);
  }
  lines.concat = concat2;
  var emptyLines = fromString("");
  return lines;
}
var comments = {}, hasRequiredComments;
function requireComments() {
  if (hasRequiredComments) return comments;
  hasRequiredComments = 1, Object.defineProperty(comments, "__esModule", { value: !0 }), comments.printComments = comments.attach = void 0;
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), types2 = tslib_1.__importStar(requireMain$2()), n = types2.namedTypes, isArray2 = types2.builtInTypes.array, isObject2 = types2.builtInTypes.object, lines_1 = requireLines(), util_1 = requireUtil(), childNodesCache = /* @__PURE__ */ new WeakMap();
  function getSortedChildNodes(node, lines2, resultArray) {
    if (!node)
      return resultArray;
    if ((0, util_1.fixFaultyLocations)(node, lines2), resultArray) {
      if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
        for (var i = resultArray.length - 1; i >= 0; --i) {
          var child = resultArray[i];
          if (child && child.loc && (0, util_1.comparePos)(child.loc.end, node.loc.start) <= 0)
            break;
        }
        return resultArray.splice(i + 1, 0, node), resultArray;
      }
    } else {
      var childNodes = childNodesCache.get(node);
      if (childNodes)
        return childNodes;
    }
    var names;
    if (isArray2.check(node))
      names = Object.keys(node);
    else if (isObject2.check(node))
      names = types2.getFieldNames(node);
    else
      return resultArray;
    resultArray || childNodesCache.set(node, resultArray = []);
    for (var i = 0, nameCount = names.length; i < nameCount; ++i)
      getSortedChildNodes(node[names[i]], lines2, resultArray);
    return resultArray;
  }
  function decorateComment(node, comment, lines2) {
    for (var childNodes = getSortedChildNodes(node, lines2), left = 0, right = childNodes && childNodes.length, precedingNode, followingNode; typeof right == "number" && left < right; ) {
      var middle = left + right >> 1, child = childNodes[middle];
      if ((0, util_1.comparePos)(child.loc.start, comment.loc.start) <= 0 && (0, util_1.comparePos)(comment.loc.end, child.loc.end) <= 0) {
        decorateComment(comment.enclosingNode = child, comment, lines2);
        return;
      }
      if ((0, util_1.comparePos)(child.loc.end, comment.loc.start) <= 0) {
        precedingNode = child, left = middle + 1;
        continue;
      }
      if ((0, util_1.comparePos)(comment.loc.end, child.loc.start) <= 0) {
        followingNode = child, right = middle;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    precedingNode && (comment.precedingNode = precedingNode), followingNode && (comment.followingNode = followingNode);
  }
  function attach(comments2, ast, lines2) {
    if (isArray2.check(comments2)) {
      var tiesToBreak = [];
      comments2.forEach(function(comment) {
        comment.loc.lines = lines2, decorateComment(ast, comment, lines2);
        var pn = comment.precedingNode, en = comment.enclosingNode, fn = comment.followingNode;
        if (pn && fn) {
          var tieCount = tiesToBreak.length;
          if (tieCount > 0) {
            var lastTie = tiesToBreak[tieCount - 1];
            (0, tiny_invariant_1.default)(lastTie.precedingNode === comment.precedingNode == (lastTie.followingNode === comment.followingNode)), lastTie.followingNode !== comment.followingNode && breakTies(tiesToBreak, lines2);
          }
          tiesToBreak.push(comment);
        } else if (pn)
          breakTies(tiesToBreak, lines2), addTrailingComment(pn, comment);
        else if (fn)
          breakTies(tiesToBreak, lines2), addLeadingComment(fn, comment);
        else if (en)
          breakTies(tiesToBreak, lines2), addDanglingComment(en, comment);
        else
          throw new Error("AST contains no nodes at all?");
      }), breakTies(tiesToBreak, lines2), comments2.forEach(function(comment) {
        delete comment.precedingNode, delete comment.enclosingNode, delete comment.followingNode;
      });
    }
  }
  comments.attach = attach;
  function breakTies(tiesToBreak, lines2) {
    var tieCount = tiesToBreak.length;
    if (tieCount !== 0) {
      for (var pn = tiesToBreak[0].precedingNode, fn = tiesToBreak[0].followingNode, gapEndPos = fn.loc.start, indexOfFirstLeadingComment = tieCount, comment; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
        comment = tiesToBreak[indexOfFirstLeadingComment - 1], (0, tiny_invariant_1.default)(comment.precedingNode === pn), (0, tiny_invariant_1.default)(comment.followingNode === fn);
        var gap = lines2.sliceString(comment.loc.end, gapEndPos);
        if (/\S/.test(gap))
          break;
        gapEndPos = comment.loc.start;
      }
      for (; indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && // If the comment is a //-style comment and indented more
      // deeply than the node itself, reconsider it as trailing.
      (comment.type === "Line" || comment.type === "CommentLine") && comment.loc.start.column > fn.loc.start.column; )
        ++indexOfFirstLeadingComment;
      if (indexOfFirstLeadingComment) {
        var enclosingNode = tiesToBreak[indexOfFirstLeadingComment - 1].enclosingNode;
        enclosingNode?.type === "CallExpression" && --indexOfFirstLeadingComment;
      }
      tiesToBreak.forEach(function(comment2, i) {
        i < indexOfFirstLeadingComment ? addTrailingComment(pn, comment2) : addLeadingComment(fn, comment2);
      }), tiesToBreak.length = 0;
    }
  }
  function addCommentHelper(node, comment) {
    var comments2 = node.comments || (node.comments = []);
    comments2.push(comment);
  }
  function addLeadingComment(node, comment) {
    comment.leading = !0, comment.trailing = !1, addCommentHelper(node, comment);
  }
  function addDanglingComment(node, comment) {
    comment.leading = !1, comment.trailing = !1, addCommentHelper(node, comment);
  }
  function addTrailingComment(node, comment) {
    comment.leading = !1, comment.trailing = !0, addCommentHelper(node, comment);
  }
  function printLeadingComment(commentPath, print) {
    var comment = commentPath.getValue();
    n.Comment.assert(comment);
    var loc = comment.loc, lines2 = loc && loc.lines, parts = [print(commentPath)];
    if (comment.trailing)
      parts.push(`
`);
    else if (lines2 instanceof lines_1.Lines) {
      var trailingSpace = lines2.slice(loc.end, lines2.skipSpaces(loc.end) || lines2.lastPos());
      trailingSpace.length === 1 ? parts.push(trailingSpace) : parts.push(new Array(trailingSpace.length).join(`
`));
    } else
      parts.push(`
`);
    return (0, lines_1.concat)(parts);
  }
  function printTrailingComment(commentPath, print) {
    var comment = commentPath.getValue(commentPath);
    n.Comment.assert(comment);
    var loc = comment.loc, lines2 = loc && loc.lines, parts = [];
    if (lines2 instanceof lines_1.Lines) {
      var fromPos = lines2.skipSpaces(loc.start, !0) || lines2.firstPos(), leadingSpace = lines2.slice(fromPos, loc.start);
      leadingSpace.length === 1 ? parts.push(leadingSpace) : parts.push(new Array(leadingSpace.length).join(`
`));
    }
    return parts.push(print(commentPath)), (0, lines_1.concat)(parts);
  }
  function printComments(path2, print) {
    var value = path2.getValue(), innerLines = print(path2), comments2 = n.Node.check(value) && types2.getFieldValue(value, "comments");
    if (!comments2 || comments2.length === 0)
      return innerLines;
    var leadingParts = [], trailingParts = [innerLines];
    return path2.each(function(commentPath) {
      var comment = commentPath.getValue(), leading = types2.getFieldValue(comment, "leading"), trailing = types2.getFieldValue(comment, "trailing");
      leading || trailing && !(n.Statement.check(value) || comment.type === "Block" || comment.type === "CommentBlock") ? leadingParts.push(printLeadingComment(commentPath, print)) : trailing && trailingParts.push(printTrailingComment(commentPath, print));
    }, "comments"), leadingParts.push.apply(leadingParts, trailingParts), (0, lines_1.concat)(leadingParts);
  }
  return comments.printComments = printComments, comments;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser$1;
  hasRequiredParser = 1, Object.defineProperty(parser$1, "__esModule", { value: !0 }), parser$1.parse = void 0;
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), types2 = tslib_1.__importStar(requireMain$2()), b = types2.builders, isObject2 = types2.builtInTypes.object, isArray2 = types2.builtInTypes.array, options_1 = requireOptions(), lines_1 = requireLines(), comments_1 = requireComments(), util2 = tslib_1.__importStar(requireUtil());
  function parse3(source2, options2) {
    options2 = (0, options_1.normalize)(options2);
    var lines2 = (0, lines_1.fromString)(source2, options2), sourceWithoutTabs = lines2.toString({
      tabWidth: options2.tabWidth,
      reuseWhitespace: !1,
      useTabs: !1
    }), comments2 = [], ast = options2.parser.parse(sourceWithoutTabs, {
      jsx: !0,
      loc: !0,
      locations: !0,
      range: options2.range,
      comment: !0,
      onComment: comments2,
      tolerant: util2.getOption(options2, "tolerant", !0),
      ecmaVersion: 6,
      sourceType: util2.getOption(options2, "sourceType", "module")
    }), tokens = Array.isArray(ast.tokens) ? ast.tokens : requireEsprima$1().tokenize(sourceWithoutTabs, {
      loc: !0
    });
    delete ast.tokens, tokens.forEach(function(token2) {
      typeof token2.value != "string" && (token2.value = lines2.sliceString(token2.loc.start, token2.loc.end));
    }), Array.isArray(ast.comments) && (comments2 = ast.comments, delete ast.comments), ast.loc ? util2.fixFaultyLocations(ast, lines2) : ast.loc = {
      start: lines2.firstPos(),
      end: lines2.lastPos()
    }, ast.loc.lines = lines2, ast.loc.indent = 0;
    var file, program;
    ast.type === "Program" ? (program = ast, file = b.file(ast, options2.sourceFileName || null), file.loc = {
      start: lines2.firstPos(),
      end: lines2.lastPos(),
      lines: lines2,
      indent: 0
    }) : ast.type === "File" && (file = ast, program = file.program), options2.tokens && (file.tokens = tokens);
    var trueProgramLoc = util2.getTrueLoc({
      type: program.type,
      loc: program.loc,
      body: [],
      comments: comments2
    }, lines2);
    return program.loc.start = trueProgramLoc.start, program.loc.end = trueProgramLoc.end, (0, comments_1.attach)(comments2, program.body.length ? file.program : file, lines2), new TreeCopier(lines2, tokens).copy(file);
  }
  parser$1.parse = parse3;
  var TreeCopier = function TreeCopier2(lines2, tokens) {
    (0, tiny_invariant_1.default)(this instanceof TreeCopier2), this.lines = lines2, this.tokens = tokens, this.startTokenIndex = 0, this.endTokenIndex = tokens.length, this.indent = 0, this.seen = /* @__PURE__ */ new Map();
  }, TCp = TreeCopier.prototype;
  return TCp.copy = function(node) {
    if (this.seen.has(node))
      return this.seen.get(node);
    if (isArray2.check(node)) {
      var copy_1 = new Array(node.length);
      return this.seen.set(node, copy_1), node.forEach(function(item, i2) {
        copy_1[i2] = this.copy(item);
      }, this), copy_1;
    }
    if (!isObject2.check(node))
      return node;
    util2.fixFaultyLocations(node, this.lines);
    var copy2 = Object.create(Object.getPrototypeOf(node), {
      original: {
        // Provide a link from the copy to the original.
        value: node,
        configurable: !1,
        enumerable: !1,
        writable: !0
      }
    });
    this.seen.set(node, copy2);
    var loc = node.loc, oldIndent = this.indent, newIndent = oldIndent, oldStartTokenIndex = this.startTokenIndex, oldEndTokenIndex = this.endTokenIndex;
    loc && ((node.type === "Block" || node.type === "Line" || node.type === "CommentBlock" || node.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) && (newIndent = this.indent = loc.start.column), loc.lines = this.lines, loc.tokens = this.tokens, loc.indent = newIndent, this.findTokenRange(loc));
    for (var keys = Object.keys(node), keyCount = keys.length, i = 0; i < keyCount; ++i) {
      var key2 = keys[i];
      key2 === "loc" || key2 === "tokens" && node.type === "File" ? copy2[key2] = node[key2] : copy2[key2] = this.copy(node[key2]);
    }
    return this.indent = oldIndent, this.startTokenIndex = oldStartTokenIndex, this.endTokenIndex = oldEndTokenIndex, copy2;
  }, TCp.findTokenRange = function(loc) {
    for (; this.startTokenIndex > 0; ) {
      var token2 = loc.tokens[this.startTokenIndex];
      if (util2.comparePos(loc.start, token2.loc.start) < 0)
        --this.startTokenIndex;
      else
        break;
    }
    for (; this.endTokenIndex < loc.tokens.length; ) {
      var token2 = loc.tokens[this.endTokenIndex];
      if (util2.comparePos(token2.loc.end, loc.end) < 0)
        ++this.endTokenIndex;
      else
        break;
    }
    for (; this.startTokenIndex < this.endTokenIndex; ) {
      var token2 = loc.tokens[this.startTokenIndex];
      if (util2.comparePos(token2.loc.start, loc.start) < 0)
        ++this.startTokenIndex;
      else
        break;
    }
    for (loc.start.token = this.startTokenIndex; this.endTokenIndex > this.startTokenIndex; ) {
      var token2 = loc.tokens[this.endTokenIndex - 1];
      if (util2.comparePos(loc.end, token2.loc.end) < 0)
        --this.endTokenIndex;
      else
        break;
    }
    loc.end.token = this.endTokenIndex;
  }, parser$1;
}
var printer = {}, fastPath = {}, hasRequiredFastPath;
function requireFastPath() {
  if (hasRequiredFastPath) return fastPath;
  hasRequiredFastPath = 1, Object.defineProperty(fastPath, "__esModule", { value: !0 });
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), types2 = tslib_1.__importStar(requireMain$2()), util2 = tslib_1.__importStar(requireUtil()), n = types2.namedTypes, isArray2 = types2.builtInTypes.array, isNumber2 = types2.builtInTypes.number, PRECEDENCE = {};
  [
    ["??"],
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!=="],
    ["<", ">", "<=", ">=", "in", "instanceof"],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"],
    ["**"]
  ].forEach(function(tier, i) {
    tier.forEach(function(op) {
      PRECEDENCE[op] = i;
    });
  });
  var FastPath = function FastPath2(value) {
    (0, tiny_invariant_1.default)(this instanceof FastPath2), this.stack = [value];
  }, FPp = FastPath.prototype;
  FastPath.from = function(obj) {
    if (obj instanceof FastPath)
      return obj.copy();
    if (obj instanceof types2.NodePath) {
      for (var copy2 = Object.create(FastPath.prototype), stack2 = [obj.value], pp = void 0; pp = obj.parentPath; obj = pp)
        stack2.push(obj.name, pp.value);
      return copy2.stack = stack2.reverse(), copy2;
    }
    return new FastPath(obj);
  }, FPp.copy = function() {
    var copy3 = Object.create(FastPath.prototype);
    return copy3.stack = this.stack.slice(0), copy3;
  }, FPp.getName = function() {
    var s = this.stack, len = s.length;
    return len > 1 ? s[len - 2] : null;
  }, FPp.getValue = function() {
    var s = this.stack;
    return s[s.length - 1];
  }, FPp.valueIsDuplicate = function() {
    var s = this.stack, valueIndex = s.length - 1;
    return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
  };
  function getNodeHelper(path2, count2) {
    for (var s = path2.stack, i = s.length - 1; i >= 0; i -= 2) {
      var value = s[i];
      if (n.Node.check(value) && --count2 < 0)
        return value;
    }
    return null;
  }
  FPp.getNode = function(count2) {
    return count2 === void 0 && (count2 = 0), getNodeHelper(this, ~~count2);
  }, FPp.getParentNode = function(count2) {
    return count2 === void 0 && (count2 = 0), getNodeHelper(this, ~~count2 + 1);
  }, FPp.getRootValue = function() {
    var s = this.stack;
    return s.length % 2 === 0 ? s[1] : s[0];
  }, FPp.call = function(callback) {
    for (var s = this.stack, origLen = s.length, value = s[origLen - 1], argc = arguments.length, i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name], s.push(name, value);
    }
    var result = callback(this);
    return s.length = origLen, result;
  }, FPp.each = function(callback) {
    for (var s = this.stack, origLen = s.length, value = s[origLen - 1], argc = arguments.length, i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name], s.push(name, value);
    }
    for (var i = 0; i < value.length; ++i)
      i in value && (s.push(i, value[i]), callback(this), s.length -= 2);
    s.length = origLen;
  }, FPp.map = function(callback) {
    for (var s = this.stack, origLen = s.length, value = s[origLen - 1], argc = arguments.length, i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name], s.push(name, value);
    }
    for (var result = new Array(value.length), i = 0; i < value.length; ++i)
      i in value && (s.push(i, value[i]), result[i] = callback(this, i), s.length -= 2);
    return s.length = origLen, result;
  }, FPp.hasParens = function() {
    var node = this.getNode(), prevToken = this.getPrevToken(node);
    if (!prevToken)
      return !1;
    var nextToken = this.getNextToken(node);
    if (!nextToken)
      return !1;
    if (prevToken.value === "(") {
      if (nextToken.value === ")")
        return !0;
      var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(!0);
      if (justNeedsOpeningParen)
        return !0;
    }
    return !1;
  }, FPp.getPrevToken = function(node) {
    node = node || this.getNode();
    var loc = node && node.loc, tokens = loc && loc.tokens;
    if (tokens && loc.start.token > 0) {
      var token2 = tokens[loc.start.token - 1];
      if (token2) {
        var rootLoc = this.getRootValue().loc;
        if (util2.comparePos(rootLoc.start, token2.loc.start) <= 0)
          return token2;
      }
    }
    return null;
  }, FPp.getNextToken = function(node) {
    node = node || this.getNode();
    var loc = node && node.loc, tokens = loc && loc.tokens;
    if (tokens && loc.end.token < tokens.length) {
      var token2 = tokens[loc.end.token];
      if (token2) {
        var rootLoc = this.getRootValue().loc;
        if (util2.comparePos(token2.loc.end, rootLoc.end) <= 0)
          return token2;
      }
    }
    return null;
  }, FPp.needsParens = function(assumeExpressionContext) {
    var node = this.getNode();
    if (node.type === "AssignmentExpression" && node.left.type === "ObjectPattern")
      return !0;
    var parent = this.getParentNode(), name = this.getName();
    if (this.getValue() !== node || n.Statement.check(node) || node.type === "Identifier" || parent && parent.type === "ParenthesizedExpression")
      return !1;
    if (node.extra && node.extra.parenthesized)
      return !0;
    if (!parent)
      return !1;
    if (node.type === "UnaryExpression" && parent.type === "BinaryExpression" && name === "left" && parent.left === node && parent.operator === "**")
      return !0;
    switch (node.type) {
      case "UnaryExpression":
      case "SpreadElement":
      case "SpreadProperty":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node;
      case "BinaryExpression":
      case "LogicalExpression":
        switch (parent.type) {
          case "CallExpression":
            return name === "callee" && parent.callee === node;
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return !0;
          case "MemberExpression":
            return name === "object" && parent.object === node;
          case "BinaryExpression":
          case "LogicalExpression": {
            var po = parent.operator, pp = PRECEDENCE[po], no = node.operator, np = PRECEDENCE[no];
            if (pp > np)
              return !0;
            if (pp === np && name === "right")
              return (0, tiny_invariant_1.default)(parent.right === node), !0;
            break;
          }
          default:
            return !1;
        }
        break;
      case "SequenceExpression":
        switch (parent.type) {
          case "ReturnStatement":
            return !1;
          case "ForStatement":
            return !1;
          case "ExpressionStatement":
            return name !== "expression";
          default:
            return !0;
        }
      case "OptionalIndexedAccessType":
        return node.optional && parent.type === "IndexedAccessType";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return parent.type === "NullableTypeAnnotation";
      case "Literal":
        return parent.type === "MemberExpression" && isNumber2.check(node.value) && name === "object" && parent.object === node;
      // Babel 6 Literal split
      case "NumericLiteral":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node;
      case "YieldExpression":
      case "AwaitExpression":
      case "AssignmentExpression":
      case "ConditionalExpression":
        switch (parent.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
            return !0;
          case "CallExpression":
          case "NewExpression":
            return name === "callee" && parent.callee === node;
          case "ConditionalExpression":
            return name === "test" && parent.test === node;
          case "MemberExpression":
            return name === "object" && parent.object === node;
          default:
            return !1;
        }
      case "ArrowFunctionExpression":
        return n.CallExpression.check(parent) && name === "callee" && parent.callee === node || n.MemberExpression.check(parent) && name === "object" && parent.object === node || n.TSAsExpression && n.TSAsExpression.check(parent) && name === "expression" && parent.expression === node ? !0 : isBinary(parent);
      case "ObjectExpression":
        if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node)
          return !0;
        break;
      case "TSAsExpression":
        if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node && node.expression.type === "ObjectExpression")
          return !0;
        break;
      case "CallExpression":
        if (name === "declaration" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node.callee))
          return !0;
    }
    return parent.type === "NewExpression" && name === "callee" && parent.callee === node ? containsCallExpression(node) : !!(assumeExpressionContext !== !0 && !this.canBeFirstInStatement() && this.firstInStatement());
  };
  function isBinary(node) {
    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
  }
  function containsCallExpression(node) {
    return n.CallExpression.check(node) ? !0 : isArray2.check(node) ? node.some(containsCallExpression) : n.Node.check(node) ? types2.someField(node, function(_name, child) {
      return containsCallExpression(child);
    }) : !1;
  }
  return FPp.canBeFirstInStatement = function() {
    var node = this.getNode();
    return !(n.FunctionExpression.check(node) || n.ObjectExpression.check(node) || n.ClassExpression.check(node));
  }, FPp.firstInStatement = function() {
    for (var s = this.stack, parentName, parent, childName, child, i = s.length - 1; i >= 0; i -= 2)
      if (n.Node.check(s[i]) && (childName = parentName, child = parent, parentName = s[i - 1], parent = s[i]), !(!parent || !child)) {
        if (n.BlockStatement.check(parent) && parentName === "body" && childName === 0)
          return (0, tiny_invariant_1.default)(parent.body[0] === child), !0;
        if (n.ExpressionStatement.check(parent) && childName === "expression")
          return (0, tiny_invariant_1.default)(parent.expression === child), !0;
        if (n.AssignmentExpression.check(parent) && childName === "left")
          return (0, tiny_invariant_1.default)(parent.left === child), !0;
        if (n.ArrowFunctionExpression.check(parent) && childName === "body")
          return (0, tiny_invariant_1.default)(parent.body === child), !0;
        if (n.SequenceExpression.check(parent) && s[i + 1] === "expressions" && childName === 0) {
          (0, tiny_invariant_1.default)(parent.expressions[0] === child);
          continue;
        }
        if (n.CallExpression.check(parent) && childName === "callee") {
          (0, tiny_invariant_1.default)(parent.callee === child);
          continue;
        }
        if (n.MemberExpression.check(parent) && childName === "object") {
          (0, tiny_invariant_1.default)(parent.object === child);
          continue;
        }
        if (n.ConditionalExpression.check(parent) && childName === "test") {
          (0, tiny_invariant_1.default)(parent.test === child);
          continue;
        }
        if (isBinary(parent) && childName === "left") {
          (0, tiny_invariant_1.default)(parent.left === child);
          continue;
        }
        if (n.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
          (0, tiny_invariant_1.default)(parent.argument === child);
          continue;
        }
        return !1;
      }
    return !0;
  }, fastPath.default = FastPath, fastPath;
}
var patcher = {}, hasRequiredPatcher;
function requirePatcher() {
  if (hasRequiredPatcher) return patcher;
  hasRequiredPatcher = 1, Object.defineProperty(patcher, "__esModule", { value: !0 }), patcher.getReprinter = patcher.Patcher = void 0;
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), linesModule = tslib_1.__importStar(requireLines()), types2 = tslib_1.__importStar(requireMain$2()), Printable = types2.namedTypes.Printable, Expression = types2.namedTypes.Expression, ReturnStatement = types2.namedTypes.ReturnStatement, SourceLocation = types2.namedTypes.SourceLocation, util_1 = requireUtil(), fast_path_1 = tslib_1.__importDefault(requireFastPath()), isObject2 = types2.builtInTypes.object, isArray2 = types2.builtInTypes.array, isString = types2.builtInTypes.string, riskyAdjoiningCharExp = /[0-9a-z_$]/i, Patcher = function Patcher2(lines2) {
    (0, tiny_invariant_1.default)(this instanceof Patcher2), (0, tiny_invariant_1.default)(lines2 instanceof linesModule.Lines);
    var self2 = this, replacements = [];
    self2.replace = function(loc, lines3) {
      isString.check(lines3) && (lines3 = linesModule.fromString(lines3)), replacements.push({
        lines: lines3,
        start: loc.start,
        end: loc.end
      });
    }, self2.get = function(loc) {
      loc = loc || {
        start: { line: 1, column: 0 },
        end: { line: lines2.length, column: lines2.getLineLength(lines2.length) }
      };
      var sliceFrom = loc.start, toConcat = [];
      function pushSlice(from2, to) {
        (0, tiny_invariant_1.default)((0, util_1.comparePos)(from2, to) <= 0), toConcat.push(lines2.slice(from2, to));
      }
      return replacements.sort(function(a, b) {
        return (0, util_1.comparePos)(a.start, b.start);
      }).forEach(function(rep) {
        (0, util_1.comparePos)(sliceFrom, rep.start) > 0 || (pushSlice(sliceFrom, rep.start), toConcat.push(rep.lines), sliceFrom = rep.end);
      }), pushSlice(sliceFrom, loc.end), linesModule.concat(toConcat);
    };
  };
  patcher.Patcher = Patcher;
  var Pp = Patcher.prototype;
  Pp.tryToReprintComments = function(newNode, oldNode, print) {
    var patcher2 = this;
    if (!newNode.comments && !oldNode.comments)
      return !0;
    var newPath = fast_path_1.default.from(newNode), oldPath = fast_path_1.default.from(oldNode);
    newPath.stack.push("comments", getSurroundingComments(newNode)), oldPath.stack.push("comments", getSurroundingComments(oldNode));
    var reprints = [], ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
    return ableToReprintComments && reprints.length > 0 && reprints.forEach(function(reprint) {
      var oldComment = reprint.oldPath.getValue();
      (0, tiny_invariant_1.default)(oldComment.leading || oldComment.trailing), patcher2.replace(
        oldComment.loc,
        // Comments can't have .comments, so it doesn't matter whether we
        // print with comments or without.
        print(reprint.newPath).indentTail(oldComment.loc.indent)
      );
    }), ableToReprintComments;
  };
  function getSurroundingComments(node) {
    var result = [];
    return node.comments && node.comments.length > 0 && node.comments.forEach(function(comment) {
      (comment.leading || comment.trailing) && result.push(comment);
    }), result;
  }
  Pp.deleteComments = function(node) {
    if (node.comments) {
      var patcher2 = this;
      node.comments.forEach(function(comment) {
        comment.leading ? patcher2.replace({
          start: comment.loc.start,
          end: node.loc.lines.skipSpaces(comment.loc.end, !1, !1)
        }, "") : comment.trailing && patcher2.replace({
          start: node.loc.lines.skipSpaces(comment.loc.start, !0, !1),
          end: comment.loc.end
        }, "");
      });
    }
  };
  function getReprinter(path2) {
    (0, tiny_invariant_1.default)(path2 instanceof fast_path_1.default);
    var node = path2.getValue();
    if (Printable.check(node)) {
      var orig = node.original, origLoc = orig && orig.loc, lines2 = origLoc && origLoc.lines, reprints = [];
      if (!(!lines2 || !findReprints(path2, reprints)))
        return function(print) {
          var patcher2 = new Patcher(lines2);
          reprints.forEach(function(reprint) {
            var newNode = reprint.newPath.getValue(), oldNode = reprint.oldPath.getValue();
            SourceLocation.assert(oldNode.loc, !0);
            var needToPrintNewPathWithComments = !patcher2.tryToReprintComments(newNode, oldNode, print);
            needToPrintNewPathWithComments && patcher2.deleteComments(oldNode);
            var newLines = print(reprint.newPath, {
              includeComments: needToPrintNewPathWithComments,
              // If the oldNode we're replacing already had parentheses, we may
              // not need to print the new node with any extra parentheses,
              // because the existing parentheses will suffice. However, if the
              // newNode has a different type than the oldNode, let the printer
              // decide if reprint.newPath needs parentheses, as usual.
              avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
            }).indentTail(oldNode.loc.indent), nls = needsLeadingSpace(lines2, oldNode.loc, newLines), nts = needsTrailingSpace(lines2, oldNode.loc, newLines);
            if (nls || nts) {
              var newParts = [];
              nls && newParts.push(" "), newParts.push(newLines), nts && newParts.push(" "), newLines = linesModule.concat(newParts);
            }
            patcher2.replace(oldNode.loc, newLines);
          });
          var patchedLines = patcher2.get(origLoc).indentTail(-orig.loc.indent);
          return path2.needsParens() ? linesModule.concat(["(", patchedLines, ")"]) : patchedLines;
        };
    }
  }
  patcher.getReprinter = getReprinter;
  function needsLeadingSpace(oldLines, oldLoc, newLines) {
    var posBeforeOldLoc = (0, util_1.copyPos)(oldLoc.start), charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc), newFirstChar = newLines.charAt(newLines.firstPos());
    return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
  }
  function needsTrailingSpace(oldLines, oldLoc, newLines) {
    var charAfterOldLoc = oldLines.charAt(oldLoc.end), newLastPos = newLines.lastPos(), newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
    return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
  }
  function findReprints(newPath, reprints) {
    var newNode = newPath.getValue();
    Printable.assert(newNode);
    var oldNode = newNode.original;
    if (Printable.assert(oldNode), (0, tiny_invariant_1.default)(reprints.length === 0), newNode.type !== oldNode.type)
      return !1;
    var oldPath = new fast_path_1.default(oldNode), canReprint = findChildReprints(newPath, oldPath, reprints);
    return canReprint || (reprints.length = 0), canReprint;
  }
  function findAnyReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue(), oldNode = oldPath.getValue();
    return newNode === oldNode ? !0 : isArray2.check(newNode) ? findArrayReprints(newPath, oldPath, reprints) : isObject2.check(newNode) ? findObjectReprints(newPath, oldPath, reprints) : !1;
  }
  function findArrayReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue(), oldNode = oldPath.getValue();
    if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate())
      return !0;
    isArray2.assert(newNode);
    var len = newNode.length;
    if (!(isArray2.check(oldNode) && oldNode.length === len))
      return !1;
    for (var i = 0; i < len; ++i) {
      newPath.stack.push(i, newNode[i]), oldPath.stack.push(i, oldNode[i]);
      var canReprint = findAnyReprints(newPath, oldPath, reprints);
      if (newPath.stack.length -= 2, oldPath.stack.length -= 2, !canReprint)
        return !1;
    }
    return !0;
  }
  function findObjectReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue();
    if (isObject2.assert(newNode), newNode.original === null)
      return !1;
    var oldNode = oldPath.getValue();
    if (!isObject2.check(oldNode))
      return !1;
    if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate())
      return !0;
    if (Printable.check(newNode)) {
      if (!Printable.check(oldNode))
        return !1;
      var newParentNode = newPath.getParentNode(), oldParentNode = oldPath.getParentNode();
      if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
        var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name, newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
        if (!oldNeedsParens && newNeedParens)
          return !1;
      }
      if (newNode.type === oldNode.type) {
        var childReprints = [];
        if (findChildReprints(newPath, oldPath, childReprints))
          reprints.push.apply(reprints, childReprints);
        else if (oldNode.loc)
          reprints.push({
            oldPath: oldPath.copy(),
            newPath: newPath.copy()
          });
        else
          return !1;
        return !0;
      }
      return Expression.check(newNode) && Expression.check(oldNode) && // If we have no .loc information for oldNode, then we won't be
      // able to reprint it.
      oldNode.loc ? (reprints.push({
        oldPath: oldPath.copy(),
        newPath: newPath.copy()
      }), !0) : !1;
    }
    return findChildReprints(newPath, oldPath, reprints);
  }
  function findChildReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue(), oldNode = oldPath.getValue();
    if (isObject2.assert(newNode), isObject2.assert(oldNode), newNode.original === null || newPath.needsParens() && !oldPath.hasParens())
      return !1;
    var keys = (0, util_1.getUnionOfKeys)(oldNode, newNode);
    (oldNode.type === "File" || newNode.type === "File") && delete keys.tokens, delete keys.loc;
    var originalReprintCount = reprints.length;
    for (var k in keys)
      if (k.charAt(0) !== "_") {
        newPath.stack.push(k, types2.getFieldValue(newNode, k)), oldPath.stack.push(k, types2.getFieldValue(oldNode, k));
        var canReprint = findAnyReprints(newPath, oldPath, reprints);
        if (newPath.stack.length -= 2, oldPath.stack.length -= 2, !canReprint)
          return !1;
      }
    return !(ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount);
  }
  return patcher;
}
var hasRequiredPrinter;
function requirePrinter() {
  if (hasRequiredPrinter) return printer;
  hasRequiredPrinter = 1, Object.defineProperty(printer, "__esModule", { value: !0 }), printer.Printer = void 0;
  var tslib_1 = require$$0$3, tiny_invariant_1 = tslib_1.__importDefault(/* @__PURE__ */ requireTinyInvariant_cjs()), types2 = tslib_1.__importStar(requireMain$2()), comments_1 = requireComments(), fast_path_1 = tslib_1.__importDefault(requireFastPath()), lines_1 = requireLines(), options_1 = requireOptions(), patcher_1 = requirePatcher(), util2 = tslib_1.__importStar(requireUtil()), namedTypes2 = types2.namedTypes, isString = types2.builtInTypes.string, isObject2 = types2.builtInTypes.object, PrintResult = function PrintResult2(code, sourceMap2) {
    (0, tiny_invariant_1.default)(this instanceof PrintResult2), isString.assert(code), this.code = code, sourceMap2 && (isObject2.assert(sourceMap2), this.map = sourceMap2);
  }, PRp = PrintResult.prototype, warnedAboutToString = !1;
  PRp.toString = function() {
    return warnedAboutToString || (console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged."), warnedAboutToString = !0), this.code;
  };
  var emptyPrintResult = new PrintResult(""), Printer = function Printer2(config2) {
    (0, tiny_invariant_1.default)(this instanceof Printer2);
    var explicitTabWidth = config2 && config2.tabWidth;
    config2 = (0, options_1.normalize)(config2), config2.sourceFileName = null;
    function makePrintFunctionWith(options2, overrides) {
      return options2 = Object.assign({}, options2, overrides), function(path2) {
        return print(path2, options2);
      };
    }
    function print(path2, options2) {
      if ((0, tiny_invariant_1.default)(path2 instanceof fast_path_1.default), options2 = options2 || {}, options2.includeComments)
        return (0, comments_1.printComments)(path2, makePrintFunctionWith(options2, {
          includeComments: !1
        }));
      var oldTabWidth = config2.tabWidth;
      if (!explicitTabWidth) {
        var loc = path2.getNode().loc;
        loc && loc.lines && loc.lines.guessTabWidth && (config2.tabWidth = loc.lines.guessTabWidth());
      }
      var reprinter = (0, patcher_1.getReprinter)(path2), lines2 = reprinter ? (
        // Since the print function that we pass to the reprinter will
        // be used to print "new" nodes, it's tempting to think we
        // should pass printRootGenerically instead of print, to avoid
        // calling maybeReprint again, but that would be a mistake
        // because the new nodes might not be entirely new, but merely
        // moved from elsewhere in the AST. The print function is the
        // right choice because it gives us the opportunity to reprint
        // such nodes using their original source.
        reprinter(print)
      ) : genericPrint(path2, config2, options2, makePrintFunctionWith(options2, {
        includeComments: !0,
        avoidRootParens: !1
      }));
      return config2.tabWidth = oldTabWidth, lines2;
    }
    this.print = function(ast) {
      if (!ast)
        return emptyPrintResult;
      var lines2 = print(fast_path_1.default.from(ast), {
        includeComments: !0,
        avoidRootParens: !1
      });
      return new PrintResult(lines2.toString(config2), util2.composeSourceMaps(config2.inputSourceMap, lines2.getSourceMap(config2.sourceMapName, config2.sourceRoot)));
    }, this.printGenerically = function(ast) {
      if (!ast)
        return emptyPrintResult;
      function printGenerically(path3) {
        return (0, comments_1.printComments)(path3, function(path4) {
          return genericPrint(path4, config2, {
            includeComments: !0,
            avoidRootParens: !1
          }, printGenerically);
        });
      }
      var path2 = fast_path_1.default.from(ast), oldReuseWhitespace = config2.reuseWhitespace;
      config2.reuseWhitespace = !1;
      var pr = new PrintResult(printGenerically(path2).toString(config2));
      return config2.reuseWhitespace = oldReuseWhitespace, pr;
    };
  };
  printer.Printer = Printer;
  function genericPrint(path2, config2, options2, printPath) {
    (0, tiny_invariant_1.default)(path2 instanceof fast_path_1.default);
    var node = path2.getValue(), parts = [], linesWithoutParens = genericPrintNoParens(path2, config2, printPath);
    if (!node || linesWithoutParens.isEmpty())
      return linesWithoutParens;
    var shouldAddParens = !1, decoratorsLines = printDecorators(path2, printPath);
    return decoratorsLines.isEmpty() ? options2.avoidRootParens || (shouldAddParens = path2.needsParens()) : parts.push(decoratorsLines), shouldAddParens && parts.unshift("("), parts.push(linesWithoutParens), shouldAddParens && parts.push(")"), (0, lines_1.concat)(parts);
  }
  function genericPrintNoParens(path2, options2, print) {
    var n = path2.getValue();
    if (!n)
      return (0, lines_1.fromString)("");
    if (typeof n == "string")
      return (0, lines_1.fromString)(n, options2);
    namedTypes2.Printable.assert(n);
    var parts = [];
    switch (n.type) {
      case "File":
        return path2.call(print, "program");
      case "Program":
        return n.directives && path2.each(function(childPath) {
          parts.push(print(childPath), `;
`);
        }, "directives"), n.interpreter && parts.push(path2.call(print, "interpreter")), parts.push(path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body")), (0, lines_1.concat)(parts);
      case "Noop":
      // Babel extension.
      case "EmptyStatement":
        return (0, lines_1.fromString)("");
      case "ExpressionStatement":
        return (0, lines_1.concat)([path2.call(print, "expression"), ";"]);
      case "ParenthesizedExpression":
        return (0, lines_1.concat)(["(", path2.call(print, "expression"), ")"]);
      case "BinaryExpression":
      case "LogicalExpression":
      case "AssignmentExpression":
        return (0, lines_1.fromString)(" ").join([
          path2.call(print, "left"),
          n.operator,
          path2.call(print, "right")
        ]);
      case "AssignmentPattern":
        return (0, lines_1.concat)([
          path2.call(print, "left"),
          " = ",
          path2.call(print, "right")
        ]);
      case "MemberExpression":
      case "OptionalMemberExpression": {
        parts.push(path2.call(print, "object"));
        var property = path2.call(print, "property"), optional = types2.getFieldValue(n, "optional");
        return n.computed ? parts.push(optional ? "?.[" : "[", property, "]") : parts.push(optional ? "?." : ".", property), (0, lines_1.concat)(parts);
      }
      case "ChainExpression":
        return path2.call(print, "expression");
      case "MetaProperty":
        return (0, lines_1.concat)([
          path2.call(print, "meta"),
          ".",
          path2.call(print, "property")
        ]);
      case "BindExpression":
        return n.object && parts.push(path2.call(print, "object")), parts.push("::", path2.call(print, "callee")), (0, lines_1.concat)(parts);
      case "Path":
        return (0, lines_1.fromString)(".").join(n.body);
      case "Identifier":
        return (0, lines_1.concat)([
          (0, lines_1.fromString)(n.name, options2),
          n.optional ? "?" : "",
          path2.call(print, "typeAnnotation")
        ]);
      case "SpreadElement":
      case "SpreadElementPattern":
      case "RestProperty":
      // Babel 6 for ObjectPattern
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "ObjectTypeSpreadProperty":
      case "RestElement":
        return (0, lines_1.concat)([
          "...",
          path2.call(print, "argument"),
          path2.call(print, "typeAnnotation")
        ]);
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "TSDeclareFunction":
        return n.declare && parts.push("declare "), n.async && parts.push("async "), parts.push("function"), n.generator && parts.push("*"), n.id ? parts.push(" ", path2.call(print, "id"), path2.call(print, "typeParameters")) : n.typeParameters && parts.push(path2.call(print, "typeParameters")), parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType")), n.body && parts.push(" ", path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "ArrowFunctionExpression":
        return n.async && parts.push("async "), n.typeParameters && parts.push(path2.call(print, "typeParameters")), !options2.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === "Identifier" && !n.params[0].typeAnnotation && !n.returnType ? parts.push(path2.call(print, "params", 0)) : parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType")), parts.push(" => ", path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "MethodDefinition":
        return printMethod(path2, options2, print);
      case "YieldExpression":
        return parts.push("yield"), n.delegate && parts.push("*"), n.argument && parts.push(" ", path2.call(print, "argument")), (0, lines_1.concat)(parts);
      case "AwaitExpression":
        return parts.push("await"), n.all && parts.push("*"), n.argument && parts.push(" ", path2.call(print, "argument")), (0, lines_1.concat)(parts);
      case "ModuleExpression":
        return (0, lines_1.concat)([
          `module {
`,
          path2.call(print, "body").indent(options2.tabWidth),
          `
}`
        ]);
      case "ModuleDeclaration":
        return parts.push("module", path2.call(print, "id")), n.source ? ((0, tiny_invariant_1.default)(!n.body), parts.push("from", path2.call(print, "source"))) : parts.push(path2.call(print, "body")), (0, lines_1.fromString)(" ").join(parts);
      case "ImportSpecifier":
        return n.importKind && n.importKind !== "value" && parts.push(n.importKind + " "), n.imported ? (parts.push(path2.call(print, "imported")), n.local && n.local.name !== n.imported.name && parts.push(" as ", path2.call(print, "local"))) : n.id && (parts.push(path2.call(print, "id")), n.name && parts.push(" as ", path2.call(print, "name"))), (0, lines_1.concat)(parts);
      case "ExportSpecifier":
        return n.exportKind && n.exportKind !== "value" && parts.push(n.exportKind + " "), n.local ? (parts.push(path2.call(print, "local")), n.exported && n.exported.name !== n.local.name && parts.push(" as ", path2.call(print, "exported"))) : n.id && (parts.push(path2.call(print, "id")), n.name && parts.push(" as ", path2.call(print, "name"))), (0, lines_1.concat)(parts);
      case "ExportBatchSpecifier":
        return (0, lines_1.fromString)("*");
      case "ImportNamespaceSpecifier":
        return parts.push("* as "), n.local ? parts.push(path2.call(print, "local")) : n.id && parts.push(path2.call(print, "id")), (0, lines_1.concat)(parts);
      case "ImportDefaultSpecifier":
        return n.local ? path2.call(print, "local") : path2.call(print, "id");
      case "TSExportAssignment":
        return (0, lines_1.concat)(["export = ", path2.call(print, "expression")]);
      case "ExportDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return printExportDeclaration(path2, options2, print);
      case "ExportAllDeclaration":
        return parts.push("export *"), n.exported && parts.push(" as ", path2.call(print, "exported")), parts.push(" from ", path2.call(print, "source"), ";"), (0, lines_1.concat)(parts);
      case "TSNamespaceExportDeclaration":
        return parts.push("export as namespace ", path2.call(print, "id")), maybeAddSemicolon((0, lines_1.concat)(parts));
      case "ExportNamespaceSpecifier":
        return (0, lines_1.concat)(["* as ", path2.call(print, "exported")]);
      case "ExportDefaultSpecifier":
        return path2.call(print, "exported");
      case "Import":
        return (0, lines_1.fromString)("import", options2);
      // Recast and ast-types currently support dynamic import(...) using
      // either this dedicated ImportExpression type or a CallExpression
      // whose callee has type Import.
      // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486
      case "ImportExpression":
        return (0, lines_1.concat)(["import(", path2.call(print, "source"), ")"]);
      case "ImportDeclaration": {
        if (parts.push("import "), n.importKind && n.importKind !== "value" && parts.push(n.importKind + " "), n.specifiers && n.specifiers.length > 0) {
          var unbracedSpecifiers_1 = [], bracedSpecifiers_1 = [];
          if (path2.each(function(specifierPath) {
            var spec = specifierPath.getValue();
            spec.type === "ImportSpecifier" ? bracedSpecifiers_1.push(print(specifierPath)) : (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") && unbracedSpecifiers_1.push(print(specifierPath));
          }, "specifiers"), unbracedSpecifiers_1.forEach(function(lines3, i) {
            i > 0 && parts.push(", "), parts.push(lines3);
          }), bracedSpecifiers_1.length > 0) {
            var lines2 = (0, lines_1.fromString)(", ").join(bracedSpecifiers_1);
            lines2.getLineLength(1) > options2.wrapColumn && (lines2 = (0, lines_1.concat)([
              (0, lines_1.fromString)(`,
`).join(bracedSpecifiers_1).indent(options2.tabWidth),
              ","
            ])), unbracedSpecifiers_1.length > 0 && parts.push(", "), lines2.length > 1 ? parts.push(`{
`, lines2, `
}`) : options2.objectCurlySpacing ? parts.push("{ ", lines2, " }") : parts.push("{", lines2, "}");
          }
          parts.push(" from ");
        }
        return parts.push(path2.call(print, "source"), maybePrintImportAssertions(path2, options2, print), ";"), (0, lines_1.concat)(parts);
      }
      case "ImportAttribute":
        return (0, lines_1.concat)([path2.call(print, "key"), ": ", path2.call(print, "value")]);
      case "StaticBlock":
        parts.push("static ");
      // Intentionally fall through to BlockStatement below.
      case "BlockStatement": {
        var naked_1 = path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body");
        return naked_1.isEmpty() && (!n.directives || n.directives.length === 0) ? (parts.push("{}"), (0, lines_1.concat)(parts)) : (parts.push(`{
`), n.directives && path2.each(function(childPath) {
          parts.push(maybeAddSemicolon(print(childPath).indent(options2.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? `
` : "");
        }, "directives"), parts.push(naked_1.indent(options2.tabWidth)), parts.push(`
}`), (0, lines_1.concat)(parts));
      }
      case "ReturnStatement": {
        if (parts.push("return"), n.argument) {
          var argLines = path2.call(print, "argument");
          argLines.startsWithComment() || argLines.length > 1 && namedTypes2.JSXElement && namedTypes2.JSXElement.check(n.argument) ? parts.push(` (
`, argLines.indent(options2.tabWidth), `
)`) : parts.push(" ", argLines);
        }
        return parts.push(";"), (0, lines_1.concat)(parts);
      }
      case "CallExpression":
      case "OptionalCallExpression":
        return parts.push(path2.call(print, "callee")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), n.typeArguments && parts.push(path2.call(print, "typeArguments")), types2.getFieldValue(n, "optional") && parts.push("?."), parts.push(printArgumentsList(path2, options2, print)), (0, lines_1.concat)(parts);
      case "RecordExpression":
        parts.push("#");
      // Intentionally fall through to printing the object literal...
      case "ObjectExpression":
      case "ObjectPattern":
      case "ObjectTypeAnnotation": {
        var isTypeAnnotation_1 = n.type === "ObjectTypeAnnotation", separator_1 = options2.flowObjectCommas ? "," : isTypeAnnotation_1 ? ";" : ",", fields = [], allowBreak_1 = !1;
        isTypeAnnotation_1 && (fields.push("indexers", "callProperties"), n.internalSlots != null && fields.push("internalSlots")), fields.push("properties");
        var len_1 = 0;
        fields.forEach(function(field) {
          len_1 += n[field].length;
        });
        var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0, leftBrace = n.exact ? "{|" : "{", rightBrace = n.exact ? "|}" : "}";
        parts.push(oneLine_1 ? leftBrace : leftBrace + `
`);
        var leftBraceIndex = parts.length - 1, i_1 = 0;
        if (fields.forEach(function(field) {
          path2.each(function(childPath) {
            var lines3 = print(childPath);
            oneLine_1 || (lines3 = lines3.indent(options2.tabWidth));
            var multiLine = !isTypeAnnotation_1 && lines3.length > 1;
            multiLine && allowBreak_1 && parts.push(`
`), parts.push(lines3), i_1 < len_1 - 1 ? (parts.push(separator_1 + (multiLine ? `

` : `
`)), allowBreak_1 = !multiLine) : (len_1 !== 1 && isTypeAnnotation_1 || !oneLine_1 && util2.isTrailingCommaEnabled(options2, "objects") && childPath.getValue().type !== "RestElement") && parts.push(separator_1), i_1++;
          }, field);
        }), n.inexact) {
          var line3 = (0, lines_1.fromString)("...", options2);
          oneLine_1 ? (len_1 > 0 && parts.push(separator_1, " "), parts.push(line3)) : parts.push(`
`, line3.indent(options2.tabWidth));
        }
        return parts.push(oneLine_1 ? rightBrace : `
` + rightBrace), i_1 !== 0 && oneLine_1 && options2.objectCurlySpacing && (parts[leftBraceIndex] = leftBrace + " ", parts[parts.length - 1] = " " + rightBrace), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "PropertyPattern":
        return (0, lines_1.concat)([
          path2.call(print, "key"),
          ": ",
          path2.call(print, "pattern")
        ]);
      case "ObjectProperty":
      // Babel 6
      case "Property": {
        if (n.method || n.kind === "get" || n.kind === "set")
          return printMethod(path2, options2, print);
        if (n.shorthand && n.value.type === "AssignmentPattern")
          return path2.call(print, "value");
        var key2 = path2.call(print, "key");
        return n.computed ? parts.push("[", key2, "]") : parts.push(key2), (!n.shorthand || n.key.name !== n.value.name) && parts.push(": ", path2.call(print, "value")), (0, lines_1.concat)(parts);
      }
      case "ClassMethod":
      // Babel 6
      case "ObjectMethod":
      // Babel 6
      case "ClassPrivateMethod":
      case "TSDeclareMethod":
        return printMethod(path2, options2, print);
      case "PrivateName":
        return (0, lines_1.concat)(["#", path2.call(print, "id")]);
      case "Decorator":
        return (0, lines_1.concat)(["@", path2.call(print, "expression")]);
      case "TupleExpression":
        parts.push("#");
      // Intentionally fall through to printing the tuple elements...
      case "ArrayExpression":
      case "ArrayPattern": {
        var elems = n.elements, len_2 = elems.length, printed_1 = path2.map(print, "elements"), joined = (0, lines_1.fromString)(", ").join(printed_1), oneLine_2 = joined.getLineLength(1) <= options2.wrapColumn;
        return oneLine_2 ? options2.arrayBracketSpacing ? parts.push("[ ") : parts.push("[") : parts.push(`[
`), path2.each(function(elemPath) {
          var i = elemPath.getName(), elem = elemPath.getValue();
          if (!elem)
            parts.push(",");
          else {
            var lines3 = printed_1[i];
            oneLine_2 ? i > 0 && parts.push(" ") : lines3 = lines3.indent(options2.tabWidth), parts.push(lines3), (i < len_2 - 1 || !oneLine_2 && util2.isTrailingCommaEnabled(options2, "arrays")) && parts.push(","), oneLine_2 || parts.push(`
`);
          }
        }, "elements"), oneLine_2 && options2.arrayBracketSpacing ? parts.push(" ]") : parts.push("]"), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "SequenceExpression":
        return (0, lines_1.fromString)(", ").join(path2.map(print, "expressions"));
      case "ThisExpression":
        return (0, lines_1.fromString)("this");
      case "Super":
        return (0, lines_1.fromString)("super");
      case "NullLiteral":
        return (0, lines_1.fromString)("null");
      case "RegExpLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || "/".concat(n.pattern, "/").concat(n.flags || ""), options2);
      case "BigIntLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "n", options2);
      case "NumericLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || n.value, options2);
      case "DecimalLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "m", options2);
      case "StringLiteral":
        return (0, lines_1.fromString)(nodeStr(n.value, options2));
      case "BooleanLiteral":
      // Babel 6 Literal split
      case "Literal":
        return (0, lines_1.fromString)(getPossibleRaw(n) || (typeof n.value == "string" ? nodeStr(n.value, options2) : n.value), options2);
      case "Directive":
        return path2.call(print, "value");
      case "DirectiveLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || nodeStr(n.value, options2), options2);
      case "InterpreterDirective":
        return (0, lines_1.fromString)("#!".concat(n.value, `
`), options2);
      case "ModuleSpecifier":
        if (n.local)
          throw new Error("The ESTree ModuleSpecifier type should be abstract");
        return (0, lines_1.fromString)(nodeStr(n.value, options2), options2);
      case "UnaryExpression":
        return parts.push(n.operator), /[a-z]$/.test(n.operator) && parts.push(" "), parts.push(path2.call(print, "argument")), (0, lines_1.concat)(parts);
      case "UpdateExpression":
        return parts.push(path2.call(print, "argument"), n.operator), n.prefix && parts.reverse(), (0, lines_1.concat)(parts);
      case "ConditionalExpression":
        return (0, lines_1.concat)([
          path2.call(print, "test"),
          " ? ",
          path2.call(print, "consequent"),
          " : ",
          path2.call(print, "alternate")
        ]);
      case "NewExpression": {
        parts.push("new ", path2.call(print, "callee")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), n.typeArguments && parts.push(path2.call(print, "typeArguments"));
        var args = n.arguments;
        return args && parts.push(printArgumentsList(path2, options2, print)), (0, lines_1.concat)(parts);
      }
      case "VariableDeclaration": {
        n.declare && parts.push("declare "), parts.push(n.kind, " ");
        var maxLen_1 = 0, printed = path2.map(function(childPath) {
          var lines3 = print(childPath);
          return maxLen_1 = Math.max(lines3.length, maxLen_1), lines3;
        }, "declarations");
        maxLen_1 === 1 ? parts.push((0, lines_1.fromString)(", ").join(printed)) : printed.length > 1 ? parts.push((0, lines_1.fromString)(`,
`).join(printed).indentTail(n.kind.length + 1)) : parts.push(printed[0]);
        var parentNode = path2.getParentNode();
        return !namedTypes2.ForStatement.check(parentNode) && !namedTypes2.ForInStatement.check(parentNode) && !(namedTypes2.ForOfStatement && namedTypes2.ForOfStatement.check(parentNode)) && !(namedTypes2.ForAwaitStatement && namedTypes2.ForAwaitStatement.check(parentNode)) && parts.push(";"), (0, lines_1.concat)(parts);
      }
      case "VariableDeclarator":
        return n.init ? (0, lines_1.fromString)(" = ").join([
          path2.call(print, "id"),
          path2.call(print, "init")
        ]) : path2.call(print, "id");
      case "WithStatement":
        return (0, lines_1.concat)([
          "with (",
          path2.call(print, "object"),
          ") ",
          path2.call(print, "body")
        ]);
      case "IfStatement": {
        var con = adjustClause(path2.call(print, "consequent"), options2);
        return parts.push("if (", path2.call(print, "test"), ")", con), n.alternate && parts.push(endsWithBrace(con) ? " else" : `
else`, adjustClause(path2.call(print, "alternate"), options2)), (0, lines_1.concat)(parts);
      }
      case "ForStatement": {
        var init = path2.call(print, "init"), sep2 = init.length > 1 ? `;
` : "; ", forParen = "for (", indented = (0, lines_1.fromString)(sep2).join([init, path2.call(print, "test"), path2.call(print, "update")]).indentTail(forParen.length), head = (0, lines_1.concat)([forParen, indented, ")"]), clause = adjustClause(path2.call(print, "body"), options2);
        return parts.push(head), head.length > 1 && (parts.push(`
`), clause = clause.trimLeft()), parts.push(clause), (0, lines_1.concat)(parts);
      }
      case "WhileStatement":
        return (0, lines_1.concat)([
          "while (",
          path2.call(print, "test"),
          ")",
          adjustClause(path2.call(print, "body"), options2)
        ]);
      case "ForInStatement":
        return (0, lines_1.concat)([
          n.each ? "for each (" : "for (",
          path2.call(print, "left"),
          " in ",
          path2.call(print, "right"),
          ")",
          adjustClause(path2.call(print, "body"), options2)
        ]);
      case "ForOfStatement":
      case "ForAwaitStatement":
        return parts.push("for "), (n.await || n.type === "ForAwaitStatement") && parts.push("await "), parts.push("(", path2.call(print, "left"), " of ", path2.call(print, "right"), ")", adjustClause(path2.call(print, "body"), options2)), (0, lines_1.concat)(parts);
      case "DoWhileStatement": {
        var doBody = (0, lines_1.concat)([
          "do",
          adjustClause(path2.call(print, "body"), options2)
        ]);
        return parts.push(doBody), endsWithBrace(doBody) ? parts.push(" while") : parts.push(`
while`), parts.push(" (", path2.call(print, "test"), ");"), (0, lines_1.concat)(parts);
      }
      case "DoExpression": {
        var statements = path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body");
        return (0, lines_1.concat)([`do {
`, statements.indent(options2.tabWidth), `
}`]);
      }
      case "BreakStatement":
        return parts.push("break"), n.label && parts.push(" ", path2.call(print, "label")), parts.push(";"), (0, lines_1.concat)(parts);
      case "ContinueStatement":
        return parts.push("continue"), n.label && parts.push(" ", path2.call(print, "label")), parts.push(";"), (0, lines_1.concat)(parts);
      case "LabeledStatement":
        return (0, lines_1.concat)([
          path2.call(print, "label"),
          `:
`,
          path2.call(print, "body")
        ]);
      case "TryStatement":
        return parts.push("try ", path2.call(print, "block")), n.handler ? parts.push(" ", path2.call(print, "handler")) : n.handlers && path2.each(function(handlerPath) {
          parts.push(" ", print(handlerPath));
        }, "handlers"), n.finalizer && parts.push(" finally ", path2.call(print, "finalizer")), (0, lines_1.concat)(parts);
      case "CatchClause":
        return parts.push("catch "), n.param && parts.push("(", path2.call(print, "param")), n.guard && parts.push(" if ", path2.call(print, "guard")), n.param && parts.push(") "), parts.push(path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "ThrowStatement":
        return (0, lines_1.concat)(["throw ", path2.call(print, "argument"), ";"]);
      case "SwitchStatement":
        return (0, lines_1.concat)([
          "switch (",
          path2.call(print, "discriminant"),
          `) {
`,
          (0, lines_1.fromString)(`
`).join(path2.map(print, "cases")),
          `
}`
        ]);
      // Note: ignoring n.lexical because it has no printing consequences.
      case "SwitchCase":
        return n.test ? parts.push("case ", path2.call(print, "test"), ":") : parts.push("default:"), n.consequent.length > 0 && parts.push(`
`, path2.call(function(consequentPath) {
          return printStatementSequence(consequentPath, options2, print);
        }, "consequent").indent(options2.tabWidth)), (0, lines_1.concat)(parts);
      case "DebuggerStatement":
        return (0, lines_1.fromString)("debugger;");
      // JSX extensions below.
      case "JSXAttribute":
        return parts.push(path2.call(print, "name")), n.value && parts.push("=", path2.call(print, "value")), (0, lines_1.concat)(parts);
      case "JSXIdentifier":
        return (0, lines_1.fromString)(n.name, options2);
      case "JSXNamespacedName":
        return (0, lines_1.fromString)(":").join([
          path2.call(print, "namespace"),
          path2.call(print, "name")
        ]);
      case "JSXMemberExpression":
        return (0, lines_1.fromString)(".").join([
          path2.call(print, "object"),
          path2.call(print, "property")
        ]);
      case "JSXSpreadAttribute":
        return (0, lines_1.concat)(["{...", path2.call(print, "argument"), "}"]);
      case "JSXSpreadChild":
        return (0, lines_1.concat)(["{...", path2.call(print, "expression"), "}"]);
      case "JSXExpressionContainer":
        return (0, lines_1.concat)(["{", path2.call(print, "expression"), "}"]);
      case "JSXElement":
      case "JSXFragment": {
        var openingPropName = "opening" + (n.type === "JSXElement" ? "Element" : "Fragment"), closingPropName = "closing" + (n.type === "JSXElement" ? "Element" : "Fragment"), openingLines = path2.call(print, openingPropName);
        if (n[openingPropName].selfClosing)
          return (0, tiny_invariant_1.default)(!n[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n.type), openingLines;
        var childLines = (0, lines_1.concat)(path2.map(function(childPath) {
          var child = childPath.getValue();
          if (namedTypes2.Literal.check(child) && typeof child.value == "string") {
            if (/\S/.test(child.value))
              return child.value.replace(/^\s+/g, "");
            if (/\n/.test(child.value))
              return `
`;
          }
          return print(childPath);
        }, "children")).indentTail(options2.tabWidth), closingLines = path2.call(print, closingPropName);
        return (0, lines_1.concat)([openingLines, childLines, closingLines]);
      }
      case "JSXOpeningElement": {
        parts.push("<", path2.call(print, "name"));
        var typeDefPart = path2.call(print, "typeParameters");
        typeDefPart.length && parts.push(typeDefPart);
        var attrParts_1 = [];
        path2.each(function(attrPath) {
          attrParts_1.push(" ", print(attrPath));
        }, "attributes");
        var attrLines = (0, lines_1.concat)(attrParts_1), needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options2.wrapColumn;
        return needLineWrap && (attrParts_1.forEach(function(part, i) {
          part === " " && ((0, tiny_invariant_1.default)(i % 2 === 0), attrParts_1[i] = `
`);
        }), attrLines = (0, lines_1.concat)(attrParts_1).indentTail(options2.tabWidth)), parts.push(attrLines, n.selfClosing ? " />" : ">"), (0, lines_1.concat)(parts);
      }
      case "JSXClosingElement":
        return (0, lines_1.concat)(["</", path2.call(print, "name"), ">"]);
      case "JSXOpeningFragment":
        return (0, lines_1.fromString)("<>");
      case "JSXClosingFragment":
        return (0, lines_1.fromString)("</>");
      case "JSXText":
        return (0, lines_1.fromString)(n.value, options2);
      case "JSXEmptyExpression":
        return (0, lines_1.fromString)("");
      case "TypeAnnotatedIdentifier":
        return (0, lines_1.concat)([
          path2.call(print, "annotation"),
          " ",
          path2.call(print, "identifier")
        ]);
      case "ClassBody":
        return n.body.length === 0 ? (0, lines_1.fromString)("{}") : (0, lines_1.concat)([
          `{
`,
          path2.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options2, print);
          }, "body").indent(options2.tabWidth),
          `
}`
        ]);
      case "ClassPropertyDefinition":
        return parts.push("static ", path2.call(print, "definition")), namedTypes2.MethodDefinition.check(n.definition) || parts.push(";"), (0, lines_1.concat)(parts);
      case "ClassProperty": {
        n.declare && parts.push("declare ");
        var access = n.accessibility || n.access;
        typeof access == "string" && parts.push(access, " "), n.static && parts.push("static "), n.abstract && parts.push("abstract "), n.readonly && parts.push("readonly ");
        var key2 = path2.call(print, "key");
        return n.computed && (key2 = (0, lines_1.concat)(["[", key2, "]"])), n.variance && (key2 = (0, lines_1.concat)([printVariance(path2, print), key2])), parts.push(key2), n.optional && parts.push("?"), n.definite && parts.push("!"), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), n.value && parts.push(" = ", path2.call(print, "value")), parts.push(";"), (0, lines_1.concat)(parts);
      }
      case "ClassPrivateProperty":
        return n.static && parts.push("static "), parts.push(path2.call(print, "key")), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), n.value && parts.push(" = ", path2.call(print, "value")), parts.push(";"), (0, lines_1.concat)(parts);
      case "ClassAccessorProperty":
        return parts.push.apply(parts, tslib_1.__spreadArray(tslib_1.__spreadArray([], printClassMemberModifiers(n), !1), ["accessor "], !1)), n.computed ? parts.push("[", path2.call(print, "key"), "]") : parts.push(path2.call(print, "key")), n.optional && parts.push("?"), n.definite && parts.push("!"), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), n.value && parts.push(" = ", path2.call(print, "value")), parts.push(";"), (0, lines_1.concat)(parts);
      case "ClassDeclaration":
      case "ClassExpression":
      case "DeclareClass":
        return n.declare && parts.push("declare "), n.abstract && parts.push("abstract "), parts.push("class"), n.id && parts.push(" ", path2.call(print, "id")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), n.superClass && parts.push(" extends ", path2.call(print, "superClass"), path2.call(print, "superTypeParameters")), n.extends && n.extends.length > 0 && parts.push(" extends ", (0, lines_1.fromString)(", ").join(path2.map(print, "extends"))), n.implements && n.implements.length > 0 && parts.push(" implements ", (0, lines_1.fromString)(", ").join(path2.map(print, "implements"))), parts.push(" ", path2.call(print, "body")), n.type === "DeclareClass" ? printFlowDeclaration(path2, parts) : (0, lines_1.concat)(parts);
      case "TemplateElement":
        return (0, lines_1.fromString)(n.value.raw, options2).lockIndentTail();
      case "TemplateLiteral": {
        var expressions_1 = path2.map(print, "expressions");
        return parts.push("`"), path2.each(function(childPath) {
          var i = childPath.getName();
          parts.push(print(childPath)), i < expressions_1.length && parts.push("${", expressions_1[i], "}");
        }, "quasis"), parts.push("`"), (0, lines_1.concat)(parts).lockIndentTail();
      }
      case "TaggedTemplateExpression":
        return (0, lines_1.concat)([path2.call(print, "tag"), path2.call(print, "quasi")]);
      // These types are unprintable because they serve as abstract
      // supertypes for other (printable) types.
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      // Supertype of Block and Line
      case "Flow":
      // Supertype of all Flow AST node types
      case "FlowType":
      // Supertype of all Flow types
      case "FlowPredicate":
      // Supertype of InferredPredicate and DeclaredPredicate
      case "MemberTypeAnnotation":
      // Flow
      case "Type":
      // Flow
      case "TSHasOptionalTypeParameterInstantiation":
      case "TSHasOptionalTypeParameters":
      case "TSHasOptionalTypeAnnotation":
      case "ChainElement":
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      case "CommentBlock":
      // Babel block comment.
      case "Block":
        return (0, lines_1.concat)(["/*", (0, lines_1.fromString)(n.value, options2), "*/"]);
      case "CommentLine":
      // Babel line comment.
      case "Line":
        return (0, lines_1.concat)(["//", (0, lines_1.fromString)(n.value, options2)]);
      // Type Annotations for Facebook Flow, typically stripped out or
      // transformed away before printing.
      case "TypeAnnotation":
        return n.typeAnnotation ? (n.typeAnnotation.type !== "FunctionTypeAnnotation" && parts.push(": "), parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts)) : (0, lines_1.fromString)("");
      case "ExistentialTypeParam":
      case "ExistsTypeAnnotation":
        return (0, lines_1.fromString)("*", options2);
      case "EmptyTypeAnnotation":
        return (0, lines_1.fromString)("empty", options2);
      case "AnyTypeAnnotation":
        return (0, lines_1.fromString)("any", options2);
      case "MixedTypeAnnotation":
        return (0, lines_1.fromString)("mixed", options2);
      case "ArrayTypeAnnotation":
        return (0, lines_1.concat)([path2.call(print, "elementType"), "[]"]);
      case "TupleTypeAnnotation": {
        var printed_2 = path2.map(print, "types"), joined = (0, lines_1.fromString)(", ").join(printed_2), oneLine_3 = joined.getLineLength(1) <= options2.wrapColumn;
        return oneLine_3 ? options2.arrayBracketSpacing ? parts.push("[ ") : parts.push("[") : parts.push(`[
`), path2.each(function(elemPath) {
          var i = elemPath.getName(), elem = elemPath.getValue();
          if (!elem)
            parts.push(",");
          else {
            var lines3 = printed_2[i];
            oneLine_3 ? i > 0 && parts.push(" ") : lines3 = lines3.indent(options2.tabWidth), parts.push(lines3), (i < n.types.length - 1 || !oneLine_3 && util2.isTrailingCommaEnabled(options2, "arrays")) && parts.push(","), oneLine_3 || parts.push(`
`);
          }
        }, "types"), oneLine_3 && options2.arrayBracketSpacing ? parts.push(" ]") : parts.push("]"), (0, lines_1.concat)(parts);
      }
      case "BooleanTypeAnnotation":
        return (0, lines_1.fromString)("boolean", options2);
      case "BooleanLiteralTypeAnnotation":
        return (0, tiny_invariant_1.default)(typeof n.value == "boolean"), (0, lines_1.fromString)("" + n.value, options2);
      case "InterfaceTypeAnnotation":
        return parts.push("interface"), n.extends && n.extends.length > 0 && parts.push(" extends ", (0, lines_1.fromString)(", ").join(path2.map(print, "extends"))), parts.push(" ", path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "DeclareFunction":
        return printFlowDeclaration(path2, [
          "function ",
          path2.call(print, "id"),
          ";"
        ]);
      case "DeclareModule":
        return printFlowDeclaration(path2, [
          "module ",
          path2.call(print, "id"),
          " ",
          path2.call(print, "body")
        ]);
      case "DeclareModuleExports":
        return printFlowDeclaration(path2, [
          "module.exports",
          path2.call(print, "typeAnnotation")
        ]);
      case "DeclareVariable":
        return printFlowDeclaration(path2, ["var ", path2.call(print, "id"), ";"]);
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
        return (0, lines_1.concat)(["declare ", printExportDeclaration(path2, options2, print)]);
      case "EnumDeclaration":
        return (0, lines_1.concat)([
          "enum ",
          path2.call(print, "id"),
          path2.call(print, "body")
        ]);
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        return (n.type === "EnumSymbolBody" || n.explicitType) && parts.push(
          " of ",
          // EnumBooleanBody => boolean, etc.
          n.type.slice(4, -4).toLowerCase()
        ), parts.push(` {
`, (0, lines_1.fromString)(`
`).join(path2.map(print, "members")).indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts);
      case "EnumDefaultedMember":
        return (0, lines_1.concat)([path2.call(print, "id"), ","]);
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return (0, lines_1.concat)([
          path2.call(print, "id"),
          " = ",
          path2.call(print, "init"),
          ","
        ]);
      case "InferredPredicate":
        return (0, lines_1.fromString)("%checks", options2);
      case "DeclaredPredicate":
        return (0, lines_1.concat)(["%checks(", path2.call(print, "value"), ")"]);
      case "FunctionTypeAnnotation": {
        var parent = path2.getParentNode(0), isArrowFunctionTypeAnnotation = !(namedTypes2.ObjectTypeCallProperty.check(parent) || namedTypes2.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes2.DeclareFunction.check(path2.getParentNode(2))), needsColon = isArrowFunctionTypeAnnotation && !namedTypes2.FunctionTypeParam.check(parent) && !namedTypes2.TypeAlias.check(parent);
        needsColon && parts.push(": ");
        var hasTypeParameters = !!n.typeParameters, needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;
        return parts.push(hasTypeParameters ? path2.call(print, "typeParameters") : "", needsParens ? "(" : "", printFunctionParams(path2, options2, print), needsParens ? ")" : ""), n.returnType && parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path2.call(print, "returnType")), (0, lines_1.concat)(parts);
      }
      case "FunctionTypeParam": {
        var name = path2.call(print, "name");
        return parts.push(name), n.optional && parts.push("?"), name.infos[0].line && parts.push(": "), parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "GenericTypeAnnotation":
        return (0, lines_1.concat)([
          path2.call(print, "id"),
          path2.call(print, "typeParameters")
        ]);
      case "DeclareInterface":
        parts.push("declare ");
      // Fall through to InterfaceDeclaration...
      case "InterfaceDeclaration":
      case "TSInterfaceDeclaration":
        return n.declare && parts.push("declare "), parts.push("interface ", path2.call(print, "id"), path2.call(print, "typeParameters"), " "), n.extends && n.extends.length > 0 && parts.push("extends ", (0, lines_1.fromString)(", ").join(path2.map(print, "extends")), " "), n.body && parts.push(path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "ClassImplements":
      case "InterfaceExtends":
        return (0, lines_1.concat)([
          path2.call(print, "id"),
          path2.call(print, "typeParameters")
        ]);
      case "IntersectionTypeAnnotation":
        return (0, lines_1.fromString)(" & ").join(path2.map(print, "types"));
      case "NullableTypeAnnotation":
        return (0, lines_1.concat)(["?", path2.call(print, "typeAnnotation")]);
      case "NullLiteralTypeAnnotation":
        return (0, lines_1.fromString)("null", options2);
      case "ThisTypeAnnotation":
        return (0, lines_1.fromString)("this", options2);
      case "NumberTypeAnnotation":
        return (0, lines_1.fromString)("number", options2);
      case "ObjectTypeCallProperty":
        return path2.call(print, "value");
      case "ObjectTypeIndexer":
        return n.static && parts.push("static "), parts.push(printVariance(path2, print), "["), n.id && parts.push(path2.call(print, "id"), ": "), parts.push(path2.call(print, "key"), "]: ", path2.call(print, "value")), (0, lines_1.concat)(parts);
      case "ObjectTypeProperty":
        return (0, lines_1.concat)([
          printVariance(path2, print),
          path2.call(print, "key"),
          n.optional ? "?" : "",
          ": ",
          path2.call(print, "value")
        ]);
      case "ObjectTypeInternalSlot":
        return (0, lines_1.concat)([
          n.static ? "static " : "",
          "[[",
          path2.call(print, "id"),
          "]]",
          n.optional ? "?" : "",
          n.value.type !== "FunctionTypeAnnotation" ? ": " : "",
          path2.call(print, "value")
        ]);
      case "QualifiedTypeIdentifier":
        return (0, lines_1.concat)([
          path2.call(print, "qualification"),
          ".",
          path2.call(print, "id")
        ]);
      case "StringLiteralTypeAnnotation":
        return (0, lines_1.fromString)(nodeStr(n.value, options2), options2);
      case "NumberLiteralTypeAnnotation":
      case "NumericLiteralTypeAnnotation":
        return (0, tiny_invariant_1.default)(typeof n.value == "number"), (0, lines_1.fromString)(JSON.stringify(n.value), options2);
      case "BigIntLiteralTypeAnnotation":
        return (0, lines_1.fromString)(n.raw, options2);
      case "StringTypeAnnotation":
        return (0, lines_1.fromString)("string", options2);
      case "DeclareTypeAlias":
        parts.push("declare ");
      // Fall through to TypeAlias...
      case "TypeAlias":
        return (0, lines_1.concat)([
          "type ",
          path2.call(print, "id"),
          path2.call(print, "typeParameters"),
          " = ",
          path2.call(print, "right"),
          ";"
        ]);
      case "DeclareOpaqueType":
        parts.push("declare ");
      // Fall through to OpaqueType...
      case "OpaqueType":
        return parts.push("opaque type ", path2.call(print, "id"), path2.call(print, "typeParameters")), n.supertype && parts.push(": ", path2.call(print, "supertype")), n.impltype && parts.push(" = ", path2.call(print, "impltype")), parts.push(";"), (0, lines_1.concat)(parts);
      case "TypeCastExpression":
        return (0, lines_1.concat)([
          "(",
          path2.call(print, "expression"),
          path2.call(print, "typeAnnotation"),
          ")"
        ]);
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
        return (0, lines_1.concat)([
          "<",
          (0, lines_1.fromString)(", ").join(path2.map(print, "params")),
          ">"
        ]);
      case "Variance":
        return n.kind === "plus" ? (0, lines_1.fromString)("+") : n.kind === "minus" ? (0, lines_1.fromString)("-") : (0, lines_1.fromString)("");
      case "TypeParameter":
        return n.variance && parts.push(printVariance(path2, print)), parts.push(path2.call(print, "name")), n.bound && parts.push(path2.call(print, "bound")), n.default && parts.push("=", path2.call(print, "default")), (0, lines_1.concat)(parts);
      case "TypeofTypeAnnotation":
        return (0, lines_1.concat)([
          (0, lines_1.fromString)("typeof ", options2),
          path2.call(print, "argument")
        ]);
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return (0, lines_1.concat)([
          path2.call(print, "objectType"),
          n.optional ? "?." : "",
          "[",
          path2.call(print, "indexType"),
          "]"
        ]);
      case "UnionTypeAnnotation":
        return (0, lines_1.fromString)(" | ").join(path2.map(print, "types"));
      case "VoidTypeAnnotation":
        return (0, lines_1.fromString)("void", options2);
      case "NullTypeAnnotation":
        return (0, lines_1.fromString)("null", options2);
      case "SymbolTypeAnnotation":
        return (0, lines_1.fromString)("symbol", options2);
      case "BigIntTypeAnnotation":
        return (0, lines_1.fromString)("bigint", options2);
      // Type Annotations for TypeScript (when using Babylon as parser)
      case "TSType":
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      case "TSNumberKeyword":
        return (0, lines_1.fromString)("number", options2);
      case "TSBigIntKeyword":
        return (0, lines_1.fromString)("bigint", options2);
      case "TSObjectKeyword":
        return (0, lines_1.fromString)("object", options2);
      case "TSBooleanKeyword":
        return (0, lines_1.fromString)("boolean", options2);
      case "TSStringKeyword":
        return (0, lines_1.fromString)("string", options2);
      case "TSSymbolKeyword":
        return (0, lines_1.fromString)("symbol", options2);
      case "TSAnyKeyword":
        return (0, lines_1.fromString)("any", options2);
      case "TSVoidKeyword":
        return (0, lines_1.fromString)("void", options2);
      case "TSIntrinsicKeyword":
        return (0, lines_1.fromString)("intrinsic", options2);
      case "TSThisType":
        return (0, lines_1.fromString)("this", options2);
      case "TSNullKeyword":
        return (0, lines_1.fromString)("null", options2);
      case "TSUndefinedKeyword":
        return (0, lines_1.fromString)("undefined", options2);
      case "TSUnknownKeyword":
        return (0, lines_1.fromString)("unknown", options2);
      case "TSNeverKeyword":
        return (0, lines_1.fromString)("never", options2);
      case "TSArrayType":
        return (0, lines_1.concat)([path2.call(print, "elementType"), "[]"]);
      case "TSLiteralType":
        return path2.call(print, "literal");
      case "TSUnionType":
        return (0, lines_1.fromString)(" | ").join(path2.map(print, "types"));
      case "TSIntersectionType":
        return (0, lines_1.fromString)(" & ").join(path2.map(print, "types"));
      case "TSConditionalType":
        return parts.push(path2.call(print, "checkType"), " extends ", path2.call(print, "extendsType"), " ? ", path2.call(print, "trueType"), " : ", path2.call(print, "falseType")), (0, lines_1.concat)(parts);
      case "TSInferType":
        return parts.push("infer ", path2.call(print, "typeParameter")), (0, lines_1.concat)(parts);
      case "TSParenthesizedType":
        return (0, lines_1.concat)(["(", path2.call(print, "typeAnnotation"), ")"]);
      case "TSFunctionType":
        return (0, lines_1.concat)([
          path2.call(print, "typeParameters"),
          "(",
          printFunctionParams(path2, options2, print),
          ") => ",
          path2.call(print, "typeAnnotation", "typeAnnotation")
        ]);
      case "TSConstructorType":
        return (0, lines_1.concat)([
          "new ",
          path2.call(print, "typeParameters"),
          "(",
          printFunctionParams(path2, options2, print),
          ") => ",
          path2.call(print, "typeAnnotation", "typeAnnotation")
        ]);
      case "TSMappedType":
        return parts.push(n.readonly ? "readonly " : "", "[", path2.call(print, "typeParameter"), "]", n.optional ? "?" : ""), n.typeAnnotation && parts.push(": ", path2.call(print, "typeAnnotation"), ";"), (0, lines_1.concat)([`{
`, (0, lines_1.concat)(parts).indent(options2.tabWidth), `
}`]);
      case "TSTupleType":
        return (0, lines_1.concat)([
          "[",
          (0, lines_1.fromString)(", ").join(path2.map(print, "elementTypes")),
          "]"
        ]);
      case "TSNamedTupleMember":
        return parts.push(path2.call(print, "label")), n.optional && parts.push("?"), parts.push(": ", path2.call(print, "elementType")), (0, lines_1.concat)(parts);
      case "TSRestType":
        return (0, lines_1.concat)(["...", path2.call(print, "typeAnnotation")]);
      case "TSOptionalType":
        return (0, lines_1.concat)([path2.call(print, "typeAnnotation"), "?"]);
      case "TSIndexedAccessType":
        return (0, lines_1.concat)([
          path2.call(print, "objectType"),
          "[",
          path2.call(print, "indexType"),
          "]"
        ]);
      case "TSTypeOperator":
        return (0, lines_1.concat)([
          path2.call(print, "operator"),
          " ",
          path2.call(print, "typeAnnotation")
        ]);
      case "TSTypeLiteral": {
        var members = (0, lines_1.fromString)(`
`).join(path2.map(print, "members").map(function(member) {
          return lastNonSpaceCharacter(member) !== ";" ? member.concat(";") : member;
        }));
        return members.isEmpty() ? (0, lines_1.fromString)("{}", options2) : (parts.push(`{
`, members.indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts));
      }
      case "TSEnumMember":
        return parts.push(path2.call(print, "id")), n.initializer && parts.push(" = ", path2.call(print, "initializer")), (0, lines_1.concat)(parts);
      case "TSTypeQuery":
        return (0, lines_1.concat)(["typeof ", path2.call(print, "exprName")]);
      case "TSParameterProperty":
        return n.accessibility && parts.push(n.accessibility, " "), n.export && parts.push("export "), n.static && parts.push("static "), n.readonly && parts.push("readonly "), parts.push(path2.call(print, "parameter")), (0, lines_1.concat)(parts);
      case "TSTypeReference":
        return (0, lines_1.concat)([
          path2.call(print, "typeName"),
          path2.call(print, "typeParameters")
        ]);
      case "TSQualifiedName":
        return (0, lines_1.concat)([path2.call(print, "left"), ".", path2.call(print, "right")]);
      case "TSAsExpression":
      case "TSSatisfiesExpression": {
        var expression = path2.call(print, "expression");
        return parts.push(expression, n.type === "TSSatisfiesExpression" ? " satisfies " : " as ", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "TSTypeCastExpression":
        return (0, lines_1.concat)([
          path2.call(print, "expression"),
          path2.call(print, "typeAnnotation")
        ]);
      case "TSNonNullExpression":
        return (0, lines_1.concat)([path2.call(print, "expression"), "!"]);
      case "TSTypeAnnotation":
        return (0, lines_1.concat)([": ", path2.call(print, "typeAnnotation")]);
      case "TSIndexSignature":
        return (0, lines_1.concat)([
          n.readonly ? "readonly " : "",
          "[",
          path2.map(print, "parameters"),
          "]",
          path2.call(print, "typeAnnotation")
        ]);
      case "TSPropertySignature":
        return parts.push(printVariance(path2, print), n.readonly ? "readonly " : ""), n.computed ? parts.push("[", path2.call(print, "key"), "]") : parts.push(path2.call(print, "key")), parts.push(n.optional ? "?" : "", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSMethodSignature":
        return n.kind === "get" ? parts.push("get ") : n.kind === "set" && parts.push("set "), n.computed ? parts.push("[", path2.call(print, "key"), "]") : parts.push(path2.call(print, "key")), n.optional && parts.push("?"), parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSTypePredicate":
        return n.asserts && parts.push("asserts "), parts.push(path2.call(print, "parameterName")), n.typeAnnotation && parts.push(" is ", path2.call(print, "typeAnnotation", "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSCallSignatureDeclaration":
        return (0, lines_1.concat)([
          path2.call(print, "typeParameters"),
          "(",
          printFunctionParams(path2, options2, print),
          ")",
          path2.call(print, "typeAnnotation")
        ]);
      case "TSConstructSignatureDeclaration":
        return n.typeParameters ? parts.push("new", path2.call(print, "typeParameters")) : parts.push("new "), parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSTypeAliasDeclaration":
        return (0, lines_1.concat)([
          n.declare ? "declare " : "",
          "type ",
          path2.call(print, "id"),
          path2.call(print, "typeParameters"),
          " = ",
          path2.call(print, "typeAnnotation"),
          ";"
        ]);
      case "TSTypeParameter": {
        parts.push(path2.call(print, "name"));
        var parent = path2.getParentNode(0), isInMappedType = namedTypes2.TSMappedType.check(parent);
        return n.constraint && parts.push(isInMappedType ? " in " : " extends ", path2.call(print, "constraint")), n.default && parts.push(" = ", path2.call(print, "default")), (0, lines_1.concat)(parts);
      }
      case "TSTypeAssertion":
        return parts.push("<", path2.call(print, "typeAnnotation"), "> ", path2.call(print, "expression")), (0, lines_1.concat)(parts);
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return (0, lines_1.concat)([
          "<",
          (0, lines_1.fromString)(", ").join(path2.map(print, "params")),
          ">"
        ]);
      case "TSEnumDeclaration": {
        parts.push(n.declare ? "declare " : "", n.const ? "const " : "", "enum ", path2.call(print, "id"));
        var memberLines = (0, lines_1.fromString)(`,
`).join(path2.map(print, "members"));
        return memberLines.isEmpty() ? parts.push(" {}") : parts.push(` {
`, memberLines.indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts);
      }
      case "TSExpressionWithTypeArguments":
        return (0, lines_1.concat)([
          path2.call(print, "expression"),
          path2.call(print, "typeParameters")
        ]);
      case "TSInterfaceBody": {
        var lines2 = (0, lines_1.fromString)(`
`).join(path2.map(print, "body").map(function(element) {
          return lastNonSpaceCharacter(element) !== ";" ? element.concat(";") : element;
        }));
        return lines2.isEmpty() ? (0, lines_1.fromString)("{}", options2) : (0, lines_1.concat)([`{
`, lines2.indent(options2.tabWidth), `
}`]);
      }
      case "TSImportType":
        return parts.push("import(", path2.call(print, "argument"), ")"), n.qualifier && parts.push(".", path2.call(print, "qualifier")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), (0, lines_1.concat)(parts);
      case "TSImportEqualsDeclaration":
        return n.isExport && parts.push("export "), parts.push("import ", path2.call(print, "id"), " = ", path2.call(print, "moduleReference")), maybeAddSemicolon((0, lines_1.concat)(parts));
      case "TSExternalModuleReference":
        return (0, lines_1.concat)(["require(", path2.call(print, "expression"), ")"]);
      case "TSModuleDeclaration": {
        var parent = path2.getParentNode();
        if (parent.type === "TSModuleDeclaration")
          parts.push(".");
        else if (n.declare && parts.push("declare "), !n.global) {
          var isExternal = n.id.type === "StringLiteral" || n.id.type === "Literal" && typeof n.id.value == "string";
          if (isExternal)
            parts.push("module ");
          else if (n.loc && n.loc.lines && n.id.loc) {
            var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);
            prefix.indexOf("module") >= 0 ? parts.push("module ") : parts.push("namespace ");
          } else
            parts.push("namespace ");
        }
        return parts.push(path2.call(print, "id")), n.body && (parts.push(" "), parts.push(path2.call(print, "body"))), (0, lines_1.concat)(parts);
      }
      case "TSModuleBlock": {
        var naked = path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body");
        return naked.isEmpty() ? parts.push("{}") : parts.push(`{
`, naked.indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts);
      }
      case "TSInstantiationExpression":
        return parts.push(path2.call(print, "expression"), path2.call(print, "typeParameters")), (0, lines_1.concat)(parts);
      // https://github.com/babel/babel/pull/10148
      case "V8IntrinsicIdentifier":
        return (0, lines_1.concat)(["%", path2.call(print, "name")]);
      // https://github.com/babel/babel/pull/13191
      case "TopicReference":
        return (0, lines_1.fromString)("#");
      // Unhandled types below. If encountered, nodes of these types should
      // be either left alone or desugared into AST types that are fully
      // supported by the pretty-printer.
      case "ClassHeritage":
      // TODO
      case "ComprehensionBlock":
      // TODO
      case "ComprehensionExpression":
      // TODO
      case "Glob":
      // TODO
      case "GeneratorExpression":
      // TODO
      case "LetStatement":
      // TODO
      case "LetExpression":
      // TODO
      case "GraphExpression":
      // TODO
      case "GraphIndexExpression":
      // TODO
      case "XMLDefaultDeclaration":
      case "XMLAnyName":
      case "XMLQualifiedIdentifier":
      case "XMLFunctionQualifiedIdentifier":
      case "XMLAttributeSelector":
      case "XMLFilterExpression":
      case "XML":
      case "XMLElement":
      case "XMLList":
      case "XMLEscape":
      case "XMLText":
      case "XMLStartTag":
      case "XMLEndTag":
      case "XMLPointTag":
      case "XMLName":
      case "XMLAttribute":
      case "XMLCdata":
      case "XMLComment":
      case "XMLProcessingInstruction":
      default:
        debugger;
        throw new Error("unknown type: " + JSON.stringify(n.type));
    }
  }
  function printDecorators(path2, printPath) {
    var parts = [], node = path2.getValue();
    return node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration, it will be
    // responsible for printing node.decorators.
    !util2.getParentExportDeclaration(path2) ? path2.each(function(decoratorPath) {
      parts.push(printPath(decoratorPath), `
`);
    }, "decorators") : util2.isExportDeclaration(node) && node.declaration && node.declaration.decorators && path2.each(function(decoratorPath) {
      parts.push(printPath(decoratorPath), `
`);
    }, "declaration", "decorators"), (0, lines_1.concat)(parts);
  }
  function printStatementSequence(path2, options2, print) {
    var filtered = [], sawComment = !1, sawStatement = !1;
    path2.each(function(stmtPath) {
      var stmt = stmtPath.getValue();
      stmt && (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0) || (namedTypes2.Comment.check(stmt) ? sawComment = !0 : namedTypes2.Statement.check(stmt) ? sawStatement = !0 : isString.assert(stmt), filtered.push({
        node: stmt,
        printed: print(stmtPath)
      })));
    }), sawComment && (0, tiny_invariant_1.default)(sawStatement === !1, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
    var prevTrailingSpace = null, len = filtered.length, parts = [];
    return filtered.forEach(function(info, i) {
      var printed = info.printed, stmt = info.node, multiLine = printed.length > 1, notFirst = i > 0, notLast = i < len - 1, leadingSpace, trailingSpace, lines2 = stmt && stmt.loc && stmt.loc.lines, trueLoc = lines2 && options2.reuseWhitespace && util2.getTrueLoc(stmt, lines2);
      if (notFirst)
        if (trueLoc) {
          var beforeStart = lines2.skipSpaces(trueLoc.start, !0), beforeStartLine = beforeStart ? beforeStart.line : 1, leadingGap = trueLoc.start.line - beforeStartLine;
          leadingSpace = Array(leadingGap + 1).join(`
`);
        } else
          leadingSpace = multiLine ? `

` : `
`;
      else
        leadingSpace = "";
      if (notLast)
        if (trueLoc) {
          var afterEnd = lines2.skipSpaces(trueLoc.end), afterEndLine = afterEnd ? afterEnd.line : lines2.length, trailingGap = afterEndLine - trueLoc.end.line;
          trailingSpace = Array(trailingGap + 1).join(`
`);
        } else
          trailingSpace = multiLine ? `

` : `
`;
      else
        trailingSpace = "";
      parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed), notLast ? prevTrailingSpace = trailingSpace : trailingSpace && parts.push(trailingSpace);
    }), (0, lines_1.concat)(parts);
  }
  function maxSpace(s1, s2) {
    if (!s1 && !s2)
      return (0, lines_1.fromString)("");
    if (!s1)
      return (0, lines_1.fromString)(s2);
    if (!s2)
      return (0, lines_1.fromString)(s1);
    var spaceLines1 = (0, lines_1.fromString)(s1), spaceLines2 = (0, lines_1.fromString)(s2);
    return spaceLines2.length > spaceLines1.length ? spaceLines2 : spaceLines1;
  }
  function printClassMemberModifiers(node) {
    var parts = [];
    node.declare && parts.push("declare ");
    var access = node.accessibility || node.access;
    return typeof access == "string" && parts.push(access, " "), node.static && parts.push("static "), node.override && parts.push("override "), node.abstract && parts.push("abstract "), node.readonly && parts.push("readonly "), parts;
  }
  function printMethod(path2, options2, print) {
    var node = path2.getNode(), kind = node.kind, parts = [], nodeValue = node.value;
    namedTypes2.FunctionExpression.check(nodeValue) || (nodeValue = node), parts.push.apply(parts, printClassMemberModifiers(node)), nodeValue.async && parts.push("async "), nodeValue.generator && parts.push("*"), (kind === "get" || kind === "set") && parts.push(kind, " ");
    var key2 = path2.call(print, "key");
    return node.computed && (key2 = (0, lines_1.concat)(["[", key2, "]"])), parts.push(key2), node.optional && parts.push("?"), node === nodeValue ? (parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType")), node.body ? parts.push(" ", path2.call(print, "body")) : parts.push(";")) : (parts.push(path2.call(print, "value", "typeParameters"), "(", path2.call(function(valuePath) {
      return printFunctionParams(valuePath, options2, print);
    }, "value"), ")", path2.call(print, "value", "returnType")), nodeValue.body ? parts.push(" ", path2.call(print, "value", "body")) : parts.push(";")), (0, lines_1.concat)(parts);
  }
  function printArgumentsList(path2, options2, print) {
    var printed = path2.map(print, "arguments"), trailingComma = util2.isTrailingCommaEnabled(options2, "parameters"), joined = (0, lines_1.fromString)(", ").join(printed);
    return joined.getLineLength(1) > options2.wrapColumn ? (joined = (0, lines_1.fromString)(`,
`).join(printed), (0, lines_1.concat)([
      `(
`,
      joined.indent(options2.tabWidth),
      trailingComma ? `,
)` : `
)`
    ])) : (0, lines_1.concat)(["(", joined, ")"]);
  }
  function printFunctionParams(path2, options2, print) {
    var fun = path2.getValue(), params, printed = [];
    fun.params ? (params = fun.params, printed = path2.map(print, "params")) : fun.parameters && (params = fun.parameters, printed = path2.map(print, "parameters")), fun.defaults && path2.each(function(defExprPath) {
      var i = defExprPath.getName(), p = printed[i];
      p && defExprPath.getValue() && (printed[i] = (0, lines_1.concat)([p, " = ", print(defExprPath)]));
    }, "defaults"), fun.rest && printed.push((0, lines_1.concat)(["...", path2.call(print, "rest")]));
    var joined = (0, lines_1.fromString)(", ").join(printed);
    return joined.length > 1 || joined.getLineLength(1) > options2.wrapColumn ? (joined = (0, lines_1.fromString)(`,
`).join(printed), util2.isTrailingCommaEnabled(options2, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement" ? joined = (0, lines_1.concat)([joined, `,
`]) : joined = (0, lines_1.concat)([joined, `
`]), (0, lines_1.concat)([`
`, joined.indent(options2.tabWidth)])) : joined;
  }
  function maybePrintImportAssertions(path2, options2, print) {
    var n = path2.getValue();
    if (n.assertions && n.assertions.length > 0) {
      var parts = [" assert {"], printed = path2.map(print, "assertions"), flat = (0, lines_1.fromString)(", ").join(printed);
      return flat.length > 1 || flat.getLineLength(1) > options2.wrapColumn ? parts.push(`
`, (0, lines_1.fromString)(`,
`).join(printed).indent(options2.tabWidth), `
}`) : parts.push(" ", flat, " }"), (0, lines_1.concat)(parts);
    }
    return (0, lines_1.fromString)("");
  }
  function printExportDeclaration(path2, options2, print) {
    var decl = path2.getValue(), parts = ["export "];
    decl.exportKind && decl.exportKind === "type" && (decl.declaration || parts.push("type "));
    var shouldPrintSpaces = options2.objectCurlySpacing;
    if (namedTypes2.Declaration.assert(decl), (decl.default || decl.type === "ExportDefaultDeclaration") && parts.push("default "), decl.declaration)
      parts.push(path2.call(print, "declaration"));
    else if (decl.specifiers) {
      if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier")
        parts.push("*");
      else if (decl.specifiers.length === 0)
        parts.push("{}");
      else if (decl.specifiers[0].type === "ExportDefaultSpecifier" || decl.specifiers[0].type === "ExportNamespaceSpecifier") {
        var unbracedSpecifiers_2 = [], bracedSpecifiers_2 = [];
        if (path2.each(function(specifierPath) {
          var spec = specifierPath.getValue();
          spec.type === "ExportDefaultSpecifier" || spec.type === "ExportNamespaceSpecifier" ? unbracedSpecifiers_2.push(print(specifierPath)) : bracedSpecifiers_2.push(print(specifierPath));
        }, "specifiers"), unbracedSpecifiers_2.forEach(function(lines3, i) {
          i > 0 && parts.push(", "), parts.push(lines3);
        }), bracedSpecifiers_2.length > 0) {
          var lines_2 = (0, lines_1.fromString)(", ").join(bracedSpecifiers_2);
          lines_2.getLineLength(1) > options2.wrapColumn && (lines_2 = (0, lines_1.concat)([
            (0, lines_1.fromString)(`,
`).join(bracedSpecifiers_2).indent(options2.tabWidth),
            ","
          ])), unbracedSpecifiers_2.length > 0 && parts.push(", "), lines_2.length > 1 ? parts.push(`{
`, lines_2, `
}`) : options2.objectCurlySpacing ? parts.push("{ ", lines_2, " }") : parts.push("{", lines_2, "}");
        }
      } else
        parts.push(shouldPrintSpaces ? "{ " : "{", (0, lines_1.fromString)(", ").join(path2.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
      decl.source && parts.push(" from ", path2.call(print, "source"), maybePrintImportAssertions(path2, options2, print));
    }
    var lines2 = (0, lines_1.concat)(parts);
    return lastNonSpaceCharacter(lines2) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration")) && (lines2 = (0, lines_1.concat)([lines2, ";"])), lines2;
  }
  function printFlowDeclaration(path2, parts) {
    var parentExportDecl = util2.getParentExportDeclaration(path2);
    return parentExportDecl ? (0, tiny_invariant_1.default)(parentExportDecl.type === "DeclareExportDeclaration") : parts.unshift("declare "), (0, lines_1.concat)(parts);
  }
  function printVariance(path2, print) {
    return path2.call(function(variancePath) {
      var value = variancePath.getValue();
      return value ? value === "plus" ? (0, lines_1.fromString)("+") : value === "minus" ? (0, lines_1.fromString)("-") : print(variancePath) : (0, lines_1.fromString)("");
    }, "variance");
  }
  function adjustClause(clause, options2) {
    return clause.length > 1 ? (0, lines_1.concat)([" ", clause]) : (0, lines_1.concat)([`
`, maybeAddSemicolon(clause).indent(options2.tabWidth)]);
  }
  function lastNonSpaceCharacter(lines2) {
    var pos2 = lines2.lastPos();
    do {
      var ch = lines2.charAt(pos2);
      if (/\S/.test(ch))
        return ch;
    } while (lines2.prevPos(pos2));
  }
  function endsWithBrace(lines2) {
    return lastNonSpaceCharacter(lines2) === "}";
  }
  function swapQuotes(str2) {
    return str2.replace(/['"]/g, function(m) {
      return m === '"' ? "'" : '"';
    });
  }
  function getPossibleRaw(node) {
    var value = types2.getFieldValue(node, "value"), extra = types2.getFieldValue(node, "extra");
    if (extra && typeof extra.raw == "string" && value == extra.rawValue)
      return extra.raw;
    if (node.type === "Literal") {
      var raw = node.raw;
      if (typeof raw == "string" && value == raw)
        return raw;
    }
  }
  function jsSafeStringify(str2) {
    return JSON.stringify(str2).replace(/[\u2028\u2029]/g, function(m) {
      return "\\u" + m.charCodeAt(0).toString(16);
    });
  }
  function nodeStr(str2, options2) {
    switch (isString.assert(str2), options2.quote) {
      case "auto": {
        var double2 = jsSafeStringify(str2), single2 = swapQuotes(jsSafeStringify(swapQuotes(str2)));
        return double2.length > single2.length ? single2 : double2;
      }
      case "single":
        return swapQuotes(jsSafeStringify(swapQuotes(str2)));
      case "double":
      default:
        return jsSafeStringify(str2);
    }
  }
  function maybeAddSemicolon(lines2) {
    var eoc = lastNonSpaceCharacter(lines2);
    return !eoc || `
};`.indexOf(eoc) < 0 ? (0, lines_1.concat)([lines2, ";"]) : lines2;
  }
  return printer;
}
var hasRequiredMain$1;
function requireMain$1() {
  return hasRequiredMain$1 || (hasRequiredMain$1 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.run = exports2.prettyPrint = exports2.print = exports2.visit = exports2.types = exports2.parse = void 0;
    var tslib_1 = require$$0$3, fs_1 = tslib_1.__importDefault(require$$0__default$1.default), types2 = tslib_1.__importStar(requireMain$2());
    exports2.types = types2;
    var parser_1 = requireParser();
    Object.defineProperty(exports2, "parse", { enumerable: !0, get: function() {
      return parser_1.parse;
    } });
    var printer_1 = requirePrinter(), ast_types_1 = requireMain$2();
    Object.defineProperty(exports2, "visit", { enumerable: !0, get: function() {
      return ast_types_1.visit;
    } });
    function print(node, options2) {
      return new printer_1.Printer(options2).print(node);
    }
    exports2.print = print;
    function prettyPrint(node, options2) {
      return new printer_1.Printer(options2).printGenerically(node);
    }
    exports2.prettyPrint = prettyPrint;
    function run(transformer, options2) {
      return runFile(process.argv[2], transformer, options2);
    }
    exports2.run = run;
    function runFile(path2, transformer, options2) {
      fs_1.default.readFile(path2, "utf-8", function(err, code) {
        if (err) {
          console.error(err);
          return;
        }
        runString(code, transformer, options2);
      });
    }
    function defaultWriteback(output) {
      process.stdout.write(output);
    }
    function runString(code, transformer, options2) {
      var writeback = options2 && options2.writeback || defaultWriteback;
      transformer((0, parser_1.parse)(code, options2), function(node) {
        writeback(print(node, options2).code);
      });
    }
  }(main$2)), main$2;
}
var mainExports = requireMain$1(), typescript$1 = {}, babel = {}, _babel_options = {}, hasRequired_babel_options;
function require_babel_options() {
  if (hasRequired_babel_options) return _babel_options;
  hasRequired_babel_options = 1, Object.defineProperty(_babel_options, "__esModule", { value: !0 });
  var util_1 = requireUtil();
  function getBabelOptions(options2) {
    return {
      sourceType: (0, util_1.getOption)(options2, "sourceType", "module"),
      strictMode: (0, util_1.getOption)(options2, "strictMode", !1),
      allowImportExportEverywhere: !0,
      allowReturnOutsideFunction: !0,
      startLine: 1,
      tokens: !0,
      plugins: [
        "asyncGenerators",
        "bigInt",
        "classPrivateMethods",
        "classPrivateProperties",
        "classProperties",
        "classStaticBlock",
        "decimal",
        "decorators-legacy",
        "doExpressions",
        "dynamicImport",
        "exportDefaultFrom",
        "exportExtensions",
        "exportNamespaceFrom",
        "functionBind",
        "functionSent",
        "importAssertions",
        "importMeta",
        "nullishCoalescingOperator",
        "numericSeparator",
        "objectRestSpread",
        "optionalCatchBinding",
        "optionalChaining",
        [
          "pipelineOperator",
          {
            proposal: "minimal"
          }
        ],
        [
          "recordAndTuple",
          {
            syntaxType: "hash"
          }
        ],
        "throwExpressions",
        "topLevelAwait",
        "v8intrinsic"
      ]
    };
  }
  return _babel_options.default = getBabelOptions, _babel_options;
}
var lib$1 = {}, hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1, Object.defineProperty(lib$1, "__esModule", {
    value: !0
  });
  function _objectWithoutPropertiesLoose(r, e) {
    if (r == null) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  class Position {
    constructor(line3, col, index) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = line3, this.column = col, this.index = index;
    }
  }
  class SourceLocation {
    constructor(start, end) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = start, this.end = end;
    }
  }
  function createPositionWithColumnOffset(position, columnOffset) {
    const {
      line: line3,
      column: column2,
      index
    } = position;
    return new Position(line3, column2 + columnOffset, index + columnOffset);
  }
  const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var ModuleErrors = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code
    }
  };
  const NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
  var StandardErrors = {
    AccessorIsGenerator: ({
      kind
    }) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind
    }) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName
    }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: ({
      phase
    }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName,
      exportName
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type: type2
    }) => `'${type2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type: type2
    }) => `Unsyntactic ${type2 === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: ({
      importName
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix
    }) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord
    }) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({
      identifierName
    }) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({
      ancestor
    }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({
      ancestor
    }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor
    }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected
    }) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName
    }) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName
    }) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin
    }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key: key2
    }) => `Duplicate key "${key2}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode
    }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName
    }) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName
    }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName
    }) => `Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword
    }) => `Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord
    }) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected,
      unexpected
    }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target,
      onlyValidPropertyName
    }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName
    }) => `Identifier '${identifierName}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName
    }) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName
    }) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };
  const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var PipelineOperatorErrors = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token: token2
    }) => `Invalid topic token ${token2}. In order to use ${token2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token2}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type: type2
    }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
      type: type2
    })}; please wrap it in parentheses.`,
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  };
  const _excluded = ["message"];
  function defineHidden(obj, key2, value) {
    Object.defineProperty(obj, key2, {
      enumerable: !1,
      configurable: !0,
      value
    });
  }
  function toParseErrorConstructor({
    toMessage,
    code: code2,
    reasonCode,
    syntaxPlugin
  }) {
    const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
    {
      const oldReasonCodes = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      oldReasonCodes[reasonCode] && (reasonCode = oldReasonCodes[reasonCode]);
    }
    return function constructor(loc, details) {
      const error2 = new SyntaxError();
      return error2.code = code2, error2.reasonCode = reasonCode, error2.loc = loc, error2.pos = loc.index, error2.syntaxPlugin = syntaxPlugin, hasMissingPlugin && (error2.missingPlugin = details.missingPlugin), defineHidden(error2, "clone", function(overrides = {}) {
        var _overrides$loc;
        const {
          line: line3,
          column: column2,
          index
        } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
        return constructor(new Position(line3, column2, index), Object.assign({}, details, overrides.details));
      }), defineHidden(error2, "details", details), Object.defineProperty(error2, "message", {
        configurable: !0,
        get() {
          const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
          return this.message = message, message;
        },
        set(value) {
          Object.defineProperty(this, "message", {
            value,
            writable: !0
          });
        }
      }), error2;
    };
  }
  function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument))
      return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    const ParseErrorConstructors = {};
    for (const reasonCode of Object.keys(argument)) {
      const template = argument[reasonCode], _ref = typeof template == "string" ? {
        message: () => template
      } : typeof template == "function" ? {
        message: template
      } : template, {
        message
      } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded), toMessage = typeof message == "string" ? () => message : message;
      ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode,
        toMessage
      }, syntaxPlugin ? {
        syntaxPlugin
      } : {}, rest));
    }
    return ParseErrorConstructors;
  }
  const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors)), {
    defineProperty: defineProperty2
  } = Object, toUnenumerable = (object, key2) => {
    object && defineProperty2(object, key2, {
      enumerable: !1,
      value: object[key2]
    });
  };
  function toESTreeLocation(node) {
    return toUnenumerable(node.loc.start, "index"), toUnenumerable(node.loc.end, "index"), node;
  }
  var estree = (superClass) => class extends superClass {
    parse() {
      const file = toESTreeLocation(super.parse());
      return this.options.tokens && (file.tokens = file.tokens.map(toESTreeLocation)), file;
    }
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex2 = null;
      try {
        regex2 = new RegExp(pattern, flags);
      } catch {
      }
      const node = this.estreeParseLiteral(regex2);
      return node.regex = {
        pattern,
        flags
      }, node;
    }
    parseBigIntLiteral(value) {
      let bigInt;
      try {
        bigInt = BigInt(value);
      } catch {
        bigInt = null;
      }
      const node = this.estreeParseLiteral(bigInt);
      return node.bigint = String(node.value || value), node;
    }
    parseDecimalLiteral(value) {
      const node = this.estreeParseLiteral(null);
      return node.decimal = String(node.value || value), node;
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    directiveToStmt(directive) {
      const expression = directive.value;
      delete directive.value, expression.type = "Literal", expression.raw = expression.extra.raw, expression.value = expression.extra.expressionValue;
      const stmt = directive;
      return stmt.type = "ExpressionStatement", stmt.expression = expression, stmt.directive = expression.extra.rawValue, delete expression.extra, stmt;
    }
    initFunction(node, isAsync) {
      super.initFunction(node, isAsync), node.expression = !1;
    }
    checkDeclaration(node) {
      node != null && this.isObjectProperty(node) ? this.checkDeclaration(node.value) : super.checkDeclaration(node);
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr;
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value == "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
      const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
      node.body = directiveStatements.concat(node.body), delete node.directives;
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0), method.typeParameters && (method.value.typeParameters = method.typeParameters, delete method.typeParameters), classBody.body.push(method);
    }
    parsePrivateName() {
      const node = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(node) : node;
    }
    convertPrivateNameToPrivateIdentifier(node) {
      const name = super.getPrivateNameSV(node);
      return node = node, delete node.id, node.name = name, node.type = "PrivateIdentifier", node;
    }
    isPrivateName(node) {
      return this.getPluginOption("estree", "classFeatures") ? node.type === "PrivateIdentifier" : super.isPrivateName(node);
    }
    getPrivateNameSV(node) {
      return this.getPluginOption("estree", "classFeatures") ? node.name : super.getPrivateNameSV(node);
    }
    parseLiteral(value, type2) {
      const node = super.parseLiteral(value, type2);
      return node.raw = node.extra.raw, delete node.extra, node;
    }
    parseFunctionBody(node, allowExpression, isMethod = !1) {
      super.parseFunctionBody(node, allowExpression, isMethod), node.expression = node.body.type !== "BlockStatement";
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope = !1) {
      let funcNode = this.startNode();
      return funcNode.kind = node.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope), funcNode.type = "FunctionExpression", delete funcNode.kind, node.value = funcNode, type2 === "ClassPrivateMethod" && (node.computed = !1), this.finishNode(node, "MethodDefinition");
    }
    nameIsConstructor(key2) {
      return key2.type === "Literal" ? key2.value === "constructor" : super.nameIsConstructor(key2);
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);
      return this.getPluginOption("estree", "classFeatures") && (propertyNode.type = "PropertyDefinition"), propertyNode;
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);
      return this.getPluginOption("estree", "classFeatures") && (propertyNode.type = "PropertyDefinition", propertyNode.computed = !1), propertyNode;
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
      return node && (node.type = "Property", node.kind === "method" && (node.kind = "init"), node.shorthand = !1), node;
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      return node && (node.kind = "init", node.type = "Property"), node;
    }
    isValidLVal(type2, isUnparenthesizedInAssign, binding) {
      return type2 === "Property" ? "value" : super.isValidLVal(type2, isUnparenthesizedInAssign, binding);
    }
    isAssignable(node, isBinding) {
      return node != null && this.isObjectProperty(node) ? this.isAssignable(node.value, isBinding) : super.isAssignable(node, isBinding);
    }
    toAssignable(node, isLHS = !1) {
      if (node != null && this.isObjectProperty(node)) {
        const {
          key: key2,
          value
        } = node;
        this.isPrivateName(key2) && this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start), this.toAssignable(value, isLHS);
      } else
        super.toAssignable(node, isLHS);
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      prop.type === "Property" && (prop.kind === "get" || prop.kind === "set") ? this.raise(Errors.PatternHasAccessor, prop.key) : prop.type === "Property" && prop.method ? this.raise(Errors.PatternHasMethod, prop.key) : super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
    }
    finishCallExpression(unfinished, optional) {
      const node = super.finishCallExpression(unfinished, optional);
      if (node.callee.type === "Import") {
        var _ref, _ref2;
        node.type = "ImportExpression", node.source = node.arguments[0], node.options = (_ref = node.arguments[1]) != null ? _ref : null, node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null, delete node.arguments, delete node.callee;
      }
      return node;
    }
    toReferencedArguments(node) {
      node.type !== "ImportExpression" && super.toReferencedArguments(node);
    }
    parseExport(unfinished, decorators) {
      const exportStartLoc = this.state.lastTokStartLoc, node = super.parseExport(unfinished, decorators);
      switch (node.type) {
        case "ExportAllDeclaration":
          node.exported = null;
          break;
        case "ExportNamedDeclaration":
          node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier" && (node.type = "ExportAllDeclaration", node.exported = node.specifiers[0].exported, delete node.specifiers);
        case "ExportDefaultDeclaration":
          {
            var _declaration$decorato;
            const {
              declaration
            } = node;
            declaration?.type === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start && this.resetStartLocation(node, exportStartLoc);
          }
          break;
      }
      return node;
    }
    parseSubscript(base2, startLoc, noCalls, state) {
      const node = super.parseSubscript(base2, startLoc, noCalls, state);
      if (state.optionalChainMember) {
        if ((node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") && (node.type = node.type.substring(8)), state.stop) {
          const chain = this.startNodeAtNode(node);
          return chain.expression = node, this.finishNode(chain, "ChainExpression");
        }
      } else (node.type === "MemberExpression" || node.type === "CallExpression") && (node.optional = !1);
      return node;
    }
    isOptionalMemberExpression(node) {
      return node.type === "ChainExpression" ? node.expression.type === "MemberExpression" : super.isOptionalMemberExpression(node);
    }
    hasPropertyAsPrivateName(node) {
      return node.type === "ChainExpression" && (node = node.expression), super.hasPropertyAsPrivateName(node);
    }
    isObjectProperty(node) {
      return node.type === "Property" && node.kind === "init" && !node.method;
    }
    isObjectMethod(node) {
      return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
    }
    finishNodeAt(node, type2, endLoc) {
      return toESTreeLocation(super.finishNodeAt(node, type2, endLoc));
    }
    resetStartLocation(node, startLoc) {
      super.resetStartLocation(node, startLoc), toESTreeLocation(node);
    }
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node, endLoc), toESTreeLocation(node);
    }
  };
  class TokContext {
    constructor(token2, preserveSpace) {
      this.token = void 0, this.preserveSpace = void 0, this.token = token2, this.preserveSpace = !!preserveSpace;
    }
  }
  const types2 = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", !0)
  };
  types2.template = new TokContext("`", !0);
  const beforeExpr = !0, startsExpr = !0, isLoop = !0, isAssign = !0, prefix = !0, postfix = !0;
  class ExportedTokenType {
    constructor(label, conf2 = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = label, this.keyword = conf2.keyword, this.beforeExpr = !!conf2.beforeExpr, this.startsExpr = !!conf2.startsExpr, this.rightAssociative = !!conf2.rightAssociative, this.isLoop = !!conf2.isLoop, this.isAssign = !!conf2.isAssign, this.prefix = !!conf2.prefix, this.postfix = !!conf2.postfix, this.binop = conf2.binop != null ? conf2.binop : null, this.updateContext = null;
    }
  }
  const keywords$1 = /* @__PURE__ */ new Map();
  function createKeyword(name, options2 = {}) {
    options2.keyword = name;
    const token2 = createToken(name, options2);
    return keywords$1.set(name, token2), token2;
  }
  function createBinop(name, binop) {
    return createToken(name, {
      beforeExpr,
      binop
    });
  }
  let tokenTypeCounter = -1;
  const tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
  function createToken(name, options2 = {}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    return ++tokenTypeCounter, tokenLabels.push(name), tokenBinops.push((_options$binop = options2.binop) != null ? _options$binop : -1), tokenBeforeExprs.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : !1), tokenStartsExprs.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : !1), tokenPrefixes.push((_options$prefix = options2.prefix) != null ? _options$prefix : !1), tokenTypes.push(new ExportedTokenType(name, options2)), tokenTypeCounter;
  }
  function createKeywordLike(name, options2 = {}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    return ++tokenTypeCounter, keywords$1.set(name, tokenTypeCounter), tokenLabels.push(name), tokenBinops.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1), tokenBeforeExprs.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : !1), tokenStartsExprs.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : !1), tokenPrefixes.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : !1), tokenTypes.push(new ExportedTokenType("name", options2)), tokenTypeCounter;
  }
  const tt = {
    bracketL: createToken("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: createToken("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: createToken("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: createToken("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: createToken("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
      beforeExpr
    }),
    semi: createToken(";", {
      beforeExpr
    }),
    colon: createToken(":", {
      beforeExpr
    }),
    doubleColon: createToken("::", {
      beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
      beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
      beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
      beforeExpr
    }),
    backQuote: createToken("`", {
      startsExpr
    }),
    dollarBraceL: createToken("${", {
      beforeExpr,
      startsExpr
    }),
    templateTail: createToken("...`", {
      startsExpr
    }),
    templateNonTail: createToken("...${", {
      beforeExpr,
      startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
      startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
      beforeExpr,
      isAssign
    }),
    assign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    xorAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    moduloAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: createToken("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: createToken("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: createToken("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    doubleCaret: createToken("^^", {
      startsExpr
    }),
    doubleAt: createToken("@@", {
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: createToken("%", {
      binop: 10,
      startsExpr
    }),
    star: createToken("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: !0
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _for: createKeyword("for", {
      isLoop
    }),
    _while: createKeyword("while", {
      isLoop
    }),
    _as: createKeywordLike("as", {
      startsExpr
    }),
    _assert: createKeywordLike("assert", {
      startsExpr
    }),
    _async: createKeywordLike("async", {
      startsExpr
    }),
    _await: createKeywordLike("await", {
      startsExpr
    }),
    _defer: createKeywordLike("defer", {
      startsExpr
    }),
    _from: createKeywordLike("from", {
      startsExpr
    }),
    _get: createKeywordLike("get", {
      startsExpr
    }),
    _let: createKeywordLike("let", {
      startsExpr
    }),
    _meta: createKeywordLike("meta", {
      startsExpr
    }),
    _of: createKeywordLike("of", {
      startsExpr
    }),
    _sent: createKeywordLike("sent", {
      startsExpr
    }),
    _set: createKeywordLike("set", {
      startsExpr
    }),
    _source: createKeywordLike("source", {
      startsExpr
    }),
    _static: createKeywordLike("static", {
      startsExpr
    }),
    _using: createKeywordLike("using", {
      startsExpr
    }),
    _yield: createKeywordLike("yield", {
      startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
      startsExpr
    }),
    _checks: createKeywordLike("checks", {
      startsExpr
    }),
    _exports: createKeywordLike("exports", {
      startsExpr
    }),
    _global: createKeywordLike("global", {
      startsExpr
    }),
    _implements: createKeywordLike("implements", {
      startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
      startsExpr
    }),
    _infer: createKeywordLike("infer", {
      startsExpr
    }),
    _is: createKeywordLike("is", {
      startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
      startsExpr
    }),
    _proto: createKeywordLike("proto", {
      startsExpr
    }),
    _require: createKeywordLike("require", {
      startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
      startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
      startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
      startsExpr
    }),
    _unique: createKeywordLike("unique", {
      startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
      startsExpr
    }),
    _declare: createKeywordLike("declare", {
      startsExpr
    }),
    _enum: createKeywordLike("enum", {
      startsExpr
    }),
    _module: createKeywordLike("module", {
      startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
      startsExpr
    }),
    _interface: createKeywordLike("interface", {
      startsExpr
    }),
    _type: createKeywordLike("type", {
      startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
      startsExpr
    }),
    name: createToken("name", {
      startsExpr
    }),
    placeholder: createToken("%%", {
      startsExpr: !0
    }),
    string: createToken("string", {
      startsExpr
    }),
    num: createToken("num", {
      startsExpr
    }),
    bigint: createToken("bigint", {
      startsExpr
    }),
    decimal: createToken("decimal", {
      startsExpr
    }),
    regexp: createToken("regexp", {
      startsExpr
    }),
    privateName: createToken("#name", {
      startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: createToken("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: createToken("jsxTagEnd")
  };
  function tokenIsIdentifier(token2) {
    return token2 >= 93 && token2 <= 133;
  }
  function tokenKeywordOrIdentifierIsKeyword(token2) {
    return token2 <= 92;
  }
  function tokenIsKeywordOrIdentifier(token2) {
    return token2 >= 58 && token2 <= 133;
  }
  function tokenIsLiteralPropertyName(token2) {
    return token2 >= 58 && token2 <= 137;
  }
  function tokenComesBeforeExpression(token2) {
    return tokenBeforeExprs[token2];
  }
  function tokenCanStartExpression(token2) {
    return tokenStartsExprs[token2];
  }
  function tokenIsAssignment(token2) {
    return token2 >= 29 && token2 <= 33;
  }
  function tokenIsFlowInterfaceOrTypeOrOpaque(token2) {
    return token2 >= 129 && token2 <= 131;
  }
  function tokenIsLoop(token2) {
    return token2 >= 90 && token2 <= 92;
  }
  function tokenIsKeyword(token2) {
    return token2 >= 58 && token2 <= 92;
  }
  function tokenIsOperator(token2) {
    return token2 >= 39 && token2 <= 59;
  }
  function tokenIsPostfix(token2) {
    return token2 === 34;
  }
  function tokenIsPrefix(token2) {
    return tokenPrefixes[token2];
  }
  function tokenIsTSTypeOperator(token2) {
    return token2 >= 121 && token2 <= 123;
  }
  function tokenIsTSDeclarationStart(token2) {
    return token2 >= 124 && token2 <= 130;
  }
  function tokenLabelName(token2) {
    return tokenLabels[token2];
  }
  function tokenOperatorPrecedence(token2) {
    return tokenBinops[token2];
  }
  function tokenIsRightAssociative(token2) {
    return token2 === 57;
  }
  function tokenIsTemplate(token2) {
    return token2 >= 24 && token2 <= 25;
  }
  function getExportedToken(token2) {
    return tokenTypes[token2];
  }
  tokenTypes[8].updateContext = (context) => {
    context.pop();
  }, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
    context.push(types2.brace);
  }, tokenTypes[22].updateContext = (context) => {
    context[context.length - 1] === types2.template ? context.pop() : context.push(types2.template);
  }, tokenTypes[143].updateContext = (context) => {
    context.push(types2.j_expr, types2.j_oTag);
  };
  let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code2, set2) {
    let pos2 = 65536;
    for (let i = 0, length = set2.length; i < length; i += 2) {
      if (pos2 += set2[i], pos2 > code2) return !1;
      if (pos2 += set2[i + 1], pos2 >= code2) return !0;
    }
    return !1;
  }
  function isIdentifierStart(code2) {
    return code2 < 65 ? code2 === 36 : code2 <= 90 ? !0 : code2 < 97 ? code2 === 95 : code2 <= 122 ? !0 : code2 <= 65535 ? code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2)) : isInAstralSet(code2, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code2) {
    return code2 < 48 ? code2 === 36 : code2 < 58 ? !0 : code2 < 65 ? !1 : code2 <= 90 ? !0 : code2 < 97 ? code2 === 95 : code2 <= 122 ? !0 : code2 <= 65535 ? code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2)) : isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  }
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  function isIteratorStart(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
  }
  const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }
  class Scope {
    constructor(flags) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = flags;
    }
  }
  class ScopeHandler {
    constructor(parser2, inModule) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = parser2, this.inModule = inModule;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & 64) > 0 && (flags & 2) === 0;
    }
    get inStaticBlock() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 128)
          return !0;
        if (flags & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(scope2) {
      return !!(scope2.flags & 130 || !this.parser.inModule && scope2.flags & 1);
    }
    declareName(name, bindingType, loc) {
      let scope2 = this.currentScope();
      if (bindingType & 8 || bindingType & 16) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc);
        let type2 = scope2.names.get(name) || 0;
        bindingType & 16 ? type2 = type2 | 4 : (scope2.firstLexicalName || (scope2.firstLexicalName = name), type2 = type2 | 2), scope2.names.set(name, type2), bindingType & 8 && this.maybeExportDefined(scope2, name);
      } else if (bindingType & 4)
        for (let i = this.scopeStack.length - 1; i >= 0 && (scope2 = this.scopeStack[i], this.checkRedeclarationInScope(scope2, name, bindingType, loc), scope2.names.set(name, (scope2.names.get(name) || 0) | 1), this.maybeExportDefined(scope2, name), !(scope2.flags & 387)); --i)
          ;
      this.parser.inModule && scope2.flags & 1 && this.undefinedExports.delete(name);
    }
    maybeExportDefined(scope2, name) {
      this.parser.inModule && scope2.flags & 1 && this.undefinedExports.delete(name);
    }
    checkRedeclarationInScope(scope2, name, bindingType, loc) {
      this.isRedeclaredInScope(scope2, name, bindingType) && this.parser.raise(Errors.VarRedeclaration, loc, {
        identifierName: name
      });
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      if (!(bindingType & 1)) return !1;
      if (bindingType & 8)
        return scope2.names.has(name);
      const type2 = scope2.names.get(name);
      return bindingType & 16 ? (type2 & 2) > 0 || !this.treatFunctionsAsVarInScope(scope2) && (type2 & 1) > 0 : (type2 & 2) > 0 && !(scope2.flags & 8 && scope2.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope2) && (type2 & 4) > 0;
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      this.scopeStack[0].names.has(name) || this.undefinedExports.set(name, id.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 387)
          return flags;
      }
    }
    currentThisScopeFlags() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 451 && !(flags & 4))
          return flags;
      }
    }
  }
  class FlowScope extends Scope {
    constructor(...args) {
      super(...args), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }
    declareName(name, bindingType, loc) {
      const scope2 = this.currentScope();
      if (bindingType & 2048) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc), this.maybeExportDefined(scope2, name), scope2.declareFunctions.add(name);
        return;
      }
      super.declareName(name, bindingType, loc);
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      if (super.isRedeclaredInScope(scope2, name, bindingType)) return !0;
      if (bindingType & 2048 && !scope2.declareFunctions.has(name)) {
        const type2 = scope2.names.get(name);
        return (type2 & 4) > 0 || (type2 & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(id) {
      this.scopeStack[0].declareFunctions.has(id.name) || super.checkLocalExport(id);
    }
  }
  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(sourcePos) {
      return sourcePos + this.startIndex;
    }
    offsetToSourcePos(offsetPos) {
      return offsetPos - this.startIndex;
    }
    hasPlugin(pluginConfig) {
      if (typeof pluginConfig == "string")
        return this.plugins.has(pluginConfig);
      {
        const [pluginName, pluginOptions] = pluginConfig;
        if (!this.hasPlugin(pluginName))
          return !1;
        const actualOptions = this.plugins.get(pluginName);
        for (const key2 of Object.keys(pluginOptions))
          if (actualOptions?.[key2] !== pluginOptions[key2])
            return !1;
        return !0;
      }
    }
    getPluginOption(plugin, name) {
      var _this$plugins$get;
      return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    }
  }
  function setTrailingComments(node, comments2) {
    node.trailingComments === void 0 ? node.trailingComments = comments2 : node.trailingComments.unshift(...comments2);
  }
  function setLeadingComments(node, comments2) {
    node.leadingComments === void 0 ? node.leadingComments = comments2 : node.leadingComments.unshift(...comments2);
  }
  function setInnerComments(node, comments2) {
    node.innerComments === void 0 ? node.innerComments = comments2 : node.innerComments.unshift(...comments2);
  }
  function adjustInnerComments(node, elements, commentWS) {
    let lastElement = null, i = elements.length;
    for (; lastElement === null && i > 0; )
      lastElement = elements[--i];
    lastElement === null || lastElement.start > commentWS.start ? setInnerComments(node, commentWS.comments) : setTrailingComments(lastElement, commentWS.comments);
  }
  class CommentsParser extends BaseParser {
    addComment(comment) {
      this.filename && (comment.loc.filename = this.filename);
      const {
        commentsLen
      } = this.state;
      this.comments.length !== commentsLen && (this.comments.length = commentsLen), this.comments.push(comment), this.state.commentsLen++;
    }
    processComment(node) {
      const {
        commentStack
      } = this.state, commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      let i = commentStackLength - 1;
      const lastCommentWS = commentStack[i];
      lastCommentWS.start === node.end && (lastCommentWS.leadingNode = node, i--);
      const {
        start: nodeStart
      } = node;
      for (; i >= 0; i--) {
        const commentWS = commentStack[i], commentEnd = commentWS.end;
        if (commentEnd > nodeStart)
          commentWS.containingNode = node, this.finalizeComment(commentWS), commentStack.splice(i, 1);
        else {
          commentEnd === nodeStart && (commentWS.trailingNode = node);
          break;
        }
      }
    }
    finalizeComment(commentWS) {
      const {
        comments: comments2
      } = commentWS;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null)
        commentWS.leadingNode !== null && setTrailingComments(commentWS.leadingNode, comments2), commentWS.trailingNode !== null && setLeadingComments(commentWS.trailingNode, comments2);
      else {
        const {
          containingNode: node,
          start: commentStart
        } = commentWS;
        if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44)
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;
            default:
              setInnerComments(node, comments2);
          }
        else
          setInnerComments(node, comments2);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack
      } = this.state;
      for (let i = commentStack.length - 1; i >= 0; i--)
        this.finalizeComment(commentStack[i]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node) {
      const {
        commentStack
      } = this.state, {
        length
      } = commentStack;
      if (length === 0) return;
      const commentWS = commentStack[length - 1];
      commentWS.leadingNode === node && (commentWS.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(node) {
      const {
        commentStack
      } = this.state, {
        length
      } = commentStack;
      length !== 0 && (commentStack[length - 1].trailingNode === node ? commentStack[length - 1].trailingNode = null : length >= 2 && commentStack[length - 2].trailingNode === node && (commentStack[length - 2].trailingNode = null));
    }
    takeSurroundingComments(node, start, end) {
      const {
        commentStack
      } = this.state, commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      let i = commentStackLength - 1;
      for (; i >= 0; i--) {
        const commentWS = commentStack[i], commentEnd = commentWS.end;
        if (commentWS.start === end)
          commentWS.leadingNode = node;
        else if (commentEnd === start)
          commentWS.trailingNode = node;
        else if (commentEnd < start)
          break;
      }
    }
  }
  const lineBreak = /\r\n|[\r\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code2) {
    switch (code2) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  function hasNewLine(input2, start, end) {
    for (let i = start; i < end; i++)
      if (isNewLine(input2.charCodeAt(i)))
        return !0;
    return !1;
  }
  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function isWhitespace(code2) {
    switch (code2) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  class State {
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [types2.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(v) {
      v ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode,
      sourceType,
      startIndex,
      startLine,
      startColumn
    }) {
      this.strict = strictMode === !1 ? !1 : strictMode === !0 ? !0 : sourceType === "module", this.startIndex = startIndex, this.curLine = startLine, this.lineStart = -startColumn, this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(v) {
      v ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(v) {
      v ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(v) {
      v ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(v) {
      v ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(v) {
      v ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(v) {
      v ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(v) {
      v ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(v) {
      v ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(v) {
      v ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(v) {
      v ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(v) {
      v ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(v) {
      v ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      const state = new State();
      return state.flags = this.flags, state.startIndex = this.startIndex, state.curLine = this.curLine, state.lineStart = this.lineStart, state.startLoc = this.startLoc, state.endLoc = this.endLoc, state.errors = this.errors.slice(), state.potentialArrowAt = this.potentialArrowAt, state.noArrowAt = this.noArrowAt.slice(), state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), state.topicContext = this.topicContext, state.labels = this.labels.slice(), state.commentsLen = this.commentsLen, state.commentStack = this.commentStack.slice(), state.pos = this.pos, state.type = this.type, state.value = this.value, state.start = this.start, state.end = this.end, state.lastTokEndLoc = this.lastTokEndLoc, state.lastTokStartLoc = this.lastTokStartLoc, state.context = this.context.slice(), state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, state.strictErrors = this.strictErrors, state.tokensLength = this.tokensLength, state;
    }
  }
  var _isDigit = function(code2) {
    return code2 >= 48 && code2 <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  function readStringContents(type2, input2, pos2, lineStart, curLine, errors) {
    const initialPos = pos2, initialLineStart = lineStart, initialCurLine = curLine;
    let out = "", firstInvalidLoc = null, chunkStart = pos2;
    const {
      length
    } = input2;
    for (; ; ) {
      if (pos2 >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine), out += input2.slice(chunkStart, pos2);
        break;
      }
      const ch = input2.charCodeAt(pos2);
      if (isStringEnd(type2, ch, input2, pos2)) {
        out += input2.slice(chunkStart, pos2);
        break;
      }
      if (ch === 92) {
        out += input2.slice(chunkStart, pos2);
        const res = readEscapedChar(input2, pos2, lineStart, curLine, type2 === "template", errors);
        res.ch === null && !firstInvalidLoc ? firstInvalidLoc = {
          pos: pos2,
          lineStart,
          curLine
        } : out += res.ch, {
          pos: pos2,
          lineStart,
          curLine
        } = res, chunkStart = pos2;
      } else ch === 8232 || ch === 8233 ? (++pos2, ++curLine, lineStart = pos2) : ch === 10 || ch === 13 ? type2 === "template" ? (out += input2.slice(chunkStart, pos2) + `
`, ++pos2, ch === 13 && input2.charCodeAt(pos2) === 10 && ++pos2, ++curLine, chunkStart = lineStart = pos2) : errors.unterminated(initialPos, initialLineStart, initialCurLine) : ++pos2;
    }
    return {
      pos: pos2,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type2, ch, input2, pos2) {
    return type2 === "template" ? ch === 96 || ch === 36 && input2.charCodeAt(pos2 + 1) === 123 : ch === (type2 === "double" ? 34 : 39);
  }
  function readEscapedChar(input2, pos2, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos2++;
    const res = (ch2) => ({
      pos: pos2,
      ch: ch2,
      lineStart,
      curLine
    }), ch = input2.charCodeAt(pos2++);
    switch (ch) {
      case 110:
        return res(`
`);
      case 114:
        return res("\r");
      case 120: {
        let code2;
        return {
          code: code2,
          pos: pos2
        } = readHexChar(input2, pos2, lineStart, curLine, 2, !1, throwOnInvalid, errors), res(code2 === null ? null : String.fromCharCode(code2));
      }
      case 117: {
        let code2;
        return {
          code: code2,
          pos: pos2
        } = readCodePoint(input2, pos2, lineStart, curLine, throwOnInvalid, errors), res(code2 === null ? null : String.fromCodePoint(code2));
      }
      case 116:
        return res("	");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        input2.charCodeAt(pos2) === 10 && ++pos2;
      case 10:
        lineStart = pos2, ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate)
          return res(null);
        errors.strictNumericEscape(pos2 - 1, lineStart, curLine);
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos2 - 1;
          let octalStr = /^[0-7]+/.exec(input2.slice(startPos, pos2 + 2))[0], octal = parseInt(octalStr, 8);
          octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), pos2 += octalStr.length - 1;
          const next = input2.charCodeAt(pos2);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate)
              return res(null);
            errors.strictNumericEscape(startPos, lineStart, curLine);
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input2, pos2, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos2;
    let n;
    return {
      n,
      pos: pos2
    } = readInt(input2, pos2, lineStart, curLine, 16, len, forceLen, !1, errors, !throwOnInvalid), n === null && (throwOnInvalid ? errors.invalidEscapeSequence(initialPos, lineStart, curLine) : pos2 = initialPos - 1), {
      code: n,
      pos: pos2
    };
  }
  function readInt(input2, pos2, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos2, forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = !1, total = 0;
    for (let i = 0, e = len ?? 1 / 0; i < e; ++i) {
      const code2 = input2.charCodeAt(pos2);
      let val;
      if (code2 === 95 && allowNumSeparator !== "bail") {
        const prev = input2.charCodeAt(pos2 - 1), next = input2.charCodeAt(pos2 + 1);
        if (allowNumSeparator) {
          if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos: pos2
            };
            errors.unexpectedNumericSeparator(pos2, lineStart, curLine);
          }
        } else {
          if (bailOnError) return {
            n: null,
            pos: pos2
          };
          errors.numericSeparatorInEscapeSequence(pos2, lineStart, curLine);
        }
        ++pos2;
        continue;
      }
      if (code2 >= 97 ? val = code2 - 97 + 10 : code2 >= 65 ? val = code2 - 65 + 10 : _isDigit(code2) ? val = code2 - 48 : val = 1 / 0, val >= radix) {
        if (val <= 9 && bailOnError)
          return {
            n: null,
            pos: pos2
          };
        if (val <= 9 && errors.invalidDigit(pos2, lineStart, curLine, radix))
          val = 0;
        else if (forceLen)
          val = 0, invalid = !0;
        else
          break;
      }
      ++pos2, total = total * radix + val;
    }
    return pos2 === start || len != null && pos2 - start !== len || invalid ? {
      n: null,
      pos: pos2
    } : {
      n: total,
      pos: pos2
    };
  }
  function readCodePoint(input2, pos2, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input2.charCodeAt(pos2);
    let code2;
    if (ch === 123) {
      if (++pos2, {
        code: code2,
        pos: pos2
      } = readHexChar(input2, pos2, lineStart, curLine, input2.indexOf("}", pos2) - pos2, !0, throwOnInvalid, errors), ++pos2, code2 !== null && code2 > 1114111)
        if (throwOnInvalid)
          errors.invalidCodePoint(pos2, lineStart, curLine);
        else
          return {
            code: null,
            pos: pos2
          };
    } else
      ({
        code: code2,
        pos: pos2
      } = readHexChar(input2, pos2, lineStart, curLine, 4, !1, throwOnInvalid, errors));
    return {
      code: code2,
      pos: pos2
    };
  }
  function buildPosition(pos2, lineStart, curLine) {
    return new Position(curLine, pos2 - lineStart, pos2);
  }
  const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class Token {
    constructor(state) {
      const startIndex = state.startIndex || 0;
      this.type = state.type, this.value = state.value, this.start = startIndex + state.start, this.end = startIndex + state.end, this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  }
  class Tokenizer extends CommentsParser {
    constructor(options2, input2) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: (pos2, lineStart, curLine, radix) => this.options.errorRecovery ? (this.raise(Errors.InvalidDigit, buildPosition(pos2, lineStart, curLine), {
          radix
        }), !0) : !1,
        numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (pos2, lineStart, curLine) => {
          this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos2, lineStart, curLine));
        },
        unterminated: (pos2, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedString, buildPosition(pos2 - 1, lineStart, curLine));
        }
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: (pos2, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos2, lineStart, curLine));
        }
      }), this.state = new State(), this.state.init(options2), this.input = input2, this.length = input2.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(token2) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(token2), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(type2) {
      return this.match(type2) ? (this.next(), !0) : !1;
    }
    match(type2) {
      return this.state.type === type2;
    }
    createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        context: [this.curContext()],
        inType: state.inType,
        startLoc: state.startLoc,
        lastTokEndLoc: state.lastTokEndLoc,
        curLine: state.curLine,
        lineStart: state.lineStart,
        curPosition: state.curPosition
      };
    }
    lookahead() {
      const old2 = this.state;
      this.state = this.createLookaheadState(old2), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      const curr = this.state;
      return this.state = old2, curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos2) {
      return skipWhiteSpace.lastIndex = pos2, skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos2;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(pos2) {
      return skipWhiteSpaceInLine.lastIndex = pos2, skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos2;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(pos2) {
      let cp = this.input.charCodeAt(pos2);
      if ((cp & 64512) === 55296 && ++pos2 < this.input.length) {
        const trail = this.input.charCodeAt(pos2);
        (trail & 64512) === 56320 && (cp = 65536 + ((cp & 1023) << 10) + (trail & 1023));
      }
      return cp;
    }
    setStrict(strict) {
      this.state.strict = strict, strict && (this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(commentEnd) {
      let startLoc;
      this.isLookahead || (startLoc = this.state.curPosition());
      const start = this.state.pos, end = this.input.indexOf(commentEnd, start + 2);
      if (end === -1)
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = end + commentEnd.length, lineBreakG.lastIndex = start + 2; lineBreakG.test(this.input) && lineBreakG.lastIndex <= end; )
        ++this.state.curLine, this.state.lineStart = lineBreakG.lastIndex;
      if (this.isLookahead) return;
      const comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start: this.sourceToOffsetPos(start),
        end: this.sourceToOffsetPos(end + commentEnd.length),
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(comment), comment;
    }
    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      this.isLookahead || (startLoc = this.state.curPosition());
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length)
        for (; !isNewLine(ch) && ++this.state.pos < this.length; )
          ch = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const end = this.state.pos, comment = {
        type: "CommentLine",
        value: this.input.slice(start + startSkip, end),
        start: this.sourceToOffsetPos(start),
        end: this.sourceToOffsetPos(end),
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(comment), comment;
    }
    skipSpace() {
      const spaceStart = this.state.pos, comments2 = [];
      loop: for (; this.state.pos < this.length; ) {
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const comment = this.skipBlockComment("*/");
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
                break;
              }
              case 47: {
                const comment = this.skipLineComment(2);
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
                break;
              }
              default:
                break loop;
            }
            break;
          default:
            if (isWhitespace(ch))
              ++this.state.pos;
            else if (ch === 45 && !this.inModule && this.options.annexB) {
              const pos2 = this.state.pos;
              if (this.input.charCodeAt(pos2 + 1) === 45 && this.input.charCodeAt(pos2 + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                const comment = this.skipLineComment(3);
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
              } else
                break loop;
            } else if (ch === 60 && !this.inModule && this.options.annexB) {
              const pos2 = this.state.pos;
              if (this.input.charCodeAt(pos2 + 1) === 33 && this.input.charCodeAt(pos2 + 2) === 45 && this.input.charCodeAt(pos2 + 3) === 45) {
                const comment = this.skipLineComment(4);
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
              } else
                break loop;
            } else
              break loop;
        }
      }
      if (comments2.length > 0) {
        const end = this.state.pos, commentWhitespace = {
          start: this.sourceToOffsetPos(spaceStart),
          end: this.sourceToOffsetPos(end),
          comments: comments2,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    }
    finishToken(type2, val) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type2, this.state.value = val, this.isLookahead || this.updateContext(prevType);
    }
    replaceToken(type2) {
      this.state.type = type2, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const nextPos = this.state.pos + 1, next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57)
        throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, next === 123 ? this.finishToken(7) : this.finishToken(1);
      } else isIdentifierStart(next) ? (++this.state.pos, this.finishToken(139, this.readWord1(next))) : next === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(!0);
        return;
      }
      next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return !1;
      const start = this.state.pos;
      for (this.state.pos += 1; !isNewLine(ch) && ++this.state.pos < this.length; )
        ch = this.input.charCodeAt(this.state.pos);
      const value = this.input.slice(start + 2, this.state.pos);
      return this.finishToken(28, value), !0;
    }
    readToken_mult_modulo(code2) {
      let type2 = code2 === 42 ? 55 : 54, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
      code2 === 42 && next === 42 && (width++, next = this.input.charCodeAt(this.state.pos + 2), type2 = 57), next === 61 && !this.state.inType && (width++, type2 = code2 === 37 ? 33 : 30), this.finishOp(type2, width);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(code2 === 124 ? 41 : 42, 2);
        return;
      }
      if (code2 === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(code2 === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      next === 61 && !this.state.inType ? this.finishOp(32, 2) : next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.finishOp(34, 2);
        return;
      }
      next === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: pos2
      } = this.state, next = this.input.charCodeAt(pos2 + 1);
      if (next === 60) {
        if (this.input.charCodeAt(pos2 + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: pos2
      } = this.state, next = this.input.charCodeAt(pos2 + 1);
      if (next === 62) {
        const size = this.input.charCodeAt(pos2 + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(pos2 + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }
        this.finishOp(52, size);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code2 === 61 && next === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(code2 === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
      next === 63 ? next2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : next === 46 && !(next2 >= 48 && next2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(code2) {
      switch (code2) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(code2);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code2);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code2);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code2);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code2);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code2)) {
            this.readWord(code2);
            return;
          }
      }
      throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(code2)
      });
    }
    finishOp(type2, size) {
      const str2 = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size, this.finishToken(type2, str2);
    }
    readRegexp() {
      const startLoc = this.state.startLoc, start = this.state.start + 1;
      let escaped, inClass, {
        pos: pos2
      } = this.state;
      for (; ; ++pos2) {
        if (pos2 >= this.length)
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        const ch = this.input.charCodeAt(pos2);
        if (isNewLine(ch))
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        if (escaped)
          escaped = !1;
        else {
          if (ch === 91)
            inClass = !0;
          else if (ch === 93 && inClass)
            inClass = !1;
          else if (ch === 47 && !inClass)
            break;
          escaped = ch === 92;
        }
      }
      const content = this.input.slice(start, pos2);
      ++pos2;
      let mods2 = "";
      const nextPos = () => createPositionWithColumnOffset(startLoc, pos2 + 2 - start);
      for (; pos2 < this.length; ) {
        const cp = this.codePointAtPos(pos2), char = String.fromCharCode(cp);
        if (VALID_REGEX_FLAGS.has(cp))
          cp === 118 ? mods2.includes("u") && this.raise(Errors.IncompatibleRegExpUVFlags, nextPos()) : cp === 117 && mods2.includes("v") && this.raise(Errors.IncompatibleRegExpUVFlags, nextPos()), mods2.includes(char) && this.raise(Errors.DuplicateRegExpFlags, nextPos());
        else if (isIdentifierChar(cp) || cp === 92)
          this.raise(Errors.MalformedRegExpFlags, nextPos());
        else
          break;
        ++pos2, mods2 += char;
      }
      this.state.pos = pos2, this.finishToken(138, {
        pattern: content,
        flags: mods2
      });
    }
    readInt(radix, len, forceLen = !1, allowNumSeparator = !0) {
      const {
        n,
        pos: pos2
      } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, !1);
      return this.state.pos = pos2, n;
    }
    readRadixNumber(radix) {
      const start = this.state.pos, startLoc = this.state.curPosition();
      let isBigInt = !1;
      this.state.pos += 2;
      const val = this.readInt(radix);
      val == null && this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
        radix
      });
      const next = this.input.charCodeAt(this.state.pos);
      if (next === 110)
        ++this.state.pos, isBigInt = !0;
      else if (next === 109)
        throw this.raise(Errors.InvalidDecimal, startLoc);
      if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      if (isBigInt) {
        const str2 = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, str2);
        return;
      }
      this.finishToken(135, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos, startLoc = this.state.curPosition();
      let isFloat2 = !1, isBigInt = !1, hasExponent = !1, isOctal = !1;
      !startsWithDot && this.readInt(10) === null && this.raise(Errors.InvalidNumber, this.state.curPosition());
      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        if (this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc), !this.state.strict) {
          const underscorePos = integer.indexOf("_");
          underscorePos > 0 && this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      let next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal && (++this.state.pos, this.readInt(10), isFloat2 = !0, next = this.input.charCodeAt(this.state.pos)), (next === 69 || next === 101) && !isOctal && (next = this.input.charCodeAt(++this.state.pos), (next === 43 || next === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(Errors.InvalidOrMissingExponent, startLoc), isFloat2 = !0, hasExponent = !0, next = this.input.charCodeAt(this.state.pos)), next === 110 && ((isFloat2 || hasLeadingZero) && this.raise(Errors.InvalidBigIntLiteral, startLoc), ++this.state.pos, isBigInt = !0), next === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (hasExponent || hasLeadingZero) && this.raise(Errors.InvalidDecimal, startLoc), ++this.state.pos;
        var isDecimal = !0;
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      const str2 = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(136, str2);
        return;
      }
      if (isDecimal) {
        this.finishToken(137, str2);
        return;
      }
      const val = isOctal ? parseInt(str2, 8) : parseFloat(str2);
      this.finishToken(135, val);
    }
    readCodePoint(throwOnInvalid) {
      const {
        code: code2,
        pos: pos2
      } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
      return this.state.pos = pos2, code2;
    }
    readString(quote) {
      const {
        str: str2,
        pos: pos2,
        curLine,
        lineStart
      } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = pos2 + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, this.finishToken(134, str2);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const opening = this.input[this.state.pos], {
        str: str2,
        firstInvalidLoc,
        pos: pos2,
        curLine,
        lineStart
      } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = pos2 + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, firstInvalidLoc && (this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos))), this.input.codePointAt(pos2) === 96 ? this.finishToken(24, firstInvalidLoc ? null : opening + str2 + "`") : (this.state.pos++, this.finishToken(25, firstInvalidLoc ? null : opening + str2 + "${"));
    }
    recordStrictModeErrors(toParseError, at) {
      const index = at.index;
      this.state.strict && !this.state.strictErrors.has(index) ? this.raise(toParseError, at) : this.state.strictErrors.set(index, [toParseError, at]);
    }
    readWord1(firstCode) {
      this.state.containsEsc = !1;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      for (firstCode !== void 0 && (this.state.pos += firstCode <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch))
          this.state.pos += ch <= 65535 ? 1 : 2;
        else if (ch === 92) {
          this.state.containsEsc = !0, word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.curPosition(), identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, this.state.curPosition()), chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const esc = this.readCodePoint(!0);
          esc !== null && (identifierCheck(esc) || this.raise(Errors.EscapedCharNotAnIdentifier, escStart), word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
        } else
          break;
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
      const word = this.readWord1(firstCode), type2 = keywords$1.get(word);
      type2 !== void 0 ? this.finishToken(type2, tokenLabelName(type2)) : this.finishToken(132, word);
    }
    checkKeywordEscapes() {
      const {
        type: type2
      } = this.state;
      tokenIsKeyword(type2) && this.state.containsEsc && this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: tokenLabelName(type2)
      });
    }
    raise(toParseError, at, details = {}) {
      const loc = at instanceof Position ? at : at.loc.start, error2 = toParseError(loc, details);
      if (!this.options.errorRecovery) throw error2;
      return this.isLookahead || this.state.errors.push(error2), error2;
    }
    raiseOverwrite(toParseError, at, details = {}) {
      const loc = at instanceof Position ? at : at.loc.start, pos2 = loc.index, errors = this.state.errors;
      for (let i = errors.length - 1; i >= 0; i--) {
        const error2 = errors[i];
        if (error2.loc.index === pos2)
          return errors[i] = toParseError(loc, details);
        if (error2.loc.index < pos2) break;
      }
      return this.raise(toParseError, at, details);
    }
    updateContext(prevType) {
    }
    unexpected(loc, type2) {
      throw this.raise(Errors.UnexpectedToken, loc ?? this.state.startLoc, {
        expected: type2 ? tokenLabelName(type2) : null
      });
    }
    expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName))
        return !0;
      throw this.raise(Errors.MissingPlugin, loc ?? this.state.startLoc, {
        missingPlugin: [pluginName]
      });
    }
    expectOnePlugin(pluginNames) {
      if (!pluginNames.some((name) => this.hasPlugin(name)))
        throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: pluginNames
        });
    }
    errorBuilder(error2) {
      return (pos2, lineStart, curLine) => {
        this.raise(error2, buildPosition(pos2, lineStart, curLine));
      };
    }
  }
  class ClassScope {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class ClassScopeHandler {
    constructor(parser2) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = parser2;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope());
    }
    exit() {
      const oldClassScope = this.stack.pop(), current = this.current();
      for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames))
        current ? current.undefinedPrivateNames.has(name) || current.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
          identifierName: name
        });
    }
    declarePrivateName(name, elementType, loc) {
      const {
        privateNames,
        loneAccessors,
        undefinedPrivateNames
      } = this.current();
      let redefined = privateNames.has(name);
      if (elementType & 3) {
        const accessor = redefined && loneAccessors.get(name);
        if (accessor) {
          const oldStatic = accessor & 4, newStatic = elementType & 4, oldKind = accessor & 3, newKind = elementType & 3;
          redefined = oldKind === newKind || oldStatic !== newStatic, redefined || loneAccessors.delete(name);
        } else redefined || loneAccessors.set(name, elementType);
      }
      redefined && this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
        identifierName: name
      }), privateNames.add(name), undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, loc) {
      let classScope;
      for (classScope of this.stack)
        if (classScope.privateNames.has(name)) return;
      classScope ? classScope.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
        identifierName: name
      });
    }
  }
  class ExpressionScope {
    constructor(type2 = 0) {
      this.type = type2;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type2) {
      super(type2), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(ParsingErrorClass, at) {
      const index = at.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at]);
    }
    clearDeclarationError(index) {
      this.declarationErrors.delete(index);
    }
    iterateErrors(iterator2) {
      this.declarationErrors.forEach(iterator2);
    }
  }
  class ExpressionScopeHandler {
    constructor(parser2) {
      this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = parser2;
    }
    enter(scope2) {
      this.stack.push(scope2);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(toParseError, node) {
      const origin = node.loc.start, {
        stack: stack2
      } = this;
      let i = stack2.length - 1, scope2 = stack2[i];
      for (; !scope2.isCertainlyParameterDeclaration(); ) {
        if (scope2.canBeArrowParameterDeclaration())
          scope2.recordDeclarationError(toParseError, origin);
        else
          return;
        scope2 = stack2[--i];
      }
      this.parser.raise(toParseError, origin);
    }
    recordArrowParameterBindingError(error2, node) {
      const {
        stack: stack2
      } = this, scope2 = stack2[stack2.length - 1], origin = node.loc.start;
      if (scope2.isCertainlyParameterDeclaration())
        this.parser.raise(error2, origin);
      else if (scope2.canBeArrowParameterDeclaration())
        scope2.recordDeclarationError(error2, origin);
      else
        return;
    }
    recordAsyncArrowParametersError(at) {
      const {
        stack: stack2
      } = this;
      let i = stack2.length - 1, scope2 = stack2[i];
      for (; scope2.canBeArrowParameterDeclaration(); )
        scope2.type === 2 && scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, at), scope2 = stack2[--i];
    }
    validateAsPattern() {
      const {
        stack: stack2
      } = this, currentScope = stack2[stack2.length - 1];
      currentScope.canBeArrowParameterDeclaration() && currentScope.iterateErrors(([toParseError, loc]) => {
        this.parser.raise(toParseError, loc);
        let i = stack2.length - 2, scope2 = stack2[i];
        for (; scope2.canBeArrowParameterDeclaration(); )
          scope2.clearDeclarationError(loc.index), scope2 = stack2[--i];
      });
    }
  }
  function newParameterDeclarationScope() {
    return new ExpressionScope(3);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(1);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(2);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }
  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
  }
  class UtilParser extends Tokenizer {
    addExtra(node, key2, value, enumerable = !0) {
      if (!node) return;
      let {
        extra
      } = node;
      extra == null && (extra = {}, node.extra = extra), enumerable ? extra[key2] = value : Object.defineProperty(extra, key2, {
        enumerable,
        value
      });
    }
    isContextual(token2) {
      return this.state.type === token2 && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      if (this.input.slice(nameStart, nameEnd) === name) {
        const nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(token2) {
      return this.isContextual(token2) ? (this.next(), !0) : !1;
    }
    expectContextual(token2, toParseError) {
      if (!this.eatContextual(token2)) {
        if (toParseError != null)
          throw this.raise(toParseError, this.state.startLoc);
        this.unexpected(null, token2);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return hasNewLine(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = !0) {
      (allowAsi ? this.isLineTerminator() : this.eat(13)) || this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(type2, loc) {
      this.eat(type2) || this.unexpected(loc, type2);
    }
    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node = fn((node2 = null) => {
          throw abortSignal.node = node2, abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          return this.state = oldState, this.state.tokensLength = failState.tokensLength, {
            node,
            error: failState.errors[oldState.errors.length],
            thrown: !1,
            aborted: !1,
            failState
          };
        }
        return {
          node,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (error2) {
        const failState = this.state;
        if (this.state = oldState, error2 instanceof SyntaxError)
          return {
            node: null,
            error: error2,
            thrown: !0,
            aborted: !1,
            failState
          };
        if (error2 === abortSignal)
          return {
            node: abortSignal.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState
          };
        throw error2;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return !1;
      const {
        shorthandAssignLoc,
        doubleProtoLoc,
        privateKeyLoc,
        optionalParametersLoc
      } = refExpressionErrors, hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
      if (!andThrow)
        return hasErrors;
      shorthandAssignLoc != null && this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc), doubleProtoLoc != null && this.raise(Errors.DuplicateProto, doubleProtoLoc), privateKeyLoc != null && this.raise(Errors.UnexpectedPrivateField, privateKeyLoc), optionalParametersLoc != null && this.unexpected(optionalParametersLoc);
    }
    isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node) {
      return node.type === "PrivateName";
    }
    getPrivateNameSV(node) {
      return node.id.name;
    }
    hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }
    isObjectProperty(node) {
      return node.type === "ObjectProperty";
    }
    isObjectMethod(node) {
      return node.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope, ScopeHandler2 = this.getScopeHandler();
      this.scope = new ScopeHandler2(this, inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      const oldExpressionScope = this.expressionScope;
      return this.expressionScope = new ExpressionScopeHandler(this), () => {
        this.state.labels = oldLabels, this.exportedIdentifiers = oldExportedIdentifiers, this.inModule = oldInModule, this.scope = oldScope, this.prodParam = oldProdParam, this.classScope = oldClassScope, this.expressionScope = oldExpressionScope;
      };
    }
    enterInitialScopes() {
      let paramFlags = 0;
      this.inModule && (paramFlags |= 2), this.scope.enter(1), this.prodParam.enter(paramFlags);
    }
    checkDestructuringPrivate(refExpressionErrors) {
      const {
        privateKeyLoc
      } = refExpressionErrors;
      privateKeyLoc !== null && this.expectPlugin("destructuringPrivate", privateKeyLoc);
    }
  }
  class ExpressionErrors {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class Node {
    constructor(parser2, pos2, loc) {
      this.type = "", this.start = pos2, this.end = 0, this.loc = new SourceLocation(loc), parser2 != null && parser2.options.ranges && (this.range = [pos2, 0]), parser2 != null && parser2.filename && (this.loc.filename = parser2.filename);
    }
  }
  const NodePrototype = Node.prototype;
  NodePrototype.__clone = function() {
    const newNode = new Node(void 0, this.start, this.loc.start), keys = Object.keys(this);
    for (let i = 0, length = keys.length; i < length; i++) {
      const key2 = keys[i];
      key2 !== "leadingComments" && key2 !== "trailingComments" && key2 !== "innerComments" && (newNode[key2] = this[key2]);
    }
    return newNode;
  };
  function clonePlaceholder(node) {
    return cloneIdentifier(node);
  }
  function cloneIdentifier(node) {
    const {
      type: type2,
      start,
      end,
      loc,
      range: range2,
      extra,
      name
    } = node, cloned = Object.create(NodePrototype);
    return cloned.type = type2, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range2, cloned.extra = extra, cloned.name = name, type2 === "Placeholder" && (cloned.expectedNode = node.expectedNode), cloned;
  }
  function cloneStringLiteral(node) {
    const {
      type: type2,
      start,
      end,
      loc,
      range: range2,
      extra
    } = node;
    if (type2 === "Placeholder")
      return clonePlaceholder(node);
    const cloned = Object.create(NodePrototype);
    return cloned.type = type2, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range2, node.raw !== void 0 ? cloned.raw = node.raw : cloned.extra = extra, cloned.value = node.value, cloned;
  }
  class NodeUtils extends UtilParser {
    startNode() {
      const loc = this.state.startLoc;
      return new Node(this, loc.index, loc);
    }
    startNodeAt(loc) {
      return new Node(this, loc.index, loc);
    }
    startNodeAtNode(type2) {
      return this.startNodeAt(type2.loc.start);
    }
    finishNode(node, type2) {
      return this.finishNodeAt(node, type2, this.state.lastTokEndLoc);
    }
    finishNodeAt(node, type2, endLoc) {
      return node.type = type2, node.end = endLoc.index, node.loc.end = endLoc, this.options.ranges && (node.range[1] = endLoc.index), this.options.attachComment && this.processComment(node), node;
    }
    resetStartLocation(node, startLoc) {
      node.start = startLoc.index, node.loc.start = startLoc, this.options.ranges && (node.range[0] = startLoc.index);
    }
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
      node.end = endLoc.index, node.loc.end = endLoc, this.options.ranges && (node.range[1] = endLoc.index);
    }
    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.loc.start);
    }
  }
  const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), FlowErrors = ParseErrorEnum`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType
    }) => `Cannot overwrite reserved type ${reservedType}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName,
      enumName
    }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    EnumDuplicateMemberName: ({
      memberName,
      enumName
    }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    EnumInconsistentMemberValues: ({
      enumName
    }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType,
      enumName
    }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName,
      memberName,
      explicitType
    }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName,
      memberName
    }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName,
      memberName
    }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    EnumInvalidMemberName: ({
      enumName,
      memberName,
      suggestion
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName,
      memberName
    }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType
    }) => `Unexpected reserved type ${reservedType}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind,
      suggestion
    }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }
  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }
  const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function partition2(list2, test) {
    const list1 = [], list22 = [];
    for (let i = 0; i < list2.length; i++)
      (test(list2[i], i, list2) ? list1 : list22).push(list2[i]);
    return [list1, list22];
  }
  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow2 = (superClass) => class extends superClass {
    constructor(...args) {
      super(...args), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return FlowScopeHandler;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(type2, val) {
      type2 !== 134 && type2 !== 13 && type2 !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(type2, val);
    }
    addComment(comment) {
      if (this.flowPragma === void 0) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (matches) if (matches[1] === "flow")
          this.flowPragma = "flow";
        else if (matches[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(comment);
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = !0, this.expect(tok || 14);
      const type2 = this.flowParseType();
      return this.state.inType = oldInType, type2;
    }
    flowParsePredicate() {
      const node = this.startNode(), moduloLoc = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > moduloLoc.index + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc), this.eat(10) ? (node.value = super.parseExpression(), this.expect(11), this.finishNode(node, "DeclaredPredicate")) : this.finishNode(node, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let type2 = null, predicate = null;
      return this.match(54) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type2 = this.flowParseType(), this.state.inType = oldInType, this.match(54) && (predicate = this.flowParsePredicate())), [type2, predicate];
    }
    flowParseDeclareClass(node) {
      return this.next(), this.flowParseInterfaceish(node, !0), this.finishNode(node, "DeclareClass");
    }
    flowParseDeclareFunction(node) {
      this.next();
      const id = node.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
      this.match(47) ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, this.expect(10);
      const tmp2 = this.flowParseFunctionTypeParams();
      return typeNode.params = tmp2.params, typeNode.rest = tmp2.rest, typeNode.this = tmp2._this, this.expect(11), [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), this.semicolon(), this.scope.declareName(node.id.name, 2048, node.id.loc.start), this.finishNode(node, "DeclareFunction");
    }
    flowParseDeclare(node, insideModule) {
      if (this.match(80))
        return this.flowParseDeclareClass(node);
      if (this.match(68))
        return this.flowParseDeclareFunction(node);
      if (this.match(74))
        return this.flowParseDeclareVariable(node);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(node) : (insideModule && this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(node));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(node);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(node);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(node);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(node, insideModule);
      this.unexpected();
    }
    flowParseDeclareVariable(node) {
      return this.next(), node.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(node.id.name, 5, node.id.loc.start), this.semicolon(), this.finishNode(node, "DeclareVariable");
    }
    flowParseDeclareModule(node) {
      this.scope.enter(0), this.match(134) ? node.id = super.parseExprAtom() : node.id = this.parseIdentifier();
      const bodyNode = node.body = this.startNode(), body = bodyNode.body = [];
      for (this.expect(5); !this.match(8); ) {
        let bodyNode2 = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(bodyNode2)) : (this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule), bodyNode2 = this.flowParseDeclare(bodyNode2, !0)), body.push(bodyNode2);
      }
      this.scope.exit(), this.expect(8), this.finishNode(bodyNode, "BlockStatement");
      let kind = null, hasModuleExport = !1;
      return body.forEach((bodyElement) => {
        isEsModuleType(bodyElement) ? (kind === "CommonJS" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement), kind = "ES") : bodyElement.type === "DeclareModuleExports" && (hasModuleExport && this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement), kind === "ES" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement), kind = "CommonJS", hasModuleExport = !0);
      }), node.kind = kind || "CommonJS", this.finishNode(node, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(node, insideModule) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? node.declaration = this.flowParseDeclare(this.startNode()) : (node.declaration = this.flowParseType(), this.semicolon()), node.default = !0, this.finishNode(node, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
        const label = this.state.value;
        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: label,
          suggestion: exportSuggestions[label]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return node.declaration = this.flowParseDeclare(this.startNode()), node.default = !1, this.finishNode(node, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return node = this.parseExport(node, null), node.type === "ExportNamedDeclaration" && (node.type = "ExportDeclaration", node.default = !1, delete node.exportKind), node.type = "Declare" + node.type, node;
      this.unexpected();
    }
    flowParseDeclareModuleExports(node) {
      return this.next(), this.expectContextual(111), node.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(node, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(node) {
      this.next();
      const finished = this.flowParseTypeAlias(node);
      return finished.type = "DeclareTypeAlias", finished;
    }
    flowParseDeclareOpaqueType(node) {
      this.next();
      const finished = this.flowParseOpaqueType(node, !0);
      return finished.type = "DeclareOpaqueType", finished;
    }
    flowParseDeclareInterface(node) {
      return this.next(), this.flowParseInterfaceish(node, !1), this.finishNode(node, "DeclareInterface");
    }
    flowParseInterfaceish(node, isClass) {
      if (node.id = this.flowParseRestrictedIdentifier(!isClass, !0), this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.extends = [], this.eat(81))
        do
          node.extends.push(this.flowParseInterfaceExtends());
        while (!isClass && this.eat(12));
      if (isClass) {
        if (node.implements = [], node.mixins = [], this.eatContextual(117))
          do
            node.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            node.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      node.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: !1,
        allowSpread: !1,
        allowProto: isClass,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      const node = this.startNode();
      return node.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, this.finishNode(node, "InterfaceExtends");
    }
    flowParseInterface(node) {
      return this.flowParseInterfaceish(node, !1), this.finishNode(node, "InterfaceDeclaration");
    }
    checkNotUnderscore(word) {
      word === "_" && this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(word, startLoc, declaration) {
      reservedTypes.has(word) && this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
        reservedType: word
      });
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      return this.checkReservedType(this.state.value, this.state.startLoc, declaration), this.parseIdentifier(liberal);
    }
    flowParseTypeAlias(node) {
      return node.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(node.id.name, 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(node, "TypeAlias");
    }
    flowParseOpaqueType(node, declare) {
      return this.expectContextual(130), node.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(node.id.name, 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.supertype = null, this.match(14) && (node.supertype = this.flowParseTypeInitialiser(14)), node.impltype = null, declare || (node.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(node, "OpaqueType");
    }
    flowParseTypeParameter(requireDefault = !1) {
      const nodeStartLoc = this.state.startLoc, node = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
      return node.name = ident.name, node.variance = variance, node.bound = ident.typeAnnotation, this.match(29) ? (this.eat(29), node.default = this.flowParseType()) : requireDefault && this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc), this.finishNode(node, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType, node = this.startNode();
      node.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let defaultRequired = !1;
      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node.params.push(typeParameter), typeParameter.default && (defaultRequired = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const node = this.startNode(), oldInType = this.state.inType;
      node.params = [], this.state.inType = !0, this.expect(47);
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        node.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = oldNoAnonFunctionType, this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node = this.startNode(), oldInType = this.state.inType;
      for (node.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        node.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const node = this.startNode();
      if (this.expectContextual(129), node.extends = [], this.eat(81))
        do
          node.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return node.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(node, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(node, isStatic, variance) {
      return node.static = isStatic, this.lookahead().type === 14 ? (node.id = this.flowParseObjectPropertyKey(), node.key = this.flowParseTypeInitialiser()) : (node.id = null, node.key = this.flowParseType()), this.expect(3), node.value = this.flowParseTypeInitialiser(), node.variance = variance, this.finishNode(node, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(node, isStatic) {
      return node.static = isStatic, node.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (node.method = !0, node.optional = !1, node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start))) : (node.method = !1, this.eat(17) && (node.optional = !0), node.value = this.flowParseTypeInitialiser()), this.finishNode(node, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(node) {
      for (node.params = [], node.rest = null, node.typeParameters = null, node.this = null, this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (node.this = this.flowParseFunctionTypeParam(!0), node.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        node.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (node.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), node.returnType = this.flowParseTypeInitialiser(), this.finishNode(node, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(node, isStatic) {
      const valueNode = this.startNode();
      return node.static = isStatic, node.value = this.flowParseObjectTypeMethodish(valueNode), this.finishNode(node, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = !0;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], nodeStart.internalSlots = [];
      let endDelim, exact, inexact = !1;
      for (allowExact && this.match(6) ? (this.expect(6), endDelim = 9, exact = !0) : (this.expect(5), endDelim = 8, exact = !1), nodeStart.exact = exact; !this.match(endDelim); ) {
        let isStatic = !1, protoStartLoc = null, inexactStartLoc = null;
        const node = this.startNode();
        if (allowProto && this.isContextual(118)) {
          const lookahead = this.lookahead();
          lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), protoStartLoc = this.state.startLoc, allowStatic = !1);
        }
        if (allowStatic && this.isContextual(106)) {
          const lookahead = this.lookahead();
          lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), isStatic = !0);
        }
        const variance = this.flowParseVariance();
        if (this.eat(0))
          protoStartLoc != null && this.unexpected(protoStartLoc), this.eat(0) ? (variance && this.unexpected(variance.loc.start), nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
        else if (this.match(10) || this.match(47))
          protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
        else {
          let kind = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const lookahead = this.lookahead();
            tokenIsLiteralPropertyName(lookahead.type) && (kind = this.state.value, this.next());
          }
          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact ?? !exact);
          propOrInexact === null ? (inexact = !0, inexactStartLoc = this.state.lastTokStartLoc) : nodeStart.properties.push(propOrInexact);
        }
        this.flowObjectTypeSemicolon(), inexactStartLoc && !this.match(8) && !this.match(9) && this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
      }
      this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      return this.state.inType = oldInType, out;
    }
    flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (allowSpread ? allowInexact || this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc), variance && this.raise(FlowErrors.InexactVariance, variance), null) : (allowSpread || this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc), protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.raise(FlowErrors.SpreadVariance, variance), node.argument = this.flowParseType(), this.finishNode(node, "ObjectTypeSpreadProperty"));
      {
        node.key = this.flowParseObjectPropertyKey(), node.static = isStatic, node.proto = protoStartLoc != null, node.kind = kind;
        let optional = !1;
        return this.match(47) || this.match(10) ? (node.method = !0, protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start)), (kind === "get" || kind === "set") && this.flowCheckGetterSetterParams(node), !allowSpread && node.key.name === "constructor" && node.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this)) : (kind !== "init" && this.unexpected(), node.method = !1, this.eat(17) && (optional = !0), node.value = this.flowParseTypeInitialiser(), node.variance = variance), node.optional = optional, this.finishNode(node, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1, length = property.value.params.length + (property.value.rest ? 1 : 0);
      property.value.this && this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this), length !== paramCount && this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property), property.kind === "set" && property.value.rest && this.raise(Errors.BadSetterRestParameter, property);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(startLoc, id) {
      var _startLoc;
      (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
      let node = id || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        const node2 = this.startNodeAt(startLoc);
        node2.qualification = node, node2.id = this.flowParseRestrictedIdentifier(!0), node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }
      return node;
    }
    flowParseGenericType(startLoc, id) {
      const node = this.startNodeAt(startLoc);
      return node.typeParameters = null, node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id), this.match(47) && (node.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(node, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const node = this.startNode();
      return this.expect(87), node.argument = this.flowParsePrimaryType(), this.finishNode(node, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const node = this.startNode();
      for (node.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (node.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(node, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(first2) {
      let name = null, optional = !1, typeAnnotation = null;
      const node = this.startNode(), lh = this.lookahead(), isThis = this.state.type === 78;
      return lh.type === 14 || lh.type === 17 ? (isThis && !first2 && this.raise(FlowErrors.ThisParamMustBeFirst, node), name = this.parseIdentifier(isThis), this.eat(17) && (optional = !0, isThis && this.raise(FlowErrors.ThisParamMayNotBeOptional, node)), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), node.name = name, node.optional = optional, node.typeAnnotation = typeAnnotation, this.finishNode(node, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(type2) {
      const node = this.startNodeAt(type2.loc.start);
      return node.name = null, node.optional = !1, node.typeAnnotation = type2, this.finishNode(node, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null, _this = null;
      for (this.match(78) && (_this = this.flowParseFunctionTypeParam(!0), _this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (rest = this.flowParseFunctionTypeParam(!1)), {
        params,
        rest,
        _this
      };
    }
    flowIdentToTypeAnnotation(startLoc, node, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(node, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(id.name), this.flowParseGenericType(startLoc, id);
      }
    }
    flowParsePrimaryType() {
      const startLoc = this.state.startLoc, node = this.startNode();
      let tmp2, type2, isGroupedType = !1;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, type2 = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, type2;
        case 47: {
          const node2 = this.startNode();
          return node2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), tmp2 = this.flowParseFunctionTypeParams(), node2.params = tmp2.params, node2.rest = tmp2.rest, node2.this = tmp2._this, this.expect(11), this.expect(19), node2.returnType = this.flowParseType(), this.finishNode(node2, "FunctionTypeAnnotation");
        }
        case 10: {
          const node2 = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              const token2 = this.lookahead().type;
              isGroupedType = token2 !== 17 && token2 !== 14;
            } else
              isGroupedType = !0;
          if (isGroupedType) {
            if (this.state.noAnonFunctionType = !1, type2 = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), type2;
            this.eat(12);
          }
          return type2 ? tmp2 = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type2)]) : tmp2 = this.flowParseFunctionTypeParams(), node2.params = tmp2.params, node2.rest = tmp2.rest, node2.this = tmp2._this, this.expect(11), this.expect(19), node2.returnType = this.flowParseType(), node2.typeParameters = null, this.finishNode(node2, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return node.value = this.match(85), this.next(), this.finishNode(node, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(node, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(node, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(node, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(node, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (tokenIsKeyword(this.state.type)) {
            const label = tokenLabelName(this.state.type);
            return this.next(), super.createIdentifier(node, label);
          } else if (tokenIsIdentifier(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const startLoc = this.state.startLoc;
      let type2 = this.flowParsePrimaryType(), seenOptionalIndexedAccess = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const node = this.startNodeAt(startLoc), optional = this.eat(18);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional, this.expect(0), !optional && this.match(3) ? (node.elementType = type2, this.next(), type2 = this.finishNode(node, "ArrayTypeAnnotation")) : (node.objectType = type2, node.indexType = this.flowParseType(), this.expect(3), seenOptionalIndexedAccess ? (node.optional = optional, type2 = this.finishNode(node, "OptionalIndexedAccessType")) : type2 = this.finishNode(node, "IndexedAccessType"));
      }
      return type2;
    }
    flowParsePrefixType() {
      const node = this.startNode();
      return this.eat(17) ? (node.typeAnnotation = this.flowParsePrefixType(), this.finishNode(node, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node = this.startNodeAt(param.loc.start);
        return node.params = [this.reinterpretTypeAsFunctionTypeParam(param)], node.rest = null, node.this = null, node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType() {
      const node = this.startNode();
      this.eat(45);
      const type2 = this.flowParseAnonFunctionWithoutParens();
      for (node.types = [type2]; this.eat(45); )
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      return node.types.length === 1 ? type2 : this.finishNode(node, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const node = this.startNode();
      this.eat(43);
      const type2 = this.flowParseIntersectionType();
      for (node.types = [type2]; this.eat(43); )
        node.types.push(this.flowParseIntersectionType());
      return node.types.length === 1 ? type2 : this.finishNode(node, "UnionTypeAnnotation");
    }
    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = !0;
      const type2 = this.flowParseUnionType();
      return this.state.inType = oldInType, type2;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const startLoc = this.state.startLoc, node = this.parseIdentifier();
        return this.flowParseGenericType(startLoc, node);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const node = this.startNode();
      return node.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(ident)), ident;
    }
    typeCastToParameter(node) {
      return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
    }
    flowParseVariance() {
      let variance = null;
      return this.match(53) ? (variance = this.startNode(), this.state.value === "+" ? variance.kind = "plus" : variance.kind = "minus", this.next(), this.finishNode(variance, "Variance")) : variance;
    }
    parseFunctionBody(node, allowExpressionBody, isMethod = !1) {
      if (allowExpressionBody) {
        this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, !0, isMethod));
        return;
      }
      super.parseFunctionBody(node, !1, isMethod);
    }
    parseFunctionBodyAndFinish(node, type2, isMethod = !1) {
      if (this.match(14)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(node, type2, isMethod);
    }
    parseStatementLike(flags) {
      if (this.state.strict && this.isContextual(129)) {
        const lookahead = this.lookahead();
        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
          const node = this.startNode();
          return this.next(), this.flowParseInterface(node);
        }
      } else if (this.isContextual(126)) {
        const node = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(node);
      }
      const stmt = super.parseStatementLike(flags);
      return this.flowPragma === void 0 && !this.isValidDirective(stmt) && (this.flowPragma = null), stmt;
    }
    parseExpressionStatement(node, expr, decorators) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(node);
        } else if (tokenIsIdentifier(this.state.type)) {
          if (expr.name === "interface")
            return this.flowParseInterface(node);
          if (expr.name === "type")
            return this.flowParseTypeAlias(node);
          if (expr.name === "opaque")
            return this.flowParseOpaqueType(node, !1);
        }
      }
      return super.parseExpressionStatement(node, expr, decorators);
    }
    shouldParseExportDeclaration() {
      const {
        type: type2
      } = this.state;
      return type2 === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type2) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: type2
      } = this.state;
      return type2 === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type2) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        const node = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(node);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.match(17)) return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41)
          return this.setOptionalParametersError(refExpressionErrors), expr;
      }
      this.expect(17);
      const state = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node = this.startNodeAt(startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state, this.state.noArrowAt = noArrowAt;
          for (let i = 0; i < invalid.length; i++)
            noArrowAt.push(invalid[i].start);
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent()), [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        failed && valid.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc), failed && valid.length === 1 && (this.state = state, noArrowAt.push(valid[0].start), this.state.noArrowAt = noArrowAt, {
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(consequent, !0), this.state.noArrowAt = originalNoArrowAt, this.expect(14), node.test = expr, node.consequent = consequent, node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(node, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn(), failed = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent,
        failed
      };
    }
    getArrowLikeExpressions(node, disallowInvalid) {
      const stack2 = [node], arrows = [];
      for (; stack2.length !== 0; ) {
        const node2 = stack2.pop();
        node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement" ? (node2.typeParameters || !node2.returnType ? this.finishArrowValidation(node2) : arrows.push(node2), stack2.push(node2.body)) : node2.type === "ConditionalExpression" && (stack2.push(node2.consequent), stack2.push(node2.alternate));
      }
      return disallowInvalid ? (arrows.forEach((node2) => this.finishArrowValidation(node2)), [arrows, []]) : partition2(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, !0)));
    }
    finishArrowValidation(node) {
      var _node$extra;
      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(node, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(node, parse4) {
      let result;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), result = parse4(), this.state.noArrowParamsConversionAt.pop()) : result = parse4(), result;
    }
    parseParenItem(node, startLoc) {
      const newNode = super.parseParenItem(node, startLoc);
      if (this.eat(17) && (newNode.optional = !0, this.resetEndLocation(node)), this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        return typeCastNode.expression = newNode, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return newNode;
    }
    assertModuleNodeAllowed(node) {
      node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type" || super.assertModuleNodeAllowed(node);
    }
    parseExportDeclaration(node) {
      if (this.isContextual(130)) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        return this.next(), this.match(5) ? (node.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(node), null) : this.flowParseTypeAlias(declarationNode);
      } else if (this.isContextual(131)) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        return this.next(), this.flowParseOpaqueType(declarationNode, !1);
      } else if (this.isContextual(129)) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        return this.next(), this.flowParseInterface(declarationNode);
      } else if (this.isContextual(126)) {
        node.exportKind = "value";
        const declarationNode = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(declarationNode);
      } else
        return super.parseExportDeclaration(node);
    }
    eatExportStar(node) {
      return super.eatExportStar(node) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (node.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(node) {
      const {
        startLoc
      } = this.state, hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
      return hasNamespace && node.exportKind === "type" && this.unexpected(startLoc), hasNamespace;
    }
    parseClassId(node, isStatement, optionalId) {
      super.parseClassId(node, isStatement, optionalId), this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(classBody, member, state) {
      const {
        startLoc
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(classBody, member))
          return;
        member.declare = !0;
      }
      super.parseClassMember(classBody, member, state), member.declare && (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition" ? this.raise(FlowErrors.DeclareClassElement, startLoc) : member.value && this.raise(FlowErrors.DeclareClassFieldInitializer, member.value));
    }
    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }
    readIterator() {
      const word = super.readWord1(), fullWord = "@@" + word;
      (!this.isIterator(word) || !this.state.inType) && this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
        identifierName: fullWord
      }), this.finishToken(132, fullWord);
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      code2 === 123 && next === 124 ? this.finishOp(6, 2) : this.state.inType && (code2 === 62 || code2 === 60) ? this.finishOp(code2 === 62 ? 48 : 47, 1) : this.state.inType && code2 === 63 ? next === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(code2);
    }
    isAssignable(node, isBinding) {
      return node.type === "TypeCastExpression" ? this.isAssignable(node.expression, isBinding) : super.isAssignable(node, isBinding);
    }
    toAssignable(node, isLHS = !1) {
      !isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression" && (node.left = this.typeCastToParameter(node.left)), super.toAssignable(node, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        expr?.type === "TypeCastExpression" && (exprList[i] = this.typeCastToParameter(expr));
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra;
        const expr = exprList[i];
        expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr) && this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
      }
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      return canBePattern && !this.state.maybeInArrowParameters && this.toReferencedList(node.elements), node;
    }
    isValidLVal(type2, isParenthesized, binding) {
      return type2 === "TypeCastExpression" || super.isValidLVal(type2, isParenthesized, binding);
    }
    parseClassProperty(node) {
      return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(node);
    }
    parseClassPrivateProperty(node) {
      return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(node);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper), method.params && isConstructor) {
        const params = method.params;
        params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, method);
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;
        params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, method);
      }
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node) {
      if (super.parseClassSuper(node), node.superClass && this.match(47) && (node.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        const implemented = node.implements = [];
        do {
          const node2 = this.startNode();
          node2.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterInstantiation() : node2.typeParameters = null, implemented.push(this.finishNode(node2, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length > 0) {
        const param = params[0];
        this.isThisParam(param) && method.kind === "get" ? this.raise(FlowErrors.GetterMayNotHaveThisParam, param) : this.isThisParam(param) && this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
      }
    }
    parsePropertyNamePrefixOperator(node) {
      node.variance = this.flowParseVariance();
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      prop.variance && this.unexpected(prop.variance.loc.start), delete prop.variance;
      let typeParameters;
      this.match(47) && !isAccessor && (typeParameters = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return typeParameters && ((result.value || result).typeParameters = typeParameters), result;
    }
    parseFunctionParamType(param) {
      return this.eat(17) && (param.type !== "Identifier" && this.raise(FlowErrors.PatternIsOptional, param), this.isThisParam(param) && this.raise(FlowErrors.ThisParamMayNotBeOptional, param), param.optional = !0), this.match(14) ? param.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(param) && this.raise(FlowErrors.ThisParamAnnotationRequired, param), this.match(29) && this.isThisParam(param) && this.raise(FlowErrors.ThisParamNoDefault, param), this.resetEndLocation(param), param;
    }
    parseMaybeDefault(startLoc, left) {
      const node = super.parseMaybeDefault(startLoc, left);
      return node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation), node;
    }
    checkImportReflection(node) {
      super.checkImportReflection(node), node.module && node.importKind !== "value" && this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(node, specifier, type2) {
      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type2));
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport)) return !0;
      if (this.isContextual(130)) {
        if (!isExport) return !0;
        const ch = this.lookaheadCharCode();
        return ch === 123 || ch === 42;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node, isExport, phase, loc) {
      if (super.applyImportPhase(node, isExport, phase, loc), isExport) {
        if (!phase && this.match(65))
          return;
        node.exportKind = phase === "type" ? phase : "value";
      } else
        phase === "type" && this.match(55) && this.unexpected(), node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      const firstIdent = specifier.imported;
      let specifierTypeKind = null;
      firstIdent.type === "Identifier" && (firstIdent.name === "type" ? specifierTypeKind = "type" : firstIdent.name === "typeof" && (specifierTypeKind = "typeof"));
      let isBinding = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(!0);
        specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type) ? (specifier.imported = as_ident, specifier.importKind = specifierTypeKind, specifier.local = cloneIdentifier(as_ident)) : (specifier.imported = firstIdent, specifier.importKind = null, specifier.local = this.parseIdentifier());
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type))
          specifier.imported = this.parseIdentifier(!0), specifier.importKind = specifierTypeKind;
        else {
          if (importedIsString)
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: firstIdent.value
            });
          specifier.imported = firstIdent, specifier.importKind = null;
        }
        this.eatContextual(93) ? specifier.local = this.parseIdentifier() : (isBinding = !0, specifier.local = cloneIdentifier(specifier.imported));
      }
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      return isInTypeOnlyImport && specifierIsTypeImport && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier), (isInTypeOnlyImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.loc.start, !0), isBinding && !isInTypeOnlyImport && !specifierIsTypeImport && this.checkReservedWord(specifier.local.name, specifier.loc.start, !0, !0), this.finishImportSpecifier(specifier, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(node, isConstructor) {
      const kind = node.kind;
      kind !== "get" && kind !== "set" && this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(node, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind), this.match(14) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(decl.id));
    }
    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, node.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;
      let state = null, jsx3;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (state = this.state.clone(), jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx3.error) return jsx3.node;
        const {
          context
        } = this.state, currentContext = context[context.length - 1];
        (currentContext === types2.j_oTag || currentContext === types2.j_expr) && context.pop();
      }
      if ((_jsx = jsx3) != null && _jsx.error || this.match(47)) {
        var _jsx2, _jsx3;
        state = state || this.state.clone();
        let typeParameters;
        const arrow4 = this.tryParse((abort) => {
          var _arrowExpression$extr;
          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            return this.resetStartLocationFromNode(result, typeParameters), result;
          });
          (_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized && abort();
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
          return expr.type !== "ArrowFunctionExpression" && abort(), expr.typeParameters = typeParameters, this.resetStartLocationFromNode(expr, typeParameters), arrowExpression2;
        }, state);
        let arrowExpression = null;
        if (arrow4.node && this.maybeUnwrapTypeCastExpression(arrow4.node).type === "ArrowFunctionExpression") {
          if (!arrow4.error && !arrow4.aborted)
            return arrow4.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters), arrow4.node;
          arrowExpression = arrow4.node;
        }
        if ((_jsx2 = jsx3) != null && _jsx2.node)
          return this.state = jsx3.failState, jsx3.node;
        if (arrowExpression)
          return this.state = arrow4.failState, arrowExpression;
        throw (_jsx3 = jsx3) != null && _jsx3.thrown ? jsx3.error : arrow4.thrown ? arrow4.error : this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    parseArrow(node) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          const typeNode = this.startNode();
          return [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), typeNode;
        });
        if (result.thrown) return null;
        result.error && (this.state = result.failState), node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(node);
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params);
    }
    setArrowFunctionParameters(node, params) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start)) ? node.params = params : super.setArrowFunctionParameters(node, params);
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
      if (!(isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start)))) {
        for (let i = 0; i < node.params.length; i++)
          this.isThisParam(node.params[i]) && i > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(base2, startLoc, noCalls) {
      if (base2.type === "Identifier" && base2.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base2, node.arguments = super.parseCallExpressionArguments(11), base2 = this.finishNode(node, "CallExpression");
      } else if (base2.type === "Identifier" && base2.name === "async" && this.match(47)) {
        const state = this.state.clone(), arrow4 = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
        if (!arrow4.error && !arrow4.aborted) return arrow4.node;
        const result = this.tryParse(() => super.parseSubscripts(base2, startLoc, noCalls), state);
        if (result.node && !result.error) return result.node;
        if (arrow4.node)
          return this.state = arrow4.failState, arrow4.node;
        if (result.node)
          return this.state = result.failState, result.node;
        throw arrow4.error || result.error;
      }
      return super.parseSubscripts(base2, startLoc, noCalls);
    }
    parseSubscript(base2, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (subscriptState.optionalChainMember = !0, noCalls)
          return subscriptState.stop = !0, base2;
        this.next();
        const node = this.startNodeAt(startLoc);
        return node.callee = base2, node.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), node.arguments = this.parseCallExpressionArguments(11), node.optional = !0, this.finishCallExpression(node, !0);
      } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
        const node = this.startNodeAt(startLoc);
        node.callee = base2;
        const result = this.tryParse(() => (node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), node.arguments = super.parseCallExpressionArguments(11), subscriptState.optionalChainMember && (node.optional = !1), this.finishCallExpression(node, subscriptState.optionalChainMember)));
        if (result.node)
          return result.error && (this.state = result.failState), result.node;
      }
      return super.parseSubscript(base2, startLoc, noCalls, subscriptState);
    }
    parseNewCallee(node) {
      super.parseNewCallee(node);
      let targs = null;
      this.shouldParseTypes() && this.match(47) && (targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), node.typeArguments = targs;
    }
    parseAsyncArrowWithTypeParameters(startLoc) {
      const node = this.startNodeAt(startLoc);
      if (this.parseFunctionParams(node, !1), !!this.parseArrow(node))
        return super.parseArrowExpression(node, void 0, !0);
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code2);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(code2);
    }
    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);
      return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition()), fileNode;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const commentSkip = this.skipFlowComment();
        commentSkip && (this.state.pos += commentSkip, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos: pos2
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;
      for (; [32, 9].includes(this.input.charCodeAt(pos2 + shiftToFirstNonWhiteSpace)); )
        shiftToFirstNonWhiteSpace++;
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos2), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos2 + 1);
      return ch2 === 58 && ch3 === 58 ? shiftToFirstNonWhiteSpace + 2 : this.input.slice(shiftToFirstNonWhiteSpace + pos2, shiftToFirstNonWhiteSpace + pos2 + 12) === "flow-include" ? shiftToFirstNonWhiteSpace + 12 : ch2 === 58 && ch3 !== 58 ? shiftToFirstNonWhiteSpace : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, {
      enumName,
      memberName
    }) {
      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
        memberName,
        enumName
      });
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(enumContext.explicitType ? enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType : FlowErrors.EnumInvalidMemberInitializerUnknownType, loc, enumContext);
    }
    flowEnumErrorNumberMemberNotInitialized(loc, details) {
      this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 135: {
          const literal2 = this.parseNumericLiteral(this.state.value);
          return endOfInit() ? {
            type: "number",
            loc: literal2.loc.start,
            value: literal2
          } : {
            type: "invalid",
            loc: startLoc
          };
        }
        case 134: {
          const literal2 = this.parseStringLiteral(this.state.value);
          return endOfInit() ? {
            type: "string",
            loc: literal2.loc.start,
            value: literal2
          } : {
            type: "invalid",
            loc: startLoc
          };
        }
        case 85:
        case 86: {
          const literal2 = this.parseBooleanLiteral(this.match(85));
          return endOfInit() ? {
            type: "boolean",
            loc: literal2.loc.start,
            value: literal2
          } : {
            type: "invalid",
            loc: startLoc
          };
        }
        default:
          return {
            type: "invalid",
            loc: startLoc
          };
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc, id = this.parseIdentifier(!0), init = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc
      };
      return {
        id,
        init
      };
    }
    flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
      const {
        explicitType
      } = context;
      explicitType !== null && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(loc, context);
    }
    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = /* @__PURE__ */ new Set(), members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          hasUnknownMembers = !0;
          break;
        }
        const memberNode = this.startNode(), {
          id,
          init
        } = this.flowEnumMemberRaw(), memberName = id.name;
        if (memberName === "")
          continue;
        /^[a-z]/.test(memberName) && this.raise(FlowErrors.EnumInvalidMemberName, id, {
          memberName,
          suggestion: memberName[0].toUpperCase() + memberName.slice(1),
          enumName
        }), seenNames.has(memberName) && this.raise(FlowErrors.EnumDuplicateMemberName, id, {
          memberName,
          enumName
        }), seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        switch (memberNode.id = id, init.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean"), memberNode.init = init.value, members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number"), memberNode.init = init.value, members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string"), memberNode.init = init.value, members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
          case "none":
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                break;
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members,
        hasUnknownMembers
      };
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0)
        return defaultedMembers;
      if (defaultedMembers.length === 0)
        return initializedMembers;
      if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        return defaultedMembers;
      } else {
        for (const member of defaultedMembers)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        return initializedMembers;
      }
    }
    flowEnumParseExplicitType({
      enumName
    }) {
      if (!this.eatContextual(102)) return null;
      if (!tokenIsIdentifier(this.state.type))
        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName
        });
      const {
        value
      } = this.state;
      return this.next(), value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol" && this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
        enumName,
        invalidEnumType: value
      }), value;
    }
    flowEnumBody(node, id) {
      const enumName = id.name, nameLoc = id.loc.start, explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(5);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      switch (node.hasUnknownMembers = hasUnknownMembers, explicitType) {
        case "boolean":
          return node.explicitType = !0, node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
        case "number":
          return node.explicitType = !0, node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
        case "string":
          return node.explicitType = !0, node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          }), this.expect(8), this.finishNode(node, "EnumStringBody");
        case "symbol":
          return node.members = members.defaultedMembers, this.expect(8), this.finishNode(node, "EnumSymbolBody");
        default: {
          const empty2 = () => (node.members = [], this.expect(8), this.finishNode(node, "EnumStringBody"));
          node.explicitType = !1;
          const boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen)
            return empty2();
          if (!boolsLen && !numsLen)
            return node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            }), this.expect(8), this.finishNode(node, "EnumStringBody");
          if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            return node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            return node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
          } else
            return this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
              enumName
            }), empty2();
        }
      }
    }
    flowParseEnumDeclaration(node) {
      const id = this.parseIdentifier();
      return node.id = id, node.body = this.flowEnumBody(this.startNode(), id), this.finishNode(node, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(node) {
      return node.type === "TypeCastExpression" ? node.expression : node;
    }
  };
  const entities = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName
    }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected,
      HTMLEntity
    }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : !1;
  }
  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier")
      return object.name;
    if (object.type === "JSXNamespacedName")
      return object.namespace.name + ":" + object.name.name;
    if (object.type === "JSXMemberExpression")
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    throw new Error("Node had unexpected type: " + object.type);
  }
  var jsx2 = (superClass) => class extends superClass {
    jsxReadToken() {
      let out = "", chunkStart = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              ch === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(ch);
              return;
            }
            out += this.input.slice(chunkStart, this.state.pos), this.finishToken(142, out);
            return;
          case 38:
            out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!0), chunkStart = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      return ++this.state.pos, ch === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, out = normalizeCRLF ? `
` : `\r
`) : out = String.fromCharCode(ch), ++this.state.curLine, this.state.lineStart = this.state.pos, out;
    }
    jsxReadString(quote) {
      let out = "", chunkStart = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Errors.UnterminatedString, this.state.startLoc);
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;
        ch === 38 ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!1), chunkStart = this.state.pos) : ++this.state.pos;
      }
      out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(134, out);
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let radix = 10;
        this.codePointAtPos(this.state.pos) === 120 && (radix = 16, ++this.state.pos);
        const codePoint = this.readInt(radix, void 0, !1, "bail");
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(codePoint);
      } else {
        let count2 = 0, semi = !1;
        for (; count2++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos), entity = entities[desc];
          if (++this.state.pos, entity)
            return entity;
        }
      }
      return this.state.pos = startPos, "&";
    }
    jsxReadWord() {
      let ch;
      const start = this.state.pos;
      do
        ch = this.input.charCodeAt(++this.state.pos);
      while (isIdentifierChar(ch) || ch === 45);
      this.finishToken(141, this.input.slice(start, this.state.pos));
    }
    jsxParseIdentifier() {
      const node = this.startNode();
      return this.match(141) ? node.name = this.state.value : tokenIsKeyword(this.state.type) ? node.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(node, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
      if (!this.eat(14)) return name;
      const node = this.startNodeAt(startLoc);
      return node.namespace = name, node.name = this.jsxParseIdentifier(), this.finishNode(node, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const startLoc = this.state.startLoc;
      let node = this.jsxParseNamespacedName();
      if (node.type === "JSXNamespacedName")
        return node;
      for (; this.eat(16); ) {
        const newNode = this.startNodeAt(startLoc);
        newNode.object = node, newNode.property = this.jsxParseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    jsxParseAttributeValue() {
      let node;
      switch (this.state.type) {
        case 5:
          return node = this.startNode(), this.setContext(types2.brace), this.next(), node = this.jsxParseExpressionContainer(node, types2.j_oTag), node.expression.type === "JSXEmptyExpression" && this.raise(JsxErrors.AttributeIsEmpty, node), node;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const node = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(node) {
      return this.next(), node.expression = this.parseExpression(), this.setContext(types2.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(node, previousContext) {
      if (this.match(8))
        node.expression = this.jsxParseEmptyExpression();
      else {
        const expression = this.parseExpression();
        node.expression = expression;
      }
      return this.setContext(previousContext), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const node = this.startNode();
      return this.match(5) ? (this.setContext(types2.brace), this.next(), this.expect(21), node.argument = this.parseMaybeAssignAllowIn(), this.setContext(types2.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsxParseNamespacedName(), node.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(startLoc) {
      const node = this.startNodeAt(startLoc);
      return this.eat(144) ? this.finishNode(node, "JSXOpeningFragment") : (node.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(node));
    }
    jsxParseOpeningElementAfterName(node) {
      const attributes = [];
      for (; !this.match(56) && !this.match(144); )
        attributes.push(this.jsxParseAttribute());
      return node.attributes = attributes, node.selfClosing = this.eat(56), this.expect(144), this.finishNode(node, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(startLoc) {
      const node = this.startNodeAt(startLoc);
      return this.eat(144) ? this.finishNode(node, "JSXClosingFragment") : (node.name = this.jsxParseElementName(), this.expect(144), this.finishNode(node, "JSXClosingElement"));
    }
    jsxParseElementAt(startLoc) {
      const node = this.startNodeAt(startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (; ; )
          switch (this.state.type) {
            case 143:
              if (startLoc = this.state.startLoc, this.next(), this.eat(56)) {
                closingElement = this.jsxParseClosingElementAt(startLoc);
                break contents;
              }
              children.push(this.jsxParseElementAt(startLoc));
              break;
            case 142:
              children.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              const node2 = this.startNode();
              this.setContext(types2.brace), this.next(), this.match(21) ? children.push(this.jsxParseSpreadChild(node2)) : children.push(this.jsxParseExpressionContainer(node2, types2.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null ? this.raise(JsxErrors.MissingClosingTagFragment, closingElement) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
          openingTagName: getQualifiedJSXName(openingElement.name)
        }) : !isFragment(openingElement) && !isFragment(closingElement) && getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
          openingTagName: getQualifiedJSXName(openingElement.name)
        });
      }
      if (isFragment(openingElement) ? (node.openingFragment = openingElement, node.closingFragment = closingElement) : (node.openingElement = openingElement, node.closingElement = closingElement), node.children = children, this.match(47))
        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
    }
    jsxParseElement() {
      const startLoc = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(startLoc);
    }
    setContext(newContext) {
      const {
        context
      } = this.state;
      context[context.length - 1] = newContext;
    }
    parseExprAtom(refExpressionErrors) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(code2) {
      const context = this.curContext();
      if (context === types2.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (context === types2.j_oTag || context === types2.j_cTag) {
        if (isIdentifierStart(code2)) {
          this.jsxReadWord();
          return;
        }
        if (code2 === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((code2 === 34 || code2 === 39) && context === types2.j_oTag) {
          this.jsxReadString(code2);
          return;
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(code2);
    }
    updateContext(prevType) {
      const {
        context,
        type: type2
      } = this.state;
      if (type2 === 56 && prevType === 143)
        context.splice(-2, 2, types2.j_cTag), this.state.canStartJSXElement = !1;
      else if (type2 === 143)
        context.push(types2.j_oTag);
      else if (type2 === 144) {
        const out = context[context.length - 1];
        out === types2.j_oTag && prevType === 56 || out === types2.j_cTag ? (context.pop(), this.state.canStartJSXElement = context[context.length - 1] === types2.j_expr) : (this.setContext(types2.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = tokenComesBeforeExpression(type2);
    }
  };
  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args) {
      super(...args), this.importsStack = [];
    }
    createScope(flags) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(flags);
    }
    enter(flags) {
      flags === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(flags);
    }
    exit() {
      const flags = super.exit();
      return flags === 256 && this.importsStack.pop(), flags;
    }
    hasImport(name, allowShadow) {
      const len = this.importsStack.length;
      if (this.importsStack[len - 1].has(name))
        return !0;
      if (!allowShadow && len > 1) {
        for (let i = 0; i < len - 1; i++)
          if (this.importsStack[i].has(name)) return !0;
      }
      return !1;
    }
    declareName(name, bindingType, loc) {
      if (bindingType & 4096) {
        this.hasImport(name, !0) && this.parser.raise(Errors.VarRedeclaration, loc, {
          identifierName: name
        }), this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }
      const scope2 = this.currentScope();
      let type2 = scope2.tsNames.get(name) || 0;
      if (bindingType & 1024) {
        this.maybeExportDefined(scope2, name), scope2.tsNames.set(name, type2 | 16);
        return;
      }
      super.declareName(name, bindingType, loc), bindingType & 2 && (bindingType & 1 || (this.checkRedeclarationInScope(scope2, name, bindingType, loc), this.maybeExportDefined(scope2, name)), type2 = type2 | 1), bindingType & 256 && (type2 = type2 | 2), bindingType & 512 && (type2 = type2 | 4), bindingType & 128 && (type2 = type2 | 8), type2 && scope2.tsNames.set(name, type2);
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      const type2 = scope2.tsNames.get(name);
      if ((type2 & 2) > 0) {
        if (bindingType & 256) {
          const isConst = !!(bindingType & 512), wasConst = (type2 & 4) > 0;
          return isConst !== wasConst;
        }
        return !0;
      }
      return bindingType & 128 && (type2 & 8) > 0 ? scope2.names.get(name) & 2 ? !!(bindingType & 1) : !1 : bindingType & 2 && (type2 & 1) > 0 ? !0 : super.isRedeclaredInScope(scope2, name, bindingType);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      if (this.hasImport(name)) return;
      const len = this.scopeStack.length;
      for (let i = len - 1; i >= 0; i--) {
        const type2 = this.scopeStack[i].tsNames.get(name);
        if ((type2 & 1) > 0 || (type2 & 16) > 0)
          return;
      }
      super.checkLocalExport(id);
    }
  }
  const unwrapParenthesizedExpression = (node) => node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  class LValParser extends NodeUtils {
    toAssignable(node, isLHS = !1) {
      var _node$extra, _node$extra3;
      let parenthesized;
      switch ((node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) && (parenthesized = unwrapParenthesizedExpression(node), isLHS ? parenthesized.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node) : parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized) && this.raise(Errors.InvalidParenthesizedAssignment, node) : this.raise(Errors.InvalidParenthesizedAssignment, node)), node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (let i = 0, length = node.properties.length, last2 = length - 1; i < length; i++) {
            var _node$extra2;
            const prop = node.properties[i], isLast = i === last2;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS), isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc && this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const {
            key: key2,
            value
          } = node;
          this.isPrivateName(key2) && this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start), this.toAssignable(value, isLHS);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          node.type = "ArrayPattern", this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
          break;
        case "AssignmentExpression":
          node.operator !== "=" && this.raise(Errors.MissingEqInAssignment, node.left.loc.end), node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod")
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
      else if (prop.type === "SpreadElement") {
        prop.type = "RestElement";
        const arg = prop.argument;
        this.checkToRestConversion(arg, !1), this.toAssignable(arg, isLHS), isLast || this.raise(Errors.RestTrailingComma, prop);
      } else
        this.toAssignable(prop, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      const end = exprList.length - 1;
      for (let i = 0; i <= end; i++) {
        const elt = exprList[i];
        if (elt) {
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, !0), this.toAssignable(arg, isLHS);
          } else
            this.toAssignable(elt, isLHS);
          elt.type === "RestElement" && (i < end ? this.raise(Errors.RestTrailingComma, elt) : trailingCommaLoc && this.raise(Errors.RestTrailingComma, trailingCommaLoc));
        }
      }
    }
    isAssignable(node, isBinding) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          const last2 = node.properties.length - 1;
          return node.properties.every((prop, i) => prop.type !== "ObjectMethod" && (i === last2 || prop.type !== "SpreadElement") && this.isAssignable(prop));
        }
        case "ObjectProperty":
          return this.isAssignable(node.value);
        case "SpreadElement":
          return this.isAssignable(node.argument);
        case "ArrayExpression":
          return node.elements.every((element) => element === null || this.isAssignable(element));
        case "AssignmentExpression":
          return node.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;
        default:
          return !1;
      }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (const expr of exprList)
        expr?.type === "ArrayExpression" && this.toReferencedListDeep(expr.elements);
    }
    parseSpread(refExpressionErrors) {
      const node = this.startNode();
      return this.next(), node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0), this.finishNode(node, "SpreadElement");
    }
    parseRestBinding() {
      const node = this.startNode();
      return this.next(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const node = this.startNode();
          return this.next(), node.elements = this.parseBindingList(3, 93, 1), this.finishNode(node, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, flags) {
      const allowEmpty = flags & 1, elts = [];
      let first2 = !0;
      for (; !this.eat(close); )
        if (first2 ? first2 = !1 : this.expect(12), allowEmpty && this.match(12))
          elts.push(null);
        else {
          if (this.eat(close))
            break;
          if (this.match(21)) {
            let rest = this.parseRestBinding();
            if ((this.hasPlugin("flow") || flags & 2) && (rest = this.parseFunctionParamType(rest)), elts.push(rest), !this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              decorators.push(this.parseDecorator());
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
      return elts;
    }
    parseBindingRestProperty(prop) {
      return this.next(), prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(prop, "RestElement");
    }
    parseBindingProperty() {
      const {
        type: type2,
        startLoc
      } = this.state;
      if (type2 === 21)
        return this.parseBindingRestProperty(this.startNode());
      const prop = this.startNode();
      return type2 === 139 ? (this.expectPlugin("destructuringPrivate", startLoc), this.classScope.usePrivateName(this.state.value, startLoc), prop.key = this.parsePrivateName()) : this.parsePropertyName(prop), prop.method = !1, this.parseObjPropValue(prop, startLoc, !1, !1, !0, !1);
    }
    parseAssignableListItem(flags, decorators) {
      const left = this.parseMaybeDefault();
      (this.hasPlugin("flow") || flags & 2) && this.parseFunctionParamType(left);
      const elt = this.parseMaybeDefault(left.loc.start, left);
      return decorators.length && (left.decorators = decorators), elt;
    }
    parseFunctionParamType(param) {
      return param;
    }
    parseMaybeDefault(startLoc, left) {
      var _startLoc, _left;
      if ((_startLoc = startLoc) != null || (startLoc = this.state.startLoc), left = (_left = left) != null ? _left : this.parseBindingAtom(), !this.eat(29)) return left;
      const node = this.startNodeAt(startLoc);
      return node.left = left, node.right = this.parseMaybeAssignAllowIn(), this.finishNode(node, "AssignmentPattern");
    }
    isValidLVal(type2, isUnparenthesizedInAssign, binding) {
      switch (type2) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(expression) {
      return expression.type === "OptionalMemberExpression";
    }
    checkLVal(expression, ancestor, binding = 64, checkClashes = !1, strictModeChanged = !1, hasParenthesizedAncestor = !1) {
      var _expression$extra;
      const type2 = expression.type;
      if (this.isObjectMethod(expression)) return;
      const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
      if (isOptionalMemberExpression || type2 === "MemberExpression") {
        isOptionalMemberExpression && (this.expectPlugin("optionalChainingAssign", expression.loc.start), ancestor.type !== "AssignmentExpression" && this.raise(Errors.InvalidLhsOptionalChaining, expression, {
          ancestor
        })), binding !== 64 && this.raise(Errors.InvalidPropertyBindingPattern, expression);
        return;
      }
      if (type2 === "Identifier") {
        this.checkIdentifier(expression, binding, strictModeChanged);
        const {
          name
        } = expression;
        checkClashes && (checkClashes.has(name) ? this.raise(Errors.ParamDupe, expression) : checkClashes.add(name));
        return;
      }
      const validity = this.isValidLVal(type2, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
      if (validity === !0) return;
      if (validity === !1) {
        const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, expression, {
          ancestor
        });
        return;
      }
      let key2, isParenthesizedExpression;
      typeof validity == "string" ? (key2 = validity, isParenthesizedExpression = type2 === "ParenthesizedExpression") : [key2, isParenthesizedExpression] = validity;
      const nextAncestor = type2 === "ArrayPattern" || type2 === "ObjectPattern" ? {
        type: type2
      } : ancestor, val = expression[key2];
      if (Array.isArray(val))
        for (const child of val)
          child && this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
      else val && this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
    }
    checkIdentifier(at, bindingType, strictModeChanged = !1) {
      this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name)) && (bindingType === 64 ? this.raise(Errors.StrictEvalArguments, at, {
        referenceName: at.name
      }) : this.raise(Errors.StrictEvalArgumentsBinding, at, {
        bindingName: at.name
      })), bindingType & 8192 && at.name === "let" && this.raise(Errors.LetInLexicalBinding, at), bindingType & 64 || this.declareNameFromIdentifier(at, bindingType);
    }
    declareNameFromIdentifier(identifier, binding) {
      this.scope.declareName(identifier.name, binding, identifier.loc.start);
    }
    checkToRestConversion(node, allowPattern) {
      switch (node.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node.expression, allowPattern);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern) break;
        default:
          this.raise(Errors.InvalidRestAssignmentPattern, node);
      }
    }
    checkCommaAfterRest(close) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }
  function nonNull(x) {
    if (x == null)
      throw new Error(`Unexpected ${x} value.`);
    return x;
  }
  function assert(x) {
    if (!x)
      throw new Error("Assert fail");
  }
  const TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({
      methodName
    }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName
    }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind
    }) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier
    }) => "Accessibility modifier already seen.",
    DuplicateModifier: ({
      modifier
    }) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({
      token: token2
    }) => `'${token2}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers
    }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier
    }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier
    }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({
      orderedModifiers
    }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier
    }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName
    }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type: type2
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type2}.`
  });
  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }
  function tsIsVarianceAnnotations(modifier) {
    return modifier === "in" || modifier === "out";
  }
  var typescript2 = (superClass) => class extends superClass {
    constructor(...args) {
      super(...args), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }
    tsIsIdentifier() {
      return tokenIsIdentifier(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
      if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      const modifier = this.state.value;
      if (allowedModifiers.includes(modifier)) {
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return modifier;
      }
    }
    tsParseModifiers({
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors.InvalidModifierOnTypeMember
    }, modified) {
      const enforceOrder = (loc, modifier, before, after) => {
        modifier === before && modified[after] && this.raise(TSErrors.InvalidModifiersOrder, loc, {
          orderedModifiers: [before, after]
        });
      }, incompatible = (loc, modifier, mod1, mod2) => {
        (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) && this.raise(TSErrors.IncompatibleModifiers, loc, {
          modifiers: [mod1, mod2]
        });
      };
      for (; ; ) {
        const {
          startLoc
        } = this.state, modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock);
        if (!modifier) break;
        tsIsAccessModifier(modifier) ? modified.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
          modifier
        }) : (enforceOrder(startLoc, modifier, modifier, "override"), enforceOrder(startLoc, modifier, modifier, "static"), enforceOrder(startLoc, modifier, modifier, "readonly"), modified.accessibility = modifier) : tsIsVarianceAnnotations(modifier) ? (modified[modifier] && this.raise(TSErrors.DuplicateModifier, startLoc, {
          modifier
        }), modified[modifier] = !0, enforceOrder(startLoc, modifier, "in", "out")) : (hasOwnProperty.call(modified, modifier) ? this.raise(TSErrors.DuplicateModifier, startLoc, {
          modifier
        }) : (enforceOrder(startLoc, modifier, "static", "readonly"), enforceOrder(startLoc, modifier, "static", "override"), enforceOrder(startLoc, modifier, "override", "readonly"), enforceOrder(startLoc, modifier, "abstract", "override"), incompatible(startLoc, modifier, "declare", "override"), incompatible(startLoc, modifier, "static", "abstract")), modified[modifier] = !0), disallowedModifiers != null && disallowedModifiers.includes(modifier) && this.raise(errorTemplate, startLoc, {
          modifier
        });
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(kind, parseElement) {
      const result = [];
      for (; !this.tsIsListTerminator(kind); )
        result.push(parseElement());
      return result;
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, !0, refTrailingCommaPos));
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = [];
      let trailingCommaPos = -1;
      for (; !this.tsIsListTerminator(kind); ) {
        trailingCommaPos = -1;
        const element = parseElement();
        if (element == null)
          return;
        if (result.push(element), this.eat(12)) {
          trailingCommaPos = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(kind))
          break;
        expectSuccess && this.expect(12);
        return;
      }
      return refTrailingCommaPos && (refTrailingCommaPos.value = trailingCommaPos), result;
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      skipFirstToken || (bracket ? this.expect(0) : this.expect(47));
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
      return bracket ? this.expect(3) : this.expect(48), result;
    }
    tsParseImportType() {
      const node = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) || this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc), node.argument = super.parseExprAtom(), this.eat(12) && !this.match(11) ? (node.options = super.parseMaybeAssignAllowIn(), this.eat(12)) : node.options = null, this.expect(11), this.eat(16) && (node.qualifier = this.tsParseEntityName()), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSImportType");
    }
    tsParseEntityName(allowReservedWords = !0) {
      let entity = this.parseIdentifier(allowReservedWords);
      for (; this.eat(16); ) {
        const node = this.startNodeAtNode(entity);
        node.left = entity, node.right = this.parseIdentifier(allowReservedWords), entity = this.finishNode(node, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference() {
      const node = this.startNode();
      return node.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs) {
      this.next();
      const node = this.startNodeAtNode(lhs);
      return node.parameterName = lhs, node.typeAnnotation = this.tsParseTypeAnnotation(!1), node.asserts = !1, this.finishNode(node, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const node = this.startNode();
      return this.next(), this.finishNode(node, "TSThisType");
    }
    tsParseTypeQuery() {
      const node = this.startNode();
      return this.expect(87), this.match(83) ? node.exprName = this.tsParseImportType() : node.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeQuery");
    }
    tsParseTypeParameter(parseModifiers) {
      const node = this.startNode();
      return parseModifiers(node), node.name = this.tsParseTypeParameterName(), node.constraint = this.tsEatThenParseType(81), node.default = this.tsEatThenParseType(29), this.finishNode(node, "TSTypeParameter");
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47))
        return this.tsParseTypeParameters(parseModifiers);
    }
    tsParseTypeParameters(parseModifiers) {
      const node = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      const refTrailingCommaPos = {
        value: -1
      };
      return node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), !1, !0, refTrailingCommaPos), node.params.length === 0 && this.raise(TSErrors.EmptyTypeParameters, node), refTrailingCommaPos.value !== -1 && this.addExtra(node, "trailingComma", refTrailingCommaPos.value), this.finishNode(node, "TSTypeParameterDeclaration");
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19, paramsKey = "parameters", returnTypeKey = "typeAnnotation";
      signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), signature[paramsKey] = this.tsParseBindingListForSignature(), returnTokenRequired ? signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken) : this.match(returnToken) && (signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
    }
    tsParseBindingListForSignature() {
      const list2 = super.parseBindingList(11, 41, 2);
      for (const pattern of list2) {
        const {
          type: type2
        } = pattern;
        (type2 === "AssignmentPattern" || type2 === "TSParameterProperty") && this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
          type: type2
        });
      }
      return list2;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(kind, node) {
      return this.tsFillSignature(14, node), this.tsParseTypeMemberSemicolon(), this.finishNode(node, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), tokenIsIdentifier(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(node) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(3), node.parameters = [id];
      const type2 = this.tsTryParseTypeAnnotation();
      return type2 && (node.typeAnnotation = type2), this.tsParseTypeMemberSemicolon(), this.finishNode(node, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(node, readonly) {
      this.eat(17) && (node.optional = !0);
      const nodeAny = node;
      if (this.match(10) || this.match(47)) {
        readonly && this.raise(TSErrors.ReadonlyForMethodSignature, node);
        const method = nodeAny;
        method.kind && this.match(47) && this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, method), this.tsParseTypeMemberSemicolon();
        const paramsKey = "parameters", returnTypeKey = "typeAnnotation";
        if (method.kind === "get")
          method[paramsKey].length > 0 && (this.raise(Errors.BadGetterArity, this.state.curPosition()), this.isThisParam(method[paramsKey][0]) && this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition()));
        else if (method.kind === "set") {
          if (method[paramsKey].length !== 1)
            this.raise(Errors.BadSetterArity, this.state.curPosition());
          else {
            const firstParameter = method[paramsKey][0];
            this.isThisParam(firstParameter) && this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition()), firstParameter.type === "Identifier" && firstParameter.optional && this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), firstParameter.type === "RestElement" && this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          method[returnTypeKey] && this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
        } else
          method.kind = "method";
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = nodeAny;
        readonly && (property.readonly = !0);
        const type2 = this.tsTryParseTypeAnnotation();
        return type2 && (property.typeAnnotation = type2), this.tsParseTypeMemberSemicolon(), this.finishNode(property, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const node = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
      if (this.match(77)) {
        const id = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node) : (node.key = this.createIdentifier(id, "new"), this.tsParsePropertyOrMethodSignature(node, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, node);
      const idx = this.tsTryParseIndexSignature(node);
      return idx || (super.parsePropertyName(node), !node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier() && (node.kind = node.key.name, super.parsePropertyName(node)), this.tsParsePropertyOrMethodSignature(node, !!node.readonly));
    }
    tsParseTypeLiteral() {
      const node = this.startNode();
      return node.members = this.tsParseObjectTypeMembers(), this.finishNode(node, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), members;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      const node = this.startNode();
      this.expect(5), this.match(53) ? (node.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (node.readonly = !0), this.expect(0);
      {
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName(), typeParameter.constraint = this.tsExpectThenParseType(58), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      }
      return node.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (node.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (node.optional = !0), node.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(node, "TSMappedType");
    }
    tsParseTupleType() {
      const node = this.startNode();
      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let seenOptionalElement = !1;
      return node.elementTypes.forEach((elementNode) => {
        const {
          type: type2
        } = elementNode;
        seenOptionalElement && type2 !== "TSRestType" && type2 !== "TSOptionalType" && !(type2 === "TSNamedTupleMember" && elementNode.optional) && this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode), seenOptionalElement || (seenOptionalElement = type2 === "TSNamedTupleMember" && elementNode.optional || type2 === "TSOptionalType");
      }), this.finishNode(node, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        startLoc
      } = this.state, rest = this.eat(21);
      let labeled, label, optional, type2;
      const chAfterWord = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
      if (chAfterWord === 58)
        labeled = !0, optional = !1, label = this.parseIdentifier(!0), this.expect(14), type2 = this.tsParseType();
      else if (chAfterWord === 63) {
        optional = !0;
        const startLoc2 = this.state.startLoc, wordName = this.state.value, typeOrLabel = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (labeled = !0, label = this.createIdentifier(this.startNodeAt(startLoc2), wordName), this.expect(17), this.expect(14), type2 = this.tsParseType()) : (labeled = !1, type2 = typeOrLabel, this.expect(17));
      } else
        type2 = this.tsParseType(), optional = this.eat(17), labeled = this.eat(14);
      if (labeled) {
        let labeledNode;
        label ? (labeledNode = this.startNodeAtNode(label), labeledNode.optional = optional, labeledNode.label = label, labeledNode.elementType = type2, this.eat(17) && (labeledNode.optional = !0, this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (labeledNode = this.startNodeAtNode(type2), labeledNode.optional = optional, this.raise(TSErrors.InvalidTupleMemberLabel, type2), labeledNode.label = type2, labeledNode.elementType = this.tsParseType()), type2 = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type2);
        optionalTypeNode.typeAnnotation = type2, type2 = this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      if (rest) {
        const restNode = this.startNodeAt(startLoc);
        restNode.typeAnnotation = type2, type2 = this.finishNode(restNode, "TSRestType");
      }
      return type2;
    }
    tsParseParenthesizedType() {
      const node = this.startNode();
      return this.expect(10), node.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(node, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(type2, abstract) {
      const node = this.startNode();
      return type2 === "TSConstructorType" && (node.abstract = !!abstract, abstract && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node)), this.finishNode(node, type2);
    }
    tsParseLiteralTypeNode() {
      const node = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          node.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(node, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const node = this.startNode();
      return node.literal = super.parseTemplate(!1), this.finishNode(node, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const node = this.startNode(), nextToken = this.lookahead();
            return nextToken.type !== 135 && nextToken.type !== 136 && this.unexpected(), node.literal = this.parseMaybeUnary(), this.finishNode(node, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: type2
          } = this.state;
          if (tokenIsIdentifier(type2) || type2 === 88 || type2 === 84) {
            const nodeType = type2 === 88 ? "TSVoidKeyword" : type2 === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
            if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
              const node = this.startNode();
              return this.next(), this.finishNode(node, nodeType);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let type2 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const node = this.startNodeAtNode(type2);
          node.elementType = type2, this.expect(3), type2 = this.finishNode(node, "TSArrayType");
        } else {
          const node = this.startNodeAtNode(type2);
          node.objectType = type2, node.indexType = this.tsParseType(), this.expect(3), type2 = this.finishNode(node, "TSIndexedAccessType");
        }
      return type2;
    }
    tsParseTypeOperator() {
      const node = this.startNode(), operator = this.state.value;
      return this.next(), node.operator = operator, node.typeAnnotation = this.tsParseTypeOperatorOrHigher(), operator === "readonly" && this.tsCheckTypeAnnotationForReadOnly(node), this.finishNode(node, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(node) {
      switch (node.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(TSErrors.UnexpectedReadonly, node);
      }
    }
    tsParseInferType() {
      const node = this.startNode();
      this.expectContextual(115);
      const typeParameter = this.startNode();
      return typeParameter.name = this.tsParseTypeParameterName(), typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), this.finishNode(node, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return constraint;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node = this.startNode(), hasLeadingOperator = this.eat(operator), types3 = [];
      do
        types3.push(parseConstituentType());
      while (this.eat(operator));
      return types3.length === 1 && !hasLeadingOperator ? types3[0] : (node.types = types3, this.finishNode(node, kind));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        const {
          errors
        } = this.state, previousErrorCount = errors.length;
        try {
          return this.parseObjectLike(8, !0), errors.length === previousErrorCount;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors
        } = this.state, previousErrorCount = errors.length;
        try {
          return super.parseBindingList(3, 93, 1), errors.length === previousErrorCount;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node = this.startNode(), asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
          return thisTypePredicate.type === "TSThisType" ? (node.parameterName = thisTypePredicate, node.asserts = !0, node.typeAnnotation = null, thisTypePredicate = this.finishNode(node, "TSTypePredicate")) : (this.resetStartLocationFromNode(thisTypePredicate, node), thisTypePredicate.asserts = !0), t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
        }
        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable)
          return asserts ? (node.parameterName = this.parseIdentifier(), node.asserts = asserts, node.typeAnnotation = null, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
        const type2 = this.tsParseTypeAnnotation(!1);
        return node.parameterName = typePredicateVariable, node.typeAnnotation = type2, node.asserts = asserts, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), id;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      const containsEsc = this.state.containsEsc;
      return this.next(), !tokenIsIdentifier(this.state.type) && !this.match(78) ? !1 : (containsEsc && this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(eatColon = !0, t = this.startNode()) {
      return this.tsInType(() => {
        eatColon && this.expect(14), t.typeAnnotation = this.tsParseType();
      }), this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      assert(this.state.inType);
      const type2 = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return type2;
      const node = this.startNodeAtNode(type2);
      return node.checkType = type2, node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(node, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
      const node = this.startNode();
      return node.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), node.expression = this.parseMaybeUnary(), this.finishNode(node, "TSTypeAssertion");
    }
    tsParseHeritageClause(token2) {
      const originalStartLoc = this.state.startLoc, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const node = this.startNode();
        return node.expression = this.tsParseEntityName(), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSExpressionWithTypeArguments");
      });
      return delimitedList.length || this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
        token: token2
      }), delimitedList;
    }
    tsParseInterfaceDeclaration(node, properties = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), properties.declare && (node.declare = !0), tokenIsIdentifier(this.state.type) ? (node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 130)) : (node.id = null, this.raise(TSErrors.MissingInterfaceName, this.state.startLoc)), node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (node.extends = this.tsParseHeritageClause("extends"));
      const body = this.startNode();
      return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node.body = this.finishNode(body, "TSInterfaceBody"), this.finishNode(node, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(node) {
      return node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 2), node.typeAnnotation = this.tsInType(() => {
        if (node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          const node2 = this.startNode();
          return this.next(), this.finishNode(node2, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(node, "TSTypeAliasDeclaration");
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];
      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = !0;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsEatThenParseType(token2) {
      if (this.match(token2))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(token2) {
      return this.tsInType(() => (this.expect(token2), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const node = this.startNode();
      return node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (node.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(node, "TSEnumMember");
    }
    tsParseEnumDeclaration(node, properties = {}) {
      return properties.const && (node.const = !0), properties.declare && (node.declare = !0), this.expectContextual(126), node.id = this.parseIdentifier(), this.checkIdentifier(node.id, node.const ? 8971 : 8459), this.expect(5), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(node, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const node = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(node.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(node, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(node, nested = !1) {
      if (node.id = this.parseIdentifier(), nested || this.checkIdentifier(node.id, 1024), this.eat(16)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, !0), node.body = inner;
      } else
        this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(node) {
      return this.isContextual(112) ? (node.kind = "global", node.global = !0, node.id = this.parseIdentifier()) : this.match(134) ? (node.kind = "module", node.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
      node.isExport = isExport || !1, node.id = maybeDefaultIdentifier || this.parseIdentifier(), this.checkIdentifier(node.id, 4096), this.expect(29);
      const moduleReference = this.tsParseModuleReference();
      return node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference" && this.raise(TSErrors.ImportAliasHasImportType, moduleReference), node.moduleReference = moduleReference, this.semicolon(), this.finishNode(node, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      const node = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), node.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(node, "TSExternalModuleReference");
    }
    tsLookAhead(f) {
      const state = this.state.clone(), res = f();
      return this.state = state, res;
    }
    tsTryParseAndCatch(f) {
      const result = this.tryParse((abort) => f() || abort());
      if (!(result.aborted || !result.node))
        return result.error && (this.state = result.failState), result.node;
    }
    tsTryParse(f) {
      const state = this.state.clone(), result = f();
      if (result !== void 0 && result !== !1)
        return result;
      this.state = state;
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator())
        return;
      let startType = this.state.type, kind;
      return this.isContextual(100) && (startType = 74, kind = "let"), this.tsInAmbientContext(() => {
        switch (startType) {
          case 68:
            return nany.declare = !0, super.parseFunctionStatement(nany, !1, !1);
          case 80:
            return nany.declare = !0, this.parseClass(nany, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(nany, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (nany.declare = !0, this.parseVarStatement(nany, kind || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(nany, {
              const: !0,
              declare: !0
            }));
          case 129: {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: !0
            });
            if (result) return result;
          }
          default:
            if (tokenIsIdentifier(startType))
              return this.tsParseDeclaration(nany, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(node, expr, decorators) {
      switch (expr.name) {
        case "declare": {
          const declaration = this.tsTryParseDeclare(node);
          return declaration && (declaration.declare = !0), declaration;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const mod = node;
            return mod.kind = "global", node.global = !0, mod.id = expr, mod.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(mod, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(node, expr.name, !1, decorators);
      }
    }
    tsParseDeclaration(node, value, next, decorators) {
      switch (value) {
        case "abstract":
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type)))
            return this.tsParseAbstractDeclaration(node, decorators);
          break;
        case "module":
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(node);
            if (tokenIsIdentifier(this.state.type))
              return node.kind = "module", this.tsParseModuleOrNamespaceDeclaration(node);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
            return node.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(node);
          break;
        case "type":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
            return this.tsParseTypeAliasDeclaration(node);
          break;
      }
    }
    tsCheckLineTerminator(next) {
      return next ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(startLoc) {
      if (!this.match(47)) return;
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      const res = this.tsTryParseAndCatch(() => {
        const node = this.startNodeAt(startLoc);
        return node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(node), node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), node;
      });
      if (this.state.maybeInArrowParameters = oldMaybeInArrowParameters, !!res)
        return super.parseArrowExpression(res, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const node = this.startNode();
      return node.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), node.params.length === 0 ? this.raise(TSErrors.EmptyTypeArguments, node) : !this.state.inType && this.curContext() === types2.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(node, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(flags, decorators) {
      const startLoc = this.state.startLoc, modified = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, modified);
      const accessibility = modified.accessibility, override = modified.override, readonly = modified.readonly;
      !(flags & 4) && (accessibility || readonly || override) && this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
      const left = this.parseMaybeDefault();
      flags & 2 && this.parseFunctionParamType(left);
      const elt = this.parseMaybeDefault(left.loc.start, left);
      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startLoc);
        return decorators.length && (pp.decorators = decorators), accessibility && (pp.accessibility = accessibility), readonly && (pp.readonly = readonly), override && (pp.override = override), elt.type !== "Identifier" && elt.type !== "AssignmentPattern" && this.raise(TSErrors.UnsupportedParameterPropertyKind, pp), pp.parameter = elt, this.finishNode(pp, "TSParameterProperty");
      }
      return decorators.length && (left.decorators = decorators), elt;
    }
    isSimpleParameter(node) {
      return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
    }
    tsDisallowOptionalPattern(node) {
      for (const param of node.params)
        param.type !== "Identifier" && param.optional && !this.state.isAmbientContext && this.raise(TSErrors.PatternIsOptional, param);
    }
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
      super.setArrowFunctionParameters(node, params, trailingCommaLoc), this.tsDisallowOptionalPattern(node);
    }
    parseFunctionBodyAndFinish(node, type2, isMethod = !1) {
      this.match(14) && (node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const bodilessType = type2 === "FunctionDeclaration" ? "TSDeclareFunction" : type2 === "ClassMethod" || type2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return bodilessType && !this.match(5) && this.isLineTerminator() ? this.finishNode(node, bodilessType) : bodilessType === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, node), node.declare) ? super.parseFunctionBodyAndFinish(node, bodilessType, isMethod) : (this.tsDisallowOptionalPattern(node), super.parseFunctionBodyAndFinish(node, type2, isMethod));
    }
    registerFunctionStatementId(node) {
      !node.body && node.id ? this.checkIdentifier(node.id, 1024) : super.registerFunctionStatementId(node);
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node) => {
        node?.type === "TSTypeCastExpression" && this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
      });
    }
    toReferencedList(exprList, isInParens) {
      return this.tsCheckForInvalidTypeCasts(exprList), exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      return node.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(node.elements), node;
    }
    parseSubscript(base2, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        const nonNullExpression = this.startNodeAt(startLoc);
        return nonNullExpression.expression = base2, this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      let isOptionalCall = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls)
          return state.stop = !0, base2;
        state.optionalChainMember = isOptionalCall = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc;
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base2)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
            if (asyncArrowFn)
              return asyncArrowFn;
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (!typeArguments) return;
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition();
            return;
          }
          if (tokenIsTemplate(this.state.type)) {
            const result2 = super.parseTaggedTemplateExpression(base2, startLoc, state);
            return result2.typeParameters = typeArguments, result2;
          }
          if (!noCalls && this.eat(10)) {
            const node2 = this.startNodeAt(startLoc);
            return node2.callee = base2, node2.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(node2.arguments), node2.typeParameters = typeArguments, state.optionalChainMember && (node2.optional = isOptionalCall), this.finishCallExpression(node2, state.optionalChainMember);
          }
          const tokenType = this.state.type;
          if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak())
            return;
          const node = this.startNodeAt(startLoc);
          return node.expression = base2, node.typeParameters = typeArguments, this.finishNode(node, "TSInstantiationExpression");
        });
        if (missingParenErrorLoc && this.unexpected(missingParenErrorLoc, 10), result)
          return result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), result;
      }
      return super.parseSubscript(base2, startLoc, noCalls, state);
    }
    parseNewCallee(node) {
      var _callee$extra;
      super.parseNewCallee(node);
      const {
        callee
      } = node;
      callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized) && (node.typeParameters = callee.typeParameters, node.callee = callee.expression);
    }
    parseExprOp(left, leftStartLoc, minPrec) {
      let isSatisfies;
      if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
        const node = this.startNodeAt(leftStartLoc);
        return node.expression = left, node.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (isSatisfies && this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(node, leftStartLoc, minPrec);
      }
      return super.parseExprOp(left, leftStartLoc, minPrec);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      this.state.isAmbientContext || super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    }
    checkImportReflection(node) {
      super.checkImportReflection(node), node.module && node.importKind !== "value" && this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport)) return !0;
      if (this.isContextual(130)) {
        const ch = this.lookaheadCharCode();
        return isExport ? ch === 123 || ch === 42 : ch !== 61;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node, isExport, phase, loc) {
      super.applyImportPhase(node, isExport, phase, loc), isExport ? node.exportKind = phase === "type" ? "type" : "value" : node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    }
    parseImport(node) {
      if (this.match(134))
        return node.importKind = "value", super.parseImport(node);
      let importNode;
      if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61)
        return node.importKind = "value", this.tsParseImportEqualsDeclaration(node);
      if (this.isContextual(130)) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
      } else
        importNode = super.parseImport(node);
      return importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode), importNode;
    }
    parseExport(node, decorators) {
      if (this.match(83)) {
        this.next();
        const nodeImportEquals = node;
        let maybeDefaultIdentifier = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, !1) : nodeImportEquals.importKind = "value", this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, !0);
      } else if (this.eat(29)) {
        const assign = node;
        return assign.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const decl = node;
        return this.expectContextual(128), decl.id = this.parseIdentifier(), this.semicolon(), this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(node, decorators);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        return this.next(), cls.abstract = !0, this.parseClass(cls, !0, !0);
      }
      if (this.match(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result) return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(node, kind, allowMissingInitializer = !1) {
      const {
        isAmbientContext
      } = this.state, declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
      if (!isAmbientContext) return declaration;
      for (const {
        id,
        init
      } of declaration.declarations)
        init && (kind !== "const" || id.typeAnnotation ? this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init) : isValidAmbientConstInitializer(init, this.hasPlugin("estree")) || this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init));
      return declaration;
    }
    parseStatementContent(flags, decorators) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const node = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(node, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result) return result;
      }
      return super.parseStatementContent(flags, decorators);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => tsIsAccessModifier(modifier) ? member.accessibility === modifier : !!member[modifier]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(classBody, member, state) {
      const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: modifiers,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }, member);
      const callParseClassMemberWithIsStatic = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(member, modifiers) && this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(classBody, member)) : this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
      };
      member.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);
      if (idx) {
        classBody.body.push(idx), member.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, member), member.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
          modifier: member.accessibility
        }), member.declare && this.raise(TSErrors.IndexSignatureHasDeclare, member), member.override && this.raise(TSErrors.IndexSignatureHasOverride, member);
        return;
      }
      !this.state.inAbstractClass && member.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member), member.override && (state.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, member)), super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parsePostMemberNameModifiers(methodOrProp) {
      this.eat(17) && (methodOrProp.optional = !0), methodOrProp.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp), methodOrProp.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
    }
    parseExpressionStatement(node, expr, decorators) {
      return (expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0) || super.parseExpressionStatement(node, expr, decorators);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      const result = this.tryParse(() => super.parseConditional(expr, startLoc));
      return result.node ? (result.error && (this.state = result.failState), result.node) : (result.error && super.setOptionalParametersError(refExpressionErrors, result.error), expr);
    }
    parseParenItem(node, startLoc) {
      const newNode = super.parseParenItem(node, startLoc);
      if (this.eat(17) && (newNode.optional = !0, this.resetEndLocation(node)), this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node;
    }
    parseExportDeclaration(node) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
      const startLoc = this.state.startLoc, isDeclare = this.eatContextual(125);
      if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const declaration = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
      return declaration ? ((declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) && (node.exportKind = "type"), isDeclare && (this.resetStartLocation(declaration, startLoc), declaration.declare = !0), declaration) : null;
    }
    parseClassId(node, isStatement, optionalId, bindingType) {
      if ((!isStatement || optionalId) && this.isContextual(113))
        return;
      super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      typeParameters && (node.typeParameters = typeParameters);
    }
    parseClassPropertyAnnotation(node) {
      node.optional || (this.eat(35) ? node.definite = !0 : this.eat(17) && (node.optional = !0));
      const type2 = this.tsTryParseTypeAnnotation();
      type2 && (node.typeAnnotation = type2);
    }
    parseClassProperty(node) {
      if (this.parseClassPropertyAnnotation(node), this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc), node.abstract && this.match(29)) {
        const {
          key: key2
        } = node;
        this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: key2.type === "Identifier" && !node.computed ? key2.name : `[${this.input.slice(this.offsetToSourcePos(key2.start), this.offsetToSourcePos(key2.end))}]`
        });
      }
      return super.parseClassProperty(node);
    }
    parseClassPrivateProperty(node) {
      return node.abstract && this.raise(TSErrors.PrivateElementHasAbstract, node), node.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, node, {
        modifier: node.accessibility
      }), this.parseClassPropertyAnnotation(node), super.parseClassPrivateProperty(node);
    }
    parseClassAccessorProperty(node) {
      return this.parseClassPropertyAnnotation(node), node.optional && this.raise(TSErrors.AccessorCannotBeOptional, node), super.parseClassAccessorProperty(node);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      typeParameters && isConstructor && this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
      const {
        declare = !1,
        kind
      } = method;
      declare && (kind === "get" || kind === "set") && this.raise(TSErrors.DeclareAccessor, method, {
        kind
      }), typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    declareClassPrivateMethodInScope(node, kind) {
      node.type !== "TSDeclareMethod" && (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body") || super.declareClassPrivateMethodInScope(node, kind));
    }
    parseClassSuper(node) {
      super.parseClassSuper(node), node.superClass && (this.match(47) || this.match(51)) && (node.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (node.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    }
    parseFunctionParams(node, isConstructor) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      typeParameters && (node.typeParameters = typeParameters), super.parseFunctionParams(node, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind), decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (decl.definite = !0);
      const type2 = this.tsTryParseTypeAnnotation();
      type2 && (decl.id.typeAnnotation = type2, this.resetEndLocation(decl.id));
    }
    parseAsyncArrowFromCallExpression(node, call) {
      return this.match(14) && (node.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(node, call);
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
      let state, jsx3, typeCast;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (state = this.state.clone(), jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx3.error) return jsx3.node;
        const {
          context
        } = this.state, currentContext = context[context.length - 1];
        (currentContext === types2.j_oTag || currentContext === types2.j_expr) && context.pop();
      }
      if (!((_jsx = jsx3) != null && _jsx.error) && !this.match(47))
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      (!state || state === this.state) && (state = this.state.clone());
      let typeParameters;
      const arrow4 = this.tryParse((abort) => {
        var _expr$extra, _typeParameters;
        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        return (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && abort(), ((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0 && this.resetStartLocationFromNode(expr, typeParameters), expr.typeParameters = typeParameters, expr;
      }, state);
      if (!arrow4.error && !arrow4.aborted)
        return typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow4.node;
      if (!jsx3 && (assert(!this.hasPlugin("jsx")), typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !typeCast.error))
        return typeCast.node;
      if ((_jsx2 = jsx3) != null && _jsx2.node)
        return this.state = jsx3.failState, jsx3.node;
      if (arrow4.node)
        return this.state = arrow4.failState, typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow4.node;
      if ((_typeCast = typeCast) != null && _typeCast.node)
        return this.state = typeCast.failState, typeCast.node;
      throw ((_jsx3 = jsx3) == null ? void 0 : _jsx3.error) || arrow4.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
    }
    reportReservedArrowTypeParam(node) {
      var _node$extra;
      node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedArrowTypeParam, node);
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    parseArrow(node) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && abort(), returnType;
        });
        if (result.aborted) return;
        result.thrown || (result.error && (this.state = result.failState), node.returnType = result.node);
      }
      return super.parseArrow(node);
    }
    parseFunctionParamType(param) {
      this.eat(17) && (param.optional = !0);
      const type2 = this.tsTryParseTypeAnnotation();
      return type2 && (param.typeAnnotation = type2), this.resetEndLocation(param), param;
    }
    isAssignable(node, isBinding) {
      switch (node.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(node.expression, isBinding);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(node, isBinding);
      }
    }
    toAssignable(node, isLHS = !1) {
      switch (node.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(node, isLHS);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          isLHS ? this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node) : this.raise(TSErrors.UnexpectedTypeCastInParameter, node), this.toAssignable(node.expression, isLHS);
          break;
        case "AssignmentExpression":
          !isLHS && node.left.type === "TSTypeCastExpression" && (node.left = this.typeCastToParameter(node.left));
        default:
          super.toAssignable(node, isLHS);
      }
    }
    toAssignableParenthesizedExpression(node, isLHS) {
      switch (node.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isLHS);
          break;
        default:
          super.toAssignable(node, isLHS);
      }
    }
    checkToRestConversion(node, allowPattern) {
      switch (node.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(node.expression, !1);
          break;
        default:
          super.checkToRestConversion(node, allowPattern);
      }
    }
    isValidLVal(type2, isUnparenthesizedInAssign, binding) {
      switch (type2) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
        case "TSInstantiationExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", !0];
        default:
          return super.isValidLVal(type2, isUnparenthesizedInAssign, binding);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          return call.typeParameters = typeArguments, call;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(expr);
    }
    checkCommaAfterRest(close) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close ? (this.next(), !1) : super.checkCommaAfterRest(close);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(startLoc, left) {
      const node = super.parseMaybeDefault(startLoc, left);
      return node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation), node;
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (code2 === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(code2);
    }
    reScan_lt_gt() {
      const {
        type: type2
      } = this.state;
      type2 === 47 ? (this.state.pos -= 1, this.readToken_lt()) : type2 === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: type2
      } = this.state;
      return type2 === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : type2;
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        expr?.type === "TSTypeCastExpression" && (exprList[i] = this.typeCastToParameter(expr));
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    typeCastToParameter(node) {
      return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
    }
    shouldParseArrow(params) {
      return this.match(14) ? params.every((expr) => this.isAssignable(expr, !0)) : super.shouldParseArrow(params);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(node) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        typeArguments && (node.typeParameters = typeArguments);
      }
      return super.jsxParseOpeningElementAfterName(node);
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = this.getObjectOrClassMethodParams(method)[0];
      return firstParam && this.isThisParam(firstParam) ? baseCount + 1 : baseCount;
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam(), type2 = this.tsTryParseTypeAnnotation();
      return type2 && (param.typeAnnotation = type2, this.resetEndLocation(param)), param;
    }
    tsInAmbientContext(cb) {
      const {
        isAmbientContext: oldIsAmbientContext,
        strict: oldStrict
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext, this.state.strict = oldStrict;
      }
    }
    parseClass(node, isStatement, optionalId) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node.abstract;
      try {
        return super.parseClass(node, isStatement, optionalId);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }
    tsParseAbstractDeclaration(node, decorators) {
      if (this.match(80))
        return node.abstract = !0, this.maybeTakeDecorators(decorators, this.parseClass(node, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return node.abstract = !0, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node), this.tsParseInterfaceDeclaration(node);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope) {
      const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope);
      if (method.abstract && (this.hasPlugin("estree") ? !!method.value.body : !!method.body)) {
        const {
          key: key2
        } = method;
        this.raise(TSErrors.AbstractMethodHasImplementation, method, {
          methodName: key2.type === "Identifier" && !method.computed ? key2.name : `[${this.input.slice(this.offsetToSourcePos(key2.start), this.offsetToSourcePos(key2.end))}]`
        });
      }
      return method;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
      return !isString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(node, !1, isInTypeExport), this.finishNode(node, "ExportSpecifier")) : (node.exportKind = "value", super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      return !importedIsString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(specifier, !0, isInTypeOnlyImport), this.finishNode(specifier, "ImportSpecifier")) : (specifier.importKind = "value", super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport ? "imported" : "local", rightOfAsKey = isImport ? "local" : "exported";
      let leftOfAs = node[leftOfAsKey], rightOfAs, hasTypeSpecifier = !1, canParseAsKeyword = !0;
      const loc = leftOfAs.loc.start;
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier();
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier();
          tokenIsKeywordOrIdentifier(this.state.type) ? (hasTypeSpecifier = !0, leftOfAs = firstAs, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName(), canParseAsKeyword = !1) : (rightOfAs = secondAs, canParseAsKeyword = !1);
        } else tokenIsKeywordOrIdentifier(this.state.type) ? (canParseAsKeyword = !1, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName()) : (hasTypeSpecifier = !0, leftOfAs = firstAs);
      } else tokenIsKeywordOrIdentifier(this.state.type) && (hasTypeSpecifier = !0, isImport ? (leftOfAs = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, !0, !0)) : leftOfAs = this.parseModuleExportName());
      hasTypeSpecifier && isInTypeOnlyImportExport && this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc), node[leftOfAsKey] = leftOfAs, node[rightOfAsKey] = rightOfAs;
      const kindKey = isImport ? "importKind" : "exportKind";
      node[kindKey] = hasTypeSpecifier ? "type" : "value", canParseAsKeyword && this.eatContextual(93) && (node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName()), node[rightOfAsKey] || (node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey])), isImport && this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
    }
  };
  function isPossiblyLiteralEnum(expression) {
    if (expression.type !== "MemberExpression") return !1;
    const {
      computed,
      property
    } = expression;
    return computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0) ? !1 : isUncomputedMemberExpressionChain(expression.object);
  }
  function isValidAmbientConstInitializer(expression, estree2) {
    var _expression$extra;
    const {
      type: type2
    } = expression;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized)
      return !1;
    if (estree2) {
      if (type2 === "Literal") {
        const {
          value
        } = expression;
        if (typeof value == "string" || typeof value == "boolean")
          return !0;
      }
    } else if (type2 === "StringLiteral" || type2 === "BooleanLiteral")
      return !0;
    return !!(isNumber2(expression, estree2) || isNegativeNumber(expression, estree2) || type2 === "TemplateLiteral" && expression.expressions.length === 0 || isPossiblyLiteralEnum(expression));
  }
  function isNumber2(expression, estree2) {
    return estree2 ? expression.type === "Literal" && (typeof expression.value == "number" || "bigint" in expression) : expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
  }
  function isNegativeNumber(expression, estree2) {
    if (expression.type === "UnaryExpression") {
      const {
        operator,
        argument
      } = expression;
      if (operator === "-" && isNumber2(argument, estree2))
        return !0;
    }
    return !1;
  }
  function isUncomputedMemberExpressionChain(expression) {
    return expression.type === "Identifier" ? !0 : expression.type !== "MemberExpression" || expression.computed ? !1 : isUncomputedMemberExpressionChain(expression.object);
  }
  const PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var placeholders = (superClass) => class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(133)) {
        const node = this.startNode();
        return this.next(), this.assertNoSpace(), node.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(node, expectedNode);
      }
    }
    finishPlaceholder(node, expectedNode) {
      let placeholder = node;
      return (!placeholder.expectedNode || !placeholder.type) && (placeholder = this.finishNode(placeholder, "Placeholder")), placeholder.expectedNode = expectedNode, placeholder;
    }
    getTokenFromCode(code2) {
      code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(code2);
    }
    parseExprAtom(refExpressionErrors) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
    }
    parseIdentifier(liberal) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      word !== void 0 && super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(type2, isParenthesized, binding) {
      return type2 === "Placeholder" || super.isValidLVal(type2, isParenthesized, binding);
    }
    toAssignable(node, isLHS) {
      node && node.type === "Placeholder" && node.expectedNode === "Expression" ? node.expectedNode = "Pattern" : super.toAssignable(node, isLHS);
    }
    chStartsBindingIdentifier(ch, pos2) {
      return !!(super.chStartsBindingIdentifier(ch, pos2) || this.lookahead().type === 133);
    }
    verifyBreakContinue(node, isBreak) {
      node.label && node.label.type === "Placeholder" || super.verifyBreakContinue(node, isBreak);
    }
    parseExpressionStatement(node, expr) {
      var _expr$extra;
      if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
        return super.parseExpressionStatement(node, expr);
      if (this.match(14)) {
        const stmt = node;
        return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(stmt, "LabeledStatement");
      }
      this.semicolon();
      const stmtPlaceholder = node;
      return stmtPlaceholder.name = expr.name, this.finishPlaceholder(stmtPlaceholder, "Statement");
    }
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    parseFunctionId(requireId) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
    }
    parseClass(node, isStatement, optionalId) {
      const type2 = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const oldStrict = this.state.strict, placeholder = this.parsePlaceholder("Identifier");
      if (placeholder)
        if (this.match(81) || this.match(133) || this.match(5))
          node.id = placeholder;
        else {
          if (optionalId || !isStatement)
            return node.id = null, node.body = this.finishPlaceholder(placeholder, "ClassBody"), this.finishNode(node, type2);
          throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(node, isStatement, optionalId);
      return super.parseClassSuper(node), node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, type2);
    }
    parseExport(node, decorators) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseExport(node, decorators);
      const node2 = node;
      if (!this.isContextual(98) && !this.match(12))
        return node2.specifiers = [], node2.source = null, node2.declaration = this.finishPlaceholder(placeholder, "Declaration"), this.finishNode(node2, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      return specifier.exported = placeholder, node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], super.parseExport(node2, decorators);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart();
        if (this.isUnparsedContextual(next, "from") && this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
      var _specifiers;
      return (_specifiers = node.specifiers) != null && _specifiers.length ? !0 : super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    }
    checkExport(node) {
      const {
        specifiers
      } = node;
      specifiers != null && specifiers.length && (node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder")), super.checkExport(node), node.specifiers = specifiers;
    }
    parseImport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseImport(node);
      if (node.specifiers = [], !this.isContextual(98) && !this.match(12))
        return node.source = this.finishPlaceholder(placeholder, "StringLiteral"), this.semicolon(), this.finishNode(node, "ImportDeclaration");
      const specifier = this.startNodeAtNode(placeholder);
      return specifier.local = placeholder, node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(node) || this.parseNamedImportSpecifiers(node)), this.expectContextual(98), node.source = this.parseImportSource(), this.semicolon(), this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, v8intrinsic = (superClass) => class extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc, node = this.startNode();
        if (this.next(), tokenIsIdentifier(this.state.type)) {
          const name = this.parseIdentifierName(), identifier = this.createIdentifier(node, name);
          if (identifier.type = "V8IntrinsicIdentifier", this.match(10))
            return identifier;
        }
        this.unexpected(v8IntrinsicStartLoc);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
  };
  const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"], TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
  function validatePlugins(pluginsMap) {
    if (pluginsMap.has("decorators")) {
      if (pluginsMap.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
      if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
      if (allowCallParenthesized != null && typeof allowCallParenthesized != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (pluginsMap.has("flow") && pluginsMap.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (pluginsMap.has("pipelineOperator")) {
      var _pluginsMap$get;
      const proposal = pluginsMap.get("pipelineOperator").proposal;
      if (!PIPELINE_PROPOSALS.includes(proposal)) {
        const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
      }
      const tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";
      if (proposal === "hack") {
        if (pluginsMap.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (pluginsMap.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const topicToken = pluginsMap.get("pipelineOperator").topicToken;
        if (!TOPIC_TOKENS.includes(topicToken)) {
          const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
        }
        if (topicToken === "#" && tupleSyntaxIsHash)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
      } else if (proposal === "smart" && tupleSyntaxIsHash)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
    }
    if (pluginsMap.has("moduleAttributes")) {
      if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (pluginsMap.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (pluginsMap.has("importAssertions") && pluginsMap.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax && pluginsMap.set("deprecatedImportAssert", {}), pluginsMap.has("recordAndTuple")) {
      const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
      if (syntaxType != null) {
        const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
      }
    }
    if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
      const error2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw error2.missingPlugins = "doExpressions", error2;
    }
    if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  const mixinPlugins = {
    estree,
    jsx: jsx2,
    flow: flow2,
    typescript: typescript2,
    v8intrinsic,
    placeholders
  }, mixinPluginNames = Object.keys(mixinPlugins);
  function createDefaultOptions() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  function getOptions(opts) {
    const options2 = createDefaultOptions();
    if (opts == null)
      return options2;
    if (opts.annexB != null && opts.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (const key2 of Object.keys(options2))
      opts[key2] != null && (options2[key2] = opts[key2]);
    if (options2.startLine === 1)
      opts.startIndex == null && options2.startColumn > 0 ? options2.startIndex = options2.startColumn : opts.startColumn == null && options2.startIndex > 0 && (options2.startColumn = options2.startIndex);
    else if ((opts.startColumn == null || opts.startIndex == null) && opts.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return options2;
  }
  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand)
        return;
      const key2 = prop.key;
      if ((key2.type === "Identifier" ? key2.name : key2.value) === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, key2);
          return;
        }
        protoRef.used && (refExpressionErrors ? refExpressionErrors.doubleProtoLoc === null && (refExpressionErrors.doubleProtoLoc = key2.loc.start) : this.raise(Errors.DuplicateProto, key2)), protoRef.used = !0;
      }
    }
    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const expr = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), expr.comments = this.comments, expr.errors = this.state.errors, this.options.tokens && (expr.tokens = this.tokens), expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
      return disallowIn ? this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors)) : this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
      const startLoc = this.state.startLoc, expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(12)) {
        const node = this.startNodeAt(startLoc);
        for (node.expressions = [expr]; this.eat(12); )
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        return this.toReferencedList(node.expressions), this.finishNode(node, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$loc;
      refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError?.loc) != null ? _resultError$loc : this.state.startLoc;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startLoc = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let left2 = this.parseYield();
        return afterLeftParse && (left2 = afterLeftParse.call(this, left2, startLoc)), left2;
      }
      let ownExpressionErrors;
      refExpressionErrors ? ownExpressionErrors = !1 : (refExpressionErrors = new ExpressionErrors(), ownExpressionErrors = !0);
      const {
        type: type2
      } = this.state;
      (type2 === 10 || tokenIsIdentifier(type2)) && (this.state.potentialArrowAt = this.state.start);
      let left = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse && (left = afterLeftParse.call(this, left, startLoc)), tokenIsAssignment(this.state.type)) {
        const node = this.startNodeAt(startLoc), operator = this.state.value;
        if (node.operator = operator, this.match(29)) {
          this.toAssignable(left, !0), node.left = left;
          const startIndex = startLoc.index;
          refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex && (refExpressionErrors.doubleProtoLoc = null), refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex && (refExpressionErrors.shorthandAssignLoc = null), refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex && (this.checkDestructuringPrivate(refExpressionErrors), refExpressionErrors.privateKeyLoc = null);
        } else
          node.left = left;
        return this.next(), node.right = this.parseMaybeAssign(), this.checkLVal(left, this.finishNode(node, "AssignmentExpression")), node;
      } else ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, !0);
      return left;
    }
    parseMaybeConditional(refExpressionErrors) {
      const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(refExpressionErrors);
      return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        const node = this.startNodeAt(startLoc);
        return node.test = expr, node.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), node.alternate = this.parseMaybeAssign(), this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    parseExprOps(refExpressionErrors) {
      const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
      return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseExprOp(expr, startLoc, -1);
    }
    parseExprOp(left, leftStartLoc, minPrec) {
      if (this.isPrivateName(left)) {
        const value = this.getPrivateNameSV(left);
        (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Errors.PrivateInExpectedIn, left, {
          identifierName: value
        }), this.classScope.usePrivateName(value, left.loc.start);
      }
      const op = this.state.type;
      if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
        let prec = tokenOperatorPrecedence(op);
        if (prec > minPrec) {
          if (op === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return left;
            this.checkPipelineAtInfixOperator(left, leftStartLoc);
          }
          const node = this.startNodeAt(leftStartLoc);
          node.left = left, node.operator = this.state.value;
          const logical = op === 41 || op === 42, coalesce = op === 40;
          if (coalesce && (prec = tokenOperatorPrecedence(42)), this.next(), op === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          node.right = this.parseExprOpRightExpr(op, prec);
          const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression"), nextOp = this.state.type;
          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40)
            throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
        }
      }
      return left;
    }
    parseExprOpRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      switch (op) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(prec));
          }
        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
    parseExprOpBaseRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    parseHackPipeBody() {
      var _body$extra;
      const {
        startLoc
      } = this.state, body = this.parseMaybeAssign();
      return UnparenthesizedPipeBodyDescriptions.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized) && this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
        type: body.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipeTopicUnused, startLoc), body;
    }
    checkExponentialAfterUnary(node) {
      this.match(57) && this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startLoc = this.state.startLoc, isAwait = this.isContextual(96);
      if (isAwait && this.recordAwaitIfAllowed()) {
        this.next();
        const expr2 = this.parseAwait(startLoc);
        return sawUnary || this.checkExponentialAfterUnary(expr2), expr2;
      }
      const update2 = this.match(34), node = this.startNode();
      if (tokenIsPrefix(this.state.type)) {
        node.operator = this.state.value, node.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        const isDelete = this.match(89);
        if (this.next(), node.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(refExpressionErrors, !0), this.state.strict && isDelete) {
          const arg = node.argument;
          arg.type === "Identifier" ? this.raise(Errors.StrictDelete, node) : this.hasPropertyAsPrivateName(arg) && this.raise(Errors.DeletePrivateField, node);
        }
        if (!update2)
          return sawUnary || this.checkExponentialAfterUnary(node), this.finishNode(node, "UnaryExpression");
      }
      const expr = this.parseUpdate(node, update2, refExpressionErrors);
      if (isAwait) {
        const {
          type: type2
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc), this.parseAwait(startLoc);
      }
      return expr;
    }
    parseUpdate(node, update2, refExpressionErrors) {
      if (update2) {
        const updateExpressionNode = node;
        return this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression")), node;
      }
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, !1)) return expr;
      for (; tokenIsPostfix(this.state.type) && !this.canInsertSemicolon(); ) {
        const node2 = this.startNodeAt(startLoc);
        node2.operator = this.state.value, node2.prefix = !1, node2.argument = expr, this.next(), this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
      return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseSubscripts(expr, startLoc);
    }
    parseSubscripts(base2, startLoc, noCalls) {
      const state = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base2),
        stop: !1
      };
      do
        base2 = this.parseSubscript(base2, startLoc, noCalls, state), state.maybeAsyncArrow = !1;
      while (!state.stop);
      return base2;
    }
    parseSubscript(base2, startLoc, noCalls, state) {
      const {
        type: type2
      } = this.state;
      if (!noCalls && type2 === 15)
        return this.parseBind(base2, startLoc, noCalls, state);
      if (tokenIsTemplate(type2))
        return this.parseTaggedTemplateExpression(base2, startLoc, state);
      let optional = !1;
      if (type2 === 18) {
        if (noCalls && (this.raise(Errors.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return state.stop = !0, base2;
        state.optionalChainMember = optional = !0, this.next();
      }
      if (!noCalls && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(base2, startLoc, state, optional);
      {
        const computed = this.eat(0);
        return computed || optional || this.eat(16) ? this.parseMember(base2, startLoc, state, computed, optional) : (state.stop = !0, base2);
      }
    }
    parseMember(base2, startLoc, state, computed, optional) {
      const node = this.startNodeAt(startLoc);
      return node.object = base2, node.computed = computed, computed ? (node.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (base2.type === "Super" && this.raise(Errors.SuperPrivateField, startLoc), this.classScope.usePrivateName(this.state.value, this.state.startLoc), node.property = this.parsePrivateName()) : node.property = this.parseIdentifier(!0), state.optionalChainMember ? (node.optional = optional, this.finishNode(node, "OptionalMemberExpression")) : this.finishNode(node, "MemberExpression");
    }
    parseBind(base2, startLoc, noCalls, state) {
      const node = this.startNodeAt(startLoc);
      return node.object = base2, this.next(), node.callee = this.parseNoCallExpr(), state.stop = !0, this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base2, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = !0, this.next();
      const node = this.startNodeAt(startLoc);
      node.callee = base2;
      const {
        maybeAsyncArrow,
        optionalChainMember
      } = state;
      maybeAsyncArrow && (this.expressionScope.enter(newAsyncArrowScope()), refExpressionErrors = new ExpressionErrors()), optionalChainMember && (node.optional = optional), optional ? node.arguments = this.parseCallExpressionArguments(11) : node.arguments = this.parseCallExpressionArguments(11, base2.type !== "Super", node, refExpressionErrors);
      let finishedNode = this.finishCallExpression(node, optionalChainMember);
      return maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state.stop = !0, this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode)) : (maybeAsyncArrow && (this.checkExpressionErrors(refExpressionErrors, !0), this.expressionScope.exit()), this.toReferencedArguments(finishedNode)), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, finishedNode;
    }
    toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base2, startLoc, state) {
      const node = this.startNodeAt(startLoc);
      return node.tag = base2, node.quasi = this.parseTemplate(!0), state.optionalChainMember && this.raise(Errors.OptionalChainingNoTemplate, startLoc), this.finishNode(node, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base2) {
      return base2.type === "Identifier" && base2.name === "async" && this.state.lastTokEndLoc.index === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.offsetToSourcePos(base2.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(node, optional) {
      if (node.callee.type === "Import")
        if (node.arguments.length === 0 || node.arguments.length > 2)
          this.raise(Errors.ImportCallArity, node);
        else
          for (const arg of node.arguments)
            arg.type === "SpreadElement" && this.raise(Errors.ImportCallSpreadArgument, arg);
      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first2 = !0;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(close); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.match(close)) {
          nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
          break;
        }
        elts.push(this.parseExprListItem(!1, refExpressionErrors, allowPlaceholder));
      }
      return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;
      return this.resetPreviousNodeTrailingComments(call), this.expect(19), this.parseArrowExpression(node, call.arguments, !0, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc), call.innerComments && setInnerComments(node, call.innerComments), call.callee.trailingComments && setInnerComments(node, call.callee.trailingComments), node;
    }
    parseNoCallExpr() {
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startLoc, !0);
    }
    parseExprAtom(refExpressionErrors) {
      let node, decorators = null;
      const {
        type: type2
      } = this.state;
      switch (type2) {
        case 79:
          return this.parseSuper();
        case 83:
          return node = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(node) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(node) : this.finishNode(node, "Import") : (this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(node, "Import"));
        case 78:
          return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, refExpressionErrors);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, refExpressionErrors);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          decorators = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          node = this.startNode(), this.next(), node.object = null;
          const callee = node.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression")
            return this.finishNode(node, "BindExpression");
          throw this.raise(Errors.UnsupportedBind, callee);
        }
        case 139:
          return this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal)
            return this.parseTopicReference(pipeProposal);
          this.unexpected();
          break;
        }
        case 47: {
          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
          isIdentifierStart(lookaheadCh) || lookaheadCh === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (type2 === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (tokenIsIdentifier(type2)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            const canBeArrow = this.state.potentialArrowAt === this.state.start, containsEsc = this.state.containsEsc, id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: type3
              } = this.state;
              if (type3 === 68)
                return this.resetPreviousNodeTrailingComments(id), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
              if (tokenIsIdentifier(type3))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)) : id;
              if (type3 === 90)
                return this.resetPreviousNodeTrailingComments(id), this.parseDo(this.startNodeAtNode(id), !0);
            }
            return canBeArrow && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(id), [id], !1)) : id;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
      if (pipeProposal)
        return this.state.type = topicTokenType, this.state.value = topicTokenValue, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(pipeProposal);
      this.unexpected();
    }
    parseTopicReference(pipeProposal) {
      const node = this.startNode(), startLoc = this.state.startLoc, tokenType = this.state.type;
      return this.next(), this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    }
    finishTopicReference(node, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc), this.registerTopicReference(), this.finishNode(node, nodeType);
      } else
        throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
          token: tokenLabelName(tokenType)
        });
    }
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: tokenLabelName(tokenType)
          }]);
        case "smart":
          return tokenType === 27;
        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
      }
    }
    parseAsyncArrowUnaryFunction(node) {
      this.prodParam.enter(functionFlags(!0, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(node, params, !0);
    }
    parseDo(node, isAsync) {
      this.expectPlugin("doExpressions"), isAsync && this.expectPlugin("asyncDoExpressions"), node.async = isAsync, this.next();
      const oldLabels = this.state.labels;
      return this.state.labels = [], isAsync ? (this.prodParam.enter(2), node.body = this.parseBlock(), this.prodParam.exit()) : node.body = this.parseBlock(), this.state.labels = oldLabels, this.finishNode(node, "DoExpression");
    }
    parseSuper() {
      const node = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(Errors.SuperNotAllowed, node) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(Errors.UnexpectedSuper, node), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(Errors.UnsupportedSuper, node), this.finishNode(node, "Super");
    }
    parsePrivateName() {
      const node = this.startNode(), id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), name = this.state.value;
      return this.next(), node.id = this.createIdentifier(id, name), this.finishNode(node, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const node = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(node, meta, "sent");
      }
      return this.parseFunction(node);
    }
    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;
      const containsEsc = this.state.containsEsc;
      return node.property = this.parseIdentifier(!0), (node.property.name !== propertyName || containsEsc) && this.raise(Errors.UnsupportedMetaProperty, node.property, {
        target: meta.name,
        onlyValidPropertyName: propertyName
      }), this.finishNode(node, "MetaProperty");
    }
    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(Errors.ImportMetaOutsideModule, id), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        const isSource = this.isContextual(105);
        if (isSource || this.unexpected(), this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), node.phase = isSource ? "source" : "defer", this.parseImportCall(node);
      }
      return this.parseMetaProperty(node, id, "meta");
    }
    parseLiteralAtNode(value, type2, node) {
      return this.addExtra(node, "rawValue", value), this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end)), node.value = value, this.next(), this.finishNode(node, type2);
    }
    parseLiteral(value, type2) {
      const node = this.startNode();
      return this.parseLiteralAtNode(value, type2, node);
    }
    parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
    parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
    parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }
    parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
    parseRegExpLiteral(value) {
      const node = this.startNode();
      return this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end)), node.pattern = value.pattern, node.flags = value.flags, this.next(), this.finishNode(node, "RegExpLiteral");
    }
    parseBooleanLiteral(value) {
      const node = this.startNode();
      return node.value = value, this.next(), this.finishNode(node, "BooleanLiteral");
    }
    parseNullLiteral() {
      const node = this.startNode();
      return this.next(), this.finishNode(node, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startLoc = this.state.startLoc;
      let val;
      this.next(), this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      const innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors();
      let first2 = !0, spreadStartLoc, optionalCommaStartLoc;
      for (; !this.match(11); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc), this.match(11)) {
          optionalCommaStartLoc = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          if (spreadStartLoc = this.state.startLoc, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc)), !this.checkCommaAfterRest(41))
            break;
        } else
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
      }
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startLoc);
      return canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode)) ? (this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(arrowNode, exprList, !1), arrowNode) : (this.expressionScope.exit(), exprList.length || this.unexpected(this.state.lastTokStartLoc), optionalCommaStartLoc && this.unexpected(optionalCommaStartLoc), spreadStartLoc && this.unexpected(spreadStartLoc), this.checkExpressionErrors(refExpressionErrors, !0), this.toReferencedListDeep(exprList, !0), exprList.length > 1 ? (val = this.startNodeAt(innerStartLoc), val.expressions = exprList, this.finishNode(val, "SequenceExpression"), this.resetEndLocation(val, innerEndLoc)) : val = exprList[0], this.wrapParenthesis(startLoc, val));
    }
    wrapParenthesis(startLoc, expression) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(expression, "parenthesized", !0), this.addExtra(expression, "parenStart", startLoc.index), this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index), expression;
      const parenExpression = this.startNodeAt(startLoc);
      return parenExpression.expression = expression, this.finishNode(parenExpression, "ParenthesizedExpression");
    }
    shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
    parseArrow(node) {
      if (this.eat(19))
        return node;
    }
    parseParenItem(node, startLoc) {
      return node;
    }
    parseNewOrNewTarget() {
      const node = this.startNode();
      if (this.next(), this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node, meta, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(Errors.UnexpectedNewTarget, metaProp), metaProp;
      }
      return this.parseNew(node);
    }
    parseNew(node) {
      if (this.parseNewCallee(node), this.eat(10)) {
        const args = this.parseExprList(11);
        this.toReferencedList(args), node.arguments = args;
      } else
        node.arguments = [];
      return this.finishNode(node, "NewExpression");
    }
    parseNewCallee(node) {
      const isImport = this.match(83), callee = this.parseNoCallExpr();
      node.callee = callee, isImport && (callee.type === "Import" || callee.type === "ImportExpression") && this.raise(Errors.ImportCallNotNewExpression, callee);
    }
    parseTemplateElement(isTagged) {
      const {
        start,
        startLoc,
        end,
        value
      } = this.state, elemStart = start + 1, elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
      value === null && (isTagged || this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)));
      const isTail = this.match(24), endOffset = isTail ? -1 : -2, elemEnd = end + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, `
`),
        cooked: value === null ? null : value.slice(1, endOffset)
      }, elem.tail = isTail, this.next();
      const finishedNode = this.finishNode(elem, "TemplateElement");
      return this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset)), finishedNode;
    }
    parseTemplate(isTagged) {
      const node = this.startNode();
      let curElt = this.parseTemplateElement(isTagged);
      const quasis = [curElt], substitutions = [];
      for (; !curElt.tail; )
        substitutions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), quasis.push(curElt = this.parseTemplateElement(isTagged));
      return node.expressions = substitutions, node.quasis = quasis, this.finishNode(node, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      isRecord && this.expectPlugin("recordAndTuple");
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const propHash = /* @__PURE__ */ Object.create(null);
      let first2 = !0;
      const node = this.startNode();
      for (node.properties = [], this.next(); !this.match(close); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.match(close)) {
          this.addTrailingCommaExtraToNode(node);
          break;
        }
        let prop;
        isPattern ? prop = this.parseBindingProperty() : (prop = this.parsePropertyDefinition(refExpressionErrors), this.checkProto(prop, isRecord, propHash, refExpressionErrors)), isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement" && this.raise(Errors.InvalidRecordProperty, prop), prop.shorthand && this.addExtra(prop, "shorthand", !0), node.properties.push(prop);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type2 = "ObjectExpression";
      return isPattern ? type2 = "ObjectPattern" : isRecord && (type2 = "RecordExpression"), this.finishNode(node, type2);
    }
    addTrailingCommaExtraToNode(node) {
      this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(refExpressionErrors) {
      let decorators = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          decorators.push(this.parseDecorator());
      const prop = this.startNode();
      let isAsync = !1, isAccessor = !1, startLoc;
      if (this.match(21))
        return decorators.length && this.unexpected(), this.parseSpread();
      decorators.length && (prop.decorators = decorators, decorators = []), prop.method = !1, refExpressionErrors && (startLoc = this.state.startLoc);
      let isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      const containsEsc = this.state.containsEsc;
      if (this.parsePropertyName(prop, refExpressionErrors), !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const {
          key: key2
        } = prop, keyName = key2.name;
        keyName === "async" && !this.hasPrecedingLineBreak() && (isAsync = !0, this.resetPreviousNodeTrailingComments(key2), isGenerator = this.eat(55), this.parsePropertyName(prop)), (keyName === "get" || keyName === "set") && (isAccessor = !0, this.resetPreviousNodeTrailingComments(key2), prop.kind = keyName, this.match(55) && (isGenerator = !0, this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
          kind: keyName
        }), this.next()), this.parsePropertyName(prop));
      }
      return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, !1, isAccessor, refExpressionErrors);
    }
    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
      return method.params;
    }
    checkGetterSetterParams(method) {
      var _params;
      const paramCount = this.getGetterSetterExpectedParamCount(method), params = this.getObjectOrClassMethodParams(method);
      params.length !== paramCount && this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method), method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement" && this.raise(Errors.BadSetterRestParameter, method);
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        const finishedProp = this.parseMethod(prop, isGenerator, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(finishedProp), finishedProp;
      }
      if (isAsync || isGenerator || this.match(10))
        return isPattern && this.unexpected(), prop.kind = "method", prop.method = !0, this.parseMethod(prop, isGenerator, isAsync, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      if (prop.shorthand = !1, this.eat(14))
        return prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors), this.finishNode(prop, "ObjectProperty");
      if (!prop.computed && prop.key.type === "Identifier") {
        if (this.checkReservedWord(prop.key.name, prop.key.loc.start, !0, !1), isPattern)
          prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        else if (this.match(29)) {
          const shorthandAssignLoc = this.state.startLoc;
          refExpressionErrors != null ? refExpressionErrors.shorthandAssignLoc === null && (refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc) : this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc), prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        } else
          prop.value = cloneIdentifier(prop.key);
        return prop.shorthand = !0, this.finishNode(prop, "ObjectProperty");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      return node || this.unexpected(), node;
    }
    parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0))
        prop.computed = !0, prop.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: type2,
          value
        } = this.state;
        let key2;
        if (tokenIsKeywordOrIdentifier(type2))
          key2 = this.parseIdentifier(!0);
        else
          switch (type2) {
            case 135:
              key2 = this.parseNumericLiteral(value);
              break;
            case 134:
              key2 = this.parseStringLiteral(value);
              break;
            case 136:
              key2 = this.parseBigIntLiteral(value);
              break;
            case 139: {
              const privateKeyLoc = this.state.startLoc;
              refExpressionErrors != null ? refExpressionErrors.privateKeyLoc === null && (refExpressionErrors.privateKeyLoc = privateKeyLoc) : this.raise(Errors.UnexpectedPrivateField, privateKeyLoc), key2 = this.parsePrivateName();
              break;
            }
            default:
              if (type2 === 137) {
                key2 = this.parseDecimalLiteral(value);
                break;
              }
              this.unexpected();
          }
        prop.key = key2, type2 !== 139 && (prop.computed = !1);
      }
    }
    initFunction(node, isAsync) {
      node.id = null, node.generator = !1, node.async = isAsync;
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope = !1) {
      this.initFunction(node, isAsync), node.generator = isGenerator, this.scope.enter(18 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0)), this.prodParam.enter(functionFlags(isAsync, node.generator)), this.parseFunctionParams(node, isConstructor);
      const finishedNode = this.parseFunctionBodyAndFinish(node, type2, !0);
      return this.prodParam.exit(), this.scope.exit(), finishedNode;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      isTuple && this.expectPlugin("recordAndTuple");
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const node = this.startNode();
      return this.next(), node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
      this.scope.enter(6);
      let flags = functionFlags(isAsync, !1);
      !this.match(5) && this.prodParam.hasIn && (flags |= 8), this.prodParam.enter(flags), this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      return params && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(node, params, trailingCommaLoc)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(node, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.finishNode(node, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, !1), node.params = params;
    }
    parseFunctionBodyAndFinish(node, type2, isMethod = !1) {
      return this.parseFunctionBody(node, !1, isMethod), this.finishNode(node, type2);
    }
    parseFunctionBody(node, allowExpression, isMethod = !1) {
      const isExpression = allowExpression && !this.match(5);
      if (this.expressionScope.enter(newExpressionScope()), isExpression)
        node.body = this.parseMaybeAssign(), this.checkParams(node, !1, allowExpression, !1);
      else {
        const oldStrict = this.state.strict, oldLabels = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), node.body = this.parseBlock(!0, !1, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node.params);
          hasStrictModeDirective && nonSimple && this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && node.key ? node.key.loc.end : node);
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged), this.state.strict && node.id && this.checkIdentifier(node.id, 65, strictModeChanged);
        }), this.prodParam.exit(), this.state.labels = oldLabels;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(node) {
      return node.type === "Identifier";
    }
    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++)
        if (!this.isSimpleParameter(params[i])) return !1;
      return !0;
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
      const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set(), formalParameters = {
        type: "FormalParameters"
      };
      for (const param of node.params)
        this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first2 = !0;
      for (; !this.eat(close); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.match(close)) {
          nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
          break;
        }
        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;
      if (this.match(12))
        allowEmpty || this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), elt = null;
      else if (this.match(21)) {
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const node = this.startNode();
        this.next(), elt = this.finishNode(node, "ArgumentPlaceholder");
      } else
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      return elt;
    }
    parseIdentifier(liberal) {
      const node = this.startNode(), name = this.parseIdentifierName(liberal);
      return this.createIdentifier(node, name);
    }
    createIdentifier(node, name) {
      return node.name = name, node.loc.identifierName = name, this.finishNode(node, "Identifier");
    }
    parseIdentifierName(liberal) {
      let name;
      const {
        startLoc,
        type: type2
      } = this.state;
      tokenIsKeywordOrIdentifier(type2) ? name = this.state.value : this.unexpected();
      const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type2);
      return liberal ? tokenIsKeyword2 && this.replaceToken(132) : this.checkReservedWord(name, startLoc, tokenIsKeyword2, !1), this.next(), name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10 || !canBeReservedWord(word))
        return;
      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, startLoc, {
          keyword: word
        });
        return;
      }
      if ((this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, startLoc, {
          reservedWord: word
        });
        return;
      } else if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, startLoc);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, startLoc);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(startLoc);
      } else if (word === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Errors.ArgumentsInClass, startLoc);
        return;
      }
    }
    recordAwaitIfAllowed() {
      const isAwaitAllowed = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;
      return isAwaitAllowed && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), isAwaitAllowed;
    }
    parseAwait(startLoc) {
      const node = this.startNodeAt(startLoc);
      return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node), this.eat(55) && this.raise(Errors.ObsoleteAwaitStar, node), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (node.argument = this.parseMaybeUnary(null, !0)), this.finishNode(node, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      const {
        type: type2
      } = this.state;
      return type2 === 53 || type2 === 10 || type2 === 0 || tokenIsTemplate(type2) || type2 === 102 && !this.state.containsEsc || type2 === 138 || type2 === 56 || this.hasPlugin("v8intrinsic") && type2 === 54;
    }
    parseYield() {
      const node = this.startNode();
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node), this.next();
      let delegating = !1, argument = null;
      if (!this.hasPrecedingLineBreak())
        switch (delegating = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating) break;
          default:
            argument = this.parseMaybeAssign();
        }
      return node.delegate = delegating, node.argument = argument, this.finishNode(node, "YieldExpression");
    }
    parseImportCall(node) {
      if (this.next(), node.source = this.parseMaybeAssignAllowIn(), node.options = null, this.eat(12) && !this.match(11) && (node.options = this.parseMaybeAssignAllowIn(), this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(Errors.ImportCallArity, node);
      }
      return this.expect(11), this.finishNode(node, "ImportExpression");
    }
    checkPipelineAtInfixOperator(left, leftStartLoc) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && left.type === "SequenceExpression" && this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
    }
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        const bodyNode = this.startNodeAt(startLoc);
        return bodyNode.callee = childExpr, this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        const bodyNode = this.startNodeAt(startLoc);
        return this.checkSmartPipeTopicBodyEarlyErrors(startLoc), bodyNode.expression = childExpr, this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19))
        throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipelineTopicUnused, startLoc);
    }
    withTopicBindingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else
        return callback();
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      if (8 & ~flags) {
        this.prodParam.enter(flags | 8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      if (8 & flags) {
        this.prodParam.enter(flags & -9);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
      return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const program = this.startNodeAt(this.state.endLoc);
      this.next();
      const revertScopes = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        node.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }
      return this.finishNode(node, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(prop) {
    }
  }
  const loopLabel = {
    kind: 1
  }, switchLabel = {
    kind: 2
  }, loneSurrogate = /[\uD800-\uDFFF]/u, keywordRelationalOperator = /in(?:stanceof)?/y;
  function babel7CompatTokens(tokens, input2, startIndex) {
    for (let i = 0; i < tokens.length; i++) {
      const token2 = tokens[i], {
        type: type2
      } = token2;
      if (typeof type2 == "number") {
        {
          if (type2 === 139) {
            const {
              loc,
              start,
              value,
              end
            } = token2, hashEndPos = start + 1, hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            })), i++;
            continue;
          }
          if (tokenIsTemplate(type2)) {
            const {
              loc,
              start,
              value,
              end
            } = token2, backquoteEnd = start + 1, backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
            let startToken;
            input2.charCodeAt(start - startIndex) === 96 ? startToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc
            }) : startToken = new Token({
              type: getExportedToken(8),
              value: "}",
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc
            });
            let templateValue, templateElementEnd, templateElementEndLoc, endToken;
            type2 === 24 ? (templateElementEnd = end - 1, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1), templateValue = value === null ? null : value.slice(1, -1), endToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end
            })) : (templateElementEnd = end - 2, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2), templateValue = value === null ? null : value.slice(1, -2), endToken = new Token({
              type: getExportedToken(23),
              value: "${",
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end
            })), tokens.splice(i, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken), i += 2;
            continue;
          }
        }
        token2.type = getExportedToken(type2);
      }
    }
    return tokens;
  }
  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      return file.program = this.parseProgram(program), file.comments = this.comments, this.options.tokens && (file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex)), this.finishNode(file, "File");
    }
    parseProgram(program, end = 140, sourceType = this.options.sourceType) {
      if (program.sourceType = sourceType, program.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(program, !0, !0, end), this.inModule) {
        if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
          for (const [localName, at] of Array.from(this.scope.undefinedExports))
            this.raise(Errors.ModuleExportUndefined, at, {
              localName
            });
        this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let finishedProgram;
      return end === 140 ? finishedProgram = this.finishNode(program, "Program") : finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), finishedProgram;
    }
    stmtToDirective(stmt) {
      const directive = stmt;
      directive.type = "Directive", directive.value = directive.expression, delete directive.expression;
      const directiveLiteral = directive.value, expressionValue = directiveLiteral.value, raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end)), val = directiveLiteral.value = raw.slice(1, -1);
      return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), this.addExtra(directiveLiteral, "expressionValue", expressionValue), directiveLiteral.type = "DirectiveLiteral", directive;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const node = this.startNode();
      return node.value = this.state.value, this.next(), this.finishNode(node, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(ch, pos2) {
      if (isIdentifierStart(ch)) {
        if (keywordRelationalOperator.lastIndex = pos2, keywordRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92)
            return !1;
        }
        return !0;
      } else return ch === 92;
    }
    chStartsBindingPattern(ch) {
      return ch === 91 || ch === 123;
    }
    hasFollowingBindingAtom() {
      const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
      return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      const next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
      return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
    }
    startsUsingForOf() {
      const {
        type: type2,
        containsEsc
      } = this.lookahead();
      if (type2 === 102 && !containsEsc)
        return !1;
      if (tokenIsIdentifier(type2) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let next = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(next, "using")) {
        next = this.nextTokenInLineStartSince(next + 5);
        const nextCh = this.codePointAtPos(next);
        if (this.chStartsBindingIdentifier(nextCh, next))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = !1) {
      let flags = 0;
      return this.options.annexB && !this.state.strict && (flags |= 4, allowLabeledFunction && (flags |= 8)), this.parseStatementLike(flags);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(flags) {
      let decorators = null;
      return this.match(26) && (decorators = this.parseDecorators(!0)), this.parseStatementContent(flags, decorators);
    }
    parseStatementContent(flags, decorators) {
      const startType = this.state.type, node = this.startNode(), allowDeclaration = !!(flags & 2), allowFunctionDeclaration = !!(flags & 4), topLevel = flags & 1;
      switch (startType) {
        case 60:
          return this.parseBreakContinueStatement(node, !0);
        case 63:
          return this.parseBreakContinueStatement(node, !1);
        case 64:
          return this.parseDebuggerStatement(node);
        case 90:
          return this.parseDoWhileStatement(node);
        case 91:
          return this.parseForStatement(node);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return allowFunctionDeclaration || this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(node, !1, !allowDeclaration && allowFunctionDeclaration);
        case 80:
          return allowDeclaration || this.unexpected(), this.parseClass(this.maybeTakeDecorators(decorators, node), !0);
        case 69:
          return this.parseIfStatement(node);
        case 70:
          return this.parseReturnStatement(node);
        case 71:
          return this.parseSwitchStatement(node);
        case 72:
          return this.parseThrowStatement(node);
        case 73:
          return this.parseTryStatement(node);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, node) : this.raise(Errors.AwaitUsingNotInAsyncContext, node), this.next(), this.parseVarStatement(node, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc) : allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(node, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
          if (nextCh !== 91 && (!allowDeclaration && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123))
            break;
        }
        case 75:
          allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const kind = this.state.value;
          return this.parseVarStatement(node, kind);
        }
        case 92:
          return this.parseWhileStatement(node);
        case 76:
          return this.parseWithStatement(node);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(node);
        case 83: {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (nextTokenCharCode === 40 || nextTokenCharCode === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !topLevel && this.raise(Errors.UnexpectedImportExport, this.state.startLoc), this.next();
          let result;
          return startType === 83 ? (result = this.parseImport(node), result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value") && (this.sawUnambiguousESM = !0)) : (result = this.parseExport(node, decorators), (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(result), result;
        }
        default:
          if (this.isAsyncFunction())
            return allowDeclaration || this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(node, !0, !allowDeclaration && allowFunctionDeclaration);
      }
      const maybeName = this.state.value, expr = this.parseExpression();
      return tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(node, maybeName, expr, flags) : this.parseExpressionStatement(node, expr, decorators);
    }
    assertModuleNodeAllowed(node) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(Errors.ImportOutsideModule, node);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
      return maybeDecorators && (classNode.decorators && classNode.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]), classNode.decorators.unshift(...maybeDecorators)) : classNode.decorators = maybeDecorators, this.resetStartLocationFromNode(classNode, maybeDecorators[0]), exportNode && this.resetStartLocationFromNode(exportNode, classNode)), classNode;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(allowExport) {
      const decorators = [];
      do
        decorators.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        allowExport || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Errors.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
      return decorators;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const node = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const startLoc = this.state.startLoc;
        let expr;
        if (this.match(10)) {
          const startLoc2 = this.state.startLoc;
          this.next(), expr = this.parseExpression(), this.expect(11), expr = this.wrapParenthesis(startLoc2, expr);
          const paramsStartLoc = this.state.startLoc;
          node.expression = this.parseMaybeDecoratorArguments(expr), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && node.expression !== expr && this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
        } else {
          for (expr = this.parseIdentifier(!1); this.eat(16); ) {
            const node2 = this.startNodeAt(startLoc);
            node2.object = expr, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), node2.property = this.parsePrivateName()) : node2.property = this.parseIdentifier(!0), node2.computed = !1, expr = this.finishNode(node2, "MemberExpression");
          }
          node.expression = this.parseMaybeDecoratorArguments(expr);
        }
      } else
        node.expression = this.parseExprSubscripts();
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(10)) {
        const node = this.startNodeAtNode(expr);
        return node.callee = expr, node.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(node.arguments), this.finishNode(node, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node, isBreak) {
      return this.next(), this.isLineTerminator() ? node.label = null : (node.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(node, isBreak), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node, isBreak) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];
        if ((node.label == null || lab.name === node.label.name) && (lab.kind != null && (isBreak || lab.kind === 1) || node.label && isBreak))
          break;
      }
      if (i === this.state.labels.length) {
        const type2 = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, node, {
          type: type2
        });
      }
    }
    parseDebuggerStatement(node) {
      return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const val = this.parseExpression();
      return this.expect(11), val;
    }
    parseDoWhileStatement(node) {
      return this.next(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), node.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(node, "DoWhileStatement");
    }
    parseForStatement(node) {
      this.next(), this.state.labels.push(loopLabel);
      let awaitAt = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (awaitAt = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13))
        return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, null);
      const startsWithLet = this.isContextual(100);
      {
        const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing(), starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf(), isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          const initNode = this.startNode();
          let kind;
          startsWithAwaitUsing ? (kind = "await using", this.recordAwaitIfAllowed() || this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : kind = this.state.value, this.next(), this.parseVar(initNode, !0, kind);
          const init2 = this.finishNode(initNode, "VariableDeclaration"), isForIn = this.match(58);
          return isForIn && starsWithUsingDeclaration && this.raise(Errors.ForInUsing, init2), (isForIn || this.isContextual(102)) && init2.declarations.length === 1 ? this.parseForIn(node, init2, awaitAt) : (awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, init2));
        }
      }
      const startsWithAsync = this.isContextual(95), refExpressionErrors = new ExpressionErrors(), init = this.parseExpression(!0, refExpressionErrors), isForOf = this.isContextual(102);
      if (isForOf && (startsWithLet && this.raise(Errors.ForOfLet, init), awaitAt === null && startsWithAsync && init.type === "Identifier" && this.raise(Errors.ForOfAsync, init)), isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors), this.toAssignable(init, !0);
        const type2 = isForOf ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(init, {
          type: type2
        }), this.parseForIn(node, init, awaitAt);
      } else
        this.checkExpressionErrors(refExpressionErrors, !0);
      return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, init);
    }
    parseFunctionStatement(node, isAsync, isHangingDeclaration) {
      return this.next(), this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    parseIfStatement(node) {
      return this.next(), node.test = this.parseHeaderExpression(), node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(node, "IfStatement");
    }
    parseReturnStatement(node) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(Errors.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? node.argument = null : (node.argument = this.parseExpression(), this.semicolon()), this.finishNode(node, "ReturnStatement");
    }
    parseSwitchStatement(node) {
      this.next(), node.discriminant = this.parseHeaderExpression();
      const cases = node.cases = [];
      this.expect(5), this.state.labels.push(switchLabel), this.scope.enter(0);
      let cur;
      for (let sawDefault; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const isCase = this.match(61);
          cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), sawDefault = !0, cur.test = null), this.expect(14);
        } else
          cur ? cur.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(node, "SwitchStatement");
    }
    parseThrowStatement(node) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0), this.checkLVal(param, {
        type: "CatchClause"
      }, 9), param;
    }
    parseTryStatement(node) {
      if (this.next(), node.block = this.parseBlock(), node.handler = null, this.match(62)) {
        const clause = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), clause.param = this.parseCatchClauseParam(), this.expect(11)) : (clause.param = null, this.scope.enter(0)), clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), node.handler = this.finishNode(clause, "CatchClause");
      }
      return node.finalizer = this.eat(67) ? this.parseBlock() : null, !node.handler && !node.finalizer && this.raise(Errors.NoCatchOrFinally, node), this.finishNode(node, "TryStatement");
    }
    parseVarStatement(node, kind, allowMissingInitializer = !1) {
      return this.next(), this.parseVar(node, !1, kind, allowMissingInitializer), this.semicolon(), this.finishNode(node, "VariableDeclaration");
    }
    parseWhileStatement(node) {
      return this.next(), node.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(node, "WhileStatement");
    }
    parseWithStatement(node) {
      return this.state.strict && this.raise(Errors.StrictWith, this.state.startLoc), this.next(), node.object = this.parseHeaderExpression(), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(node, "WithStatement");
    }
    parseEmptyStatement(node) {
      return this.next(), this.finishNode(node, "EmptyStatement");
    }
    parseLabeledStatement(node, maybeName, expr, flags) {
      for (const label of this.state.labels)
        label.name === maybeName && this.raise(Errors.LabelRedeclaration, expr, {
          labelName: maybeName
        });
      const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];
        if (label.statementStart === node.start)
          label.statementStart = this.sourceToOffsetPos(this.state.start), label.kind = kind;
        else
          break;
      }
      return this.state.labels.push({
        name: maybeName,
        kind,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
    }
    parseExpressionStatement(node, expr, decorators) {
      return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
    }
    parseBlock(allowDirectives = !1, createNewLexicalScope = !0, afterBlockParse) {
      const node = this.startNode();
      return allowDirectives && this.state.strictErrors.clear(), this.expect(5), createNewLexicalScope && this.scope.enter(0), this.parseBlockBody(node, allowDirectives, !1, 8, afterBlockParse), createNewLexicalScope && this.scope.exit(), this.finishNode(node, "BlockStatement");
    }
    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node.body = [], directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = !1, parsedNonDirective = !1;
      for (; !this.match(end); ) {
        const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive), !hasStrictModeDirective && directive.value.value === "use strict" && (hasStrictModeDirective = !0, this.setStrict(!0));
            continue;
          }
          parsedNonDirective = !0, this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      afterBlockParse?.call(this, hasStrictModeDirective), oldStrict || this.setStrict(!1), this.next();
    }
    parseFor(node, init) {
      return node.init = init, this.semicolon(!1), node.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), node.update = this.match(11) ? null : this.parseExpression(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, "ForStatement");
    }
    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(58);
      return this.next(), isForIn ? awaitAt !== null && this.unexpected(awaitAt) : node.await = awaitAt !== null, init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier") && this.raise(Errors.ForInOfLoopInitializer, init, {
        type: isForIn ? "ForInStatement" : "ForOfStatement"
      }), init.type === "AssignmentPattern" && this.raise(Errors.InvalidLhs, init, {
        ancestor: {
          type: "ForStatement"
        }
      }), node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node, isFor, kind, allowMissingInitializer = !1) {
      const declarations = node.declarations = [];
      for (node.kind = kind; ; ) {
        const decl = this.startNode();
        if (this.parseVarId(decl, kind), decl.init = this.eat(29) ? isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, decl.init === null && !allowMissingInitializer && (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102))) ? this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind
        })), declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(12)) break;
      }
      return node;
    }
    parseVarId(decl, kind) {
      const id = this.parseBindingAtom();
      (kind === "using" || kind === "await using") && (id.type === "ArrayPattern" || id.type === "ObjectPattern") && this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start), this.checkLVal(id, {
        type: "VariableDeclarator"
      }, kind === "var" ? 5 : 8201), decl.id = id;
    }
    parseAsyncFunctionExpression(node) {
      return this.parseFunction(node, 8);
    }
    parseFunction(node, flags = 0) {
      const hangingDeclaration = flags & 2, isDeclaration = !!(flags & 1), requireId = isDeclaration && !(flags & 4), isAsync = !!(flags & 8);
      this.initFunction(node, isAsync), this.match(55) && (hangingDeclaration && this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), node.generator = !0), isDeclaration && (node.id = this.parseFunctionId(requireId));
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(functionFlags(isAsync, node.generator)), isDeclaration || (node.id = this.parseFunctionId()), this.parseFunctionParams(node, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), isDeclaration && !hangingDeclaration && this.registerFunctionStatementId(node), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
    }
    parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node, isConstructor) {
      this.expect(10), this.expressionScope.enter(newParameterDeclarationScope()), node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(node) {
      node.id && this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
    }
    parseClass(node, isStatement, optionalId) {
      this.next();
      const oldStrict = this.state.strict;
      return this.state.strict = !0, this.parseClassId(node, isStatement, optionalId), this.parseClassSuper(node), node.body = this.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(key2) {
      return key2.type === "Identifier" && key2.name === "constructor" || key2.type === "StringLiteral" && key2.value === "constructor";
    }
    isNonstaticConstructor(method) {
      return !method.computed && !method.static && this.nameIsConstructor(method.key);
    }
    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: !1,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      if (classBody.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (decorators.length > 0)
              throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), decorators = []), this.parseClassMember(classBody, member, state), member.kind === "constructor" && member.decorators && member.decorators.length > 0 && this.raise(Errors.DecoratorConstructor, member);
        }
      }), this.state.strict = oldStrict, this.next(), decorators.length)
        throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const key2 = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const method = member;
        return method.kind = "method", method.computed = !1, method.key = key2, method.static = !1, this.pushClassMethod(classBody, method, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        const prop = member;
        return prop.computed = !1, prop.key = key2, prop.static = !1, classBody.body.push(this.parseClassProperty(prop)), !0;
      }
      return this.resetPreviousNodeTrailingComments(key2), !1;
    }
    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual(106);
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, accessorProp = member, method = publicMethod, publicMember = publicMethod;
      if (member.static = isStatic, this.parsePropertyNamePrefixOperator(member), this.eat(55)) {
        method.kind = "method";
        const isPrivateName = this.match(139);
        if (this.parseClassElementName(method), isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, !0, !1);
          return;
        }
        this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsGenerator, publicMethod.key), this.pushClassMethod(classBody, publicMethod, !0, !1, !1, !1);
        return;
      }
      const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type), key2 = this.parseClassElementName(member), maybeContextualKw = isContextual ? key2.name : null, isPrivate = this.isPrivateName(key2), maybeQuestionTokenStartLoc = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
        if (method.kind = "method", isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, !1, !1);
          return;
        }
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = !1;
        isConstructor && (publicMethod.kind = "constructor", state.hadConstructor && !this.hasPlugin("typescript") && this.raise(Errors.DuplicateConstructor, key2), isConstructor && this.hasPlugin("typescript") && member.override && this.raise(Errors.OverrideOnConstructor, key2), state.hadConstructor = !0, allowsDirectSuper = state.hadSuperClass), this.pushClassMethod(classBody, publicMethod, !1, !1, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty())
        isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp);
      else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key2);
        const isGenerator = this.eat(55);
        publicMember.optional && this.unexpected(maybeQuestionTokenStartLoc), method.kind = "method";
        const isPrivate2 = this.match(139);
        this.parseClassElementName(method), this.parsePostMemberNameModifiers(publicMember), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, !0) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAsync, publicMethod.key), this.pushClassMethod(classBody, publicMethod, isGenerator, !0, !1, !1));
      } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key2), method.kind = maybeContextualKw;
        const isPrivate2 = this.match(139);
        this.parseClassElementName(publicMethod), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, !1, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAccessor, publicMethod.key), this.pushClassMethod(classBody, publicMethod, !1, !1, !1, !1)), this.checkGetterSetterParams(publicMethod);
      } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(key2);
        const isPrivate2 = this.match(139);
        this.parseClassElementName(publicProp), this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
      } else this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected();
    }
    parseClassElementName(member) {
      const {
        type: type2,
        value
      } = this.state;
      if ((type2 === 132 || type2 === 134) && member.static && value === "prototype" && this.raise(Errors.StaticPrototype, this.state.startLoc), type2 === 139) {
        value === "constructor" && this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
        const key2 = this.parsePrivateName();
        return member.key = key2, key2;
      }
      return this.parsePropertyName(member), member.key;
    }
    parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.scope.enter(208);
      const oldLabels = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = oldLabels, classBody.body.push(this.finishNode(member, "StaticBlock")), (_member$decorators = member.decorators) != null && _member$decorators.length && this.raise(Errors.DecoratorStaticBlock, member);
    }
    pushClassProperty(classBody, prop) {
      !prop.computed && this.nameIsConstructor(prop.key) && this.raise(Errors.ConstructorClassField, prop.key), classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node), this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    }
    pushClassAccessorProperty(classBody, prop, isPrivate) {
      !isPrivate && !prop.computed && this.nameIsConstructor(prop.key) && this.raise(Errors.ConstructorClassField, prop.key);
      const node = this.parseClassAccessorProperty(prop);
      classBody.body.push(node), isPrivate && this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const node = this.parseMethod(method, isGenerator, isAsync, !1, !1, "ClassPrivateMethod", !0);
      classBody.body.push(node);
      const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(node, kind);
    }
    declareClassPrivateMethodInScope(node, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node) {
      return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassPrivateProperty");
    }
    parseClassProperty(node) {
      return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassProperty");
    }
    parseClassAccessorProperty(node) {
      return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassAccessorProperty");
    }
    parseInitializer(node) {
      this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(node, isStatement, optionalId, bindingType = 8331) {
      if (tokenIsIdentifier(this.state.type))
        node.id = this.parseIdentifier(), isStatement && this.declareNameFromIdentifier(node.id, bindingType);
      else if (optionalId || !isStatement)
        node.id = null;
      else
        throw this.raise(Errors.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(node) {
      node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(node, decorators) {
      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, !0), hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier), parseAfterDefault = !hasDefault || this.eat(12), hasStar = parseAfterDefault && this.eatExportStar(node), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12)), isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault && this.unexpected(), decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        return this.parseExportFrom(node, !0), this.finishNode(node, "ExportAllDeclaration");
      }
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
      hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers && this.unexpected(null, 5), hasNamespace && parseAfterNamespace && this.unexpected(null, 98);
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        if (hasDeclaration = !1, decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        this.parseExportFrom(node, isFromRequired);
      } else
        hasDeclaration = this.maybeParseExportDeclaration(node);
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        var _node2$declaration;
        const node2 = node;
        if (this.checkExport(node2, !0, !1, !!node2.source), ((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration")
          this.maybeTakeDecorators(decorators, node2.declaration, node2);
        else if (decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        return this.finishNode(node2, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const node2 = node, decl = this.parseExportDefaultExpression();
        if (node2.declaration = decl, decl.type === "ClassDeclaration")
          this.maybeTakeDecorators(decorators, decl, node2);
        else if (decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        return this.checkExport(node2, !0, !0), this.finishNode(node2, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(node) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier?.loc.start);
        const id = maybeDefaultIdentifier || this.parseIdentifier(!0), specifier = this.startNodeAtNode(id);
        return specifier.exported = id, node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual(93)) {
        var _ref, _ref$specifiers;
        (_ref$specifiers = (_ref = node).specifiers) != null || (_ref.specifiers = []);
        const specifier = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), specifier.exported = this.parseModuleExportName(), node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(node) {
      if (this.match(5)) {
        const node2 = node;
        node2.specifiers || (node2.specifiers = []);
        const isTypeExport = node2.exportKind === "type";
        return node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport)), node2.source = null, node2.declaration = null, this.hasPlugin("importAssertions") && (node2.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(node) {
      return this.shouldParseExportDeclaration() ? (node.specifiers = [], node.source = null, this.hasPlugin("importAssertions") && (node.assertions = []), node.declaration = this.parseExportDeclaration(node), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      const next = this.nextTokenInLineStart();
      return this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(expr, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(expr, 13);
      if (this.match(80))
        return this.parseClass(expr, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
      const res = this.parseMaybeAssignAllowIn();
      return this.semicolon(), res;
    }
    parseExportDeclaration(node) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type: type2
      } = this.state;
      if (tokenIsIdentifier(type2)) {
        if (type2 === 95 && !this.state.containsEsc || type2 === 100)
          return !1;
        if ((type2 === 130 || type2 === 129) && !this.state.containsEsc) {
          const {
            type: nextType
          } = this.lookahead();
          if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      const next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom)
        return !0;
      if (this.match(65) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return !1;
    }
    parseExportFrom(node, expect) {
      this.eatContextual(98) ? (node.source = this.parseImportSource(), this.checkExport(node), this.maybeParseImportAttributes(node), this.checkJSONModuleImport(node)) : expect && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: type2
      } = this.state;
      return type2 === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(Errors.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(Errors.UsingDeclarationExport, this.state.startLoc), !0) : type2 === 74 || type2 === 75 || type2 === 68 || type2 === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        var _node$specifiers;
        if (isDefault) {
          if (this.checkDuplicateExports(node, "default"), this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            const declaration = node.declaration;
            declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized) && this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
          }
        } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length)
          for (const specifier of node.specifiers) {
            const {
              exported
            } = specifier, exportName = exported.type === "Identifier" ? exported.name : exported.value;
            if (this.checkDuplicateExports(specifier, exportName), !isFrom && specifier.local) {
              const {
                local
              } = specifier;
              local.type !== "Identifier" ? this.raise(Errors.ExportBindingIsString, specifier, {
                localName: local.value,
                exportName
              }) : (this.checkReservedWord(local.name, local.loc.start, !0, !1), this.scope.checkLocalExport(local));
            }
          }
        else if (node.declaration) {
          const decl = node.declaration;
          if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
            const {
              id
            } = decl;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (decl.type === "VariableDeclaration")
            for (const declaration of decl.declarations)
              this.checkDeclaration(declaration.id);
        }
      }
    }
    checkDeclaration(node) {
      if (node.type === "Identifier")
        this.checkDuplicateExports(node, node.name);
      else if (node.type === "ObjectPattern")
        for (const prop of node.properties)
          this.checkDeclaration(prop);
      else if (node.type === "ArrayPattern")
        for (const elem of node.elements)
          elem && this.checkDeclaration(elem);
      else node.type === "ObjectProperty" ? this.checkDeclaration(node.value) : node.type === "RestElement" ? this.checkDeclaration(node.argument) : node.type === "AssignmentPattern" && this.checkDeclaration(node.left);
    }
    checkDuplicateExports(node, exportName) {
      this.exportedIdentifiers.has(exportName) && (exportName === "default" ? this.raise(Errors.DuplicateDefaultExport, node) : this.raise(Errors.DuplicateExport, node, {
        exportName
      })), this.exportedIdentifiers.add(exportName);
    }
    parseExportSpecifiers(isInTypeExport) {
      const nodes = [];
      let first2 = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.eat(8)) break;
        const isMaybeTypeOnly = this.isContextual(130), isString = this.match(134), node = this.startNode();
        node.local = this.parseModuleExportName(), nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
      }
      return nodes;
    }
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
      return this.eatContextual(93) ? node.exported = this.parseModuleExportName() : isString ? node.exported = cloneStringLiteral(node.local) : node.exported || (node.exported = cloneIdentifier(node.local)), this.finishNode(node, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        const result = this.parseStringLiteral(this.state.value), surrogate = loneSurrogate.exec(result.value);
        return surrogate && this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
          surrogateCharCode: surrogate[0].charCodeAt(0)
        }), result;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(node) {
      return node.assertions != null ? node.assertions.some(({
        key: key2,
        value
      }) => value.value === "json" && (key2.type === "Identifier" ? key2.name === "type" : key2.value === "type")) : !1;
    }
    checkImportReflection(node) {
      const {
        specifiers
      } = node, singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
      if (node.phase === "source")
        singleBindingType !== "ImportDefaultSpecifier" && this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
      else if (node.phase === "defer")
        singleBindingType !== "ImportNamespaceSpecifier" && this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
      else if (node.module) {
        var _node$assertions;
        singleBindingType !== "ImportDefaultSpecifier" && this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start), ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0 && this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
      }
    }
    checkJSONModuleImport(node) {
      if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
        const {
          specifiers
        } = node;
        if (specifiers != null) {
          const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
            let imported;
            if (specifier.type === "ExportSpecifier" ? imported = specifier.local : specifier.type === "ImportSpecifier" && (imported = specifier.imported), imported !== void 0)
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
          });
          nonDefaultNamedSpecifier !== void 0 && this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
        }
      }
    }
    isPotentialImportPhase(isExport) {
      return isExport ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(node, isExport, phase, loc) {
      isExport || (phase === "module" ? (this.expectPlugin("importReflection", loc), node.module = !0) : this.hasPlugin("importReflection") && (node.module = !1), phase === "source" ? (this.expectPlugin("sourcePhaseImports", loc), node.phase = "source") : phase === "defer" ? (this.expectPlugin("deferredImportEvaluation", loc), node.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (node.phase = null));
    }
    parseMaybeImportPhase(node, isExport) {
      if (!this.isPotentialImportPhase(isExport))
        return this.applyImportPhase(node, isExport, null), null;
      const phaseIdentifier = this.parseIdentifier(!0), {
        type: type2
      } = this.state;
      return (tokenIsKeywordOrIdentifier(type2) ? type2 !== 98 || this.lookaheadCharCode() === 102 : type2 !== 12) ? (this.resetPreviousIdentifierLeadingComments(phaseIdentifier), this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start), null) : (this.applyImportPhase(node, isExport, null), phaseIdentifier);
    }
    isPrecedingIdImportPhase(phase) {
      const {
        type: type2
      } = this.state;
      return tokenIsIdentifier(type2) ? type2 !== 98 || this.lookaheadCharCode() === 102 : type2 !== 12;
    }
    parseImport(node) {
      return this.match(134) ? this.parseImportSourceAndAttributes(node) : this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, !1));
    }
    parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
      node.specifiers = [];
      const parseNext = !this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) || this.eat(12), hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
      return parseNext && !hasStar && this.parseNamedImportSpecifiers(node), this.expectContextual(98), this.parseImportSourceAndAttributes(node);
    }
    parseImportSourceAndAttributes(node) {
      var _node$specifiers2;
      return (_node$specifiers2 = node.specifiers) != null || (node.specifiers = []), node.source = this.parseImportSource(), this.maybeParseImportAttributes(node), this.checkImportReflection(node), this.checkJSONModuleImport(node), this.semicolon(), this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(node, specifier, type2) {
      specifier.local = this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type2));
    }
    finishImportSpecifier(specifier, type2, bindingType = 8201) {
      return this.checkLVal(specifier.local, {
        type: type2
      }, bindingType), this.finishNode(specifier, type2);
    }
    parseImportAttributes() {
      this.expect(5);
      const attrs = [], attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const node = this.startNode(), keyName = this.state.value;
        if (attrNames.has(keyName) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: keyName
        }), attrNames.add(keyName), this.match(134) ? node.key = this.parseStringLiteral(keyName) : node.key = this.parseIdentifier(!0), this.expect(14), !this.match(134))
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        node.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), attrs;
    }
    parseModuleAttributes() {
      const attrs = [], attributes = /* @__PURE__ */ new Set();
      do {
        const node = this.startNode();
        if (node.key = this.parseIdentifier(!0), node.key.name !== "type" && this.raise(Errors.ModuleAttributeDifferentFromType, node.key), attributes.has(node.key.name) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
          key: node.key.name
        }), attributes.add(node.key.name), this.expect(14), !this.match(134))
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        node.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(12));
      return attrs;
    }
    maybeParseImportAttributes(node) {
      let attributes;
      var useWith = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? attributes = this.parseModuleAttributes() : attributes = this.parseImportAttributes(), useWith = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions") && this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(node, "deprecatedAssertSyntax", !0), this.next(), attributes = this.parseImportAttributes()) : attributes = [];
      !useWith && this.hasPlugin("importAssertions") ? node.assertions = attributes : node.attributes = attributes;
    }
    maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier) {
        const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
        return specifier.local = maybeDefaultIdentifier, node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier")), !0;
      } else if (tokenIsKeywordOrIdentifier(this.state.type))
        return this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(node) {
      if (this.match(55)) {
        const specifier = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(node) {
      let first2 = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (first2)
          first2 = !1;
        else {
          if (this.eat(14))
            throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const specifier = this.startNode(), importedIsString = this.match(134), isMaybeTypeOnly = this.isContextual(130);
        specifier.imported = this.parseModuleExportName();
        const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
        node.specifiers.push(importSpecifier);
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93))
        specifier.local = this.parseIdentifier();
      else {
        const {
          imported
        } = specifier;
        if (importedIsString)
          throw this.raise(Errors.ImportBindingIsString, specifier, {
            importName: imported.value
          });
        this.checkReservedWord(imported.name, specifier.loc.start, !0, !0), specifier.local || (specifier.local = cloneIdentifier(imported));
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }
  class Parser extends StatementParser {
    constructor(options2, input2, pluginsMap) {
      options2 = getOptions(options2), super(options2, input2), this.options = options2, this.initializeScopes(), this.plugins = pluginsMap, this.filename = options2.sourceFilename, this.startIndex = options2.startIndex;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      this.enterInitialScopes();
      const file = this.startNode(), program = this.startNode();
      return this.nextToken(), file.errors = null, this.parseTopLevel(file, program), file.errors = this.state.errors, file.comments.length = this.state.commentsLen, file;
    }
  }
  function parse3(input2, options2) {
    var _options;
    if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options2 = Object.assign({}, options2);
      try {
        options2.sourceType = "module";
        const parser2 = getParser(options2, input2), ast = parser2.parse();
        if (parser2.sawUnambiguousESM)
          return ast;
        if (parser2.ambiguousScriptDifferentAst)
          try {
            return options2.sourceType = "script", getParser(options2, input2).parse();
          } catch {
          }
        else
          ast.program.sourceType = "script";
        return ast;
      } catch (moduleError) {
        try {
          return options2.sourceType = "script", getParser(options2, input2).parse();
        } catch {
        }
        throw moduleError;
      }
    } else
      return getParser(options2, input2).parse();
  }
  function parseExpression(input2, options2) {
    const parser2 = getParser(options2, input2);
    return parser2.options.strictMode && (parser2.state.strict = !0), parser2.getExpression();
  }
  function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes2 = {};
    for (const typeName of Object.keys(internalTokenTypes))
      tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    return tokenTypes2;
  }
  const tokTypes = generateExportedTokenTypes(tt);
  function getParser(options2, input2) {
    let cls = Parser;
    const pluginsMap = /* @__PURE__ */ new Map();
    if (options2 != null && options2.plugins) {
      for (const plugin of options2.plugins) {
        let name, opts;
        typeof plugin == "string" ? name = plugin : [name, opts] = plugin, pluginsMap.has(name) || pluginsMap.set(name, opts || {});
      }
      validatePlugins(pluginsMap), cls = getParserClass(pluginsMap);
    }
    return new cls(options2, input2, pluginsMap);
  }
  const parserClassCache = /* @__PURE__ */ new Map();
  function getParserClass(pluginsMap) {
    const pluginList = [];
    for (const name of mixinPluginNames)
      pluginsMap.has(name) && pluginList.push(name);
    const key2 = pluginList.join("|");
    let cls = parserClassCache.get(key2);
    if (!cls) {
      cls = Parser;
      for (const plugin of pluginList)
        cls = mixinPlugins[plugin](cls);
      parserClassCache.set(key2, cls);
    }
    return cls;
  }
  return lib$1.parse = parse3, lib$1.parseExpression = parseExpression, lib$1.tokTypes = tokTypes, lib$1;
}
var hasRequiredBabel;
function requireBabel() {
  return hasRequiredBabel || (hasRequiredBabel = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.parse = exports2.parser = void 0;
    var tslib_1 = require$$0$3, _babel_options_1 = tslib_1.__importDefault(require_babel_options());
    exports2.parser = function() {
      try {
        return requireLib$1();
      } catch {
        try {
          return require("babylon");
        } catch {
          throw new Error("Install @babel/parser to use the `typescript`, `flow`, or `babel` parsers");
        }
      }
    }();
    function parse3(source2, options2) {
      var babelOptions = (0, _babel_options_1.default)(options2);
      return babelOptions.plugins.push("jsx", "flow", "decoratorAutoAccessors"), exports2.parser.parse(source2, babelOptions);
    }
    exports2.parse = parse3;
  }(babel)), babel;
}
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript$1;
  hasRequiredTypescript = 1, Object.defineProperty(typescript$1, "__esModule", { value: !0 }), typescript$1.parse = void 0;
  var tslib_1 = require$$0$3, babel_1 = requireBabel(), _babel_options_1 = tslib_1.__importDefault(require_babel_options());
  function parse3(source2, options2) {
    var babelOptions = (0, _babel_options_1.default)(options2);
    return babelOptions.plugins.push("typescript"), babel_1.parser.parse(source2, babelOptions);
  }
  return typescript$1.parse = parse3, typescript$1;
}
var typescriptExports = requireTypescript(), typescript = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(typescriptExports), parser = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: typescript
}, [typescriptExports]);
const defaultTemplate$1 = `
import {defineCliConfig} from 'sanity/cli'

export default defineCliConfig({
  api: {
    projectId: '%projectId%',
    dataset: '%dataset%'
  },
  /**
   * Enable auto-updates for studios.
   * Learn more at https://www.sanity.io/docs/cli#auto-updates
   */
  autoUpdates: __BOOL__autoUpdates__,
})
`;
function createCliConfig(options2) {
  const variables = options2, template = defaultTemplate$1.trimStart(), ast = mainExports.parse(template, { parser });
  return traverse__default.default(ast, {
    StringLiteral: {
      enter({ node }) {
        const value = node.value;
        if (!value.startsWith("%") || !value.endsWith("%"))
          return;
        const variableName = value.slice(1, -1);
        if (!(variableName in variables))
          throw new Error(`Template variable '${value}' not defined`);
        const newValue = variables[variableName];
        node.value = typeof newValue == "string" ? newValue : "";
      }
    },
    Identifier: {
      enter(path2) {
        if (!path2.node.name.startsWith("__BOOL__"))
          return;
        const variableName = path2.node.name.replace(
          /^__BOOL__(.+?)__$/,
          "$1"
        );
        if (!(variableName in variables))
          throw new Error(`Template variable '${variableName}' not defined`);
        const value = variables[variableName];
        if (typeof value != "boolean")
          throw new Error(`Expected boolean value for '${variableName}'`);
        path2.replaceWith({ type: "BooleanLiteral", value });
      }
    }
  }), mainExports.print(ast, { quote: "single" }).code;
}
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject, hasRequiredIsobject;
function requireIsobject() {
  return hasRequiredIsobject || (hasRequiredIsobject = 1, isobject = function(val) {
    return val != null && typeof val == "object" && Array.isArray(val) === !1;
  }), isobject;
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isPlainObject, hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject;
  hasRequiredIsPlainObject = 1;
  var isObject2 = requireIsobject();
  function isObjectObject(o) {
    return isObject2(o) === !0 && Object.prototype.toString.call(o) === "[object Object]";
  }
  return isPlainObject = function(o) {
    var ctor, prot;
    return !(isObjectObject(o) === !1 || (ctor = o.constructor, typeof ctor != "function") || (prot = ctor.prototype, isObjectObject(prot) === !1) || prot.hasOwnProperty("isPrototypeOf") === !1);
  }, isPlainObject;
}
var deepSortObject, hasRequiredDeepSortObject;
function requireDeepSortObject() {
  if (hasRequiredDeepSortObject) return deepSortObject;
  hasRequiredDeepSortObject = 1;
  var isPlainObject2 = requireIsPlainObject();
  function defaultSortFn(a, b) {
    return a.localeCompare(b);
  }
  function sort(src2, comparator) {
    var out;
    return Array.isArray(src2) ? src2.map(function(item) {
      return sort(item, comparator);
    }) : isPlainObject2(src2) ? (out = {}, Object.keys(src2).sort(comparator || defaultSortFn).forEach(function(key2) {
      out[key2] = sort(src2[key2], comparator);
    }), out) : src2;
  }
  return deepSortObject = sort, deepSortObject;
}
var deepSortObjectExports = requireDeepSortObject(), sortObject = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(deepSortObjectExports);
const manifestPropOrder = [
  "name",
  "private",
  "version",
  "description",
  "main",
  "author",
  "license",
  "scripts",
  "keywords",
  "dependencies",
  "devDependencies"
];
function createPackageManifest(data) {
  const dependencies = data.dependencies ? { dependencies: sortObject(data.dependencies) } : {}, devDependencies = data.devDependencies ? { devDependencies: sortObject(data.devDependencies) } : {}, pkg = {
    ...getCommonManifest(data),
    main: "package.json",
    keywords: ["sanity"],
    scripts: {
      dev: "sanity dev",
      start: "sanity start",
      build: "sanity build",
      deploy: "sanity deploy",
      "deploy-graphql": "sanity graphql deploy"
    },
    ...dependencies,
    ...devDependencies,
    prettier: {
      semi: !1,
      printWidth: 100,
      bracketSpacing: !1,
      singleQuote: !0
    }
  };
  return serializeManifest(pkg);
}
function getCommonManifest(data) {
  const pkg = {
    name: data.name,
    version: "1.0.0",
    description: data.description,
    author: data.author,
    license: data.license || "UNLICENSED",
    devDependencies: {}
  };
  return pkg.license === "UNLICENSED" && (pkg.private = !0), data.gitRemote && (pkg.repository = {
    type: "git",
    url: data.gitRemote
  }), pkg;
}
function serializeManifest(src2) {
  const ordered = manifestPropOrder.concat(Object.keys(src2)).reduce(
    (target, prop) => {
      const source2 = src2;
      return typeof source2[prop] < "u" && typeof target[prop] > "u" && (target[prop] = source2[prop]), target;
    },
    {}
  );
  return `${JSON.stringify(ordered, null, 2)}
`;
}
const defaultTemplate = `
import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [structureTool(), visionTool()],

  schema: {
    types: schemaTypes,
  },
})
`, defaultVariables = {
  projectName: "Sanity Studio",
  sourceName: "default",
  sourceTitle: "Default"
};
function createStudioConfig(options2) {
  const variables = { ...defaultVariables, ...options2.variables };
  if (typeof options2.template == "function")
    return options2.template(variables).trimStart();
  const template = (options2.template || defaultTemplate).trimStart(), ast = mainExports.parse(template, { parser });
  return traverse__default.default(ast, {
    StringLiteral: {
      enter({ node }) {
        const value = node.value;
        if (!value.startsWith("%") || !value.endsWith("%"))
          return;
        const variableName = value.slice(1, -1);
        if (!(variableName in variables))
          throw new Error(`Template variable '${value}' not defined`);
        const newValue = variables[variableName];
        node.value = typeof newValue == "string" ? newValue : "";
      }
    }
  }), mainExports.print(ast, { quote: "single" }).code;
}
const blogTemplate = {}, cleanTemplate = {}, configTemplate$3 = `
import {defineConfig, isDev} from 'sanity'
import {visionTool} from '@sanity/vision'
import {structureTool} from 'sanity/structure'
import {schemaTypes} from './schemaTypes'
import {getStartedPlugin} from './plugins/sanity-plugin-tutorial'

const devOnlyPlugins = [getStartedPlugin()]

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [structureTool(), visionTool(), ...(isDev ? devOnlyPlugins : [])],

  schema: {
    types: schemaTypes,
  },
})

`, getStartedTemplate = {
  configTemplate: configTemplate$3,
  typescriptOnly: !0,
  dependencies: {
    "@sanity/icons": "^2.11.0",
    "@sanity/ui": "^2.0.0"
  }
}, configTemplate$2 = `
import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [
    structureTool(),
    visionTool(),
  ],

  schema: {
    types: schemaTypes,
  },
})
`, movieTemplate = {
  configTemplate: configTemplate$2,
  importPrompt: "Add a sampling of sci-fi movies to your dataset on the hosted backend?",
  datasetUrl: "https://public.sanity.io/moviesdb-2018-03-06.tar.gz",
  dependencies: {
    "react-icons": "^3.11.0"
  }
}, quickStartTemplate = {}, configTemplate$1 = `
import {defineConfig, isDev} from 'sanity'

import {structureTool} from 'sanity/structure'
import {schemaTypes} from './schemaTypes'
import {structure} from './structure'

import {visionTool} from '@sanity/vision'
import {colorInput} from '@sanity/color-input'
import {imageHotspotArrayPlugin} from 'sanity-plugin-hotspot-array'
import {media, mediaAssetSource} from 'sanity-plugin-media'
import {customDocumentActions} from './plugins/customDocumentActions'
import Navbar from './components/studio/Navbar'

const devOnlyPlugins = [visionTool()]

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [
    structureTool({structure}),
    colorInput(),
    imageHotspotArrayPlugin(),
    customDocumentActions(),
    media(),
    ...(isDev ? devOnlyPlugins : []),
  ],

  schema: {
    types: schemaTypes,
  },

  form: {
    file: {
      assetSources: (previousAssetSources) => {
        return previousAssetSources.filter((assetSource) => assetSource !== mediaAssetSource)
      },
    },
    image: {
      assetSources: (previousAssetSources) => {
        return previousAssetSources.filter((assetSource) => assetSource === mediaAssetSource)
      },
    },
  },

  studio: {
    components: {
      navbar: Navbar,
    },
  },
})`, shopifyTemplate$1 = {
  configTemplate: configTemplate$1,
  dependencies: {
    "@sanity/asset-utils": "^1.3.0",
    "@sanity/color-input": "^3.0.2",
    "@sanity/icons": "^2.11.0",
    "@sanity/ui": "^2.0.0",
    "lodash.get": "^4.4.2",
    "pluralize-esm": "^9.0.2",
    "sanity-plugin-hotspot-array": "^1.0.1",
    "sanity-plugin-media": "^2.0.5",
    slug: "^8.2.2"
  },
  devDependencies: {
    "@portabletext/types": "^2.0.2",
    "@types/lodash.get": "^4.4.7",
    "@types/slug": "^5.0.3"
  }
}, configTemplate = `
import {shopifyAssets} from 'sanity-plugin-shopify-assets'
import {defineConfig, isDev} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {shopifyDocumentActions} from './plugins/shopifyDocumentActions'
import {schemaTypes} from './schemaTypes'
import {structure} from './structure'
import {SHOPIFY_STORE_ID} from './constants'

const devOnlyPlugins = [visionTool()]

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [
    structureTool({structure}),
    shopifyDocumentActions(),
    shopifyAssets({
      shopifyDomain: SHOPIFY_STORE_ID,
    }),
    ...(isDev ? devOnlyPlugins : []),
  ],

  schema: {
    types: schemaTypes,
  },
})
`, shopifyTemplate = {
  configTemplate,
  typescriptOnly: !0,
  dependencies: {
    "@portabletext/toolkit": "^2.0.1",
    "@sanity/icons": "^2.11.0",
    "@sanity/ui": "^2.0.0",
    "@types/lodash.get": "^4.4.7",
    "lodash.get": "^4.4.2",
    "pluralize-esm": "^9.0.4",
    "sanity-plugin-shopify-assets": "^1.1.0"
  }
}, templates = {
  blog: blogTemplate,
  clean: cleanTemplate,
  "get-started": getStartedTemplate,
  moviedb: movieTemplate,
  shopify: shopifyTemplate$1,
  "shopify-online-storefront": shopifyTemplate,
  quickstart: quickStartTemplate
  // empty project that dynamically imports its own schema
};
async function updateInitialTemplateMetadata(apiClient, projectId, templateName) {
  try {
    await apiClient({ api: { projectId } }).request({
      method: "PATCH",
      uri: `/projects/${projectId}`,
      body: { metadata: { initialTemplate: templateName } }
    });
  } catch (err) {
    let message = typeof err == "string" ? err : "<unknown error>";
    err instanceof Error && (message = err.message), loadEnv.debug("Failed to update initial template metadata for project: %s", message);
  }
}
async function bootstrapLocalTemplate(opts, context) {
  const { apiClient, cliRoot, output } = context, templatesDir = path__default.default.join(cliRoot, "templates"), { outputPath, templateName, useTypeScript, packageName, variables } = opts, sourceDir = path__default.default.join(templatesDir, templateName), sharedDir = path__default.default.join(templatesDir, "shared"), template = templates[templateName];
  if (!template)
    throw new Error(`Template "${templateName}" not defined`);
  loadEnv.debug('Copying files from template "%s" to "%s"', templateName, outputPath);
  let spinner = output.spinner(
    opts.schemaUrl ? "Extracting your Sanity configuration" : "Bootstrapping files from template"
  ).start();
  await copy(sourceDir, outputPath, {
    rename: useTypeScript ? toTypeScriptPath : void 0
  }), await copy(path__default.default.join(sharedDir, "gitignore.txt"), outputPath, { rename: () => ".gitignore" }), useTypeScript && await fs__default.default.copyFile(path__default.default.join(sharedDir, "tsconfig.json"), path__default.default.join(outputPath, "tsconfig.json")), opts.schemaUrl && (loadEnv.debug('Fetching and writing remote schema "%s"', opts.schemaUrl), await journeyConfig.getAndWriteJourneySchemaWorker({
    schemasPath: path__default.default.join(outputPath, "schemaTypes"),
    useTypeScript,
    schemaUrl: opts.schemaUrl
  })), spinner.succeed(), spinner = output.spinner("Resolving latest module versions").start();
  const dependencyVersions = await resolveLatestVersions({
    ...studioDependencies.dependencies,
    ...studioDependencies.devDependencies,
    ...template.dependencies || {}
  });
  spinner.succeed();
  const dependencies = Object.keys({
    ...studioDependencies.dependencies,
    ...template.dependencies
  }).reduce(
    (deps, dependency) => (deps[dependency] = dependencyVersions[dependency], deps),
    {}
  ), devDependencies = Object.keys({
    ...studioDependencies.devDependencies,
    ...template.devDependencies
  }).reduce(
    (deps, dependency) => (deps[dependency] = dependencyVersions[dependency], deps),
    {}
  );
  spinner = output.spinner("Creating default project files").start();
  const packageManifest = await createPackageManifest({
    name: packageName,
    dependencies,
    devDependencies
  }), studioConfig = await createStudioConfig({
    template: template.configTemplate,
    variables
  }), cliConfig = await createCliConfig({
    projectId: variables.projectId,
    dataset: variables.dataset,
    autoUpdates: variables.autoUpdates
  }), codeExt = useTypeScript ? "ts" : "js";
  return await Promise.all([
    writeFileIfNotExists(`sanity.config.${codeExt}`, studioConfig),
    writeFileIfNotExists(`sanity.cli.${codeExt}`, cliConfig),
    writeFileIfNotExists("package.json", packageManifest),
    writeFileIfNotExists(
      "eslint.config.mjs",
      `import studio from '@sanity/eslint-config-studio'

export default [...studio]
`
    )
  ]), loadEnv.debug("Updating initial template metadata"), await updateInitialTemplateMetadata(apiClient, variables.projectId, `cli-${templateName}`), spinner.succeed(), template;
  async function writeFileIfNotExists(fileName, content) {
    const filePath = path__default.default.join(outputPath, fileName);
    try {
      await fs__default.default.writeFile(filePath, content, { flag: "wx" });
    } catch (err) {
      if (err.code === "EEXIST")
        output.warn(`
${chalk__default.default.yellow("\u26A0")} File "${filePath}" already exists, skipping`);
      else
        throw err;
    }
  }
}
function toTypeScriptPath(originalPath) {
  return originalPath.replace(/\.js$/, ".ts");
}
const portMap = {
  nextjs: 3e3,
  blitzjs: 3e3,
  gatsby: 8e3,
  remix: 3e3,
  astro: 3e3,
  hexo: 4e3,
  eleventy: 8080,
  docusaurus: 3e3,
  "docusaurus-2": 3e3,
  preact: 8080,
  solidstart: 3e3,
  "solidstart-1": 3e3,
  dojo: 3e3,
  ember: 4200,
  vue: 8080,
  scully: 1668,
  "ionic-angular": 4200,
  angular: 4200,
  polymer: 8081,
  svelte: 5e3,
  sveltekit: 5173,
  "sveltekit-1": 5173,
  "ionic-react": 3e3,
  "create-react-app": 3e3,
  gridsome: 8080,
  umijs: 8e3,
  saber: 3e3,
  stencil: 3333,
  nuxtjs: 3e3,
  redwoodjs: 8910,
  hugo: 1313,
  jekyll: 4e3,
  brunch: 3333,
  middleman: 4567,
  zola: 1111,
  hydrogen: 3e3,
  vite: 5173,
  vitepress: 5173,
  vuepress: 8080,
  parcel: 1234,
  fasthtml: 8e3,
  sanity: 3333,
  "sanity-v3": 3333,
  storybook: 6006
};
function getDefaultPortForFramework(frameworkSlug) {
  return portMap[frameworkSlug ?? ""] ?? 3e3;
}
var braceExpansionExports = requireBraceExpansion(), expand$2 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(braceExpansionExports);
const MAX_PATTERN_LENGTH = 1024 * 64, assertValidPattern = (pattern) => {
  if (typeof pattern != "string")
    throw new TypeError("invalid pattern");
  if (pattern.length > MAX_PATTERN_LENGTH)
    throw new TypeError("pattern is too long");
}, posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&"), regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), rangesToString = (ranges) => ranges.join(""), parseClass = (glob2, position) => {
  const pos2 = position;
  if (glob2.charAt(pos2) !== "[")
    throw new Error("not in a brace expression");
  const ranges = [], negs = [];
  let i = pos2 + 1, sawStart = !1, uflag = !1, escaping = !1, negate = !1, endPos = pos2, rangeStart = "";
  WHILE: for (; i < glob2.length; ) {
    const c2 = glob2.charAt(i);
    if ((c2 === "!" || c2 === "^") && i === pos2 + 1) {
      negate = !0, i++;
      continue;
    }
    if (c2 === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    if (sawStart = !0, c2 === "\\" && !escaping) {
      escaping = !0, i++;
      continue;
    }
    if (c2 === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses))
        if (glob2.startsWith(cls, i)) {
          if (rangeStart)
            return ["$.", !1, glob2.length - pos2, !0];
          i += cls.length, neg ? negs.push(unip) : ranges.push(unip), uflag = uflag || u;
          continue WHILE;
        }
    }
    if (escaping = !1, rangeStart) {
      c2 > rangeStart ? ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2)) : c2 === rangeStart && ranges.push(braceEscape(c2)), rangeStart = "", i++;
      continue;
    }
    if (glob2.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c2 + "-")), i += 2;
      continue;
    }
    if (glob2.startsWith("-", i + 1)) {
      rangeStart = c2, i += 2;
      continue;
    }
    ranges.push(braceEscape(c2)), i++;
  }
  if (endPos < i)
    return ["", !1, 0, !1];
  if (!ranges.length && !negs.length)
    return ["$.", !1, glob2.length - pos2, !0];
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), !1, endPos - pos2, !1];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]", snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  return [ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs, uflag, endPos - pos2, !0];
}, unescape = (s, { windowsPathsNoEscape = !1 } = {}) => windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), isExtglobType = (c2) => types.has(c2), startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))", startNoDot = "(?!\\.)", addPatternStart = /* @__PURE__ */ new Set(["[", "."]), justDots = /* @__PURE__ */ new Set(["..", "."]), reSpecials = new Set("().*{}+?[]^$\\!"), regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), qmark$1 = "[^/]", star$2 = qmark$1 + "*?", starNoEmpty = qmark$1 + "+?";
class AST {
  type;
  #root;
  #hasMagic;
  #uflag = !1;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = !1;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = !1;
  constructor(type2, parent, options2 = {}) {
    this.type = type2, type2 && (this.#hasMagic = !0), this.#parent = parent, this.#root = this.#parent ? this.#parent.#root : this, this.#options = this.#root === this ? options2 : this.#root.#options, this.#negs = this.#root === this ? [] : this.#root.#negs, type2 === "!" && !this.#root.#filledNegs && this.#negs.push(this), this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts)
      if (typeof p != "string" && (p.type || p.hasMagic))
        return this.#hasMagic = !0;
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    return this.#toString !== void 0 ? this.#toString : this.type ? this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")" : this.#toString = this.#parts.map((p) => String(p)).join("");
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString(), this.#filledNegs = !0;
    let n;
    for (; n = this.#negs.pop(); ) {
      if (n.type !== "!")
        continue;
      let p = n, pp = p.#parent;
      for (; pp; ) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++)
          for (const part of n.#parts) {
            if (typeof part == "string")
              throw new Error("string part in extglob AST??");
            part.copyIn(pp.#parts[i]);
          }
        p = pp, pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts)
      if (p !== "") {
        if (typeof p != "string" && !(p instanceof AST && p.#parent === this))
          throw new Error("invalid part: " + p);
        this.#parts.push(p);
      }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p == "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!") && ret.push({}), ret;
  }
  isStart() {
    if (this.#root === this)
      return !0;
    if (!this.#parent?.isStart())
      return !1;
    if (this.#parentIndex === 0)
      return !0;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof AST && pp.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    if (this.#root === this || this.#parent?.type === "!")
      return !0;
    if (!this.#parent?.isEnd())
      return !1;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    typeof part == "string" ? this.push(part) : this.push(part.clone(this));
  }
  clone(parent) {
    const c2 = new AST(this.type, parent);
    for (const p of this.#parts)
      c2.copyIn(p);
    return c2;
  }
  static #parseAST(str2, ast, pos2, opt) {
    let escaping = !1, inBrace = !1, braceStart = -1, braceNeg = !1;
    if (ast.type === null) {
      let i2 = pos2, acc2 = "";
      for (; i2 < str2.length; ) {
        const c2 = str2.charAt(i2++);
        if (escaping || c2 === "\\") {
          escaping = !escaping, acc2 += c2;
          continue;
        }
        if (inBrace) {
          i2 === braceStart + 1 ? (c2 === "^" || c2 === "!") && (braceNeg = !0) : c2 === "]" && !(i2 === braceStart + 2 && braceNeg) && (inBrace = !1), acc2 += c2;
          continue;
        } else if (c2 === "[") {
          inBrace = !0, braceStart = i2, braceNeg = !1, acc2 += c2;
          continue;
        }
        if (!opt.noext && isExtglobType(c2) && str2.charAt(i2) === "(") {
          ast.push(acc2), acc2 = "";
          const ext2 = new AST(c2, ast);
          i2 = AST.#parseAST(str2, ext2, i2, opt), ast.push(ext2);
          continue;
        }
        acc2 += c2;
      }
      return ast.push(acc2), i2;
    }
    let i = pos2 + 1, part = new AST(null, ast);
    const parts = [];
    let acc = "";
    for (; i < str2.length; ) {
      const c2 = str2.charAt(i++);
      if (escaping || c2 === "\\") {
        escaping = !escaping, acc += c2;
        continue;
      }
      if (inBrace) {
        i === braceStart + 1 ? (c2 === "^" || c2 === "!") && (braceNeg = !0) : c2 === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c2;
        continue;
      } else if (c2 === "[") {
        inBrace = !0, braceStart = i, braceNeg = !1, acc += c2;
        continue;
      }
      if (isExtglobType(c2) && str2.charAt(i) === "(") {
        part.push(acc), acc = "";
        const ext2 = new AST(c2, part);
        part.push(ext2), i = AST.#parseAST(str2, ext2, i, opt);
        continue;
      }
      if (c2 === "|") {
        part.push(acc), acc = "", parts.push(part), part = new AST(null, ast);
        continue;
      }
      if (c2 === ")")
        return acc === "" && ast.#parts.length === 0 && (ast.#emptyExt = !0), part.push(acc), acc = "", ast.push(...parts, part), i;
      acc += c2;
    }
    return ast.type = null, ast.#hasMagic = void 0, ast.#parts = [str2.substring(pos2 - 1)], i;
  }
  static fromGlob(pattern, options2 = {}) {
    const ast = new AST(null, void 0, options2);
    return AST.#parseAST(pattern, ast, 0, options2), ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob2 = this.toString(), [re, body, hasMagic2, uflag] = this.toRegExpSource();
    if (!(hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase()))
      return body;
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this && this.#fillNegs(), !this.type) {
      const noEmpty = this.isStart() && this.isEnd(), src2 = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p == "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        return this.#hasMagic = this.#hasMagic || hasMagic2, this.#uflag = this.#uflag || uflag, re;
      }).join("");
      let start2 = "";
      if (this.isStart() && typeof this.#parts[0] == "string" && !(this.#parts.length === 1 && justDots.has(this.#parts[0]))) {
        const aps = addPatternStart, needNoTrav = (
          // dots are allowed, and the pattern starts with [ or .
          dot && aps.has(src2.charAt(0)) || // the pattern starts with \., and then [ or .
          src2.startsWith("\\.") && aps.has(src2.charAt(2)) || // the pattern starts with \.\., and then [ or .
          src2.startsWith("\\.\\.") && aps.has(src2.charAt(4))
        ), needNoDot = !dot && !allowDot && aps.has(src2.charAt(0));
        start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
      }
      let end = "";
      return this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!" && (end = "(?:$|\\/)"), [
        start2 + src2 + end,
        unescape(src2),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+", start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      return this.#parts = [s], this.type = null, this.#hasMagic = void 0, [s, unescape(this.toString()), !1, !1];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(!0);
    bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = `(?:${body})(?:${bodyDotAllowed})*?`);
    let final = "";
    if (this.type === "!" && this.#emptyExt)
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star$2 + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p == "string")
        throw new Error("string type in extglob ast??");
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      return this.#uflag = this.#uflag || uflag, re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic2, noEmpty = !1) {
    let escaping = !1, re = "", uflag = !1;
    for (let i = 0; i < glob2.length; i++) {
      const c2 = glob2.charAt(i);
      if (escaping) {
        escaping = !1, re += (reSpecials.has(c2) ? "\\" : "") + c2;
        continue;
      }
      if (c2 === "\\") {
        i === glob2.length - 1 ? re += "\\\\" : escaping = !0;
        continue;
      }
      if (c2 === "[") {
        const [src2, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src2, uflag = uflag || needUflag, i += consumed - 1, hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c2 === "*") {
        noEmpty && glob2 === "*" ? re += starNoEmpty : re += star$2, hasMagic2 = !0;
        continue;
      }
      if (c2 === "?") {
        re += qmark$1, hasMagic2 = !0;
        continue;
      }
      re += regExpEscape$1(c2);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  }
}
const escape = (s, { windowsPathsNoEscape = !1 } = {}) => windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), minimatch = (p, pattern, options2 = {}) => (assertValidPattern(pattern), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options2).match(p)), starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/, starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2), starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2), starDotExtTestNocase = (ext2) => (ext2 = ext2.toLowerCase(), (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2)), starDotExtTestNocaseDot = (ext2) => (ext2 = ext2.toLowerCase(), (f) => f.toLowerCase().endsWith(ext2)), starDotStarRE = /^\*+\.\*+$/, starDotStarTest = (f) => !f.startsWith(".") && f.includes("."), starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes("."), dotStarRE = /^\.\*+$/, dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith("."), starRE = /^\*+$/, starTest = (f) => f.length !== 0 && !f.startsWith("."), starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..", qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/, qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return ext2 ? (ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2)) : noext;
}, qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return ext2 ? (ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2)) : noext;
}, qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return ext2 ? (f) => noext(f) && f.endsWith(ext2) : noext;
}, qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return ext2 ? (f) => noext(f) && f.endsWith(ext2) : noext;
}, qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
}, qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
}, defaultPlatform$2 = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
}, sep = defaultPlatform$2 === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
const qmark = "[^/]", star$1 = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", filter$1 = (pattern, options2 = {}) => (p) => minimatch(p, pattern, options2);
minimatch.filter = filter$1;
const ext = (a, b = {}) => Object.assign({}, a, b), defaults = (def) => {
  if (!def || typeof def != "object" || !Object.keys(def).length)
    return minimatch;
  const orig = minimatch;
  return Object.assign((p, pattern, options2 = {}) => orig(p, pattern, ext(def, options2)), {
    Minimatch: class extends orig.Minimatch {
      constructor(pattern, options2 = {}) {
        super(pattern, ext(def, options2));
      }
      static defaults(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      }
    },
    AST: class extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent, options2 = {}) {
        super(type2, parent, ext(def, options2));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options2 = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options2));
      }
    },
    unescape: (s, options2 = {}) => orig.unescape(s, ext(def, options2)),
    escape: (s, options2 = {}) => orig.escape(s, ext(def, options2)),
    filter: (pattern, options2 = {}) => orig.filter(pattern, ext(def, options2)),
    defaults: (options2) => orig.defaults(ext(def, options2)),
    makeRe: (pattern, options2 = {}) => orig.makeRe(pattern, ext(def, options2)),
    braceExpand: (pattern, options2 = {}) => orig.braceExpand(pattern, ext(def, options2)),
    match: (list2, pattern, options2 = {}) => orig.match(list2, pattern, ext(def, options2)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
const braceExpand = (pattern, options2 = {}) => (assertValidPattern(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand$2(pattern));
minimatch.braceExpand = braceExpand;
const makeRe = (pattern, options2 = {}) => new Minimatch(pattern, options2).makeRe();
minimatch.makeRe = makeRe;
const match$1 = (list2, pattern, options2 = {}) => {
  const mm = new Minimatch(pattern, options2);
  return list2 = list2.filter((f) => mm.match(f)), mm.options.nonull && !list2.length && list2.push(pattern), list2;
};
minimatch.match = match$1;
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/, regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class Minimatch {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options2 = {}) {
    assertValidPattern(pattern), options2 = options2 || {}, this.options = options2, this.pattern = pattern, this.platform = options2.platform || defaultPlatform$2, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options2.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1)
      return !0;
    for (const pattern of this.set)
      for (const part of pattern)
        if (typeof part != "string")
          return !0;
    return !1;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern, options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!pattern) {
      this.empty = !0;
      return;
    }
    this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options2.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]), isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC)
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        if (isDrive)
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
      }
      return s.map((ss) => this.parse(ss));
    });
    if (this.debug(this.pattern, set2), this.set = set2.filter((s) => s.indexOf(!1) === -1), this.isWindows)
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar)
      for (let i = 0; i < globParts.length; i++)
        for (let j = 0; j < globParts[i].length; j++)
          globParts[i][j] === "**" && (globParts[i][j] = "*");
    const { optimizationLevel = 1 } = this.options;
    return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      for (; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
        let i = gs;
        for (; parts[i + 1] === "**"; )
          i++;
        i !== gs && parts.splice(gs, i - gs);
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => (parts = parts.reduce((set2, part) => {
      const prev = set2[set2.length - 1];
      return part === "**" && prev === "**" ? set2 : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set2.pop(), set2) : (set2.push(part), set2);
    }, []), parts.length === 0 ? [""] : parts));
  }
  levelTwoFileOptimize(parts) {
    Array.isArray(parts) || (parts = this.slashSplit(parts));
    let didSomething = !1;
    do {
      if (didSomething = !1, !this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
        }
        parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
      }
      let dd = 0;
      for (; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
        const p = parts[dd - 1];
        p && p !== "." && p !== ".." && p !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = !1;
    do {
      didSomething = !1;
      for (let parts of globParts) {
        let gs = -1;
        for (; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
          let gss = gs;
          for (; parts[gss + 1] === "**"; )
            gss++;
          gss > gs && parts.splice(gs + 1, gss - gs);
          let next = parts[gs + 1];
          const p = parts[gs + 2], p2 = parts[gs + 3];
          if (next !== ".." || !p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..")
            continue;
          didSomething = !0, parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**", globParts.push(other), gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
          }
          parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
        }
        let dd = 0;
        for (; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = !0;
            const splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin), parts.length === 0 && parts.push(""), dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++)
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [], globParts[j] = matched;
          break;
        }
      }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = !1) {
    let ai = 0, bi = 0, result = [], which2 = "";
    for (; ai < a.length && bi < b.length; )
      if (a[ai] === b[bi])
        result.push(which2 === "b" ? b[bi] : a[ai]), ai++, bi++;
      else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1])
        result.push(a[ai]), ai++;
      else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1])
        result.push(b[bi]), bi++;
      else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which2 === "b")
          return !1;
        which2 = "a", result.push(a[ai]), ai++, bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which2 === "a")
          return !1;
        which2 = "b", result.push(b[bi]), ai++, bi++;
      } else
        return !1;
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = !1, negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++)
      negate = !negate, negateOffset++;
    negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = !1) {
    const options2 = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]), fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]), patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]), patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]), fdi = fileUNC ? 3 : fileDrive ? 0 : void 0, pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi == "number" && typeof pdi == "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
      }
    }
    const { optimizationLevel = 1 } = this.options;
    optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, { file, pattern }), this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f = file[fi];
      if (this.debug(pattern, p, f), p === !1)
        return !1;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file[fr];
          if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
      }
      let hit;
      if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit)
        return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl)
      return fi === fl - 1 && file[fi] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options2 = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m, fastTest = null;
    (m = pattern.match(starRE)) ? fastTest = options2.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options2.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest && typeof re == "object" && Reflect.defineProperty(re, "test", { value: fastTest }), re;
  }
  makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length)
      return this.regexp = !1, this.regexp;
    const options2 = this.options, twoStar = options2.noglobstar ? star$1 : options2.dot ? twoStarDot : twoStarNoDot, flags = new Set(options2.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp)
          for (const f of p.flags.split(""))
            flags.add(f);
        return typeof p == "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      return pp.forEach((p, i) => {
        const next = pp[i + 1], prev = pp[i - 1];
        p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
      }), pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open2, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open2 + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(p) {
    return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? ["", ...p.split(/\/+/)] : p.split(/\/+/);
  }
  match(f, partial = this.partial) {
    if (this.debug("match", f, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return !0;
    const options2 = this.options;
    this.isWindows && (f = f.split("\\").join("/"));
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename)
      for (let i = ff.length - 2; !filename && i >= 0; i--)
        filename = ff[i];
    for (let i = 0; i < set2.length; i++) {
      const pattern = set2[i];
      let file = ff;
      if (options2.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial))
        return options2.flipNegate ? !0 : !this.negate;
    }
    return options2.flipNegate ? !1 : this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
}
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;
const perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, warned = /* @__PURE__ */ new Set(), PROCESS = typeof process == "object" && process ? process : {}, emitWarning = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning == "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
let AC = globalThis.AbortController, AS = globalThis.AbortSignal;
if (typeof AC > "u") {
  AS = class {
    onabort;
    _onabort = [];
    reason;
    aborted = !1;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  }, AC = class {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (!this.signal.aborted) {
        this.signal.reason = reason, this.signal.aborted = !0;
        for (const fn of this.signal._onabort)
          fn(reason);
        this.signal.onabort?.(reason);
      }
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    printACPolyfillWarning && (printACPolyfillWarning = !1, emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill));
  };
}
const shouldWarn = (code) => !warned.has(code), isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), getUintArray = (max2) => isPosInt(max2) ? max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size), this.fill(0);
  }
}
class Stack {
  heap;
  length;
  // private constructor
  static #constructing = !1;
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    Stack.#constructing = !0;
    const s = new Stack(max2, HeapCls);
    return Stack.#constructing = !1, s;
  }
  constructor(max2, HeapCls) {
    if (!Stack.#constructing)
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new HeapCls(max2), this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c2) {
    return {
      // properties
      starts: c2.#starts,
      ttls: c2.#ttls,
      sizes: c2.#sizes,
      keyMap: c2.#keyMap,
      keyList: c2.#keyList,
      valList: c2.#valList,
      next: c2.#next,
      prev: c2.#prev,
      get head() {
        return c2.#head;
      },
      get tail() {
        return c2.#tail;
      },
      free: c2.#free,
      // methods
      isBackgroundFetch: (p) => c2.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options2, context) => c2.#backgroundFetch(k, index, options2, context),
      moveToTail: (index) => c2.#moveToTail(index),
      indexes: (options2) => c2.#indexes(options2),
      rindexes: (options2) => c2.#rindexes(options2),
      isStale: (index) => c2.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options2) {
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options2;
    if (max2 !== 0 && !isPosInt(max2))
      throw new TypeError("max option must be a nonnegative integer");
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray)
      throw new Error("invalid max value: " + max2);
    if (this.#max = max2, this.#maxSize = maxSize, this.maxEntrySize = maxEntrySize || this.#maxSize, this.sizeCalculation = sizeCalculation, this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (memoMethod !== void 0 && typeof memoMethod != "function")
      throw new TypeError("memoMethod must be a function if defined");
    if (this.#memoMethod = memoMethod, fetchMethod !== void 0 && typeof fetchMethod != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (this.#fetchMethod = fetchMethod, this.#hasFetchMethod = !!fetchMethod, this.#keyMap = /* @__PURE__ */ new Map(), this.#keyList = new Array(max2).fill(void 0), this.#valList = new Array(max2).fill(void 0), this.#next = new UintArray(max2), this.#prev = new UintArray(max2), this.#head = 0, this.#tail = 0, this.#free = Stack.create(max2), this.#size = 0, this.#calculatedSize = 0, typeof dispose == "function" && (this.#dispose = dispose), typeof disposeAfter == "function" ? (this.#disposeAfter = disposeAfter, this.#disposed = []) : (this.#disposeAfter = void 0, this.#disposed = void 0), this.#hasDispose = !!this.#dispose, this.#hasDisposeAfter = !!this.#disposeAfter, this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection, this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort, this.ignoreFetchAbort = !!ignoreFetchAbort, this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0 && !isPosInt(this.#maxSize))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!isPosInt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      this.#initializeSizeTracking();
    }
    if (this.allowStale = !!allowStale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || 0, this.ttl) {
      if (!isPosInt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      shouldWarn(code) && (warned.add(code), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache));
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key2) {
    return this.#keyMap.has(key2) ? 1 / 0 : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max), starts = new ZeroArray(this.#max);
    this.#ttls = ttls, this.#starts = starts, this.#setItemTTL = (index, ttl, start = perf.now()) => {
      if (starts[index] = ttl !== 0 ? start : 0, ttls[index] = ttl, ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          this.#isStale(index) && this.#delete(this.#keyList[index], "expire");
        }, ttl + 1);
        t.unref && t.unref();
      }
    }, this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    }, this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index], start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl, status.start = start, status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        t.unref && t.unref();
      }
      return n;
    };
    this.getRemainingTTL = (key2) => {
      const index = this.#keyMap.get(key2);
      if (index === void 0)
        return 0;
      const ttl = ttls[index], start = starts[index];
      if (!ttl || !start)
        return 1 / 0;
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    }, this.#isStale = (index) => {
      const s = starts[index], t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => !1;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0, this.#sizes = sizes, this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index], sizes[index] = 0;
    }, this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v))
        return 0;
      if (!isPosInt(size))
        if (sizeCalculation) {
          if (typeof sizeCalculation != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (size = sizeCalculation(v, k), !isPosInt(size))
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        } else
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return size;
    }, this.#addItemSize = (index, size, status) => {
      if (sizes[index] = size, this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        for (; this.#calculatedSize > maxSize; )
          this.#evict(!0);
      }
      this.#calculatedSize += sizes[index], status && (status.entrySize = size, status.totalCalculatedSize = this.#calculatedSize);
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation)
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size)
      for (let i = this.#tail; !(!this.#isValidIndex(i) || ((allowStale || !this.#isStale(i)) && (yield i), i === this.#head)); )
        i = this.#prev[i];
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size)
      for (let i = this.#head; !(!this.#isValidIndex(i) || ((allowStale || !this.#isStale(i)) && (yield i), i === this.#tail)); )
        i = this.#next[i];
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes())
      this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield [this.#keyList[i], this.#valList[i]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes())
      this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield [this.#keyList[i], this.#valList[i]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      k !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield k);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      k !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield k);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes())
      this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield this.#valList[i]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes())
      this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield this.#valList[i]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value !== void 0 && fn(value, this.#keyList[i], this))
        return this.get(this.#keyList[i], getOptions);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      value !== void 0 && fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      value !== void 0 && fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = !1;
    for (const i of this.#rindexes({ allowStale: !0 }))
      this.#isStale(i) && (this.#delete(this.#keyList[i], "expire"), deleted = !0);
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key2) {
    const i = this.#keyMap.get(key2);
    if (i === void 0)
      return;
    const v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i], start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain, entry.start = Date.now();
      }
    }
    return this.#sizes && (entry.size = this.#sizes[i]), entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: !0 })) {
      const key2 = this.#keyList[i], v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key2 === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      this.#sizes && (entry.size = this.#sizes[i]), arr.unshift([key2, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key2, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key2, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0)
      return this.delete(k), this;
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize)
      return status && (status.set = "miss", status.maxEntrySizeExceeded = !0), this.#delete(k, "set"), this;
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0)
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(!1) : this.#size, this.#keyList[index] = k, this.#valList[index] = v, this.#keyMap.set(k, index), this.#next[this.#tail] = index, this.#prev[index] = this.#tail, this.#tail = index, this.#size++, this.#addItemSize(index, size, status), status && (status.set = "add"), noUpdateTTL = !1;
    else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          s !== void 0 && !noDisposeOnSet && (this.#hasDispose && this.#dispose?.(s, k, "set"), this.#hasDisposeAfter && this.#disposed?.push([s, k, "set"]));
        } else noDisposeOnSet || (this.#hasDispose && this.#dispose?.(oldVal, k, "set"), this.#hasDisposeAfter && this.#disposed?.push([oldVal, k, "set"]));
        if (this.#removeItemSize(index), this.#addItemSize(index, size, status), this.#valList[index] = v, status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          oldValue !== void 0 && (status.oldValue = oldValue);
        }
      } else status && (status.set = "update");
    }
    if (ttl !== 0 && !this.#ttls && this.#initializeTTLTracking(), this.#ttls && (noUpdateTTL || this.#setItemTTL(index, ttl, start), status && this.#statusTTL(status, index)), !noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      for (; task = dt?.shift(); )
        this.#disposeAfter?.(...task);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      for (; this.#size; ) {
        const val = this.#valList[this.#head];
        if (this.#evict(!0), this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching)
            return val.__staleWhileFetching;
        } else if (val !== void 0)
          return val;
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        for (; task = dt?.shift(); )
          this.#disposeAfter?.(...task);
      }
    }
  }
  #evict(free) {
    const head = this.#head, k = this.#keyList[head], v = this.#valList[head];
    return this.#hasFetchMethod && this.#isBackgroundFetch(v) ? v.__abortController.abort(new Error("evicted")) : (this.#hasDispose || this.#hasDisposeAfter) && (this.#hasDispose && this.#dispose?.(v, k, "evict"), this.#hasDisposeAfter && this.#disposed?.push([v, k, "evict"])), this.#removeItemSize(head), free && (this.#keyList[head] = void 0, this.#valList[head] = void 0, this.#free.push(head)), this.#size === 1 ? (this.#head = this.#tail = 0, this.#free.length = 0) : this.#head = this.#next[head], this.#keyMap.delete(k), this.#size--, head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions, index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0)
        return !1;
      if (this.#isStale(index))
        status && (status.has = "stale", this.#statusTTL(status, index));
      else return updateAgeOnHas && this.#updateItemAge(index), status && (status.has = "hit", this.#statusTTL(status, index)), !0;
    } else status && (status.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions, index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index))
      return;
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options2, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v))
      return v;
    const ac = new AC(), { signal } = options2;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options: options2,
      context
    }, cb = (v2, updateCache = !1) => {
      const { aborted } = ac.signal, ignoreAbort = options2.ignoreFetchAbort && v2 !== void 0;
      if (options2.status && (aborted && !updateCache ? (options2.status.fetchAborted = !0, options2.status.fetchError = ac.signal.reason, ignoreAbort && (options2.status.fetchAbortIgnored = !0)) : options2.status.fetchResolved = !0), aborted && !ignoreAbort && !updateCache)
        return fetchFail(ac.signal.reason);
      const bf2 = p;
      return this.#valList[index] === p && (v2 === void 0 ? bf2.__staleWhileFetching ? this.#valList[index] = bf2.__staleWhileFetching : this.#delete(k, "fetch") : (options2.status && (options2.status.fetchUpdated = !0), this.set(k, v2, fetchOpts.options))), v2;
    }, eb = (er) => (options2.status && (options2.status.fetchRejected = !0, options2.status.fetchError = er), fetchFail(er)), fetchFail = (er) => {
      const { aborted } = ac.signal, allowStaleAborted = aborted && options2.allowStaleOnFetchAbort, allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection, noDelete = allowStale || options2.noDeleteOnFetchRejection, bf2 = p;
      if (this.#valList[index] === p && (!noDelete || bf2.__staleWhileFetching === void 0 ? this.#delete(k, "fetch") : allowStaleAborted || (this.#valList[index] = bf2.__staleWhileFetching)), allowStale)
        return options2.status && bf2.__staleWhileFetching !== void 0 && (options2.status.returnedStale = !0), bf2.__staleWhileFetching;
      if (bf2.__returned === bf2)
        throw er;
    }, pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      fmp && fmp instanceof Promise && fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej), ac.signal.addEventListener("abort", () => {
        (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) && (res(void 0), options2.allowStaleOnFetchAbort && (res = (v2) => cb(v2, !0)));
      });
    };
    options2.status && (options2.status.fetchDispatched = !0);
    const p = new Promise(pcall).then(cb, eb), bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    return index === void 0 ? (this.set(k, bf, { ...fetchOpts.options, status: void 0 }), index = this.#keyMap.get(k)) : this.#valList[index] = bf, bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return !1;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = !1,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod)
      return status && (status.fetch = "get"), this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    const options2 = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      status && (status.fetch = "miss");
      const p = this.#backgroundFetch(k, index, options2, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        return status && (status.fetch = "inflight", stale && (status.returnedStale = !0)), stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale)
        return status && (status.fetch = "hit"), this.#moveToTail(index), updateAgeOnGet && this.#updateItemAge(index), status && this.#statusTTL(status, index), v;
      const p = this.#backgroundFetch(k, index, options2, context), staleVal = p.__staleWhileFetching !== void 0 && allowStale;
      return status && (status.fetch = isStale ? "stale" : "refresh", staleVal && isStale && (status.returnedStale = !0)), staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod)
      throw new Error("no memoMethod provided to constructor");
    const { context, forceRefresh, ...options2 } = memoOptions, v = this.get(k, options2);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options: options2,
      context
    });
    return this.set(k, vv, options2), vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions, index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index], fetching = this.#isBackgroundFetch(value);
      return status && this.#statusTTL(status, index), this.#isStale(index) ? (status && (status.get = "stale"), fetching ? (status && allowStale && value.__staleWhileFetching !== void 0 && (status.returnedStale = !0), allowStale ? value.__staleWhileFetching : void 0) : (noDeleteOnStaleGet || this.#delete(k, "expire"), status && allowStale && (status.returnedStale = !0), allowStale ? value : void 0)) : (status && (status.get = "hit"), fetching ? value.__staleWhileFetching : (this.#moveToTail(index), updateAgeOnGet && this.#updateItemAge(index), value));
    } else status && (status.get = "miss");
  }
  #connect(p, n) {
    this.#prev[n] = p, this.#next[p] = n;
  }
  #moveToTail(index) {
    index !== this.#tail && (index === this.#head ? this.#head = this.#next[index] : this.#connect(this.#prev[index], this.#next[index]), this.#connect(this.#tail, index), this.#tail = index);
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = !1;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0)
        if (deleted = !0, this.#size === 1)
          this.#clear(reason);
        else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) ? v.__abortController.abort(new Error("deleted")) : (this.#hasDispose || this.#hasDisposeAfter) && (this.#hasDispose && this.#dispose?.(v, k, reason), this.#hasDisposeAfter && this.#disposed?.push([v, k, reason])), this.#keyMap.delete(k), this.#keyList[index] = void 0, this.#valList[index] = void 0, index === this.#tail)
            this.#tail = this.#prev[index];
          else if (index === this.#head)
            this.#head = this.#next[index];
          else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--, this.#free.push(index);
        }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      for (; task = dt?.shift(); )
        this.#disposeAfter?.(...task);
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: !0 })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v))
        v.__abortController.abort(new Error("deleted"));
      else {
        const k = this.#keyList[index];
        this.#hasDispose && this.#dispose?.(v, k, reason), this.#hasDisposeAfter && this.#disposed?.push([v, k, reason]);
      }
    }
    if (this.#keyMap.clear(), this.#valList.fill(void 0), this.#keyList.fill(void 0), this.#ttls && this.#starts && (this.#ttls.fill(0), this.#starts.fill(0)), this.#sizes && this.#sizes.fill(0), this.#head = 0, this.#tail = 0, this.#free.length = 0, this.#calculatedSize = 0, this.#size = 0, this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      for (; task = dt?.shift(); )
        this.#disposeAfter?.(...task);
    }
  }
}
const proc = typeof process == "object" && process ? process : {
  stdout: null,
  stderr: null
}, isStream = (s) => !!s && typeof s == "object" && (s instanceof Minipass || s instanceof Stream__default.default || isReadable(s) || isWritable(s)), isReadable = (s) => !!s && typeof s == "object" && s instanceof node_events.EventEmitter && typeof s.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== Stream__default.default.Writable.prototype.pipe, isWritable = (s) => !!s && typeof s == "object" && s instanceof node_events.EventEmitter && typeof s.write == "function" && typeof s.end == "function", EOF = Symbol("EOF"), MAYBE_EMIT_END = Symbol("maybeEmitEnd"), EMITTED_END = Symbol("emittedEnd"), EMITTING_END = Symbol("emittingEnd"), EMITTED_ERROR = Symbol("emittedError"), CLOSED = Symbol("closed"), READ = Symbol("read"), FLUSH = Symbol("flush"), FLUSHCHUNK = Symbol("flushChunk"), ENCODING = Symbol("encoding"), DECODER = Symbol("decoder"), FLOWING = Symbol("flowing"), PAUSED = Symbol("paused"), RESUME = Symbol("resume"), BUFFER = Symbol("buffer"), PIPES = Symbol("pipes"), BUFFERLENGTH = Symbol("bufferLength"), BUFFERPUSH = Symbol("bufferPush"), BUFFERSHIFT = Symbol("bufferShift"), OBJECTMODE = Symbol("objectMode"), DESTROYED = Symbol("destroyed"), ERROR = Symbol("error"), EMITDATA = Symbol("emitData"), EMITEND = Symbol("emitEnd"), EMITEND2 = Symbol("emitEnd2"), ASYNC = Symbol("async"), ABORT = Symbol("abort"), ABORTED = Symbol("aborted"), SIGNAL = Symbol("signal"), DATALISTENERS = Symbol("dataListeners"), DISCARDED = Symbol("discarded"), defer$1 = (fn) => Promise.resolve().then(fn), nodefer = (fn) => fn(), isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
class Pipe {
  src;
  dest;
  opts;
  ondrain;
  constructor(src2, dest, opts) {
    this.src = src2, this.dest = dest, this.opts = opts, this.ondrain = () => src2[RESUME](), this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe(), this.opts.end && this.dest.end();
  }
}
class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors), super.unpipe();
  }
  constructor(src2, dest, opts) {
    super(src2, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src2.on("error", this.proxyErrors);
  }
}
const isObjectModeOptions = (o) => !!o.objectMode, isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
class Minipass extends node_events.EventEmitter {
  [FLOWING] = !1;
  [PAUSED] = !1;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = !1;
  [EMITTED_END] = !1;
  [EMITTING_END] = !1;
  [CLOSED] = !1;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = !1;
  [SIGNAL];
  [ABORTED] = !1;
  [DATALISTENERS] = 0;
  [DISCARDED] = !1;
  /**
   * true if the stream can be written
   */
  writable = !0;
  /**
   * true if the stream can be read
   */
  readable = !0;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options2 = args[0] || {};
    if (super(), options2.objectMode && typeof options2.encoding == "string")
      throw new TypeError("Encoding and objectMode may not be used together");
    isObjectModeOptions(options2) ? (this[OBJECTMODE] = !0, this[ENCODING] = null) : isEncodingOptions(options2) ? (this[ENCODING] = options2.encoding, this[OBJECTMODE] = !1) : (this[OBJECTMODE] = !1, this[ENCODING] = null), this[ASYNC] = !!options2.async, this[DECODER] = this[ENCODING] ? new node_string_decoder.StringDecoder(this[ENCODING]) : null, options2 && options2.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[BUFFER] }), options2 && options2.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    const { signal } = options2;
    signal && (this[SIGNAL] = signal, signal.aborted ? this[ABORT]() : signal.addEventListener("abort", () => this[ABORT]()));
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get async() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set async(a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = !0, this.emit("abort", this[SIGNAL]?.reason), this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return !1;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED])
      return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0;
    typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
    const fn = this[ASYNC] ? defer$1 : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBufferLike(chunk))
        chunk = Buffer.from(chunk);
      else if (typeof chunk != "string")
        throw new Error("Non-contiguous data written to non-objectMode stream");
    }
    return this[OBJECTMODE] ? (this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING] && (chunk = this[DECODER].write(chunk)), this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : (this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]);
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    if (this[DISCARDED] = !1, this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH])
      return this[MAYBE_EMIT_END](), null;
    this[OBJECTMODE] && (n = null), this[BUFFER].length > 1 && !this[OBJECTMODE] && (this[BUFFER] = [
      this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
    ]);
    const ret = this[READ](n || null, this[BUFFER][0]);
    return this[MAYBE_EMIT_END](), ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c2 = chunk;
      n === c2.length || n === null ? this[BUFFERSHIFT]() : typeof c2 == "string" ? (this[BUFFER][0] = c2.slice(n), chunk = c2.slice(0, n), this[BUFFERLENGTH] -= n) : (this[BUFFER][0] = c2.subarray(n), chunk = c2.subarray(0, n), this[BUFFERLENGTH] -= n);
    }
    return this.emit("data", chunk), !this[BUFFER].length && !this[EOF] && this.emit("drain"), chunk;
  }
  end(chunk, encoding, cb) {
    return typeof chunk == "function" && (cb = chunk, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk !== void 0 && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF] = !0, this.writable = !1, (this[FLOWING] || !this[PAUSED]) && this[MAYBE_EMIT_END](), this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    this[DESTROYED] || (!this[DATALISTENERS] && !this[PIPES].length && (this[DISCARDED] = !0), this[PAUSED] = !1, this[FLOWING] = !0, this.emit("resume"), this[BUFFER].length ? this[FLUSH]() : this[EOF] ? this[MAYBE_EMIT_END]() : this.emit("drain"));
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = !1, this[PAUSED] = !0, this[DISCARDED] = !1;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    this[OBJECTMODE] ? this[BUFFERLENGTH] += 1 : this[BUFFERLENGTH] += chunk.length, this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    return this[OBJECTMODE] ? this[BUFFERLENGTH] -= 1 : this[BUFFERLENGTH] -= this[BUFFER][0].length, this[BUFFER].shift();
  }
  [FLUSH](noDrain = !1) {
    do
      ;
    while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    !noDrain && !this[BUFFER].length && !this[EOF] && this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    return this.emit("data", chunk), this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = !1;
    const ended = this[EMITTED_END];
    return opts = opts || {}, dest === proc.stdout || dest === proc.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES].push(opts.proxyErrors ? new PipeProxyErrors(this, dest, opts) : new Pipe(this, dest, opts)), this[ASYNC] ? defer$1(() => this[RESUME]()) : this[RESUME]()), dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    p && (this[PIPES].length === 1 ? (this[FLOWING] && this[DATALISTENERS] === 0 && (this[FLOWING] = !1), this[PIPES] = []) : this[PIPES].splice(this[PIPES].indexOf(p), 1), p.unpipe());
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data")
      this[DISCARDED] = !1, this[DATALISTENERS]++, !this[PIPES].length && !this[FLOWING] && this[RESUME]();
    else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
      super.emit("readable");
    else if (isEndish(ev) && this[EMITTED_END])
      super.emit(ev), this.removeAllListeners(ev);
    else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      this[ASYNC] ? defer$1(() => h.call(this, this[EMITTED_ERROR])) : h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    return ev === "data" && (this[DATALISTENERS] = this.listeners("data").length, this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    return (ev === "data" || ev === void 0) && (this[DATALISTENERS] = 0, !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    !this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF] && (this[EMITTING_END] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED] && this.emit("close"), this[EMITTING_END] = !1);
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
      return !1;
    if (ev === "data")
      return !this[OBJECTMODE] && !data ? !1 : this[ASYNC] ? (defer$1(() => this[EMITDATA](data)), !0) : this[EMITDATA](data);
    if (ev === "end")
      return this[EMITEND]();
    if (ev === "close") {
      if (this[CLOSED] = !0, !this[EMITTED_END] && !this[DESTROYED])
        return !1;
      const ret2 = super.emit("close");
      return this.removeAllListeners("close"), ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data, super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : !1;
      return this[MAYBE_EMIT_END](), ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      return this[MAYBE_EMIT_END](), ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      return this.removeAllListeners(ev), ret2;
    }
    const ret = super.emit(ev, ...args);
    return this[MAYBE_EMIT_END](), ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES])
      p.dest.write(data) === !1 && this.pause();
    const ret = this[DISCARDED] ? !1 : super.emit("data", data);
    return this[MAYBE_EMIT_END](), ret;
  }
  [EMITEND]() {
    return this[EMITTED_END] ? !1 : (this[EMITTED_END] = !0, this.readable = !1, this[ASYNC] ? (defer$1(() => this[EMITEND2]()), !0) : this[EMITEND2]());
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES])
          p.dest.write(data);
        this[DISCARDED] || super.emit("data", data);
      }
    }
    for (const p of this[PIPES])
      p.end();
    const ret = super.emit("end");
    return this.removeAllListeners("end"), ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    this[OBJECTMODE] || (buf.dataLength = 0);
    const p = this.promise();
    return this.on("data", (c2) => {
      buf.push(c2), this[OBJECTMODE] || (buf.dataLength += c2.length);
    }), await p, buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE])
      throw new Error("cannot concat in objectMode");
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = !1;
    let stopped = !1;
    const stop = async () => (this.pause(), stopped = !0, { value: void 0, done: !0 });
    return {
      next: () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: !1, value: res });
        if (this[EOF])
          return stop();
        let resolve, reject;
        const onerr = (er) => {
          this.off("data", ondata), this.off("end", onend), this.off(DESTROYED, ondestroy), stop(), reject(er);
        }, ondata = (value) => {
          this.off("error", onerr), this.off("end", onend), this.off(DESTROYED, ondestroy), this.pause(), resolve({ value, done: !!this[EOF] });
        }, onend = () => {
          this.off("error", onerr), this.off("data", ondata), this.off(DESTROYED, ondestroy), stop(), resolve({ done: !0, value: void 0 });
        }, ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej, resolve = res2, this.once(DESTROYED, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
        });
      },
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = !1;
    let stopped = !1;
    const stop = () => (this.pause(), this.off(ERROR, stop), this.off(DESTROYED, stop), this.off("end", stop), stopped = !0, { done: !0, value: void 0 }), next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: !1, value };
    };
    return this.once("end", stop), this.once(ERROR, stop), this.once(DESTROYED, stop), {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED])
      return er ? this.emit("error", er) : this.emit(DESTROYED), this;
    this[DESTROYED] = !0, this[DISCARDED] = !0, this[BUFFER].length = 0, this[BUFFERLENGTH] = 0;
    const wc = this;
    return typeof wc.close == "function" && !this[CLOSED] && wc.close(), er ? this.emit("error", er) : this.emit(DESTROYED), this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
}
const realpathSync = require$$0$5.realpathSync.native, defaultFS = {
  lstatSync: require$$0$5.lstatSync,
  readdir: require$$0$5.readdir,
  readdirSync: require$$0$5.readdirSync,
  readlinkSync: require$$0$5.readlinkSync,
  realpathSync,
  promises: {
    lstat: fs.lstat,
    readdir: fs.readdir,
    readlink: fs.readlink,
    realpath: fs.realpath
  }
}, fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === fs__namespace ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
}, uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i, uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), eitherSep = /[\\\/]/, UNKNOWN = 0, IFIFO = 1, IFCHR = 2, IFDIR = 4, IFBLK = 6, IFREG = 8, IFLNK = 10, IFSOCK = 12, IFMT = 15, IFMT_UNKNOWN = ~IFMT, READDIR_CALLED = 16, LSTAT_CALLED = 32, ENOTDIR = 64, ENOENT = 128, ENOREADLINK = 256, ENOREALPATH = 512, ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH, TYPEMASK = 1023, entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN, normalizeCache = /* @__PURE__ */ new Map(), normalize = (s) => {
  const c2 = normalizeCache.get(s);
  if (c2)
    return c2;
  const n = s.normalize("NFKD");
  return normalizeCache.set(s, n), n;
}, normalizeNocaseCache = /* @__PURE__ */ new Map(), normalizeNocase = (s) => {
  const c2 = normalizeNocaseCache.get(s);
  if (c2)
    return c2;
  const n = normalize(s.toLowerCase());
  return normalizeNocaseCache.set(s, n), n;
};
class ResolveCache extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
}
class ChildrenCache extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
}
const setAsCwd = Symbol("PathScurry setAsCwd");
class PathBase {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = !1;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN, root2, roots, nocase, children, opts) {
    this.name = name, this.#matchName = nocase ? normalizeNocase(name) : normalize(name), this.#type = type2 & TYPEMASK, this.nocase = nocase, this.roots = roots, this.root = root2 || this, this.#children = children, this.#fullpath = opts.fullpath, this.#relative = opts.relative, this.#relativePosix = opts.relativePosix, this.parent = opts.parent, this.parent ? this.#fs = this.parent.#fs : this.#fs = fsFromOption(opts.fs);
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    return this.#depth !== void 0 ? this.#depth : this.parent ? this.#depth = this.parent.depth() + 1 : this.#depth = 0;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path2) {
    if (!path2)
      return this;
    const rootPath = this.getRootString(path2), dirParts = path2.substring(rootPath.length).split(this.splitSep);
    return rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts)
      p = p.child(part);
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached)
      return cached;
    const children = Object.assign([], { provisional: 0 });
    return this.#children.set(this, children), this.#type &= ~READDIR_CALLED, children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".")
      return this;
    if (pathPart === "..")
      return this.parent || this;
    const children = this.children(), name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (const p of children)
      if (p.#matchName === name)
        return p;
    const s = this.parent ? this.sep : "", fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0, pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    return this.canReaddir() || (pchild.#type |= ENOENT), children.push(pchild), pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== void 0)
      return this.#relative;
    const name = this.name, p = this.parent;
    if (!p)
      return this.#relative = this.name;
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name = this.name, p = this.parent;
    if (!p)
      return this.#relativePosix = this.fullpathPosix();
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0)
      return this.#fullpath;
    const name = this.name, p = this.parent;
    if (!p)
      return this.#fullpath = this.name;
    const fp = p.fullpath() + (p.parent ? this.sep : "") + name;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      return /^[a-z]:\//i.test(p2) ? this.#fullpathPosix = `//?/${p2}` : this.#fullpathPosix = p2;
    }
    const p = this.parent, pfpp = p.fullpathPosix(), fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type2) {
    return this[`is${type2}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return !0;
    if (!this.parent)
      return !1;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return this.nocase ? this.#matchName === normalizeNocase(n) : this.#matchName === normalize(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target)
      return target;
    if (this.canReadlink() && this.parent)
      try {
        const read2 = await this.#fs.promises.readlink(this.fullpath()), linkTarget = (await this.parent.realpath())?.resolve(read2);
        if (linkTarget)
          return this.#linkTarget = linkTarget;
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target)
      return target;
    if (this.canReadlink() && this.parent)
      try {
        const read2 = this.#fs.readlinkSync(this.fullpath()), linkTarget = this.parent.realpathSync()?.resolve(read2);
        if (linkTarget)
          return this.#linkTarget = linkTarget;
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      const c2 = children[p];
      c2 && c2.#markENOENT();
    }
  }
  #markENOENT() {
    this.#type & ENOENT || (this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN, this.#markChildrenENOENT());
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children)
      p.#markENOENT();
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH, this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    (t & IFMT) === IFDIR && (t &= IFMT_UNKNOWN), this.#type = t | ENOTDIR, this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    code === "ENOTDIR" || code === "EPERM" ? this.#markENOTDIR() : code === "ENOENT" ? this.#markENOENT() : this.children().provisional = 0;
  }
  #lstatFail(code = "") {
    code === "ENOTDIR" ? this.parent.#markENOTDIR() : code === "ENOENT" && this.#markENOENT();
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK, code === "ENOENT" && (ter |= ENOENT), (code === "EINVAL" || code === "UNKNOWN") && (ter &= IFMT_UNKNOWN), this.#type = ter, code === "ENOTDIR" && this.parent && this.parent.#markENOTDIR();
  }
  #readdirAddChild(e, c2) {
    return this.#readdirMaybePromoteChild(e, c2) || this.#readdirAddNewChild(e, c2);
  }
  #readdirAddNewChild(e, c2) {
    const type2 = entToType(e), child = this.newChild(e.name, type2, { parent: this }), ifmt = child.#type & IFMT;
    return ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN && (child.#type |= ENOTDIR), c2.unshift(child), c2.provisional++, child;
  }
  #readdirMaybePromoteChild(e, c2) {
    for (let p = c2.provisional; p < c2.length; p++) {
      const pchild = c2[p];
      if ((this.nocase ? normalizeNocase(e.name) : normalize(e.name)) === pchild.#matchName)
        return this.#readdirPromoteChild(e, pchild, p, c2);
    }
  }
  #readdirPromoteChild(e, p, index, c2) {
    const v = p.name;
    return p.#type = p.#type & IFMT_UNKNOWN | entToType(e), v !== e.name && (p.name = e.name), index !== c2.provisional && (index === c2.length - 1 ? c2.pop() : c2.splice(index, 1), c2.unshift(p)), c2.provisional++, p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if (!(this.#type & ENOENT))
      try {
        return this.#applyStat(await this.#fs.promises.lstat(this.fullpath())), this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if (!(this.#type & ENOENT))
      try {
        return this.#applyStat(this.#fs.lstatSync(this.fullpath())), this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode: mode2, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime, this.#atimeMs = atimeMs, this.#birthtime = birthtime, this.#birthtimeMs = birthtimeMs, this.#blksize = blksize, this.#blocks = blocks, this.#ctime = ctime, this.#ctimeMs = ctimeMs, this.#dev = dev, this.#gid = gid, this.#ino = ino, this.#mode = mode2, this.#mtime = mtime, this.#mtimeMs = mtimeMs, this.#nlink = nlink, this.#rdev = rdev, this.#size = size, this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED, ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK && (this.#type |= ENOTDIR);
  }
  #onReaddirCB = [];
  #readdirCBInFlight = !1;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = !1;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0, cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = !1) {
    if (!this.canReaddir()) {
      allowZalgo ? cb(null, []) : queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c2 = children.slice(0, children.provisional);
      allowZalgo ? cb(null, c2) : queueMicrotask(() => cb(null, c2));
      return;
    }
    if (this.#onReaddirCB.push(cb), this.#readdirCBInFlight)
      return;
    this.#readdirCBInFlight = !0;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: !0 }, (er, entries) => {
      if (er)
        this.#readdirFail(er.code), children.provisional = 0;
      else {
        for (const e of entries)
          this.#readdirAddChild(e, children);
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir())
      return [];
    const children = this.children();
    if (this.calledReaddir())
      return children.slice(0, children.provisional);
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight)
      await this.#asyncReaddirInFlight;
    else {
      let resolve = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: !0
        }))
          this.#readdirAddChild(e, children);
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code), children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0, resolve();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir())
      return [];
    const children = this.children();
    if (this.calledReaddir())
      return children.slice(0, children.provisional);
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: !0
      }))
        this.#readdirAddChild(e, children);
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code), children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return !1;
    const ifmt = IFMT & this.#type;
    return ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if (!((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type))
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch {
        this.#markENOREALPATH();
      }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if (!((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type))
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch {
        this.#markENOREALPATH();
      }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = !1, this.isCWD = !0;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [], p = this;
    for (; p && p.parent; )
      changed.add(p), p.#relative = rp.join(this.sep), p.#relativePosix = rp.join("/"), p = p.parent, rp.push("..");
    for (p = oldCwd; p && p.parent && !changed.has(p); )
      p.#relative = void 0, p.#relativePosix = void 0, p = p.parent;
  }
}
class PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN, root2, roots, nocase, children, opts) {
    super(name, type2, root2, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name, type2 = UNKNOWN, opts = {}) {
    return new PathWin32(name, type2, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path2) {
    return path$3.win32.parse(path2).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    if (rootPath = uncToDrive(rootPath.toUpperCase()), rootPath === this.root.name)
      return this.root;
    for (const [compare, root2] of Object.entries(this.roots))
      if (this.sameRoot(rootPath, compare))
        return this.roots[rootPath] = root2;
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    return rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), rootPath === compare;
  }
}
class PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN, root2, roots, nocase, children, opts) {
    super(name, type2, root2, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path2) {
    return path2.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type2 = UNKNOWN, opts = {}) {
    return new PathPosix(name, type2, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
}
class PathScurryBase {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs2 = defaultFS } = {}) {
    this.#fs = fsFromOption(fs2), (cwd instanceof URL || cwd.startsWith("file://")) && (cwd = node_url.fileURLToPath(cwd));
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = /* @__PURE__ */ Object.create(null), this.rootPath = this.parseRootPath(cwdPath), this.#resolveCache = new ResolveCache(), this.#resolvePosixCache = new ResolveCache(), this.#children = new ChildrenCache(childrenCacheSize);
    const split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0] && split.pop(), nocase === void 0)
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    this.nocase = nocase, this.root = this.newRoot(this.#fs), this.roots[this.rootPath] = this.root;
    let prev = this.root, len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs = this.rootPath, sawFirst = !1;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      }), sawFirst = !0;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path2 = this.cwd) {
    return typeof path2 == "string" && (path2 = this.cwd.resolve(path2)), path2.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!(!p || p === ".") && (r = r ? `${p}/${r}` : p, this.isAbsolute(p)))
        break;
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0)
      return cached;
    const result = this.cwd.resolve(r).fullpath();
    return this.#resolveCache.set(r, result), result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!(!p || p === ".") && (r = r ? `${p}/${r}` : p, this.isAbsolute(p)))
        break;
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0)
      return cached;
    const result = this.cwd.resolve(r).fullpathPosix();
    return this.#resolvePosixCache.set(r, result), result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: !0
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes } = opts;
    if (entry.canReaddir()) {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    } else
      return [];
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: !0
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes = !0 } = opts;
    return entry.canReaddir() ? withFileTypes ? entry.readdirSync() : entry.readdirSync().map((e) => e.name) : [];
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = [];
    (!filter2 || filter2(entry)) && results.push(withFileTypes ? entry : entry.fullpath());
    const dirs = /* @__PURE__ */ new Set(), walk = (dir, cb) => {
      dirs.add(dir), dir.readdirCB((er, entries) => {
        if (er)
          return cb(er);
        let len = entries.length;
        if (!len)
          return cb();
        const next = () => {
          --len === 0 && cb();
        };
        for (const e of entries)
          (!filter2 || filter2(e)) && results.push(withFileTypes ? e : e.fullpath()), follow && e.isSymbolicLink() ? e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next()) : e.shouldWalk(dirs, walkFilter) ? walk(e, next) : next();
      }, !0);
    }, start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = [];
    (!filter2 || filter2(entry)) && results.push(withFileTypes ? entry : entry.fullpath());
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        (!filter2 || filter2(e)) && results.push(withFileTypes ? e : e.fullpath());
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          r.isUnknown() && r.lstatSync();
        }
        r.shouldWalk(dirs, walkFilter) && dirs.add(r);
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options2 = {}) {
    return typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (options2 = entry, entry = this.cwd), this.stream(entry, options2)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts;
    (!filter2 || filter2(entry)) && (yield withFileTypes ? entry : entry.fullpath());
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        (!filter2 || filter2(e)) && (yield withFileTypes ? e : e.fullpath());
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          r.isUnknown() && r.lstatSync();
        }
        r.shouldWalk(dirs, walkFilter) && dirs.add(r);
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = new Minipass({ objectMode: !0 });
    (!filter2 || filter2(entry)) && results.write(withFileTypes ? entry : entry.fullpath());
    const dirs = /* @__PURE__ */ new Set(), queue2 = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = !1;
      for (; !paused; ) {
        const dir = queue2.shift();
        if (!dir) {
          processing === 0 && results.end();
          return;
        }
        processing++, dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = !1) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises2 = [];
            for (const e of entries)
              e.isSymbolicLink() && promises2.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
            if (promises2.length) {
              Promise.all(promises2).then(() => onReaddir(null, entries, !0));
              return;
            }
          }
          for (const e of entries)
            e && (!filter2 || filter2(e)) && (results.write(withFileTypes ? e : e.fullpath()) || (paused = !0));
          processing--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            r.shouldWalk(dirs, walkFilter) && queue2.push(r);
          }
          paused && !results.flowing ? results.once("drain", process2) : sync2 || process2();
        };
        let sync2 = !0;
        dir.readdirCB(onReaddir, !0), sync2 = !1;
      }
    };
    return process2(), results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    const { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = new Minipass({ objectMode: !0 }), dirs = /* @__PURE__ */ new Set();
    (!filter2 || filter2(entry)) && results.write(withFileTypes ? entry : entry.fullpath());
    const queue2 = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = !1;
      for (; !paused; ) {
        const dir = queue2.shift();
        if (!dir) {
          processing === 0 && results.end();
          return;
        }
        processing++, dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries)
          (!filter2 || filter2(e)) && (results.write(withFileTypes ? e : e.fullpath()) || (paused = !0));
        processing--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            r.isUnknown() && r.lstatSync();
          }
          r.shouldWalk(dirs, walkFilter) && queue2.push(r);
        }
      }
      paused && !results.flowing && results.once("drain", process2);
    };
    return process2(), results;
  }
  chdir(path2 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path2 == "string" ? this.cwd.resolve(path2) : path2, this.cwd[setAsCwd](oldCwd);
  }
}
class PathScurryWin32 extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = !0 } = opts;
    super(cwd, path$3.win32, "\\", { ...opts, nocase }), this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent)
      p.nocase = this.nocase;
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return path$3.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs2) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
}
class PathScurryPosix extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = !1 } = opts;
    super(cwd, path$3.posix, "/", { ...opts, nocase }), this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs2) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
}
class PathScurryDarwin extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = !0 } = opts;
    super(cwd, { ...opts, nocase });
  }
}
const PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix, isPatternList = (pl) => pl.length >= 1, isGlobList = (gl) => gl.length >= 1;
class Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = !0;
  constructor(patternList, globList, index, platform2) {
    if (!isPatternList(patternList))
      throw new TypeError("empty pattern list");
    if (!isGlobList(globList))
      throw new TypeError("empty glob list");
    if (globList.length !== patternList.length)
      throw new TypeError("mismatched pattern list and glob list lengths");
    if (this.length = patternList.length, index < 0 || index >= this.length)
      throw new TypeError("index out of range");
    if (this.#patternList = patternList, this.#globList = globList, this.#index = index, this.#platform = platform2, this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList, [g0, g1, g2, g3, ...grest] = this.#globList;
        prest[0] === "" && (prest.shift(), grest.shift());
        const p = [p0, p1, p2, p3, ""].join("/"), g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest], this.#globList = [g, ...grest], this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList, [g1, ...grest] = this.#globList;
        prest[0] === "" && (prest.shift(), grest.shift());
        const p = p1 + "/", g = g1 + "/";
        this.#patternList = [p, ...prest], this.#globList = [g, ...grest], this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] == "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    return this.#rest !== void 0 ? this.#rest : this.hasMore() ? (this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform), this.#rest.#isAbsolute = this.#isAbsolute, this.#rest.#isUNC = this.#isUNC, this.#rest.#isDrive = this.#isDrive, this.#rest) : this.#rest = null;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] == "string" && !!pl[2] && typeof pl[3] == "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] == "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p == "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    return this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar ? !1 : (this.#followGlobstar = !1, !0);
  }
}
const defaultPlatform$1 = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux";
class Ignore {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform$1 }) {
    this.relative = [], this.absolute = [], this.relativeChildren = [], this.absoluteChildren = [], this.platform = platform2, this.mmopts = {
      dot: !0,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform: platform2,
      nocomment: !0,
      nonegate: !0
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm = new Minimatch(ign, this.mmopts);
    for (let i = 0; i < mm.set.length; i++) {
      const parsed = mm.set[i], globParts = mm.globParts[i];
      if (!parsed || !globParts)
        throw new Error("invalid pattern object");
      for (; parsed[0] === "." && globParts[0] === "."; )
        parsed.shift(), globParts.shift();
      const p = new Pattern(parsed, globParts, 0, this.platform), m = new Minimatch(p.globString(), this.mmopts), children = globParts[globParts.length - 1] === "**", absolute = p.isAbsolute();
      absolute ? this.absolute.push(m) : this.relative.push(m), children && (absolute ? this.absoluteChildren.push(m) : this.relativeChildren.push(m));
    }
  }
  ignored(p) {
    const fullpath = p.fullpath(), fullpaths = `${fullpath}/`, relative = p.relative() || ".", relatives = `${relative}/`;
    for (const m of this.relative)
      if (m.match(relative) || m.match(relatives))
        return !0;
    for (const m of this.absolute)
      if (m.match(fullpath) || m.match(fullpaths))
        return !0;
    return !1;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/", relative = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren)
      if (m.match(relative))
        return !0;
    for (const m of this.absoluteChildren)
      if (m.match(fullpath))
        return !0;
    return !1;
  }
}
class HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath(), cached = this.store.get(fullpath);
    cached ? cached.add(pattern.globString()) : this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
}
class MatchRecord {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0), current = this.store.get(target);
    this.store.set(target, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path2, n]) => [
      path2,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
}
class SubWalks {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir())
      return;
    const subs = this.store.get(target);
    subs ? subs.find((p) => p.globString() === pattern.globString()) || subs.push(pattern) : this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs)
      throw new Error("attempting to walk unknown path");
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
}
class Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts, this.follow = !!opts.follow, this.dot = !!opts.dot, this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root2 = pattern.root(), absolute = pattern.isAbsolute() && this.opts.absolute !== !1;
      if (root2) {
        t = t.resolve(root2 === "/" && this.opts.root !== void 0 ? this.opts.root : root2);
        const rest2 = pattern.rest();
        if (rest2)
          pattern = rest2;
        else {
          this.matches.add(t, !0, !1);
          continue;
        }
      }
      if (t.isENOENT())
        continue;
      let p, rest, changed = !1;
      for (; typeof (p = pattern.pattern()) == "string" && (rest = pattern.rest()); )
        t = t.resolve(p), pattern = rest, changed = !0;
      if (p = pattern.pattern(), rest = pattern.rest(), changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p == "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) && this.subwalks.add(t, pattern);
        const rp = rest?.pattern(), rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest)
          this.matches.add(t, absolute, rp === "" || rp === ".");
        else if (rp === "..") {
          const tp = t.parent || t;
          rrest ? this.hasWalkedCache.hasWalked(tp, rrest) || this.subwalks.add(tp, rrest) : this.matches.add(tp, absolute, !0);
        }
      } else p instanceof RegExp && this.subwalks.add(t, pattern);
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries) {
    const patterns = this.subwalks.get(parent), results = this.child();
    for (const e of entries)
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute(), p = pattern.pattern(), rest = pattern.rest();
        p === GLOBSTAR ? results.testGlobstar(e, pattern, rest, absolute) : p instanceof RegExp ? results.testRegExp(e, p, rest, absolute) : results.testString(e, p, rest, absolute);
      }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if ((this.dot || !e.name.startsWith(".")) && (pattern.hasMore() || this.matches.add(e, absolute, !1), e.canReaddir() && (this.follow || !e.isSymbolicLink() ? this.subwalks.add(e, pattern) : e.isSymbolicLink() && (rest && pattern.checkFollowGlobstar() ? this.subwalks.add(e, rest) : pattern.markFollowGlobstar() && this.subwalks.add(e, pattern)))), rest) {
      const rp = rest.pattern();
      if (typeof rp == "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".")
        this.testString(e, rp, rest.rest(), absolute);
      else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else rp instanceof RegExp && this.testRegExp(e, rp, rest.rest(), absolute);
    }
  }
  testRegExp(e, p, rest, absolute) {
    p.test(e.name) && (rest ? this.subwalks.add(e, rest) : this.matches.add(e, absolute, !1));
  }
  testString(e, p, rest, absolute) {
    e.isNamed(p) && (rest ? this.subwalks.add(e, rest) : this.matches.add(e, absolute, !1));
  }
}
const makeIgnore = (ignore, opts) => typeof ignore == "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
class GlobUtil {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = !1;
  aborted = !1;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path2, opts) {
    if (this.patterns = patterns, this.path = path2, this.opts = opts, this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/", this.includeChildMatches = opts.includeChildMatches !== !1, (opts.ignore || !this.includeChildMatches) && (this.#ignore = makeIgnore(opts.ignore ?? [], opts), !this.includeChildMatches && typeof this.#ignore.add != "function")) {
      const m = "cannot ignore child matches, ignore lacks add() method.";
      throw new Error(m);
    }
    this.maxDepth = opts.maxDepth || 1 / 0, opts.signal && (this.signal = opts.signal, this.signal.addEventListener("abort", () => {
      this.#onResume.length = 0;
    }));
  }
  #ignored(path2) {
    return this.seen.has(path2) || !!this.#ignore?.ignored?.(path2);
  }
  #childrenIgnored(path2) {
    return !!this.#ignore?.childrenIgnored?.(path2);
  }
  // backpressure mechanism
  pause() {
    this.paused = !0;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = !1;
    let fn;
    for (; !this.paused && (fn = this.#onResume.shift()); )
      fn();
  }
  onResume(fn) {
    this.signal?.aborted || (this.paused ? this.#onResume.push(fn) : fn());
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return;
    let rpc;
    if (this.opts.realpath) {
      if (rpc = e.realpathCached() || await e.realpath(), !rpc)
        return;
      e = rpc;
    }
    const s = e.isUnknown() || this.opts.stat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      target && (target.isUnknown() || this.opts.stat) && await target.lstat();
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === 1 / 0 || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return;
    let rpc;
    if (this.opts.realpath) {
      if (rpc = e.realpathCached() || e.realpathSync(), !rpc)
        return;
      e = rpc;
    }
    const s = e.isUnknown() || this.opts.stat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      target && (target?.isUnknown() || this.opts.stat) && target.lstatSync();
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark2 = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes)
      this.matchEmit(e);
    else if (abs) {
      const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark2);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative(), pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(rel ? pre + rel + mark2 : "." + mark2);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    p && this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    p && this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    this.signal?.aborted && cb(), this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted && cb(), this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      --tasks === 0 && cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || (tasks++, this.match(m, absolute, ifDir).then(() => next()));
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)
        continue;
      tasks++;
      const childrenCached = t.readdirCached();
      t.calledReaddir() ? this.walkCB3(t, childrenCached, processor, next) : t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), !0);
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      --tasks === 0 && cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || (tasks++, this.match(m, absolute, ifDir).then(() => next()));
    for (const [target2, patterns] of processor.subwalks.entries())
      tasks++, this.walkCB2(target2, patterns, processor.child(), next);
    next();
  }
  walkCBSync(target, patterns, cb) {
    this.signal?.aborted && cb(), this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted && cb(), this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      --tasks === 0 && cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || this.matchSync(m, absolute, ifDir);
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)
        continue;
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      --tasks === 0 && cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || this.matchSync(m, absolute, ifDir);
    for (const [target2, patterns] of processor.subwalks.entries())
      tasks++, this.walkCB2Sync(target2, patterns, processor.child(), next);
    next();
  }
}
class GlobWalker extends GlobUtil {
  matches = /* @__PURE__ */ new Set();
  constructor(patterns, path2, opts) {
    super(patterns, path2, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    return this.path.isUnknown() && await this.path.lstat(), await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        this.signal?.aborted ? rej(this.signal.reason) : res(this.matches);
      });
    }), this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    }), this.matches;
  }
}
class GlobStream extends GlobUtil {
  results;
  constructor(patterns, path2, opts) {
    super(patterns, path2, opts), this.results = new Minipass({
      signal: this.signal,
      objectMode: !0
    }), this.results.on("drain", () => this.resume()), this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e), this.results.flowing || this.pause();
  }
  stream() {
    const target = this.path;
    return target.isUnknown() ? target.lstat().then(() => {
      this.walkCB(target, this.patterns, () => this.results.end());
    }) : this.walkCB(target, this.patterns, () => this.results.end()), this.results;
  }
  streamSync() {
    return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => this.results.end()), this.results;
  }
}
const defaultPlatform = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux";
class Glob {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    if (this.withFileTypes = !!opts.withFileTypes, this.signal = opts.signal, this.follow = !!opts.follow, this.dot = !!opts.dot, this.dotRelative = !!opts.dotRelative, this.nodir = !!opts.nodir, this.mark = !!opts.mark, opts.cwd ? (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) && (opts.cwd = node_url.fileURLToPath(opts.cwd)) : this.cwd = "", this.cwd = opts.cwd || "", this.root = opts.root, this.magicalBraces = !!opts.magicalBraces, this.nobrace = !!opts.nobrace, this.noext = !!opts.noext, this.realpath = !!opts.realpath, this.absolute = opts.absolute, this.includeChildMatches = opts.includeChildMatches !== !1, this.noglobstar = !!opts.noglobstar, this.matchBase = !!opts.matchBase, this.maxDepth = typeof opts.maxDepth == "number" ? opts.maxDepth : 1 / 0, this.stat = !!opts.stat, this.ignore = opts.ignore, this.withFileTypes && this.absolute !== void 0)
      throw new Error("cannot set absolute and withFileTypes:true");
    if (typeof pattern == "string" && (pattern = [pattern]), this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === !1, this.windowsPathsNoEscape && (pattern = pattern.map((p) => p.replace(/\\/g, "/"))), this.matchBase) {
      if (opts.noglobstar)
        throw new TypeError("base matching requires globstar");
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    if (this.pattern = pattern, this.platform = opts.platform || defaultPlatform, this.opts = { ...opts, platform: this.platform }, opts.scurry) {
      if (this.scurry = opts.scurry, opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase)
        throw new Error("nocase option contradicts provided scurry option");
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32", mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: !0,
      noext: this.noext,
      nonegate: !0,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    }, mms = this.pattern.map((p) => new Minimatch(p, mmo)), [matchSet, globParts] = mms.reduce((set2, m) => (set2[0].push(...m.set), set2[1].push(...m.globParts), set2), [[], []]);
    this.patterns = matchSet.map((set2, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set2, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
}
const hasMagic = (pattern, options2 = {}) => {
  Array.isArray(pattern) || (pattern = [pattern]);
  for (const p of pattern)
    if (new Minimatch(p, options2).hasMagic())
      return !0;
  return !1;
};
function globStreamSync(pattern, options2 = {}) {
  return new Glob(pattern, options2).streamSync();
}
function globStream(pattern, options2 = {}) {
  return new Glob(pattern, options2).stream();
}
function globSync(pattern, options2 = {}) {
  return new Glob(pattern, options2).walkSync();
}
async function glob_(pattern, options2 = {}) {
  return new Glob(pattern, options2).walk();
}
function globIterateSync(pattern, options2 = {}) {
  return new Glob(pattern, options2).iterateSync();
}
function globIterate(pattern, options2 = {}) {
  return new Glob(pattern, options2).iterate();
}
const streamSync = globStreamSync, stream = Object.assign(globStream, { sync: globStreamSync }), iterateSync = globIterateSync, iterate = Object.assign(globIterate, {
  sync: globIterateSync
}), sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
}), glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;
const typeOrUndef = (val, t) => typeof val > "u" || typeof val === t, isRimrafOptions = (o) => !!o && typeof o == "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.tmp, "string") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number") && (typeOrUndef(o.glob, "boolean") || o.glob && typeof o.glob == "object") && typeOrUndef(o.filter, "function"), assertRimrafOptions = (o) => {
  if (!isRimrafOptions(o))
    throw new Error("invalid rimraf options");
}, optArgT = (opt) => {
  assertRimrafOptions(opt);
  const { glob: glob2, ...options2 } = opt;
  if (!glob2)
    return options2;
  const globOpt = glob2 === !0 ? opt.signal ? { signal: opt.signal } : {} : opt.signal ? {
    signal: opt.signal,
    ...glob2
  } : glob2;
  return {
    ...options2,
    glob: {
      ...globOpt,
      // always get absolute paths from glob, to ensure
      // that we are referencing the correct thing.
      absolute: !0,
      withFileTypes: !1
    }
  };
}, optArg = (opt = {}) => optArgT(opt), optArgSync = (opt = {}) => optArgT(opt);
var platform = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;
const pathArg = (path2, opt = {}) => {
  const type2 = typeof path2;
  if (type2 !== "string") {
    const ctor = path2 && type2 === "object" && path2.constructor, msg = `The "path" argument must be of type string. Received ${ctor && ctor.name ? `an instance of ${ctor.name}` : type2 === "object" ? require$$0$a.inspect(path2) : `type ${type2} ${path2}`}`;
    throw Object.assign(new TypeError(msg), {
      path: path2,
      code: "ERR_INVALID_ARG_TYPE"
    });
  }
  if (/\0/.test(path2)) {
    const msg = "path must be a string without null bytes";
    throw Object.assign(new TypeError(msg), {
      path: path2,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path2 = require$$0$4.resolve(path2);
  const { root: root2 } = require$$0$4.parse(path2);
  if (path2 === root2 && opt.preserveRoot !== !1) {
    const msg = "refusing to remove root directory without preserveRoot:false";
    throw Object.assign(new Error(msg), {
      path: path2,
      code: "ERR_PRESERVE_ROOT"
    });
  }
  if (platform === "win32") {
    const badWinChars = /[*|"<>?:]/, { root: root3 } = require$$0$4.parse(path2);
    if (badWinChars.test(path2.substring(root3.length)))
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path2,
        code: "EINVAL"
      });
  }
  return path2;
}, readdirSync = (path2) => require$$0$5.readdirSync(path2, { withFileTypes: !0 }), chmod$2 = (path2, mode2) => new Promise((res, rej) => require$$0__default$1.default.chmod(path2, mode2, (er, ...d) => er ? rej(er) : res(...d))), mkdir = (path2, options2) => new Promise((res, rej) => require$$0__default$1.default.mkdir(path2, options2, (er, made) => er ? rej(er) : res(made))), readdir$1 = (path2) => new Promise((res, rej) => require$$0__default$1.default.readdir(path2, { withFileTypes: !0 }, (er, data) => er ? rej(er) : res(data))), rename$1 = (oldPath, newPath) => new Promise((res, rej) => require$$0__default$1.default.rename(oldPath, newPath, (er, ...d) => er ? rej(er) : res(...d))), rm$1 = (path2, options2) => new Promise((res, rej) => require$$0__default$1.default.rm(path2, options2, (er, ...d) => er ? rej(er) : res(...d))), rmdir$3 = (path2) => new Promise((res, rej) => require$$0__default$1.default.rmdir(path2, (er, ...d) => er ? rej(er) : res(...d))), stat$1 = (path2) => new Promise((res, rej) => require$$0__default$1.default.stat(path2, (er, data) => er ? rej(er) : res(data))), lstat$3 = (path2) => new Promise((res, rej) => require$$0__default$1.default.lstat(path2, (er, data) => er ? rej(er) : res(data))), unlink$3 = (path2) => new Promise((res, rej) => require$$0__default$1.default.unlink(path2, (er, ...d) => er ? rej(er) : res(...d))), promises = {
  chmod: chmod$2,
  mkdir,
  readdir: readdir$1,
  rename: rename$1,
  rm: rm$1,
  rmdir: rmdir$3,
  stat: stat$1,
  lstat: lstat$3,
  unlink: unlink$3
}, { readdir } = promises, readdirOrError = (path2) => readdir(path2).catch((er) => er), readdirOrErrorSync = (path2) => {
  try {
    return readdirSync(path2);
  } catch (er) {
    return er;
  }
}, ignoreENOENT = async (p) => p.catch((er) => {
  if (er.code !== "ENOENT")
    throw er;
}), ignoreENOENTSync = (fn) => {
  try {
    return fn();
  } catch (er) {
    if (er?.code !== "ENOENT")
      throw er;
  }
}, { lstat: lstat$2, rmdir: rmdir$2, unlink: unlink$2 } = promises, rimrafPosix = async (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  try {
    return await rimrafPosixDir(path2, opt, await lstat$2(path2));
  } catch (er) {
    if (er?.code === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafPosixSync = (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  try {
    return rimrafPosixDirSync(path2, opt, require$$0$5.lstatSync(path2));
  } catch (er) {
    if (er?.code === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafPosixDir = async (path2, opt, ent) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  const entries = ent.isDirectory() ? await readdirOrError(path2) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !await opt.filter(path2, ent) ? !1 : (await ignoreENOENT(unlink$2(path2)), !0);
  }
  return !(await Promise.all(entries.map((ent2) => rimrafPosixDir(require$$0$4.resolve(path2, ent2.name), opt, ent2)))).reduce((a, b) => a && b, !0) || opt.preserveRoot === !1 && path2 === require$$0$4.parse(path2).root || opt.filter && !await opt.filter(path2, ent) ? !1 : (await ignoreENOENT(rmdir$2(path2)), !0);
}, rimrafPosixDirSync = (path2, opt, ent) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  const entries = ent.isDirectory() ? readdirOrErrorSync(path2) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path2, ent) ? !1 : (ignoreENOENTSync(() => require$$0$5.unlinkSync(path2)), !0);
  }
  let removedAll = !0;
  for (const ent2 of entries) {
    const p = require$$0$4.resolve(path2, ent2.name);
    removedAll = rimrafPosixDirSync(p, opt, ent2) && removedAll;
  }
  return opt.preserveRoot === !1 && path2 === require$$0$4.parse(path2).root || !removedAll || opt.filter && !opt.filter(path2, ent) ? !1 : (ignoreENOENTSync(() => require$$0$5.rmdirSync(path2)), !0);
}, { chmod: chmod$1 } = promises, fixEPERM = (fn) => async (path2) => {
  try {
    return await fn(path2);
  } catch (er) {
    const fer = er;
    if (fer?.code === "ENOENT")
      return;
    if (fer?.code === "EPERM") {
      try {
        await chmod$1(path2, 438);
      } catch (er2) {
        if (er2?.code === "ENOENT")
          return;
        throw er;
      }
      return await fn(path2);
    }
    throw er;
  }
}, fixEPERMSync = (fn) => (path2) => {
  try {
    return fn(path2);
  } catch (er) {
    const fer = er;
    if (fer?.code === "ENOENT")
      return;
    if (fer?.code === "EPERM") {
      try {
        require$$0$5.chmodSync(path2, 438);
      } catch (er2) {
        if (er2?.code === "ENOENT")
          return;
        throw er;
      }
      return fn(path2);
    }
    throw er;
  }
}, MAXBACKOFF = 200, RATE = 1.2, MAXRETRIES = 10, codes = /* @__PURE__ */ new Set(["EMFILE", "ENFILE", "EBUSY"]), retryBusy = (fn) => {
  const method = async (path2, opt, backoff = 1, total = 0) => {
    const mbo = opt.maxBackoff || MAXBACKOFF, rate = opt.backoff || RATE, max2 = opt.maxRetries || MAXRETRIES;
    let retries = 0;
    for (; ; )
      try {
        return await fn(path2);
      } catch (er) {
        const fer = er;
        if (fer?.path === path2 && fer?.code && codes.has(fer.code)) {
          if (backoff = Math.ceil(backoff * rate), total = backoff + total, total < mbo)
            return new Promise((res, rej) => {
              setTimeout(() => {
                method(path2, opt, backoff, total).then(res, rej);
              }, backoff);
            });
          if (retries < max2) {
            retries++;
            continue;
          }
        }
        throw er;
      }
  };
  return method;
}, retryBusySync = (fn) => (path2, opt) => {
  const max2 = opt.maxRetries || MAXRETRIES;
  let retries = 0;
  for (; ; )
    try {
      return fn(path2);
    } catch (er) {
      const fer = er;
      if (fer?.path === path2 && fer?.code && codes.has(fer.code) && retries < max2) {
        retries++;
        continue;
      }
      throw er;
    }
}, { stat } = promises, isDirSync = (path2) => {
  try {
    return require$$0$5.statSync(path2).isDirectory();
  } catch {
    return !1;
  }
}, isDir = (path2) => stat(path2).then((st) => st.isDirectory(), () => !1), win32DefaultTmp = async (path2) => {
  const { root: root2 } = require$$0$4.parse(path2), tmp2 = require$$0$6.tmpdir(), { root: tmpRoot } = require$$0$4.parse(tmp2);
  if (root2.toLowerCase() === tmpRoot.toLowerCase())
    return tmp2;
  const driveTmp = require$$0$4.resolve(root2, "/temp");
  return await isDir(driveTmp) ? driveTmp : root2;
}, win32DefaultTmpSync = (path2) => {
  const { root: root2 } = require$$0$4.parse(path2), tmp2 = require$$0$6.tmpdir(), { root: tmpRoot } = require$$0$4.parse(tmp2);
  if (root2.toLowerCase() === tmpRoot.toLowerCase())
    return tmp2;
  const driveTmp = require$$0$4.resolve(root2, "/temp");
  return isDirSync(driveTmp) ? driveTmp : root2;
}, posixDefaultTmp = async () => require$$0$6.tmpdir(), posixDefaultTmpSync = () => require$$0$6.tmpdir(), defaultTmp = platform === "win32" ? win32DefaultTmp : posixDefaultTmp, defaultTmpSync = platform === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync, { lstat: lstat$1, rename, unlink: unlink$1, rmdir: rmdir$1, chmod } = promises, uniqueFilename = (path2) => `.${require$$0$4.basename(path2)}.${Math.random()}`, unlinkFixEPERM = async (path2) => unlink$1(path2).catch((er) => {
  if (er.code === "EPERM")
    return chmod(path2, 438).then(() => unlink$1(path2), (er2) => {
      if (er2.code !== "ENOENT")
        throw er;
    });
  if (er.code === "ENOENT")
    return;
  throw er;
}), unlinkFixEPERMSync = (path2) => {
  try {
    require$$0$5.unlinkSync(path2);
  } catch (er) {
    if (er?.code === "EPERM")
      try {
        return require$$0$5.chmodSync(path2, 438);
      } catch (er2) {
        if (er2?.code === "ENOENT")
          return;
        throw er;
      }
    else if (er?.code === "ENOENT")
      return;
    throw er;
  }
}, rimrafMoveRemove = async (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  try {
    return await rimrafMoveRemoveDir(path2, opt, await lstat$1(path2));
  } catch (er) {
    if (er?.code === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafMoveRemoveDir = async (path2, opt, ent) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  if (!opt.tmp)
    return rimrafMoveRemoveDir(path2, { ...opt, tmp: await defaultTmp(path2) }, ent);
  if (path2 === opt.tmp && require$$0$4.parse(path2).root !== path2)
    throw new Error("cannot delete temp directory used for deletion");
  const entries = ent.isDirectory() ? await readdirOrError(path2) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !await opt.filter(path2, ent) ? !1 : (await ignoreENOENT(tmpUnlink(path2, opt.tmp, unlinkFixEPERM)), !0);
  }
  return !(await Promise.all(entries.map((ent2) => rimrafMoveRemoveDir(require$$0$4.resolve(path2, ent2.name), opt, ent2)))).reduce((a, b) => a && b, !0) || opt.preserveRoot === !1 && path2 === require$$0$4.parse(path2).root || opt.filter && !await opt.filter(path2, ent) ? !1 : (await ignoreENOENT(tmpUnlink(path2, opt.tmp, rmdir$1)), !0);
}, tmpUnlink = async (path2, tmp2, rm2) => {
  const tmpFile = require$$0$4.resolve(tmp2, uniqueFilename(path2));
  return await rename(path2, tmpFile), await rm2(tmpFile);
}, rimrafMoveRemoveSync = (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  try {
    return rimrafMoveRemoveDirSync(path2, opt, require$$0$5.lstatSync(path2));
  } catch (er) {
    if (er?.code === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafMoveRemoveDirSync = (path2, opt, ent) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  if (!opt.tmp)
    return rimrafMoveRemoveDirSync(path2, { ...opt, tmp: defaultTmpSync(path2) }, ent);
  const tmp2 = opt.tmp;
  if (path2 === opt.tmp && require$$0$4.parse(path2).root !== path2)
    throw new Error("cannot delete temp directory used for deletion");
  const entries = ent.isDirectory() ? readdirOrErrorSync(path2) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path2, ent) ? !1 : (ignoreENOENTSync(() => tmpUnlinkSync(path2, tmp2, unlinkFixEPERMSync)), !0);
  }
  let removedAll = !0;
  for (const ent2 of entries) {
    const p = require$$0$4.resolve(path2, ent2.name);
    removedAll = rimrafMoveRemoveDirSync(p, opt, ent2) && removedAll;
  }
  return !removedAll || opt.preserveRoot === !1 && path2 === require$$0$4.parse(path2).root || opt.filter && !opt.filter(path2, ent) ? !1 : (ignoreENOENTSync(() => tmpUnlinkSync(path2, tmp2, require$$0$5.rmdirSync)), !0);
}, tmpUnlinkSync = (path2, tmp2, rmSync) => {
  const tmpFile = require$$0$4.resolve(tmp2, uniqueFilename(path2));
  return require$$0$5.renameSync(path2, tmpFile), rmSync(tmpFile);
}, { unlink, rmdir, lstat } = promises, rimrafWindowsFile = retryBusy(fixEPERM(unlink)), rimrafWindowsFileSync = retryBusySync(fixEPERMSync(require$$0$5.unlinkSync)), rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir)), rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(require$$0$5.rmdirSync)), rimrafWindowsDirMoveRemoveFallback = async (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  const { filter: filter2, ...options2 } = opt;
  try {
    return await rimrafWindowsDirRetry(path2, options2);
  } catch (er) {
    if (er?.code === "ENOTEMPTY")
      return await rimrafMoveRemove(path2, options2);
    throw er;
  }
}, rimrafWindowsDirMoveRemoveFallbackSync = (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  const { filter: filter2, ...options2 } = opt;
  try {
    return rimrafWindowsDirRetrySync(path2, options2);
  } catch (er) {
    if (er?.code === "ENOTEMPTY")
      return rimrafMoveRemoveSync(path2, options2);
    throw er;
  }
}, START = Symbol("start"), CHILD = Symbol("child"), FINISH = Symbol("finish"), rimrafWindows = async (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  try {
    return await rimrafWindowsDir(path2, opt, await lstat(path2), START);
  } catch (er) {
    if (er?.code === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafWindowsSync = (path2, opt) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  try {
    return rimrafWindowsDirSync(path2, opt, require$$0$5.lstatSync(path2), START);
  } catch (er) {
    if (er?.code === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafWindowsDir = async (path2, opt, ent, state = START) => {
  if (opt?.signal?.aborted)
    throw opt.signal.reason;
  const entries = ent.isDirectory() ? await readdirOrError(path2) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !await opt.filter(path2, ent) ? !1 : (await ignoreENOENT(rimrafWindowsFile(path2, opt)), !0);
  }
  const s = state === START ? CHILD : state, removedAll = (await Promise.all(entries.map((ent2) => rimrafWindowsDir(require$$0$4.resolve(path2, ent2.name), opt, ent2, s)))).reduce((a, b) => a && b, !0);
  if (state === START)
    return rimrafWindowsDir(path2, opt, ent, FINISH);
  if (state === FINISH) {
    if (opt.preserveRoot === !1 && path2 === require$$0$4.parse(path2).root || !removedAll || opt.filter && !await opt.filter(path2, ent))
      return !1;
    await ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path2, opt));
  }
  return !0;
}, rimrafWindowsDirSync = (path2, opt, ent, state = START) => {
  const entries = ent.isDirectory() ? readdirOrErrorSync(path2) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path2, ent) ? !1 : (ignoreENOENTSync(() => rimrafWindowsFileSync(path2, opt)), !0);
  }
  let removedAll = !0;
  for (const ent2 of entries) {
    const s = state === START ? CHILD : state, p = require$$0$4.resolve(path2, ent2.name);
    removedAll = rimrafWindowsDirSync(p, opt, ent2, s) && removedAll;
  }
  if (state === START)
    return rimrafWindowsDirSync(path2, opt, ent, FINISH);
  if (state === FINISH) {
    if (opt.preserveRoot === !1 && path2 === require$$0$4.parse(path2).root || !removedAll || opt.filter && !opt.filter(path2, ent))
      return !1;
    ignoreENOENTSync(() => {
      rimrafWindowsDirMoveRemoveFallbackSync(path2, opt);
    });
  }
  return !0;
}, rimrafManual = platform === "win32" ? rimrafWindows : rimrafPosix, rimrafManualSync = platform === "win32" ? rimrafWindowsSync : rimrafPosixSync, { rm } = promises, rimrafNative = async (path2, opt) => (await rm(path2, {
  ...opt,
  force: !0,
  recursive: !0
}), !0), rimrafNativeSync = (path2, opt) => (require$$0$5.rmSync(path2, {
  ...opt,
  force: !0,
  recursive: !0
}), !0), version = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version, versArr = version.replace(/^v/, "").split("."), [major = 0, minor = 0] = versArr.map((v) => parseInt(v, 10)), hasNative = major > 14 || major === 14 && minor >= 14, useNative = !hasNative || platform === "win32" ? () => !1 : (opt) => !opt?.signal && !opt?.filter, useNativeSync = !hasNative || platform === "win32" ? () => !1 : (opt) => !opt?.signal && !opt?.filter, wrap = (fn) => async (path2, opt) => {
  const options2 = optArg(opt);
  return options2.glob && (path2 = await glob(path2, options2.glob)), Array.isArray(path2) ? !!(await Promise.all(path2.map((p) => fn(pathArg(p, options2), options2)))).reduce((a, b) => a && b, !0) : !!await fn(pathArg(path2, options2), options2);
}, wrapSync = (fn) => (path2, opt) => {
  const options2 = optArgSync(opt);
  return options2.glob && (path2 = globSync(path2, options2.glob)), Array.isArray(path2) ? !!path2.map((p) => fn(pathArg(p, options2), options2)).reduce((a, b) => a && b, !0) : !!fn(pathArg(path2, options2), options2);
}, nativeSync = wrapSync(rimrafNativeSync), native = Object.assign(wrap(rimrafNative), { sync: nativeSync }), manualSync = wrapSync(rimrafManualSync), manual = Object.assign(wrap(rimrafManual), { sync: manualSync }), windowsSync = wrapSync(rimrafWindowsSync), windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync }), posixSync = wrapSync(rimrafPosixSync), posix = Object.assign(wrap(rimrafPosix), { sync: posixSync }), moveRemoveSync = wrapSync(rimrafMoveRemoveSync), moveRemove = Object.assign(wrap(rimrafMoveRemove), {
  sync: moveRemoveSync
}), rimrafSync = wrapSync((path2, opt) => useNativeSync(opt) ? rimrafNativeSync(path2, opt) : rimrafManualSync(path2, opt)), rimraf_ = wrap((path2, opt) => useNative(opt) ? rimrafNative(path2, opt) : rimrafManual(path2, opt)), rimraf = Object.assign(rimraf_, {
  rimraf: rimraf_,
  sync: rimrafSync,
  rimrafSync,
  manual,
  manualSync,
  native,
  nativeSync,
  posix,
  posixSync,
  windows,
  windowsSync,
  moveRemove,
  moveRemoveSync
});
rimraf.rimraf = rimraf;
const defaultCommitMessage = "feat: bootstrap sanity studio";
function tryGitInit(rootDir, commitMessage) {
  const execOptions = { stdio: "ignore", cwd: rootDir };
  let didInit = !1;
  try {
    return childProcess.execSync("git --version", execOptions), isInGitRepository(rootDir) || isInMercurialRepository(rootDir) ? !1 : (childProcess.execSync("git init", execOptions), didInit = !0, childProcess.execSync("git checkout -b main", execOptions), childProcess.execSync("git add -A", execOptions), childProcess.execFileSync("git", ["commit", "-m", commitMessage || defaultCommitMessage], {
      stdio: "ignore",
      cwd: rootDir
    }), !0);
  } catch {
    if (didInit)
      try {
        rimrafSync(path__default.default.join(rootDir, ".git"));
      } catch {
      }
    return !1;
  }
}
function isInGitRepository(rootDir) {
  try {
    return childProcess.execSync("git rev-parse --is-inside-work-tree", { stdio: "ignore", cwd: rootDir }), !0;
  } catch {
  }
  return !1;
}
function isInMercurialRepository(rootDir) {
  try {
    return childProcess.execSync("hg --cwd . root", { stdio: "ignore", cwd: rootDir }), !0;
  } catch {
  }
  return !1;
}
const INITIAL_COMMIT_MESSAGE = "Initial commit from Sanity CLI";
async function bootstrapRemoteTemplate(opts, context) {
  const { outputPath, repoInfo, bearerToken, variables, packageName } = opts, { output, apiClient } = context, name = [repoInfo.username, repoInfo.name, repoInfo.filePath].filter(Boolean).join("/"), spinner = output.spinner(`Bootstrapping files from template "${name}"`).start();
  loadEnv.debug("Validating remote template");
  const packages = await getPackages(repoInfo, bearerToken);
  await validateRemoteTemplate(repoInfo, packages, bearerToken), loadEnv.debug('Create new directory "%s"', outputPath), await fs.mkdir(outputPath, { recursive: !0 }), loadEnv.debug("Downloading and extracting repo to %s", outputPath), await downloadAndExtractRepo(outputPath, repoInfo, bearerToken), loadEnv.debug("Checking if template needs read token");
  const needsReadToken = await Promise.all(
    (packages ?? [""]).map((pkg) => checkNeedsReadToken(path$3.join(outputPath, pkg)))
  ).then((results) => results.some(Boolean));
  loadEnv.debug("Applying environment variables");
  const readToken = needsReadToken ? await generateSanityApiReadToken("API Read Token", variables.projectId, apiClient) : void 0;
  for (const pkg of packages ?? [""]) {
    const packagePath = path$3.join(outputPath, pkg), packageFramework = await distExports.detectFrameworkRecord({
      fs: new distExports.LocalFileSystemDetector(packagePath),
      frameworkList: frameworksExports.frameworks
    }), port = getDefaultPortForFramework(packageFramework?.slug);
    loadEnv.debug("Setting CORS origin to http://localhost:%d", port), await setCorsOrigin(`http://localhost:${port}`, variables.projectId, apiClient), loadEnv.debug("Applying environment variables to %s", pkg);
    const envName = packageFramework?.slug === "nextjs" ? ".env.local" : ".env";
    await applyEnvVariables(packagePath, { ...variables, readToken }, envName);
  }
  loadEnv.debug("Setting package name to %s", packageName), await tryApplyPackageName(outputPath, packageName), loadEnv.debug("Initializing git repository"), tryGitInit(outputPath, INITIAL_COMMIT_MESSAGE), loadEnv.debug("Updating initial template metadata"), await updateInitialTemplateMetadata(apiClient, variables.projectId, `external-${name}`), spinner.succeed();
}
function validateEmptyPath(dir) {
  const checkPath = absolutify(dir);
  return pathIsEmpty(checkPath) ? !0 : "Given path is not empty";
}
function absolutify(dir) {
  const pathName = expandHome(dir);
  return path__default.default.isAbsolute(pathName) ? pathName : path__default.default.resolve(process.cwd(), pathName);
}
function pathIsEmpty(dir) {
  try {
    return fs__namespace.default.readdirSync(dir).length === 0;
  } catch (err) {
    if (err.code === "ENOENT")
      return !0;
    throw err;
  }
}
function expandHome(filePath) {
  if (filePath.charCodeAt(0) === 126) {
    if (filePath.charCodeAt(1) === 43)
      return path__default.default.join(process.cwd(), filePath.slice(2));
    const home = os__default.default.homedir();
    return home ? path__default.default.join(home, filePath.slice(1)) : filePath;
  }
  return filePath;
}
const MAX_DATASET_NAME_LENGTH = 64, datasetNameError = `Dataset names can only contain lowercase characters,numbers, underscores and dashesand can be at most ${MAX_DATASET_NAME_LENGTH} characters.`;
function promptForDatasetName(prompt2, options2 = {}, existingDatasets = []) {
  return prompt2.single({
    type: "input",
    message: "Dataset name:",
    validate: (name) => {
      if (existingDatasets.includes(name))
        return "Dataset name already exists";
      if (!name || name.length < 2 || name.length > MAX_DATASET_NAME_LENGTH)
        return `Dataset name must be between 2 and ${MAX_DATASET_NAME_LENGTH} characters`;
      if (name.toLowerCase() !== name)
        return "Dataset name must be lowercase";
      if (name.replace(/\s/g, "") !== name)
        return "Dataset name cannot contain whitespace";
      if (/^[^a-z0-9]/.test(name))
        return "Dataset name must start with a character or letter";
      if (/[-_]$/.test(name))
        return "Dataset name must not end with a dash or an underscore";
      if (/^[a-z0-9][-\w]+$/.test(name))
        return !0;
      const invalid = name.match(/[^-\w]/g) || [];
      return invalid.length > 0 ? `Disallowed characters found: ${formatInvalid(name, invalid)}` : datasetNameError;
    },
    ...options2
  });
}
function formatInvalid(name, invalid) {
  return invalid.reduce(
    (acc, char) => acc.replace(new RegExp(escapeRegex(char), "g"), chalk__default.default.red.bold(char)),
    name
  );
}
function escapeRegex(str2) {
  return `${str2}`.replace(/([?!${}*:()|=^[\]/\\.+])/g, "\\$1");
}
function promptForTypeScript(prompt2) {
  return prompt2.single({
    type: "confirm",
    message: "Do you want to use TypeScript?",
    default: !0
  });
}
function promptForDefaultConfig(prompt2) {
  return prompt2.single({
    type: "confirm",
    message: "Use the default dataset configuration?",
    default: !0
  });
}
async function promptForAclMode(prompt2, output) {
  const mode2 = await prompt2.single({
    type: "list",
    message: "Choose dataset visibility\xA0\u2013\xA0this can be changed later",
    choices: [
      {
        value: "public",
        name: "Public (world readable)"
      },
      {
        value: "private",
        name: "Private (authenticated requests only)"
      }
    ]
  });
  return mode2 === "private" && output.print(
    `Please note that while documents are private, assets (files and images) are still public
`
  ), mode2;
}
function promptForEmbeddedStudio(prompt2) {
  return prompt2.single({
    type: "confirm",
    message: "Would you like an embedded Sanity Studio?",
    default: !0
  });
}
function promptForStudioPath(prompt2) {
  return prompt2.single({
    type: "input",
    message: "What route do you want to use for the Studio?",
    default: "/studio",
    validate(input2) {
      return input2.startsWith("/") ? input2.endsWith("/") ? "Must not end with /" : /^[a-zA-Z0-9-_\\/]+$/.test(input2) ? !0 : "Must only contain a-Z, 0-9, -, _ and /" : "Must start with /";
    }
  });
}
function promptForNextTemplate(prompt2) {
  return prompt2.single({
    message: "Select project template to use",
    type: "list",
    choices: [
      {
        value: "blog",
        name: "Blog (schema)"
      },
      {
        value: "clean",
        name: "Clean project with no predefined schema types"
      }
    ],
    default: "blog"
  });
}
function promptForAppendEnv(prompt2, envFilename) {
  return prompt2.single({
    type: "confirm",
    message: `Would you like to add the project ID and dataset to your ${envFilename} file?`,
    default: !0
  });
}
function readPackageJson(filePath) {
  try {
    return JSON.parse(fs__namespace.default.readFileSync(filePath, "utf8"));
  } catch {
    return;
  }
}
const authorType = `import {UserIcon} from '@sanity/icons'
import {defineArrayMember, defineField, defineType} from 'sanity'

export const authorType = defineType({
  name: 'author',
  title: 'Author',
  type: 'document',
  icon: UserIcon,
  fields: [
    defineField({
      name: 'name',
      type: 'string',
    }),
    defineField({
      name: 'slug',
      type: 'slug',
      options: {
        source: 'name',
      },
    }),
    defineField({
      name: 'image',
      type: 'image',
      options: {
        hotspot: true,
      },
    }),
    defineField({
      name: 'bio',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'block',
          styles: [{title: 'Normal', value: 'normal'}],
          lists: [],
        }),
      ],
    }),
  ],
  preview: {
    select: {
      title: 'name',
      media: 'image',
    },
  },
})
`, blockContentType = `import {defineType, defineArrayMember} from 'sanity'
import {ImageIcon} from '@sanity/icons'

/**
 * This is the schema type for block content used in the post document type
 * Importing this type into the studio configuration's \`schema\` property
 * lets you reuse it in other document types with:
 *  {
 *    name: 'someName',
 *    title: 'Some title',
 *    type: 'blockContent'
 *  }
 */

export const blockContentType = defineType({
  title: 'Block Content',
  name: 'blockContent',
  type: 'array',
  of: [
    defineArrayMember({
      type: 'block',
      // Styles let you define what blocks can be marked up as. The default
      // set corresponds with HTML tags, but you can set any title or value
      // you want, and decide how you want to deal with it where you want to
      // use your content.
      styles: [
        {title: 'Normal', value: 'normal'},
        {title: 'H1', value: 'h1'},
        {title: 'H2', value: 'h2'},
        {title: 'H3', value: 'h3'},
        {title: 'H4', value: 'h4'},
        {title: 'Quote', value: 'blockquote'},
      ],
      lists: [{title: 'Bullet', value: 'bullet'}],
      // Marks let you mark up inline text in the Portable Text Editor
      marks: {
        // Decorators usually describe a single property \u2013 e.g. a typographic
        // preference or highlighting
        decorators: [
          {title: 'Strong', value: 'strong'},
          {title: 'Emphasis', value: 'em'},
        ],
        // Annotations can be any object structure \u2013 e.g. a link or a footnote.
        annotations: [
          {
            title: 'URL',
            name: 'link',
            type: 'object',
            fields: [
              {
                title: 'URL',
                name: 'href',
                type: 'url',
              },
            ],
          },
        ],
      },
    }),
    // You can add additional types here. Note that you can't use
    // primitive types such as 'string' and 'number' in the same array
    // as a block type.
    defineArrayMember({
      type: 'image',
      icon: ImageIcon,
      options: {hotspot: true},
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    }),
  ],
})
`, categoryType = `import {TagIcon} from '@sanity/icons'
import {defineField, defineType} from 'sanity'

export const categoryType = defineType({
  name: 'category',
  title: 'Category',
  type: 'document',
  icon: TagIcon,
  fields: [
    defineField({
      name: 'title',
      type: 'string',
    }),
    defineField({
      name: 'slug',
      type: 'slug',
      options: {
        source: 'title',
      },
    }),
    defineField({
      name: 'description',
      type: 'text',
    }),
  ],
})
`, postType = `import {DocumentTextIcon} from '@sanity/icons'
import {defineArrayMember, defineField, defineType} from 'sanity'

export const postType = defineType({
  name: 'post',
  title: 'Post',
  type: 'document',
  icon: DocumentTextIcon,
  fields: [
    defineField({
      name: 'title',
      type: 'string',
    }),
    defineField({
      name: 'slug',
      type: 'slug',
      options: {
        source: 'title',
      },
    }),
    defineField({
      name: 'author',
      type: 'reference',
      to: {type: 'author'},
    }),
    defineField({
      name: 'mainImage',
      type: 'image',
      options: {
        hotspot: true,
      },
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative text',
        }
      ]
    }),
    defineField({
      name: 'categories',
      type: 'array',
      of: [defineArrayMember({type: 'reference', to: {type: 'category'}})],
    }),
    defineField({
      name: 'publishedAt',
      type: 'datetime',
    }),
    defineField({
      name: 'body',
      type: 'blockContent',
    }),
  ],
  preview: {
    select: {
      title: 'title',
      author: 'author.name',
      media: 'mainImage',
    },
    prepare(selection) {
      const {author} = selection
      return {...selection, subtitle: author && \`by \${author}\`}
    },
  },
})
`, blogSchemaTS = `import { type SchemaTypeDefinition } from 'sanity'

import {blockContentType} from './blockContentType'
import {categoryType} from './categoryType'
import {postType} from './postType'
import {authorType} from './authorType'

export const schema: { types: SchemaTypeDefinition[] } = {
  types: [blockContentType, categoryType, postType, authorType],
}
`, blogSchemaJS = `import {blockContentType} from './blockContentType'
import {categoryType} from './categoryType'
import {postType} from './postType'
import {authorType} from './authorType'

export const schema = {
  types: [blockContentType, categoryType, postType, authorType],
}
`, blogSchemaFolder = {
  "authorType.": authorType,
  "blockContentType.": blockContentType,
  "categoryType.": categoryType,
  "postType.": postType
}, sanityConfigTemplate = (hasSrcFolder = !1) => `'use client'

/**
 * This configuration is used to for the Sanity Studio that\u2019s mounted on the \`:route:\` route
 */

import {visionTool} from '@sanity/vision'
import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'

// Go to https://www.sanity.io/docs/api-versioning to learn how API versioning works
import {apiVersion, dataset, projectId} from ${hasSrcFolder ? "'./src/sanity/env'" : "'./sanity/env'"}
import {schema} from ${hasSrcFolder ? "'./src/sanity/schemaTypes'" : "'./sanity/schemaTypes'"}
import {structure} from ${hasSrcFolder ? "'./src/sanity/structure'" : "'./sanity/structure'"}

export default defineConfig({
  basePath: ':basePath:',
  projectId,
  dataset,
  // Add and edit the content schema in the './sanity/schemaTypes' folder
  schema,
  plugins: [
    structureTool({structure}),
    // Vision is for querying with GROQ from inside the Studio
    // https://www.sanity.io/docs/the-vision-plugin
    visionTool({defaultApiVersion: apiVersion}),
  ],
})
`, sanityCliTemplate = `/**
* This configuration file lets you run \`$ sanity [command]\` in this folder
* Go to https://www.sanity.io/docs/cli to learn more.
**/
import { defineCliConfig } from 'sanity/cli'

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET

export default defineCliConfig({ api: { projectId, dataset } })
`, sanityStudioTemplate = `/**
 * This route is responsible for the built-in authoring environment using Sanity Studio.
 * All routes under your studio path is handled by this file using Next.js' catch-all routes:
 * https://nextjs.org/docs/routing/dynamic-routes#catch-all-routes
 *
 * You can learn more about the next-sanity package here:
 * https://github.com/sanity-io/next-sanity
 */

import { NextStudio } from 'next-sanity/studio'
import config from ':configPath:'

export const dynamic = 'force-static'

export { metadata, viewport } from 'next-sanity/studio'

export default function StudioPage() {
  return <NextStudio config={config} />
}
`, envTS = `export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}'

export const dataset = assertValue(
  process.env.NEXT_PUBLIC_SANITY_DATASET,
  'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET'
)

export const projectId = assertValue(
  process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID'
)

function assertValue<T>(v: T | undefined, errorMessage: string): T {
  if (v === undefined) {
    throw new Error(errorMessage)
  }

  return v
}
`, envJS = `export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}'

export const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET;
export const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID;
`, schemaTS = `import { type SchemaTypeDefinition } from 'sanity'

export const schema: { types: SchemaTypeDefinition[] } = {
  types: [],
}
`, schemaJS = `export const schema = {
  types: [],
}
`, blogStructureTS = `import type {StructureResolver} from 'sanity/structure'

// https://www.sanity.io/docs/structure-builder-cheat-sheet
export const structure: StructureResolver = (S) =>
  S.list()
    .title('Blog')
    .items([
      S.documentTypeListItem('post').title('Posts'),
      S.documentTypeListItem('category').title('Categories'),
      S.documentTypeListItem('author').title('Authors'),
      S.divider(),
      ...S.documentTypeListItems().filter(
        (item) => item.getId() && !['post', 'category', 'author'].includes(item.getId()!),
      ),
    ])
`, blogStructureJS = `// https://www.sanity.io/docs/structure-builder-cheat-sheet
export const structure = (S) =>
  S.list()
    .title('Blog')
    .items([
      S.documentTypeListItem('post').title('Posts'),
      S.documentTypeListItem('category').title('Categories'),
      S.documentTypeListItem('author').title('Authors'),
      S.divider(),
      ...S.documentTypeListItems().filter(
        (item) => item.getId() && !['post', 'category', 'author'].includes(item.getId()),
      ),
    ])
`, structureTS = `import type {StructureResolver} from 'sanity/structure'

// https://www.sanity.io/docs/structure-builder-cheat-sheet
export const structure: StructureResolver = (S) =>
  S.list()
    .title('Content')
    .items(S.documentTypeListItems())
`, structureJS = `// https://www.sanity.io/docs/structure-builder-cheat-sheet
export const structure = (S) =>
  S.list()
    .title('Content')
    .items(S.documentTypeListItems())
`, client = `import { createClient } from 'next-sanity'

import { apiVersion, dataset, projectId } from '../env'

export const client = createClient({
  projectId,
  dataset,
  apiVersion,
  useCdn: true, // Set to false if statically generating pages, using ISR or tag-based revalidation
})
`, live = `// Querying with "sanityFetch" will keep content automatically updated
// Before using it, import and render "<SanityLive />" in your layout, see
// https://github.com/sanity-io/next-sanity#live-content-api for more information.
import { defineLive } from "next-sanity";
import { client } from './client'

export const { sanityFetch, SanityLive } = defineLive({ 
  client: client.withConfig({ 
    // Live content is currently only available on the experimental API
    // https://www.sanity.io/docs/api-versioning
    apiVersion: 'vX' 
  }) 
});
`, imageTS = `import createImageUrlBuilder from '@sanity/image-url'
import { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from '../env'

// https://www.sanity.io/docs/image-url
const builder = createImageUrlBuilder({ projectId, dataset })

export const urlFor = (source: SanityImageSource) => {
  return builder.image(source)
}
`, imageJS = `import createImageUrlBuilder from '@sanity/image-url'

import { dataset, projectId } from '../env'

// https://www.sanity.io/docs/image-url
const builder = createImageUrlBuilder({ projectId, dataset })

export const urlFor = (source) => {
  return builder.image(source)
}
`, sanityFolder = (useTypeScript, template) => {
  const structure = {
    "env.": useTypeScript ? envTS : envJS,
    lib: {
      "client.": client,
      "live.": live,
      "image.": useTypeScript ? imageTS : imageJS
    }
  };
  return template === "blog" ? (structure.schemaTypes = {
    ...blogSchemaFolder,
    "index.": useTypeScript ? blogSchemaTS : blogSchemaJS
  }, structure["structure."] = useTypeScript ? blogStructureTS : blogStructureJS) : (structure.schemaTypes = {
    "index.": useTypeScript ? schemaTS : schemaJS
  }, structure["structure."] = useTypeScript ? structureTS : structureJS), structure;
}, isCI = !!process.env.CI;
async function initSanity(args, context) {
  const { output, prompt: prompt2, workDir, apiClient, chalk: chalk2, telemetry: telemetry2, detectedFramework } = context, trace = telemetry2.trace(CLIInitStepCompleted), cliFlags = args.extOptions, unattended = cliFlags.y || cliFlags.yes, print = unattended ? lodashExports.noop : output.print, success = output.success, warn = output.warn, intendedPlan = cliFlags["project-plan"], intendedCoupon = cliFlags.coupon, reconfigure = cliFlags.reconfigure, commitMessage = cliFlags.git, useGit = typeof commitMessage > "u" ? !0 : !!commitMessage, bareOutput = cliFlags.bare, env = cliFlags.env, packageManager = cliFlags["package-manager"];
  let remoteTemplateInfo;
  cliFlags.template && checkIsRemoteTemplate(cliFlags.template) && (remoteTemplateInfo = await getGitHubRepoInfo(cliFlags.template, cliFlags["template-token"]));
  let defaultConfig = cliFlags["dataset-default"], showDefaultConfigPrompt = !defaultConfig;
  if (trace.start(), trace.log({
    step: "start",
    flags: {
      defaultConfig,
      unattended,
      plan: intendedPlan,
      coupon: intendedCoupon,
      reconfigure,
      git: commitMessage,
      bare: bareOutput,
      env
    }
  }), detectedFramework && detectedFramework.slug !== "sanity" && remoteTemplateInfo)
    throw new Error(
      `A remote template cannot be used with a detected framework. Detected: ${detectedFramework.name}`
    );
  if (intendedCoupon && intendedPlan)
    throw new Error(
      "Error! --project-plan and --coupon cannot be used together; please select only one flag"
    );
  if (intendedCoupon && cliFlags.project)
    throw new Error(
      "Error! --project and --coupon cannot be used together; coupons can only be applied to new projects"
    );
  let selectedPlan;
  if (intendedCoupon)
    try {
      selectedPlan = await getPlanFromCoupon(apiClient, intendedCoupon), print(`Coupon "${intendedCoupon}" validated!
`);
    } catch (err) {
      if (err.statusCode == "404") {
        const useDefaultPlan = unattended ?? await prompt2.single({
          type: "confirm",
          message: `Coupon "${intendedCoupon}" is not available, use default plan instead?`,
          default: !0
        });
        if (unattended && output.warn(`Coupon "${intendedCoupon}" is not available - using default plan`), trace.log({
          step: "useDefaultPlanCoupon",
          selectedOption: useDefaultPlan ? "yes" : "no",
          coupon: intendedCoupon
        }), useDefaultPlan)
          print("Using default plan.");
        else
          throw new Error(`Coupon "${intendedCoupon}" does not exist`);
      } else
        throw new Error(`Unable to validate coupon, please try again later:

${err.message}`);
    }
  else if (intendedPlan)
    try {
      selectedPlan = await getPlanFromId(apiClient, intendedPlan);
    } catch (err) {
      if (err.statusCode == "404") {
        const useDefaultPlan = unattended ?? await prompt2.single({
          type: "confirm",
          message: `Project plan "${intendedPlan}" does not exist, use default plan instead?`,
          default: !0
        });
        if (unattended && output.warn(`Project plan "${intendedPlan}" does not exist - using default plan`), trace.log({
          step: "useDefaultPlanId",
          selectedOption: useDefaultPlan ? "yes" : "no",
          planId: intendedPlan
        }), useDefaultPlan)
          print("Using default plan.");
        else
          throw new Error(`Plan id "${intendedPlan}" does not exist`);
      } else
        throw new Error(`Unable to validate plan, please try again later:

${err.message}`);
    }
  if (reconfigure)
    throw new Error("`--reconfigure` is deprecated - manual configuration is now required");
  let envFilenameDefault = ".env";
  detectedFramework && detectedFramework.slug === "nextjs" && (envFilenameDefault = ".env.local");
  const envFilename = typeof env == "string" ? env : envFilenameDefault;
  if (!envFilename.startsWith(".env"))
    throw new Error("Env filename must start with .env");
  const hasToken = getUserConfig().get("authToken");
  if (loadEnv.debug(hasToken ? "User already has a token" : "User has no token"), hasToken) {
    trace.log({ step: "login", alreadyLoggedIn: !0 });
    const user = await getUserData(apiClient);
    success("You are logged in as %s using %s", user.email, getProviderName(user.provider));
  } else unattended || (trace.log({ step: "login" }), await getOrCreateUser());
  let introMessage = "Fetching existing projects";
  cliFlags.quickstart && (introMessage = "Eject your existing project's Sanity configuration"), success(introMessage), print("");
  const flags = await prepareFlags(), { projectId, displayName, isFirstProject, datasetName, schemaUrl } = await getProjectDetails(), sluggedName = lodashExports.deburr(displayName.toLowerCase()).replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");
  if (bareOutput) {
    success("Below are your project details"), print(""), print(`Project ID: ${chalk2.cyan(projectId)}`), print(`Dataset: ${chalk2.cyan(datasetName)}`), print(
      `
You can find your project on Sanity Manage \u2014 https://www.sanity.io/manage/project/${projectId}
`
    );
    return;
  }
  let initNext = !1;
  const isNextJs = detectedFramework?.slug === "nextjs";
  isNextJs && (initNext = await prompt2.single({
    type: "confirm",
    message: "Would you like to add configuration files for a Sanity project in this Next.js folder?",
    default: !0
  }), trace.log({
    step: "useDetectedFramework",
    selectedOption: initNext ? "yes" : "no",
    detectedFramework: detectedFramework?.name
  }));
  const initFramework = initNext;
  let outputPath = workDir;
  const defaults2 = await getProjectDefaults(workDir, { isPlugin: !1, context }), answers = await getProjectInfo();
  if (outputPath = answers.outputPath, isNextJs) {
    const reactVersion = readPackageJson(`${outputPath}/package.json`)?.dependencies?.react;
    if (reactVersion) {
      const isUsingReact19 = semver__default.default.coerce(reactVersion)?.major === 19;
      semver__default.default.coerce(detectedFramework?.detectedVersion)?.major === 15 && isUsingReact19 && (warn("\u256D\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256E"), warn("\u2502                                                            \u2502"), warn("\u2502 It looks like you are using Next.js 15 and React 19        \u2502"), warn("\u2502 Please read our compatibility guide.                       \u2502"), warn("\u2502 https://www.sanity.io/help/react-19                        \u2502"), warn("\u2502                                                            \u2502"), warn("\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256F"));
    }
  }
  if (initNext) {
    const useTypeScript2 = unattended ? !0 : await promptForTypeScript(prompt2);
    trace.log({ step: "useTypeScript", selectedOption: useTypeScript2 ? "yes" : "no" });
    const fileExtension = useTypeScript2 ? "ts" : "js", embeddedStudio = unattended ? !0 : await promptForEmbeddedStudio(prompt2);
    let hasSrcFolder = !1;
    if (embeddedStudio) {
      const appDir = "app";
      let srcPath = path__default.default.join(workDir, appDir);
      fs$1.existsSync(srcPath) || (srcPath = path__default.default.join(workDir, "src", appDir), hasSrcFolder = !0, fs$1.existsSync(srcPath) || await fs__default.default.mkdir(srcPath, { recursive: !0 }).catch(() => loadEnv.debug("Error creating folder %s", srcPath)));
      const studioPath = unattended ? "/studio" : await promptForStudioPath(prompt2), embeddedStudioRouteFilePath = path__default.default.join(
        srcPath,
        `${studioPath}/`,
        `[[...tool]]/page.${fileExtension}x`
      );
      await writeOrOverwrite(
        embeddedStudioRouteFilePath,
        sanityStudioTemplate.replace(
          ":configPath:",
          new Array(countNestedFolders(embeddedStudioRouteFilePath.slice(workDir.length))).join("../").concat("sanity.config")
        )
      );
      const sanityConfigPath = path__default.default.join(workDir, `sanity.config.${fileExtension}`);
      await writeOrOverwrite(
        sanityConfigPath,
        sanityConfigTemplate(hasSrcFolder).replace(":route:", embeddedStudioRouteFilePath.slice(workDir.length).replace("src/", "")).replace(":basePath:", studioPath)
      );
    }
    const sanityCliPath = path__default.default.join(workDir, `sanity.cli.${fileExtension}`);
    await writeOrOverwrite(sanityCliPath, sanityCliTemplate);
    const writeSourceFiles = async (files, folderPath, srcFolderPrefix) => {
      for (const [filePath, content] of Object.entries(files))
        filePath.includes(".") && typeof content == "string" ? await writeOrOverwrite(
          path__default.default.join(
            workDir,
            srcFolderPrefix ? "src" : "",
            "sanity",
            folderPath || "",
            `${filePath}${fileExtension}`
          ),
          content
        ) : (await fs__default.default.mkdir(path__default.default.join(workDir, srcFolderPrefix ? "src" : "", "sanity", filePath), {
          recursive: !0
        }), typeof content == "object" && await writeSourceFiles(content, filePath, srcFolderPrefix));
    }, templateToUse = unattended ? "clean" : await promptForNextTemplate(prompt2);
    if (await writeSourceFiles(sanityFolder(useTypeScript2, templateToUse), void 0, hasSrcFolder), (unattended || await promptForAppendEnv(prompt2, envFilename)) && await createOrAppendEnvVars(envFilename, detectedFramework, { log: !0 }), embeddedStudio) {
      const nextjsLocalDevOrigin = "http://localhost:3000";
      (await apiClient({ api: { projectId } }).request({
        method: "GET",
        uri: "/cors"
      })).some(
        (item) => item.origin === nextjsLocalDevOrigin
      ) || await apiClient({ api: { projectId } }).request({
        method: "POST",
        url: "/cors",
        body: { origin: nextjsLocalDevOrigin, allowCredentials: !0 },
        maxRedirects: 0
      }).then((res) => {
        print(
          res.id ? `Added ${nextjsLocalDevOrigin} to CORS origins` : `Failed to add ${nextjsLocalDevOrigin} to CORS origins`
        );
      }).catch((error2) => {
        print(`Failed to add ${nextjsLocalDevOrigin} to CORS origins`, error2);
      });
    }
    const { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
    trace.log({ step: "selectPackageManager", selectedOption: chosen });
    const packages = ["@sanity/vision@3", "sanity@3", "@sanity/image-url@1", "styled-components@6"];
    templateToUse === "blog" && packages.push("@sanity/icons"), await installNewPackages(
      {
        packageManager: chosen,
        packages
      },
      {
        output: context.output,
        workDir
      }
    );
    const execOptions = {
      encoding: "utf8",
      env: getPartialEnvWithNpmPath(workDir),
      cwd: workDir,
      stdio: "inherit"
    };
    chosen === "npm" ? await execa("npm", ["install", "--legacy-peer-deps", "next-sanity@9"], execOptions) : chosen === "yarn" ? await execa("npx", ["install-peerdeps", "--yarn", "next-sanity@9"], execOptions) : chosen === "pnpm" && await execa("pnpm", ["install", "next-sanity@9"], execOptions), print(
      `
${chalk2.green("Success!")} Your Sanity configuration files has been added to this project`
    );
    return;
  }
  function countNestedFolders(path2) {
    const separator2 = path2.includes("\\") ? "\\" : "/";
    return path2.split(separator2).filter(Boolean).length;
  }
  async function writeOrOverwrite(filePath, content) {
    if (fs$1.existsSync(filePath) && !await prompt2.single({
      type: "confirm",
      message: `File ${chalk2.yellow(
        filePath.replace(workDir, "")
      )} already exists. Do you want to overwrite it?`,
      default: !1
    }))
      return;
    const folderPath = path__default.default.dirname(filePath);
    await fs__default.default.mkdir(folderPath, { recursive: !0 }).catch(() => loadEnv.debug("Error creating folder %s", folderPath)), await fs__default.default.writeFile(filePath, content, {
      encoding: "utf8"
    });
  }
  if (env) {
    await createOrAppendEnvVars(envFilename, detectedFramework);
    return;
  }
  const templateName = await selectProjectTemplate();
  trace.log({ step: "selectProjectTemplate", selectedOption: templateName });
  const template = templates[templateName];
  if (!remoteTemplateInfo && !template)
    throw new Error(`Template "${templateName}" not found`);
  let useTypeScript = !0;
  if (!remoteTemplateInfo && template) {
    const typescriptOnly = template.typescriptOnly === !0;
    !typescriptOnly && typeof cliFlags.typescript == "boolean" ? useTypeScript = cliFlags.typescript : !typescriptOnly && !unattended && (useTypeScript = await promptForTypeScript(prompt2), trace.log({ step: "useTypeScript", selectedOption: useTypeScript ? "yes" : "no" }));
  }
  let autoUpdates = !0;
  typeof cliFlags["auto-updates"] == "boolean" && (autoUpdates = cliFlags["auto-updates"]);
  const shouldImport = !unattended && template?.datasetUrl && await promptForDatasetImport(template.importPrompt);
  trace.log({ step: "importTemplateDataset", selectedOption: shouldImport ? "yes" : "no" });
  const [_, bootstrapPromise] = await Promise.allSettled([
    updateProjectCliInitializedMetadata(),
    bootstrapTemplate()
  ]);
  if (bootstrapPromise.status === "rejected" && bootstrapPromise.reason instanceof Error)
    throw bootstrapPromise.reason;
  let pkgManager;
  if (packageManager && ALLOWED_PACKAGE_MANAGERS.includes(packageManager) ? pkgManager = packageManager : (pkgManager = (await getPackageManagerChoice(outputPath, {
    prompt: prompt2,
    interactive: unattended ? !1 : isInteractive$1
  })).chosen, packageManager && (output.warn(
    chalk2.yellow(
      `Given package manager "${packageManager}" is not supported. Supported package managers are ${allowedPackageManagersString}.`
    )
  ), output.print(`Using ${pkgManager} as package manager`))), trace.log({ step: "selectPackageManager", selectedOption: pkgManager }), await installDeclaredPackages(outputPath, pkgManager, context), useGit && tryGitInit(outputPath, typeof commitMessage == "string" ? commitMessage : void 0), shouldImport) {
    const importCommand = getImportCommand(outputPath);
    await doDatasetImport({
      projectId,
      outputPath,
      importCommand,
      template,
      datasetName,
      context
    }), print(""), print("If you want to delete the imported data, use"), print(`  ${chalk2.cyan(`npx sanity dataset delete ${datasetName}`)}`), print("and create a new clean dataset with"), print(`  ${chalk2.cyan("npx sanity dataset create <name>")}
`);
  }
  const devCommand = {
    yarn: "yarn dev",
    npm: "npm run dev",
    pnpm: "pnpm dev",
    bun: "bun dev",
    manual: "npm run dev"
  }[pkgManager];
  outputPath === process.cwd() ? (print(`
${chalk2.green("Success!")} Now, use this command to continue:
`), print(`${chalk2.cyan(devCommand)} - to run Sanity Studio
`)) : (print(`
${chalk2.green("Success!")} Now, use these commands to continue:
`), print(`First: ${chalk2.cyan(`cd ${outputPath}`)} - to enter project\u2019s directory`), print(`Then: ${chalk2.cyan(devCommand)} - to run Sanity Studio
`)), print("Other helpful commands"), print("npx sanity docs - to open the documentation in a browser"), print("npx sanity manage - to open the project settings in a browser"), print("npx sanity help - to explore the CLI manual");
  const sendInvite = isFirstProject && await prompt2.single({
    type: "confirm",
    message: "We have an excellent developer community, would you like us to send you an invitation to join?",
    default: !0
  });
  sendInvite && (trace.log({ step: "sendCommunityInvite", selectedOption: sendInvite ? "yes" : "no" }), apiClient({ requireProject: !1 }).request({
    uri: "/invitations/community",
    method: "POST"
  }).catch(lodashExports.noop)), trace.complete();
  async function getOrCreateUser() {
    warn("No authentication credentials found in your Sanity config"), print("");
    const { extOptions, ...otherArgs } = args, loginArgs = { ...otherArgs, extOptions: {} };
    await login(loginArgs, { ...context, telemetry: trace.newContext("login") });
  }
  async function getProjectDetails() {
    if (flags.quickstart) {
      loadEnv.debug("Fetching project details from Journey API");
      const data = await journeyConfig.fetchJourneyConfig(apiClient, flags.quickstart);
      return trace.log({
        step: "fetchJourneyConfig",
        projectId: data.projectId,
        datasetName: data.datasetName,
        displayName: data.displayName,
        isFirstProject: data.isFirstProject
      }), data;
    }
    loadEnv.debug("Prompting user to select or create a project");
    const project = await getOrCreateProject();
    loadEnv.debug(`Project with name ${project.displayName} selected`), loadEnv.debug("Prompting user to select or create a dataset");
    const dataset = await getOrCreateDataset({
      projectId: project.projectId,
      displayName: project.displayName,
      dataset: flags.dataset,
      aclMode: flags.visibility,
      defaultConfig: flags["dataset-default"]
    });
    return loadEnv.debug(`Dataset with name ${dataset.datasetName} selected`), trace.log({
      step: "createOrSelectDataset",
      selectedOption: dataset.userAction,
      datasetName: dataset.datasetName,
      visibility: flags.visibility
    }), {
      projectId: project.projectId,
      displayName: project.displayName,
      isFirstProject: project.isFirstProject,
      datasetName: dataset.datasetName
    };
  }
  async function getOrCreateProject() {
    const client2 = apiClient({ requireUser: !0, requireProject: !1 });
    let projects, organizations;
    try {
      const [allProjects, allOrgs] = await Promise.all([
        client2.projects.list({ includeMembers: !1 }),
        client2.request({ uri: "/organizations" })
      ]);
      projects = allProjects.sort((a, b) => b.createdAt.localeCompare(a.createdAt)), organizations = allOrgs;
    } catch (err) {
      if (unattended && flags.project)
        return {
          projectId: flags.project,
          displayName: "Unknown project",
          isFirstProject: !1,
          userAction: "select"
        };
      throw new Error(`Failed to communicate with the Sanity API:
${err.message}`);
    }
    if (projects.length === 0 && unattended)
      throw new Error("No projects found for current user");
    if (flags.project) {
      const project = projects.find((proj) => proj.id === flags.project);
      if (!project && !unattended)
        throw new Error(
          `Given project ID (${flags.project}) not found, or you do not have access to it`
        );
      return {
        projectId: flags.project,
        displayName: project ? project.displayName : "Unknown project",
        isFirstProject: !1,
        userAction: "select"
      };
    }
    if (flags.organization) {
      if (!(organizations.find((org) => org.id === flags.organization) || organizations.find((org) => org.slug === flags.organization)))
        throw new Error(
          `Given organization ID (${flags.organization}) not found, or you do not have access to it`
        );
      if (!await hasProjectAttachGrant(flags.organization))
        throw new Error(
          "You lack the necessary permissions to attach a project to this organization"
        );
    }
    const isUsersFirstProject = projects.length === 0;
    if (isUsersFirstProject || intendedCoupon) {
      loadEnv.debug(
        isUsersFirstProject ? "No projects found for user, prompting for name" : "Using a coupon - skipping project selection"
      );
      const projectName = await prompt2.single({ type: "input", message: "Project name:" });
      return createProject(apiClient, {
        displayName: projectName,
        organizationId: await getOrganizationId(organizations),
        subscription: selectedPlan ? { planId: selectedPlan } : void 0,
        metadata: { coupon: intendedCoupon }
      }).then((response) => ({
        ...response,
        isFirstProject: isUsersFirstProject,
        userAction: "create",
        coupon: intendedCoupon
      }));
    }
    loadEnv.debug(`User has ${projects.length} project(s) already, showing list of choices`);
    const projectChoices = projects.map((project) => ({
      value: project.id,
      name: `${project.displayName} [${project.id}]`
    })), selected = await prompt2.single({
      message: "Create a new project or select an existing one",
      type: "list",
      choices: [
        { value: "new", name: "Create new project" },
        new prompt2.Separator(),
        ...projectChoices
      ]
    });
    return selected === "new" ? (loadEnv.debug("User wants to create a new project, prompting for name"), createProject(apiClient, {
      displayName: await prompt2.single({
        type: "input",
        message: "Your project name:",
        default: "My Sanity Project"
      }),
      organizationId: await getOrganizationId(organizations),
      subscription: selectedPlan ? { planId: selectedPlan } : void 0,
      metadata: { coupon: intendedCoupon }
    }).then((response) => ({
      ...response,
      isFirstProject: isUsersFirstProject,
      userAction: "create"
    }))) : (loadEnv.debug(`Returning selected project (${selected})`), {
      projectId: selected,
      displayName: projects.find((proj) => proj.id === selected)?.displayName || "",
      isFirstProject: isUsersFirstProject,
      userAction: "select"
    });
  }
  async function getOrCreateDataset(opts) {
    if (opts.dataset && (isCI || unattended))
      return { datasetName: opts.dataset, userAction: "none" };
    const client2 = apiClient({ api: { projectId: opts.projectId } }), [datasets, projectFeatures] = await Promise.all([
      client2.datasets.list(),
      client2.request({ uri: "/features" })
    ]), privateDatasetsAllowed = projectFeatures.includes("privateDataset"), allowedModes = privateDatasetsAllowed ? ["public", "private"] : ["public"];
    if (opts.aclMode && !allowedModes.includes(opts.aclMode))
      throw new Error(`Visibility mode "${opts.aclMode}" not allowed`);
    const getAclMode = async () => opts.aclMode ? opts.aclMode : unattended || !privateDatasetsAllowed || defaultConfig ? "public" : privateDatasetsAllowed ? await promptForAclMode(prompt2, output) : "public";
    if (opts.dataset) {
      if (loadEnv.debug("User has specified dataset through a flag (%s)", opts.dataset), !datasets.find((ds) => ds.name === opts.dataset)) {
        loadEnv.debug("Specified dataset not found, creating it");
        const aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
        await client2.datasets.create(opts.dataset, { aclMode }), spinner.succeed();
      }
      return { datasetName: opts.dataset, userAction: "none" };
    }
    const datasetInfo = `Your content will be stored in a dataset that can be public or private, depending on
whether you want to query your content with or without authentication.
The default dataset configuration has a public dataset named "production".`;
    if (datasets.length === 0) {
      loadEnv.debug("No datasets found for project, prompting for name"), showDefaultConfigPrompt && (output.print(datasetInfo), defaultConfig = await promptForDefaultConfig(prompt2));
      const name = defaultConfig ? "production" : await promptForDatasetName(prompt2, {
        message: "Name of your first dataset:"
      }), aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
      return await client2.datasets.create(name, { aclMode }), spinner.succeed(), { datasetName: name, userAction: "create" };
    }
    loadEnv.debug(`User has ${datasets.length} dataset(s) already, showing list of choices`);
    const datasetChoices = datasets.map((dataset) => ({ value: dataset.name })), selected = await prompt2.single({
      message: "Select dataset to use",
      type: "list",
      choices: [
        { value: "new", name: "Create new dataset" },
        new prompt2.Separator(),
        ...datasetChoices
      ]
    });
    if (selected === "new") {
      const existingDatasetNames = datasets.map((ds) => ds.name);
      loadEnv.debug("User wants to create a new dataset, prompting for name"), showDefaultConfigPrompt && !existingDatasetNames.includes("production") && (output.print(datasetInfo), defaultConfig = await promptForDefaultConfig(prompt2));
      const newDatasetName = defaultConfig ? "production" : await promptForDatasetName(
        prompt2,
        {
          message: "Dataset name:"
        },
        existingDatasetNames
      ), aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
      return await client2.datasets.create(newDatasetName, { aclMode }), spinner.succeed(), { datasetName: newDatasetName, userAction: "create" };
    }
    return loadEnv.debug(`Returning selected dataset (${selected})`), { datasetName: selected, userAction: "select" };
  }
  function promptForDatasetImport(message) {
    return prompt2.single({
      type: "confirm",
      message: message || "This template includes a sample dataset, would you like to use it?",
      default: !0
    });
  }
  function selectProjectTemplate() {
    return flags.quickstart ? "quickstart" : (unattended || flags.template ? flags.template || "clean" : null) || prompt2.single({
      message: "Select project template",
      type: "list",
      choices: [
        {
          value: "clean",
          name: "Clean project with no predefined schema types"
        },
        {
          value: "blog",
          name: "Blog (schema)"
        },
        {
          value: "shopify",
          name: "E-commerce (Shopify)"
        },
        {
          value: "moviedb",
          name: "Movie project (schema + sample data)"
        }
      ]
    });
  }
  async function updateProjectCliInitializedMetadata() {
    try {
      const client2 = apiClient({ api: { projectId } });
      (await client2.request({ uri: `/projects/${projectId}` }))?.metadata?.cliInitializedAt || await client2.request({
        method: "PATCH",
        uri: `/projects/${projectId}`,
        body: { metadata: { cliInitializedAt: (/* @__PURE__ */ new Date()).toISOString() } }
      });
    } catch {
      loadEnv.debug("Failed to update cliInitializedAt metadata");
    }
  }
  async function bootstrapTemplate() {
    const bootstrapVariables = {
      autoUpdates,
      dataset: datasetName,
      projectId,
      projectName: displayName || answers.projectName
    };
    return remoteTemplateInfo ? bootstrapRemoteTemplate(
      {
        outputPath,
        packageName: sluggedName,
        repoInfo: remoteTemplateInfo,
        bearerToken: cliFlags["template-token"],
        variables: bootstrapVariables
      },
      context
    ) : bootstrapLocalTemplate(
      {
        outputPath,
        packageName: sluggedName,
        templateName,
        schemaUrl,
        useTypeScript,
        variables: bootstrapVariables
      },
      context
    );
  }
  async function getProjectInfo() {
    const specifiedPath = flags["output-path"] && path__default.default.resolve(flags["output-path"]);
    if (unattended || specifiedPath || env || initFramework)
      return {
        ...defaults2,
        outputPath: specifiedPath || workDir
      };
    const workDirIsEmpty = (await fs__default.default.readdir(workDir)).length === 0, projectOutputPath = await prompt2.single({
      type: "input",
      message: "Project output path:",
      default: workDirIsEmpty ? workDir : path__default.default.join(workDir, sluggedName),
      validate: validateEmptyPath,
      filter: absolutify
    });
    return {
      ...defaults2,
      outputPath: projectOutputPath
    };
  }
  async function prepareFlags() {
    const createProjectName = cliFlags["create-project"];
    if ((cliFlags.dataset || cliFlags.visibility || cliFlags["dataset-default"] || unattended) && (showDefaultConfigPrompt = !1), cliFlags.project && createProjectName)
      throw new Error(
        "Both `--project` and `--create-project` specified, only a single is supported"
      );
    if (cliFlags.project && cliFlags.organization)
      throw new Error(
        "You have specified both a project and an organization. To move a project to an organization please visit https://www.sanity.io/manage"
      );
    if (cliFlags.quickstart && (cliFlags.project || cliFlags.dataset || cliFlags.visibility || cliFlags.template)) {
      const usedDisallowedStr = ["project", "dataset", "visibility", "template"].filter((flag) => cliFlags[flag]).map((flag) => `--${flag}`).join(", ");
      throw new Error(`\`--quickstart\` cannot be combined with ${usedDisallowedStr}`);
    }
    if (createProjectName === !0)
      throw new Error("Please specify a project name (`--create-project <name>`)");
    if (typeof createProjectName == "string" && createProjectName.trim().length === 0)
      throw new Error("Please specify a project name (`--create-project <name>`)");
    if (unattended && (loadEnv.debug("Unattended mode, validating required options"), ["dataset", "output-path"].forEach((flag) => {
      if (!cliFlags[flag])
        throw new Error(`\`--${flag}\` must be specified in unattended mode`);
    }), !cliFlags.project && !createProjectName))
      throw new Error(
        "`--project <id>` or `--create-project <name>` must be specified in unattended mode"
      );
    if (createProjectName) {
      loadEnv.debug("--create-project specified, creating a new project");
      const createdProject = await createProject(apiClient, {
        displayName: createProjectName.trim(),
        organizationId: cliFlags.organization || void 0,
        subscription: selectedPlan ? { planId: selectedPlan } : void 0,
        metadata: { coupon: intendedCoupon }
      });
      if (loadEnv.debug("Project with ID %s created", createdProject.projectId), cliFlags.dataset) {
        loadEnv.debug("--dataset specified, creating dataset (%s)", cliFlags.dataset);
        const client2 = apiClient({ api: { projectId: createdProject.projectId } }), spinner = context.output.spinner("Creating dataset").start(), createBody = cliFlags.visibility ? { aclMode: cliFlags.visibility } : {};
        await client2.datasets.create(cliFlags.dataset, createBody), spinner.succeed();
      }
      const newFlags = { ...cliFlags, project: createdProject.projectId };
      return delete newFlags["create-project"], newFlags;
    }
    return cliFlags;
  }
  async function getOrganizationId(organizations) {
    let organizationId = flags.organization;
    if (unattended)
      return organizationId || void 0;
    if (organizations.length > 0 && !organizationId) {
      loadEnv.debug(`User has ${organizations.length} organization(s), checking attach access`);
      const withGrant = await getOrganizationsWithAttachGrant(organizations);
      if (withGrant.length === 0) {
        loadEnv.debug("User lacks project attach grant in all organizations, not prompting");
        return;
      }
      loadEnv.debug("User has attach access to %d organizations, prompting.", withGrant.length);
      const organizationChoices = [
        { value: "none", name: "None" },
        new prompt2.Separator(),
        ...withGrant.map((organization) => ({
          value: organization.id,
          name: `${organization.name} [${organization.id}]`
        }))
      ], chosenOrg = await prompt2.single({
        message: "Select organization to attach project to",
        type: "list",
        choices: organizationChoices
      });
      chosenOrg && chosenOrg !== "none" && (organizationId = chosenOrg);
    } else organizationId ? loadEnv.debug("User has defined organization flag explicitly (%s)", organizationId) : organizations.length === 0 && loadEnv.debug("User has no organizations, skipping selection prompt");
    return organizationId || void 0;
  }
  async function hasProjectAttachGrant(organizationId) {
    const requiredGrantGroup = "sanity.organization.projects", requiredGrant = "attach";
    return ((await apiClient({ requireProject: !1, requireUser: !0 }).clone().config({ apiVersion: "v2021-06-07" }).request({ uri: `organizations/${organizationId}/grants` }))[requiredGrantGroup] || []).some(
      (resource) => resource.grants && resource.grants.some((grant) => grant.name === requiredGrant)
    );
  }
  function getOrganizationsWithAttachGrant(organizations) {
    return pFilter(organizations, (org) => hasProjectAttachGrant(org.id), { concurrency: 3 });
  }
  async function createOrAppendEnvVars(filename, framework, options2) {
    const envVars = {
      PROJECT_ID: projectId,
      DATASET: datasetName
    };
    try {
      framework && framework.envPrefix && !options2?.log && print(
        `
Detected framework ${chalk2.blue(framework?.name)}, using prefix '${framework.envPrefix}'`
      ), await writeEnvVarsToFile(filename, envVars, {
        framework,
        outputPath,
        log: options2?.log
      });
    } catch (err) {
      throw print(err), new Error("An error occurred while creating .env", { cause: err });
    }
  }
  async function writeEnvVarsToFile(filename, envVars, options2) {
    const envPrefix = options2.framework?.envPrefix || "", keyPrefix = envPrefix.includes("SANITY") ? envPrefix : `${envPrefix}SANITY_`, fileOutputPath = path__default.default.join(options2.outputPath, filename);
    for (const key2 of Object.keys(envVars))
      envVars[`${keyPrefix}${key2}`] = envVars[key2], delete envVars[key2];
    await fs__default.default.mkdir(options2.outputPath, { recursive: !0 }).catch(() => loadEnv.debug("Error creating folder %s", options2.outputPath));
    const existingEnv = await fs__default.default.readFile(fileOutputPath, { encoding: "utf8" }).catch((err) => err.code === "ENOENT" ? "" : Promise.reject(err)), updatedEnv = parseAndUpdateEnvVars(existingEnv, envVars, {
      log: options2.log
    }), warningComment = [
      "# Warning: Do not add secrets (API keys and similar) to this file, as it source controlled!",
      "# Use `.env.local` for any secrets, and ensure it is not added to source control"
    ].join(`
`);
    if (filename !== ".env.local" && !existingEnv.includes(warningComment)) {
      await fs__default.default.writeFile(fileOutputPath, `${warningComment}

${updatedEnv}`, {
        encoding: "utf8"
      });
      return;
    }
    await fs__default.default.writeFile(fileOutputPath, updatedEnv, {
      encoding: "utf8"
    }), options2.log || print(`
${chalk2.green("Success!")} Environment variables written to ${fileOutputPath}`);
  }
  function parseAndUpdateEnvVars(fileContents, envVars, options2) {
    const existingKeys = loadEnv.dotenv.parse(fileContents), updatedKeys = {};
    for (const [key2, value] of Object.entries(envVars)) {
      if (!existingKeys[key2]) {
        updatedKeys[key2] = value, options2?.log || print(`Appended ${key2}="${envVars[key2]}"`);
        continue;
      }
      options2?.log || print(`Found existing ${key2}, replacing value.`), updatedKeys[key2] = value;
    }
    let updatedEnv = fileContents;
    for (const [key2, value] of Object.entries(updatedKeys))
      if (existingKeys[key2]) {
        const existingValue = existingKeys[key2];
        updatedEnv = updatedEnv.split(`
`).map((line3) => !line3.trim().startsWith("#") && // ignore comments
        new RegExp(`(^\\s*${key2})((: )|( *=))`).test(line3) ? line3.replace(existingValue, value) : line3).join(`
`);
      } else
        updatedEnv = updatedEnv.trim().concat(`
${key2}="${value}"`);
    return updatedEnv.concat(fileContents === "" ? `
` : "");
  }
}
function doDatasetImport(options2) {
  const { outputPath, importCommand, template, datasetName, projectId, context } = options2;
  if (!template.datasetUrl)
    return Promise.resolve(void 0);
  if (!importCommand)
    throw new Error("Failed to find `sanity dataset import` command");
  const commandArgs = {
    argv: [template.datasetUrl, datasetName],
    argsWithoutOptions: [template.datasetUrl, datasetName],
    extOptions: {},
    groupOrCommand: "import",
    extraArguments: []
  }, configPath = context.cliConfigPath || path__default.default.join(outputPath, "sanity.cli.js"), apiClient = getClientWrapper({ projectId, dataset: datasetName }, configPath), commandContext = {
    ...context,
    apiClient,
    workDir: outputPath,
    fromInitCommand: !0
  };
  return importCommand.action(commandArgs, commandContext);
}
async function getPlanFromCoupon(apiClient, couponCode) {
  const planId = (await apiClient({
    requireUser: !1,
    requireProject: !1
  }).request({
    method: "GET",
    uri: `plans/coupon/${couponCode}`
  }))[0].id;
  if (!planId)
    throw new Error("Unable to find a plan from coupon code");
  return planId;
}
async function getUserData(apiClient) {
  return await apiClient({
    requireUser: !0,
    requireProject: !1
  }).request({
    method: "GET",
    uri: "users/me"
  });
}
async function getPlanFromId(apiClient, planId) {
  const id = (await apiClient({
    requireUser: !1,
    requireProject: !1
  }).request({
    method: "GET",
    uri: `plans/${planId}`
  }))[0].id;
  if (!id)
    throw new Error(`Unable to find a plan with id ${planId}`);
  return id;
}
function getImportCommand(outputPath, studioVersion) {
  {
    const pkgPath2 = resolveFrom.silent(outputPath, "sanity/_internal");
    if (!pkgPath2)
      throw new Error("Failed to resolve `sanity` module - problem with dependency installation?");
    loadEnv.debug("`sanity` module path resolved to %s (from %s)", pkgPath2, outputPath);
    const cliInternals = getCliConfig.dynamicRequire(pkgPath2);
    if (!("cliProjectCommands" in cliInternals))
      throw new Error("Incorrect version of the `sanity` module installed");
    return cliInternals.cliProjectCommands.commands.find(
      (cmd) => !isCommandGroup(cmd) && cmd.name === "import" && cmd.group === "dataset"
    );
  }
}
const helpText$7 = `
Options
  -y, --yes Use unattended mode, accepting defaults and using only flags for choices
  --project <projectId> Project ID to use for the studio
  --organization <organizationId> Organization ID to use for the project
  --dataset <dataset> Dataset name for the studio
  --dataset-default Set up a project with a public dataset named "production"
  --output-path <path> Path to write studio project to
  --template <template> Project template to use [default: "clean"]
  --bare Skip the Studio initialization and only print the selected project ID and dataset name to stdout
  --env <filename> Write environment variables to file [default: ".env"]
  --provider <provider> Login provider to use
  --visibility <mode> Visibility mode for dataset (public/private)
  --create-project <name> Create a new project with the given name
  --project-plan <name> Optionally select a plan for a new project
  --coupon <name> Optionally select a coupon for a new project (cannot be used with --project-plan)
  --no-typescript Do not use TypeScript for template files
  --package-manager <name> Specify which package manager to use [allowed: ${allowedPackageManagersString}]
  --no-auto-updates Disable auto updates of studio versions

Examples
  # Initialize a new project, prompt for required information along the way
  sanity init

  # Initialize a new project with a public dataset named "production"
  sanity init --dataset-default

  # Initialize a project with the given project ID and dataset to the given path
  sanity init -y --project abc123 --dataset production --output-path ~/myproj

  # Initialize a project with the given project ID and dataset using the moviedb
  # template to the given path
  sanity init -y --project abc123 --dataset staging --template moviedb --output-path .

  # Create a brand new project with name "Movies Unlimited"
  sanity init -y \\
    --create-project "Movies Unlimited" \\
    --dataset moviedb \\
    --visibility private \\
    --template moviedb \\
    --output-path /Users/espenh/movies-unlimited
`, initCommand = {
  name: "init",
  signature: "",
  description: "Initializes a new Sanity Studio and/or project",
  helpText: helpText$7,
  action: async (args, context) => {
    const [type2] = args.argsWithoutOptions;
    if (type2)
      return Promise.reject(new Error(`Unknown init type "${type2}"`));
    const detectedFramework = await distExports.detectFrameworkRecord({
      fs: new distExports.LocalFileSystemDetector(process.cwd()),
      frameworkList: frameworksExports.frameworks
    });
    return initSanity(args, {
      ...context,
      detectedFramework
    });
  }
}, installCommand = {
  name: "install",
  signature: "",
  helpText: "",
  description: "Installs dependencies for Sanity Studio project",
  action: async (args, context) => {
    const { workDir, prompt: prompt2, sanityMajorVersion } = context, packages = args.argsWithoutOptions;
    if (packages.length > 0 && sanityMajorVersion === 2)
      throw new Error("Re-run this command with `@sanity/core` installed");
    const pkgManager = await getPackageManagerChoice(workDir, { prompt: prompt2 });
    packages.length > 0 ? await installNewPackages(
      { packageManager: pkgManager.chosen, packages: args.argsWithoutOptions },
      context
    ) : await installDeclaredPackages(workDir, pkgManager.chosen, context);
  }
}, learnCommand = {
  name: "learn",
  helpText: "",
  signature: "learn",
  description: "Opens Sanity Learn in your web browser",
  async action(args, context) {
    const { output } = context, { print } = output, url = "https://www.sanity.io/learn";
    print(`Opening ${url}`), await open(url);
  }
}, helpText$6 = `
Options
  --sso <slug> Log in using Single Sign On, using the given slug
  --provider <providerId> Authenticate against a specific provider
  --no-open Do not open a browser window to log in, only print URL

Examples
  # Log in using default settings
  sanity login

  # Log in using Single Sign-On with the "my-organization" slug
  sanity login --sso my-organization

  # Login with GitHub provider, but do not open a browser window automatically
  sanity login --provider github --no-open
`, loginCommand = {
  name: "login",
  signature: "[--sso <slug>] [--provider <providerId>] [--no-open]",
  helpText: helpText$6,
  description: "Authenticates the CLI for access to Sanity projects",
  action: login
}, helpText$5 = `
Examples
  # Log out of the CLI
  sanity logout
`, logoutCommand = {
  name: "logout",
  helpText: helpText$5,
  signature: "logout",
  description: "Logs out the CLI from the current user session",
  async action(args, { output, apiClient }) {
    const cfg = getUserConfig();
    if (!cfg.get("authToken")) {
      output.print(chalk__default.default.red("No login credentials found"));
      return;
    }
    const client2 = apiClient({ requireUser: !0, requireProject: !1 });
    try {
      await client2.request({ uri: "/auth/logout", method: "POST" });
    } catch (err) {
      if ((err && err.response && err.response.statusCode) !== 401) {
        output.error(chalk__default.default.red(`Failed to communicate with the Sanity API:
${err.message}`));
        return;
      }
    }
    cfg.delete("authType"), cfg.delete("authToken"), cfg.delete(TELEMETRY_CONSENT_CONFIG_KEY), output.success("Logged out");
  }
}, manageCommand = {
  name: "manage",
  signature: "manage",
  helpText: "",
  description: "Opens project management interface in your web browser",
  async action(args, context) {
    const { output, cliConfig } = context, { print } = output, projectId = cliConfig?.api?.projectId, url = projectId ? `https://www.sanity.io/manage/project/${projectId}` : "https://www.sanity.io/manage/";
    print(`Opening ${url}`), await open(url);
  }
}, headings = ["id", "members", "name", "url", "created"], helpText$4 = `
Options
  --sort <field> Sort output by specified column
  --order <asc/desc> Sort output ascending/descending

Examples
  # List projects
  sanity projects list

  # List projects sorted by member count, ascending
  sanity projects list --sort=members --order=asc
`, defaultFlags = {
  sort: "created",
  order: "desc"
}, listProjectsCommand = {
  name: "list",
  group: "projects",
  signature: "",
  helpText: helpText$4,
  description: "Lists projects connected to your user",
  action: async (args, context) => {
    const { apiClient, output, chalk: chalk2 } = context, flags = { ...defaultFlags, ...args.extOptions }, projects = await apiClient({
      requireUser: !0,
      requireProject: !1
    }).projects.list(), ordered = lodashExports.sortBy(
      projects.map(({ displayName, id, members = [], createdAt }) => {
        const manage = `https://www.sanity.io/manage/project/${id}`;
        return [id, members.length, displayName, manage, createdAt].map(String);
      }),
      [headings.indexOf(flags.sort)]
    ), rows = flags.order === "asc" ? ordered : ordered.reverse(), maxWidths = rows.reduce(
      (max2, row) => row.map((current, index) => Math.max(lodashExports.size(current), max2[index])),
      headings.map((str2) => lodashExports.size(str2))
    ), printRow = (row) => row.map((col, i) => `${col}`.padEnd(maxWidths[i])).join("   ");
    output.print(chalk2.cyan(printRow(headings))), rows.forEach((row) => output.print(printRow(row)));
  }
}, projectGroup = {
  name: "projects",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Lists all projects associated with your logged-in account"
}, helpText$3 = `
Examples
  # Check telemetry consent status for your logged in user
  sanity telemetry status
`;
function telemetryStatusMessage(status, { chalk: chalk2 }) {
  switch (status) {
    case "granted":
      return `Status: ${chalk2.green("Enabled")}`;
    case "denied":
      return `Status: ${chalk2.red("Disabled")}`;
    case "unset":
      return `Status: ${chalk2.yellow("Not set")}`;
    default:
      return "";
  }
}
function telemetryLearnMoreMessage(status) {
  const url = "https://www.sanity.io/telemetry";
  switch (status) {
    case "granted":
      return `Learn more about the data being collected here:
${url}`;
    default:
      return `Learn more here:
${url}`;
  }
}
const telemetryStatusCommand = {
  name: "status",
  group: "telemetry",
  helpText: helpText$3,
  signature: "",
  description: "Check telemetry consent status for your logged in user",
  action: async (_, context) => {
    const { chalk: chalk2, output } = context, { status, reason } = await resolveConsent({ env: process.env });
    switch (!0) {
      case (status === "undetermined" && reason === "unauthenticated"):
        output.print("You need to log in first to see telemetry status.");
        break;
      case (status === "undetermined" && reason === "fetchError"):
        output.print(chalk2.yellow("Could not fetch telemetry consent status."));
        break;
      case (status === "denied" && reason === "localOverride"):
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(
          `You've opted out of telemetry data collection.
No data will be collected from your machine.
`
        ), output.print(`Using ${chalk2.cyan("DO_NOT_TRACK")} environment variable.`);
        break;
      case status === "denied":
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(
          `You've opted out of telemetry data collection.
No data will be collected from your Sanity account.`
        );
        break;
      case status === "granted":
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(
          "Telemetry data on general usage and errors is collected to help us improve Sanity."
        );
        break;
      case status === "unset":
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(`You've not set your preference for telemetry collection.
`), output.print(`Run ${chalk2.cyan("npx sanity telemetry enable/disable")} to opt in or out.`), output.print(
          `You can also use the ${chalk2.cyan("DO_NOT_TRACK")} environment variable to opt out.`
        );
        break;
    }
    output.print(`
${telemetryLearnMoreMessage(status)}`);
  }
}, resultMessages = {
  granted: {
    success: () => "You've now enabled telemetry data collection to help us improve Sanity.",
    unchanged: () => "You've already enabled telemetry data collection to help us improve Sanity.",
    failure: (message) => message ? `Failed to enable telemetry: ${message}` : "Failed to enable telemetry"
  },
  denied: {
    success: () => `You've opted out of telemetry data collection.
No data will be collected from your Sanity account.`,
    unchanged: ({ reason }) => reason === "localOverride" ? `You've already opted out of telemetry data collection.
No data is collected from your machine.

Using DO_NOT_TRACK environment variable.` : `You've already opted out of telemetry data collection.
No data is collected from your Sanity account.`,
    failure: () => "Failed to disable telemetry"
  }
};
function createSetTelemetryConsentAction(status) {
  return async function(_, context) {
    const { apiClient, output } = context, config2 = getUserConfig(), client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }).withConfig({
      apiVersion: "2023-12-18",
      useProjectHostname: !1
    }), currentInformation = await resolveConsent({ env: process.env }), isChanged = currentInformation.status !== status;
    if (isChanged || (loadEnv.debug('Telemetry consent is already "%s"', status), output.print(`${telemetryStatusMessage(status, context)}
`), output.print(resultMessages[status].unchanged(currentInformation))), isChanged) {
      loadEnv.debug('Setting telemetry consent to "%s"', status);
      try {
        const uri = `/users/me/consents/telemetry/status/${status}`;
        loadEnv.debug("Sending telemetry consent status to %s", uri), await client2.request({
          method: "PUT",
          uri
        }), config2.delete(TELEMETRY_CONSENT_CONFIG_KEY), output.print(`${telemetryStatusMessage(status, context)}
`), output.print(resultMessages[status].success());
      } catch (err) {
        const errorMessage = resultMessages[status].failure(err.response?.body?.message);
        throw err.statusCode === 403 ? new Error(errorMessage) : (err.message = errorMessage, err);
      }
    }
    output.print(`
${telemetryLearnMoreMessage(status)}`);
  };
}
const helpText$2 = `
Examples
  # Disable telemetry for your logged in user
  sanity telemetry disable
`, disableTelemetryCommand = {
  name: "disable",
  group: "telemetry",
  helpText: helpText$2,
  signature: "",
  description: "Disable telemetry for your logged in user",
  action: createSetTelemetryConsentAction("denied")
}, helpText$1 = `
Examples
  # Enable telemetry for your logged in user
  sanity telemetry enable
`, enableTelemetryCommand = {
  name: "enable",
  group: "telemetry",
  helpText: helpText$1,
  signature: "",
  description: "Enable telemetry for your logged in user",
  action: createSetTelemetryConsentAction("granted")
}, telemetryGroup = {
  name: "telemetry",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Manages telemetry settings, opting in or out of data collection"
}, description = "Generates TypeScript types from schema types and GROQ queries", helpText = `
Sanity TypeGen (Beta)
This command is currently in beta and may undergo significant changes. Feedback is welcome!

Usage
  sanity typegen generate [options]

Options:
  --config-path <path>
    Specifies the path to the typegen configuration file. This file should be a JSON file that contains settings for the type generation process.
    Default: "sanity-typegen.json"

  --help, -h
    Displays this help message, providing information on command usage and options.

Examples:
  Generate TypeScript type definitions from a Sanity Studio schema extracted using the \`sanity schema extract\` command.
    $ sanity typegen generate

Configuration:
This command can utilize configuration settings defined in a \`sanity-typegen.json\` file. These settings include:

- "path": Specifies a glob pattern to locate your TypeScript or JavaScript files.
  Default: "./src/**/*.{ts,tsx,js,jsx}"

- "schema": Defines the path to your Sanity schema file. This file should be generated using the \`sanity schema extract\` command.
  Default: "schema.json"

- "generates": Indicates the path where the generated TypeScript type definitions will be saved.
  Default: "./sanity.types.ts"

The default configuration values listed above are used if not overridden in your \`sanity-typegen.json\` configuration file. To customize the behavior of the type generation, adjust these properties in the configuration file according to your project's needs.

Note:
- The \`sanity schema extract\` command is a prerequisite for extracting your Sanity Studio schema into a \`schema.json\` file, which is then used by the \`sanity typegen generate\` command to generate type definitions.
- While this tool is in beta, we encourage you to experiment with these configurations and provide feedback to help improve its functionality and usability.
`, generateTypegenCommand = {
  name: "generate",
  group: "typegen",
  signature: "",
  description,
  helpText,
  action: async (args, context) => (await Promise.resolve().then(function() {
    return require("./generateAction.js");
  })).default(args, context)
}, typegenGroup = {
  name: "typegen",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Beta: Generate TypeScript types for schema and GROQ"
}, help = `
Shows a list of installed Sanity modules and their respective versions, and
checks the npm registry for the latest available versions.`;
var versionsCommand = {
  name: "versions",
  signature: "",
  description: "Shows installed versions of Sanity Studio and components",
  helpText: help,
  action: printVersionResultCommand
};
const baseCommands = [
  initCommand,
  loginCommand,
  logoutCommand,
  installCommand,
  versionsCommand,
  docsCommand,
  manageCommand,
  debugCommand,
  command$1,
  projectGroup,
  learnCommand,
  listProjectsCommand,
  codemodCommand,
  telemetryGroup,
  disableTelemetryCommand,
  enableTelemetryCommand,
  telemetryStatusCommand,
  generateTypegenCommand,
  typegenGroup
], copyProperty = (to, from2, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype" || property === "arguments" || property === "caller")
    return;
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property), fromDescriptor = Object.getOwnPropertyDescriptor(from2, property);
  !canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable || Object.defineProperty(to, property, fromDescriptor);
}, canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
}, changePrototype = (to, from2) => {
  const fromPrototype = Object.getPrototypeOf(from2);
  fromPrototype !== Object.getPrototypeOf(to) && Object.setPrototypeOf(to, fromPrototype);
}, wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`, toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), changeToString = (to, from2, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `, newToString = wrappedToString.bind(null, withName, from2.toString());
  Object.defineProperty(newToString, "name", toStringName);
  const { writable, enumerable, configurable } = toStringDescriptor;
  Object.defineProperty(to, "toString", { value: newToString, writable, enumerable, configurable });
};
function mimicFunction(to, from2, { ignoreNonConfigurable = !1 } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from2))
    copyProperty(to, from2, property, ignoreNonConfigurable);
  return changePrototype(to, from2), changeToString(to, from2, name), to;
}
const calledFunctions = /* @__PURE__ */ new WeakMap(), onetime$1 = (function_, options2 = {}) => {
  if (typeof function_ != "function")
    throw new TypeError("Expected a function");
  let returnValue, callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>", onetime2 = function(...arguments_) {
    if (calledFunctions.set(onetime2, ++callCount), callCount === 1)
      returnValue = function_.apply(this, arguments_), function_ = void 0;
    else if (options2.throw === !0)
      throw new Error(`Function \`${functionName}\` can only be called once`);
    return returnValue;
  };
  return mimicFunction(onetime2, function_), calledFunctions.set(onetime2, callCount), onetime2;
};
onetime$1.callCount = (function_) => {
  if (!calledFunctions.has(function_))
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  return calledFunctions.get(function_);
};
const signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
process.platform !== "win32" && signals.push(
  "SIGALRM",
  "SIGABRT",
  "SIGVTALRM",
  "SIGXCPU",
  "SIGXFSZ",
  "SIGUSR2",
  "SIGTRAP",
  "SIGSYS",
  "SIGQUIT",
  "SIGIOT"
  // should detect profiler and enable/disable accordingly.
  // see #21
  // 'SIGPROF'
);
process.platform === "linux" && signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
const processOk = (process2) => !!process2 && typeof process2 == "object" && typeof process2.removeListener == "function" && typeof process2.emit == "function" && typeof process2.reallyExit == "function" && typeof process2.listeners == "function" && typeof process2.kill == "function" && typeof process2.pid == "number" && typeof process2.on == "function", kExitEmitter = Symbol.for("signal-exit emitter"), global = globalThis, ObjectDefineProperty = Object.defineProperty.bind(Object);
class Emitter {
  emitted = {
    afterExit: !1,
    exit: !1
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global[kExitEmitter])
      return global[kExitEmitter];
    ObjectDefineProperty(global, kExitEmitter, {
      value: this,
      writable: !1,
      enumerable: !1,
      configurable: !1
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list2 = this.listeners[ev], i = list2.indexOf(fn);
    i !== -1 && (i === 0 && list2.length === 1 ? list2.length = 0 : list2.splice(i, 1));
  }
  emit(ev, code, signal) {
    if (this.emitted[ev])
      return !1;
    this.emitted[ev] = !0;
    let ret = !1;
    for (const fn of this.listeners[ev])
      ret = fn(code, signal) === !0 || ret;
    return ev === "exit" && (ret = this.emit("afterExit", code, signal) || ret), ret;
  }
}
class SignalExitBase {
}
const signalExitWrap = (handler) => ({
  onExit(cb, opts) {
    return handler.onExit(cb, opts);
  },
  load() {
    return handler.load();
  },
  unload() {
    return handler.unload();
  }
});
class SignalExitFallback extends SignalExitBase {
  onExit() {
    return () => {
    };
  }
  load() {
  }
  unload() {
  }
}
class SignalExit extends SignalExitBase {
  // "SIGHUP" throws an `ENOSYS` error on Windows,
  // so use a supported signal instead
  /* c8 ignore start */
  #hupSig = process$1.platform === "win32" ? "SIGINT" : "SIGHUP";
  /* c8 ignore stop */
  #emitter = new Emitter();
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = !1;
  constructor(process2) {
    super(), this.#process = process2, this.#sigListeners = {};
    for (const sig of signals)
      this.#sigListeners[sig] = () => {
        const listeners = this.#process.listeners(sig);
        let { count: count2 } = this.#emitter;
        const p = process2;
        if (typeof p.__signal_exit_emitter__ == "object" && typeof p.__signal_exit_emitter__.count == "number" && (count2 += p.__signal_exit_emitter__.count), listeners.length === count2) {
          this.unload();
          const ret = this.#emitter.emit("exit", null, sig), s = sig === "SIGHUP" ? this.#hupSig : sig;
          ret || process2.kill(process2.pid, s);
        }
      };
    this.#originalProcessReallyExit = process2.reallyExit, this.#originalProcessEmit = process2.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process))
      return () => {
      };
    this.#loaded === !1 && this.load();
    const ev = opts?.alwaysLast ? "afterExit" : "exit";
    return this.#emitter.on(ev, cb), () => {
      this.#emitter.removeListener(ev, cb), this.#emitter.listeners.exit.length === 0 && this.#emitter.listeners.afterExit.length === 0 && this.unload();
    };
  }
  load() {
    if (!this.#loaded) {
      this.#loaded = !0, this.#emitter.count += 1;
      for (const sig of signals)
        try {
          const fn = this.#sigListeners[sig];
          fn && this.#process.on(sig, fn);
        } catch {
        }
      this.#process.emit = (ev, ...a) => this.#processEmit(ev, ...a), this.#process.reallyExit = (code) => this.#processReallyExit(code);
    }
  }
  unload() {
    this.#loaded && (this.#loaded = !1, signals.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener)
        throw new Error("Listener not defined for signal: " + sig);
      try {
        this.#process.removeListener(sig, listener);
      } catch {
      }
    }), this.#process.emit = this.#originalProcessEmit, this.#process.reallyExit = this.#originalProcessReallyExit, this.#emitter.count -= 1);
  }
  #processReallyExit(code) {
    return processOk(this.#process) ? (this.#process.exitCode = code || 0, this.#emitter.emit("exit", this.#process.exitCode, null), this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode)) : 0;
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === "exit" && processOk(this.#process)) {
      typeof args[0] == "number" && (this.#process.exitCode = args[0]);
      const ret = og.call(this.#process, ev, ...args);
      return this.#emitter.emit("exit", this.#process.exitCode, null), ret;
    } else
      return og.call(this.#process, ev, ...args);
  }
}
const process$1 = globalThis.process, {
  /**
   * Called when the process is exiting, whether via signal, explicit
   * exit, or running out of stuff to do.
   *
   * If the global process object is not suitable for instrumentation,
   * then this will be a no-op.
   *
   * Returns a function that may be used to unload signal-exit.
   */
  onExit,
  /**
   * Load the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  load,
  /**
   * Unload the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  unload
} = signalExitWrap(processOk(process$1) ? new SignalExit(process$1) : new SignalExitFallback()), terminal = process__default.default.stderr.isTTY ? process__default.default.stderr : process__default.default.stdout.isTTY ? process__default.default.stdout : void 0, restoreCursor$1 = terminal ? onetime$1(() => {
  onExit(() => {
    terminal.write("\x1B[?25h");
  }, { alwaysLast: !0 });
}) : () => {
};
let isHidden = !1;
const cliCursor$1 = {};
cliCursor$1.show = (writableStream = process__default.default.stderr) => {
  writableStream.isTTY && (isHidden = !1, writableStream.write("\x1B[?25h"));
};
cliCursor$1.hide = (writableStream = process__default.default.stderr) => {
  writableStream.isTTY && (restoreCursor$1(), isHidden = !0, writableStream.write("\x1B[?25l"));
};
cliCursor$1.toggle = (force, writableStream) => {
  force !== void 0 && (isHidden = force), isHidden ? cliCursor$1.show(writableStream) : cliCursor$1.hide(writableStream);
};
var dots = {
  interval: 80,
  frames: [
    "\u280B",
    "\u2819",
    "\u2839",
    "\u2838",
    "\u283C",
    "\u2834",
    "\u2826",
    "\u2827",
    "\u2807",
    "\u280F"
  ]
}, dots2 = {
  interval: 80,
  frames: [
    "\u28FE",
    "\u28FD",
    "\u28FB",
    "\u28BF",
    "\u287F",
    "\u28DF",
    "\u28EF",
    "\u28F7"
  ]
}, dots3 = {
  interval: 80,
  frames: [
    "\u280B",
    "\u2819",
    "\u281A",
    "\u281E",
    "\u2816",
    "\u2826",
    "\u2834",
    "\u2832",
    "\u2833",
    "\u2813"
  ]
}, dots4 = {
  interval: 80,
  frames: [
    "\u2804",
    "\u2806",
    "\u2807",
    "\u280B",
    "\u2819",
    "\u2838",
    "\u2830",
    "\u2820",
    "\u2830",
    "\u2838",
    "\u2819",
    "\u280B",
    "\u2807",
    "\u2806"
  ]
}, dots5 = {
  interval: 80,
  frames: [
    "\u280B",
    "\u2819",
    "\u281A",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u2832",
    "\u2834",
    "\u2826",
    "\u2816",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2813",
    "\u280B"
  ]
}, dots6 = {
  interval: 80,
  frames: [
    "\u2801",
    "\u2809",
    "\u2819",
    "\u281A",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u2832",
    "\u2834",
    "\u2824",
    "\u2804",
    "\u2804",
    "\u2824",
    "\u2834",
    "\u2832",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u281A",
    "\u2819",
    "\u2809",
    "\u2801"
  ]
}, dots7 = {
  interval: 80,
  frames: [
    "\u2808",
    "\u2809",
    "\u280B",
    "\u2813",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2816",
    "\u2826",
    "\u2824",
    "\u2820",
    "\u2820",
    "\u2824",
    "\u2826",
    "\u2816",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2813",
    "\u280B",
    "\u2809",
    "\u2808"
  ]
}, dots8 = {
  interval: 80,
  frames: [
    "\u2801",
    "\u2801",
    "\u2809",
    "\u2819",
    "\u281A",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u2832",
    "\u2834",
    "\u2824",
    "\u2804",
    "\u2804",
    "\u2824",
    "\u2820",
    "\u2820",
    "\u2824",
    "\u2826",
    "\u2816",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2813",
    "\u280B",
    "\u2809",
    "\u2808",
    "\u2808"
  ]
}, dots9 = {
  interval: 80,
  frames: [
    "\u28B9",
    "\u28BA",
    "\u28BC",
    "\u28F8",
    "\u28C7",
    "\u2867",
    "\u2857",
    "\u284F"
  ]
}, dots10 = {
  interval: 80,
  frames: [
    "\u2884",
    "\u2882",
    "\u2881",
    "\u2841",
    "\u2848",
    "\u2850",
    "\u2860"
  ]
}, dots11 = {
  interval: 100,
  frames: [
    "\u2801",
    "\u2802",
    "\u2804",
    "\u2840",
    "\u2880",
    "\u2820",
    "\u2810",
    "\u2808"
  ]
}, dots12 = {
  interval: 80,
  frames: [
    "\u2880\u2800",
    "\u2840\u2800",
    "\u2804\u2800",
    "\u2882\u2800",
    "\u2842\u2800",
    "\u2805\u2800",
    "\u2883\u2800",
    "\u2843\u2800",
    "\u280D\u2800",
    "\u288B\u2800",
    "\u284B\u2800",
    "\u280D\u2801",
    "\u288B\u2801",
    "\u284B\u2801",
    "\u280D\u2809",
    "\u280B\u2809",
    "\u280B\u2809",
    "\u2809\u2819",
    "\u2809\u2819",
    "\u2809\u2829",
    "\u2808\u2899",
    "\u2808\u2859",
    "\u2888\u2829",
    "\u2840\u2899",
    "\u2804\u2859",
    "\u2882\u2829",
    "\u2842\u2898",
    "\u2805\u2858",
    "\u2883\u2828",
    "\u2843\u2890",
    "\u280D\u2850",
    "\u288B\u2820",
    "\u284B\u2880",
    "\u280D\u2841",
    "\u288B\u2801",
    "\u284B\u2801",
    "\u280D\u2809",
    "\u280B\u2809",
    "\u280B\u2809",
    "\u2809\u2819",
    "\u2809\u2819",
    "\u2809\u2829",
    "\u2808\u2899",
    "\u2808\u2859",
    "\u2808\u2829",
    "\u2800\u2899",
    "\u2800\u2859",
    "\u2800\u2829",
    "\u2800\u2898",
    "\u2800\u2858",
    "\u2800\u2828",
    "\u2800\u2890",
    "\u2800\u2850",
    "\u2800\u2820",
    "\u2800\u2880",
    "\u2800\u2840"
  ]
}, dots13 = {
  interval: 80,
  frames: [
    "\u28FC",
    "\u28F9",
    "\u28BB",
    "\u283F",
    "\u285F",
    "\u28CF",
    "\u28E7",
    "\u28F6"
  ]
}, dots8Bit = {
  interval: 80,
  frames: [
    "\u2800",
    "\u2801",
    "\u2802",
    "\u2803",
    "\u2804",
    "\u2805",
    "\u2806",
    "\u2807",
    "\u2840",
    "\u2841",
    "\u2842",
    "\u2843",
    "\u2844",
    "\u2845",
    "\u2846",
    "\u2847",
    "\u2808",
    "\u2809",
    "\u280A",
    "\u280B",
    "\u280C",
    "\u280D",
    "\u280E",
    "\u280F",
    "\u2848",
    "\u2849",
    "\u284A",
    "\u284B",
    "\u284C",
    "\u284D",
    "\u284E",
    "\u284F",
    "\u2810",
    "\u2811",
    "\u2812",
    "\u2813",
    "\u2814",
    "\u2815",
    "\u2816",
    "\u2817",
    "\u2850",
    "\u2851",
    "\u2852",
    "\u2853",
    "\u2854",
    "\u2855",
    "\u2856",
    "\u2857",
    "\u2818",
    "\u2819",
    "\u281A",
    "\u281B",
    "\u281C",
    "\u281D",
    "\u281E",
    "\u281F",
    "\u2858",
    "\u2859",
    "\u285A",
    "\u285B",
    "\u285C",
    "\u285D",
    "\u285E",
    "\u285F",
    "\u2820",
    "\u2821",
    "\u2822",
    "\u2823",
    "\u2824",
    "\u2825",
    "\u2826",
    "\u2827",
    "\u2860",
    "\u2861",
    "\u2862",
    "\u2863",
    "\u2864",
    "\u2865",
    "\u2866",
    "\u2867",
    "\u2828",
    "\u2829",
    "\u282A",
    "\u282B",
    "\u282C",
    "\u282D",
    "\u282E",
    "\u282F",
    "\u2868",
    "\u2869",
    "\u286A",
    "\u286B",
    "\u286C",
    "\u286D",
    "\u286E",
    "\u286F",
    "\u2830",
    "\u2831",
    "\u2832",
    "\u2833",
    "\u2834",
    "\u2835",
    "\u2836",
    "\u2837",
    "\u2870",
    "\u2871",
    "\u2872",
    "\u2873",
    "\u2874",
    "\u2875",
    "\u2876",
    "\u2877",
    "\u2838",
    "\u2839",
    "\u283A",
    "\u283B",
    "\u283C",
    "\u283D",
    "\u283E",
    "\u283F",
    "\u2878",
    "\u2879",
    "\u287A",
    "\u287B",
    "\u287C",
    "\u287D",
    "\u287E",
    "\u287F",
    "\u2880",
    "\u2881",
    "\u2882",
    "\u2883",
    "\u2884",
    "\u2885",
    "\u2886",
    "\u2887",
    "\u28C0",
    "\u28C1",
    "\u28C2",
    "\u28C3",
    "\u28C4",
    "\u28C5",
    "\u28C6",
    "\u28C7",
    "\u2888",
    "\u2889",
    "\u288A",
    "\u288B",
    "\u288C",
    "\u288D",
    "\u288E",
    "\u288F",
    "\u28C8",
    "\u28C9",
    "\u28CA",
    "\u28CB",
    "\u28CC",
    "\u28CD",
    "\u28CE",
    "\u28CF",
    "\u2890",
    "\u2891",
    "\u2892",
    "\u2893",
    "\u2894",
    "\u2895",
    "\u2896",
    "\u2897",
    "\u28D0",
    "\u28D1",
    "\u28D2",
    "\u28D3",
    "\u28D4",
    "\u28D5",
    "\u28D6",
    "\u28D7",
    "\u2898",
    "\u2899",
    "\u289A",
    "\u289B",
    "\u289C",
    "\u289D",
    "\u289E",
    "\u289F",
    "\u28D8",
    "\u28D9",
    "\u28DA",
    "\u28DB",
    "\u28DC",
    "\u28DD",
    "\u28DE",
    "\u28DF",
    "\u28A0",
    "\u28A1",
    "\u28A2",
    "\u28A3",
    "\u28A4",
    "\u28A5",
    "\u28A6",
    "\u28A7",
    "\u28E0",
    "\u28E1",
    "\u28E2",
    "\u28E3",
    "\u28E4",
    "\u28E5",
    "\u28E6",
    "\u28E7",
    "\u28A8",
    "\u28A9",
    "\u28AA",
    "\u28AB",
    "\u28AC",
    "\u28AD",
    "\u28AE",
    "\u28AF",
    "\u28E8",
    "\u28E9",
    "\u28EA",
    "\u28EB",
    "\u28EC",
    "\u28ED",
    "\u28EE",
    "\u28EF",
    "\u28B0",
    "\u28B1",
    "\u28B2",
    "\u28B3",
    "\u28B4",
    "\u28B5",
    "\u28B6",
    "\u28B7",
    "\u28F0",
    "\u28F1",
    "\u28F2",
    "\u28F3",
    "\u28F4",
    "\u28F5",
    "\u28F6",
    "\u28F7",
    "\u28B8",
    "\u28B9",
    "\u28BA",
    "\u28BB",
    "\u28BC",
    "\u28BD",
    "\u28BE",
    "\u28BF",
    "\u28F8",
    "\u28F9",
    "\u28FA",
    "\u28FB",
    "\u28FC",
    "\u28FD",
    "\u28FE",
    "\u28FF"
  ]
}, sand = {
  interval: 80,
  frames: [
    "\u2801",
    "\u2802",
    "\u2804",
    "\u2840",
    "\u2848",
    "\u2850",
    "\u2860",
    "\u28C0",
    "\u28C1",
    "\u28C2",
    "\u28C4",
    "\u28CC",
    "\u28D4",
    "\u28E4",
    "\u28E5",
    "\u28E6",
    "\u28EE",
    "\u28F6",
    "\u28F7",
    "\u28FF",
    "\u287F",
    "\u283F",
    "\u289F",
    "\u281F",
    "\u285B",
    "\u281B",
    "\u282B",
    "\u288B",
    "\u280B",
    "\u280D",
    "\u2849",
    "\u2809",
    "\u2811",
    "\u2821",
    "\u2881"
  ]
}, line = {
  interval: 130,
  frames: [
    "-",
    "\\",
    "|",
    "/"
  ]
}, line2 = {
  interval: 100,
  frames: [
    "\u2802",
    "-",
    "\u2013",
    "\u2014",
    "\u2013",
    "-"
  ]
}, pipe$1 = {
  interval: 100,
  frames: [
    "\u2524",
    "\u2518",
    "\u2534",
    "\u2514",
    "\u251C",
    "\u250C",
    "\u252C",
    "\u2510"
  ]
}, simpleDots = {
  interval: 400,
  frames: [
    ".  ",
    ".. ",
    "...",
    "   "
  ]
}, simpleDotsScrolling = {
  interval: 200,
  frames: [
    ".  ",
    ".. ",
    "...",
    " ..",
    "  .",
    "   "
  ]
}, star = {
  interval: 70,
  frames: [
    "\u2736",
    "\u2738",
    "\u2739",
    "\u273A",
    "\u2739",
    "\u2737"
  ]
}, star2 = {
  interval: 80,
  frames: [
    "+",
    "x",
    "*"
  ]
}, flip = {
  interval: 70,
  frames: [
    "_",
    "_",
    "_",
    "-",
    "`",
    "`",
    "'",
    "\xB4",
    "-",
    "_",
    "_",
    "_"
  ]
}, hamburger = {
  interval: 100,
  frames: [
    "\u2631",
    "\u2632",
    "\u2634"
  ]
}, growVertical = {
  interval: 120,
  frames: [
    "\u2581",
    "\u2583",
    "\u2584",
    "\u2585",
    "\u2586",
    "\u2587",
    "\u2586",
    "\u2585",
    "\u2584",
    "\u2583"
  ]
}, growHorizontal = {
  interval: 120,
  frames: [
    "\u258F",
    "\u258E",
    "\u258D",
    "\u258C",
    "\u258B",
    "\u258A",
    "\u2589",
    "\u258A",
    "\u258B",
    "\u258C",
    "\u258D",
    "\u258E"
  ]
}, balloon = {
  interval: 140,
  frames: [
    " ",
    ".",
    "o",
    "O",
    "@",
    "*",
    " "
  ]
}, balloon2 = {
  interval: 120,
  frames: [
    ".",
    "o",
    "O",
    "\xB0",
    "O",
    "o",
    "."
  ]
}, noise = {
  interval: 100,
  frames: [
    "\u2593",
    "\u2592",
    "\u2591"
  ]
}, bounce = {
  interval: 120,
  frames: [
    "\u2801",
    "\u2802",
    "\u2804",
    "\u2802"
  ]
}, boxBounce = {
  interval: 120,
  frames: [
    "\u2596",
    "\u2598",
    "\u259D",
    "\u2597"
  ]
}, boxBounce2 = {
  interval: 100,
  frames: [
    "\u258C",
    "\u2580",
    "\u2590",
    "\u2584"
  ]
}, triangle = {
  interval: 50,
  frames: [
    "\u25E2",
    "\u25E3",
    "\u25E4",
    "\u25E5"
  ]
}, binary = {
  interval: 80,
  frames: [
    "010010",
    "001100",
    "100101",
    "111010",
    "111101",
    "010111",
    "101011",
    "111000",
    "110011",
    "110101"
  ]
}, arc = {
  interval: 100,
  frames: [
    "\u25DC",
    "\u25E0",
    "\u25DD",
    "\u25DE",
    "\u25E1",
    "\u25DF"
  ]
}, circle = {
  interval: 120,
  frames: [
    "\u25E1",
    "\u2299",
    "\u25E0"
  ]
}, squareCorners = {
  interval: 180,
  frames: [
    "\u25F0",
    "\u25F3",
    "\u25F2",
    "\u25F1"
  ]
}, circleQuarters = {
  interval: 120,
  frames: [
    "\u25F4",
    "\u25F7",
    "\u25F6",
    "\u25F5"
  ]
}, circleHalves = {
  interval: 50,
  frames: [
    "\u25D0",
    "\u25D3",
    "\u25D1",
    "\u25D2"
  ]
}, squish = {
  interval: 100,
  frames: [
    "\u256B",
    "\u256A"
  ]
}, toggle = {
  interval: 250,
  frames: [
    "\u22B6",
    "\u22B7"
  ]
}, toggle2 = {
  interval: 80,
  frames: [
    "\u25AB",
    "\u25AA"
  ]
}, toggle3 = {
  interval: 120,
  frames: [
    "\u25A1",
    "\u25A0"
  ]
}, toggle4 = {
  interval: 100,
  frames: [
    "\u25A0",
    "\u25A1",
    "\u25AA",
    "\u25AB"
  ]
}, toggle5 = {
  interval: 100,
  frames: [
    "\u25AE",
    "\u25AF"
  ]
}, toggle6 = {
  interval: 300,
  frames: [
    "\u101D",
    "\u1040"
  ]
}, toggle7 = {
  interval: 80,
  frames: [
    "\u29BE",
    "\u29BF"
  ]
}, toggle8 = {
  interval: 100,
  frames: [
    "\u25CD",
    "\u25CC"
  ]
}, toggle9 = {
  interval: 100,
  frames: [
    "\u25C9",
    "\u25CE"
  ]
}, toggle10 = {
  interval: 100,
  frames: [
    "\u3282",
    "\u3280",
    "\u3281"
  ]
}, toggle11 = {
  interval: 50,
  frames: [
    "\u29C7",
    "\u29C6"
  ]
}, toggle12 = {
  interval: 120,
  frames: [
    "\u2617",
    "\u2616"
  ]
}, toggle13 = {
  interval: 80,
  frames: [
    "=",
    "*",
    "-"
  ]
}, arrow = {
  interval: 100,
  frames: [
    "\u2190",
    "\u2196",
    "\u2191",
    "\u2197",
    "\u2192",
    "\u2198",
    "\u2193",
    "\u2199"
  ]
}, arrow2 = {
  interval: 80,
  frames: [
    "\u2B06\uFE0F ",
    "\u2197\uFE0F ",
    "\u27A1\uFE0F ",
    "\u2198\uFE0F ",
    "\u2B07\uFE0F ",
    "\u2199\uFE0F ",
    "\u2B05\uFE0F ",
    "\u2196\uFE0F "
  ]
}, arrow3 = {
  interval: 120,
  frames: [
    "\u25B9\u25B9\u25B9\u25B9\u25B9",
    "\u25B8\u25B9\u25B9\u25B9\u25B9",
    "\u25B9\u25B8\u25B9\u25B9\u25B9",
    "\u25B9\u25B9\u25B8\u25B9\u25B9",
    "\u25B9\u25B9\u25B9\u25B8\u25B9",
    "\u25B9\u25B9\u25B9\u25B9\u25B8"
  ]
}, bouncingBar = {
  interval: 80,
  frames: [
    "[    ]",
    "[=   ]",
    "[==  ]",
    "[=== ]",
    "[====]",
    "[ ===]",
    "[  ==]",
    "[   =]",
    "[    ]",
    "[   =]",
    "[  ==]",
    "[ ===]",
    "[====]",
    "[=== ]",
    "[==  ]",
    "[=   ]"
  ]
}, bouncingBall = {
  interval: 80,
  frames: [
    "( \u25CF    )",
    "(  \u25CF   )",
    "(   \u25CF  )",
    "(    \u25CF )",
    "(     \u25CF)",
    "(    \u25CF )",
    "(   \u25CF  )",
    "(  \u25CF   )",
    "( \u25CF    )",
    "(\u25CF     )"
  ]
}, smiley = {
  interval: 200,
  frames: [
    "\u{1F604} ",
    "\u{1F61D} "
  ]
}, monkey = {
  interval: 300,
  frames: [
    "\u{1F648} ",
    "\u{1F648} ",
    "\u{1F649} ",
    "\u{1F64A} "
  ]
}, hearts = {
  interval: 100,
  frames: [
    "\u{1F49B} ",
    "\u{1F499} ",
    "\u{1F49C} ",
    "\u{1F49A} ",
    "\u2764\uFE0F "
  ]
}, clock = {
  interval: 100,
  frames: [
    "\u{1F55B} ",
    "\u{1F550} ",
    "\u{1F551} ",
    "\u{1F552} ",
    "\u{1F553} ",
    "\u{1F554} ",
    "\u{1F555} ",
    "\u{1F556} ",
    "\u{1F557} ",
    "\u{1F558} ",
    "\u{1F559} ",
    "\u{1F55A} "
  ]
}, earth = {
  interval: 180,
  frames: [
    "\u{1F30D} ",
    "\u{1F30E} ",
    "\u{1F30F} "
  ]
}, material = {
  interval: 17,
  frames: [
    "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
    "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581"
  ]
}, moon = {
  interval: 80,
  frames: [
    "\u{1F311} ",
    "\u{1F312} ",
    "\u{1F313} ",
    "\u{1F314} ",
    "\u{1F315} ",
    "\u{1F316} ",
    "\u{1F317} ",
    "\u{1F318} "
  ]
}, runner = {
  interval: 140,
  frames: [
    "\u{1F6B6} ",
    "\u{1F3C3} "
  ]
}, pong = {
  interval: 80,
  frames: [
    "\u2590\u2802       \u258C",
    "\u2590\u2808       \u258C",
    "\u2590 \u2802      \u258C",
    "\u2590 \u2820      \u258C",
    "\u2590  \u2840     \u258C",
    "\u2590  \u2820     \u258C",
    "\u2590   \u2802    \u258C",
    "\u2590   \u2808    \u258C",
    "\u2590    \u2802   \u258C",
    "\u2590    \u2820   \u258C",
    "\u2590     \u2840  \u258C",
    "\u2590     \u2820  \u258C",
    "\u2590      \u2802 \u258C",
    "\u2590      \u2808 \u258C",
    "\u2590       \u2802\u258C",
    "\u2590       \u2820\u258C",
    "\u2590       \u2840\u258C",
    "\u2590      \u2820 \u258C",
    "\u2590      \u2802 \u258C",
    "\u2590     \u2808  \u258C",
    "\u2590     \u2802  \u258C",
    "\u2590    \u2820   \u258C",
    "\u2590    \u2840   \u258C",
    "\u2590   \u2820    \u258C",
    "\u2590   \u2802    \u258C",
    "\u2590  \u2808     \u258C",
    "\u2590  \u2802     \u258C",
    "\u2590 \u2820      \u258C",
    "\u2590 \u2840      \u258C",
    "\u2590\u2820       \u258C"
  ]
}, shark = {
  interval: 120,
  frames: [
    "\u2590|\\____________\u258C",
    "\u2590_|\\___________\u258C",
    "\u2590__|\\__________\u258C",
    "\u2590___|\\_________\u258C",
    "\u2590____|\\________\u258C",
    "\u2590_____|\\_______\u258C",
    "\u2590______|\\______\u258C",
    "\u2590_______|\\_____\u258C",
    "\u2590________|\\____\u258C",
    "\u2590_________|\\___\u258C",
    "\u2590__________|\\__\u258C",
    "\u2590___________|\\_\u258C",
    "\u2590____________|\\\u258C",
    "\u2590____________/|\u258C",
    "\u2590___________/|_\u258C",
    "\u2590__________/|__\u258C",
    "\u2590_________/|___\u258C",
    "\u2590________/|____\u258C",
    "\u2590_______/|_____\u258C",
    "\u2590______/|______\u258C",
    "\u2590_____/|_______\u258C",
    "\u2590____/|________\u258C",
    "\u2590___/|_________\u258C",
    "\u2590__/|__________\u258C",
    "\u2590_/|___________\u258C",
    "\u2590/|____________\u258C"
  ]
}, dqpb = {
  interval: 100,
  frames: [
    "d",
    "q",
    "p",
    "b"
  ]
}, weather = {
  interval: 100,
  frames: [
    "\u2600\uFE0F ",
    "\u2600\uFE0F ",
    "\u2600\uFE0F ",
    "\u{1F324} ",
    "\u26C5\uFE0F ",
    "\u{1F325} ",
    "\u2601\uFE0F ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u26C8 ",
    "\u{1F328} ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u2601\uFE0F ",
    "\u{1F325} ",
    "\u26C5\uFE0F ",
    "\u{1F324} ",
    "\u2600\uFE0F ",
    "\u2600\uFE0F "
  ]
}, christmas = {
  interval: 400,
  frames: [
    "\u{1F332}",
    "\u{1F384}"
  ]
}, grenade = {
  interval: 80,
  frames: [
    "\u060C  ",
    "\u2032  ",
    " \xB4 ",
    " \u203E ",
    "  \u2E0C",
    "  \u2E0A",
    "  |",
    "  \u204E",
    "  \u2055",
    " \u0DF4 ",
    "  \u2053",
    "   ",
    "   ",
    "   "
  ]
}, point = {
  interval: 125,
  frames: [
    "\u2219\u2219\u2219",
    "\u25CF\u2219\u2219",
    "\u2219\u25CF\u2219",
    "\u2219\u2219\u25CF",
    "\u2219\u2219\u2219"
  ]
}, layer = {
  interval: 150,
  frames: [
    "-",
    "=",
    "\u2261"
  ]
}, betaWave = {
  interval: 80,
  frames: [
    "\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2",
    "\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2",
    "\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2",
    "\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2",
    "\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2",
    "\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2",
    "\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1"
  ]
}, fingerDance = {
  interval: 160,
  frames: [
    "\u{1F918} ",
    "\u{1F91F} ",
    "\u{1F596} ",
    "\u270B ",
    "\u{1F91A} ",
    "\u{1F446} "
  ]
}, fistBump = {
  interval: 80,
  frames: [
    "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
    "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
    "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
    "\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ",
    "\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ",
    "\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ",
    "\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 "
  ]
}, soccerHeader = {
  interval: 80,
  frames: [
    " \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ",
    "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ",
    "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
    "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
    "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
    "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
    "\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ",
    "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
    "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
    "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
    "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
    "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} "
  ]
}, mindblown = {
  interval: 160,
  frames: [
    "\u{1F610} ",
    "\u{1F610} ",
    "\u{1F62E} ",
    "\u{1F62E} ",
    "\u{1F626} ",
    "\u{1F626} ",
    "\u{1F627} ",
    "\u{1F627} ",
    "\u{1F92F} ",
    "\u{1F4A5} ",
    "\u2728 ",
    "\u3000 ",
    "\u3000 ",
    "\u3000 "
  ]
}, speaker = {
  interval: 160,
  frames: [
    "\u{1F508} ",
    "\u{1F509} ",
    "\u{1F50A} ",
    "\u{1F509} "
  ]
}, orangePulse = {
  interval: 100,
  frames: [
    "\u{1F538} ",
    "\u{1F536} ",
    "\u{1F7E0} ",
    "\u{1F7E0} ",
    "\u{1F536} "
  ]
}, bluePulse = {
  interval: 100,
  frames: [
    "\u{1F539} ",
    "\u{1F537} ",
    "\u{1F535} ",
    "\u{1F535} ",
    "\u{1F537} "
  ]
}, orangeBluePulse = {
  interval: 100,
  frames: [
    "\u{1F538} ",
    "\u{1F536} ",
    "\u{1F7E0} ",
    "\u{1F7E0} ",
    "\u{1F536} ",
    "\u{1F539} ",
    "\u{1F537} ",
    "\u{1F535} ",
    "\u{1F535} ",
    "\u{1F537} "
  ]
}, timeTravel = {
  interval: 100,
  frames: [
    "\u{1F55B} ",
    "\u{1F55A} ",
    "\u{1F559} ",
    "\u{1F558} ",
    "\u{1F557} ",
    "\u{1F556} ",
    "\u{1F555} ",
    "\u{1F554} ",
    "\u{1F553} ",
    "\u{1F552} ",
    "\u{1F551} ",
    "\u{1F550} "
  ]
}, aesthetic = {
  interval: 80,
  frames: [
    "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0",
    "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1"
  ]
}, dwarfFortress = {
  interval: 80,
  frames: [
    " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A \u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A \u2588\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
    "    \u263A \u2588\xA3\xA3\xA3  ",
    "     \u263A\u2588\xA3\xA3\xA3  ",
    "     \u263A\u2588\xA3\xA3\xA3  ",
    "     \u263A\u2593\xA3\xA3\xA3  ",
    "     \u263A\u2593\xA3\xA3\xA3  ",
    "     \u263A\u2592\xA3\xA3\xA3  ",
    "     \u263A\u2592\xA3\xA3\xA3  ",
    "     \u263A\u2591\xA3\xA3\xA3  ",
    "     \u263A\u2591\xA3\xA3\xA3  ",
    "     \u263A \xA3\xA3\xA3  ",
    "      \u263A\xA3\xA3\xA3  ",
    "      \u263A\xA3\xA3\xA3  ",
    "      \u263A\u2593\xA3\xA3  ",
    "      \u263A\u2593\xA3\xA3  ",
    "      \u263A\u2592\xA3\xA3  ",
    "      \u263A\u2592\xA3\xA3  ",
    "      \u263A\u2591\xA3\xA3  ",
    "      \u263A\u2591\xA3\xA3  ",
    "      \u263A \xA3\xA3  ",
    "       \u263A\xA3\xA3  ",
    "       \u263A\xA3\xA3  ",
    "       \u263A\u2593\xA3  ",
    "       \u263A\u2593\xA3  ",
    "       \u263A\u2592\xA3  ",
    "       \u263A\u2592\xA3  ",
    "       \u263A\u2591\xA3  ",
    "       \u263A\u2591\xA3  ",
    "       \u263A \xA3  ",
    "        \u263A\xA3  ",
    "        \u263A\xA3  ",
    "        \u263A\u2593  ",
    "        \u263A\u2593  ",
    "        \u263A\u2592  ",
    "        \u263A\u2592  ",
    "        \u263A\u2591  ",
    "        \u263A\u2591  ",
    "        \u263A   ",
    "        \u263A  &",
    "        \u263A \u263C&",
    "       \u263A \u263C &",
    "       \u263A\u263C  &",
    "      \u263A\u263C  & ",
    "      \u203C   & ",
    "     \u263A   &  ",
    "    \u203C    &  ",
    "   \u263A    &   ",
    "  \u203C     &   ",
    " \u263A     &    ",
    "\u203C      &    ",
    "      &     ",
    "      &     ",
    "     &   \u2591  ",
    "     &   \u2592  ",
    "    &    \u2593  ",
    "    &    \xA3  ",
    "   &    \u2591\xA3  ",
    "   &    \u2592\xA3  ",
    "  &     \u2593\xA3  ",
    "  &     \xA3\xA3  ",
    " &     \u2591\xA3\xA3  ",
    " &     \u2592\xA3\xA3  ",
    "&      \u2593\xA3\xA3  ",
    "&      \xA3\xA3\xA3  ",
    "      \u2591\xA3\xA3\xA3  ",
    "      \u2592\xA3\xA3\xA3  ",
    "      \u2593\xA3\xA3\xA3  ",
    "      \u2588\xA3\xA3\xA3  ",
    "     \u2591\u2588\xA3\xA3\xA3  ",
    "     \u2592\u2588\xA3\xA3\xA3  ",
    "     \u2593\u2588\xA3\xA3\xA3  ",
    "     \u2588\u2588\xA3\xA3\xA3  ",
    "    \u2591\u2588\u2588\xA3\xA3\xA3  ",
    "    \u2592\u2588\u2588\xA3\xA3\xA3  ",
    "    \u2593\u2588\u2588\xA3\xA3\xA3  ",
    "    \u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  "
  ]
}, require$$0$2 = {
  dots,
  dots2,
  dots3,
  dots4,
  dots5,
  dots6,
  dots7,
  dots8,
  dots9,
  dots10,
  dots11,
  dots12,
  dots13,
  dots8Bit,
  sand,
  line,
  line2,
  pipe: pipe$1,
  simpleDots,
  simpleDotsScrolling,
  star,
  star2,
  flip,
  hamburger,
  growVertical,
  growHorizontal,
  balloon,
  balloon2,
  noise,
  bounce,
  boxBounce,
  boxBounce2,
  triangle,
  binary,
  arc,
  circle,
  squareCorners,
  circleQuarters,
  circleHalves,
  squish,
  toggle,
  toggle2,
  toggle3,
  toggle4,
  toggle5,
  toggle6,
  toggle7,
  toggle8,
  toggle9,
  toggle10,
  toggle11,
  toggle12,
  toggle13,
  arrow,
  arrow2,
  arrow3,
  bouncingBar,
  bouncingBall,
  smiley,
  monkey,
  hearts,
  clock,
  earth,
  material,
  moon,
  runner,
  pong,
  shark,
  dqpb,
  weather,
  christmas,
  grenade,
  point,
  layer,
  betaWave,
  fingerDance,
  fistBump,
  soccerHeader,
  mindblown,
  speaker,
  orangePulse,
  bluePulse,
  orangeBluePulse,
  timeTravel,
  aesthetic,
  dwarfFortress
}, cliSpinners$1, hasRequiredCliSpinners;
function requireCliSpinners() {
  if (hasRequiredCliSpinners) return cliSpinners$1;
  hasRequiredCliSpinners = 1;
  const spinners = Object.assign({}, require$$0$2), spinnersList = Object.keys(spinners);
  return Object.defineProperty(spinners, "random", {
    get() {
      const randomIndex = Math.floor(Math.random() * spinnersList.length), spinnerName = spinnersList[randomIndex];
      return spinners[spinnerName];
    }
  }), cliSpinners$1 = spinners, cliSpinners$1;
}
var cliSpinnersExports = requireCliSpinners(), cliSpinners = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(cliSpinnersExports);
const logSymbols = {
  info: "\u2139\uFE0F",
  success: "\u2705",
  warning: "\u26A0\uFE0F",
  error: "\u274C\uFE0F"
};
function ansiRegex$3({ onlyFirst = !1 } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
const regex = ansiRegex$3();
function stripAnsi$3(string) {
  if (typeof string != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  return string.replace(regex, "");
}
function isAmbiguous(x) {
  return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}
function isFullWidth(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101631 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129673 || x >= 129679 && x <= 129734 || x >= 129742 && x <= 129756 || x >= 129759 && x <= 129769 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
function validate(codePoint) {
  if (!Number.isSafeInteger(codePoint))
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
}
function eastAsianWidth(codePoint, { ambiguousAsWide = !1 } = {}) {
  return validate(codePoint), isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint) ? 2 : 1;
}
var emojiRegex$1 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
const segmenter = new Intl.Segmenter(), defaultIgnorableCodePointRegex = new RegExp("^\\p{Default_Ignorable_Code_Point}$", "u");
function stringWidth$2(string, options2 = {}) {
  if (typeof string != "string" || string.length === 0)
    return 0;
  const {
    ambiguousIsNarrow = !0,
    countAnsiEscapeCodes = !1
  } = options2;
  if (countAnsiEscapeCodes || (string = stripAnsi$3(string)), string.length === 0)
    return 0;
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (!(codePoint <= 31 || codePoint >= 127 && codePoint <= 159) && !(codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) && !(codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) && !(codePoint >= 55296 && codePoint <= 57343) && !(codePoint >= 65024 && codePoint <= 65039) && !defaultIgnorableCodePointRegex.test(character)) {
      if (emojiRegex$1().test(character)) {
        width += 2;
        continue;
      }
      width += eastAsianWidth(codePoint, eastAsianWidthOptions);
    }
  }
  return width;
}
function isInteractive({ stream: stream2 = process.stdout } = {}) {
  return !!(stream2 && stream2.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env));
}
function isUnicodeSupported() {
  const { env } = process__default.default, { TERM, TERM_PROGRAM } = env;
  return process__default.default.platform !== "win32" ? TERM !== "linux" : !!env.WT_SESSION || !!env.TERMINUS_SUBLIME || env.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
const ASCII_ETX_CODE = 3;
class StdinDiscarder {
  #activeCount = 0;
  start() {
    this.#activeCount++, this.#activeCount === 1 && this.#realStart();
  }
  stop() {
    if (this.#activeCount <= 0)
      throw new Error("`stop` called more times than `start`");
    this.#activeCount--, this.#activeCount === 0 && this.#realStop();
  }
  #realStart() {
    process__default.default.platform === "win32" || !process__default.default.stdin.isTTY || (process__default.default.stdin.setRawMode(!0), process__default.default.stdin.on("data", this.#handleInput), process__default.default.stdin.resume());
  }
  #realStop() {
    process__default.default.stdin.isTTY && (process__default.default.stdin.off("data", this.#handleInput), process__default.default.stdin.pause(), process__default.default.stdin.setRawMode(!1));
  }
  #handleInput(chunk) {
    chunk[0] === ASCII_ETX_CODE && process__default.default.emit("SIGINT");
  }
}
const stdinDiscarder = new StdinDiscarder();
class Ora {
  #linesToClear = 0;
  #isDiscardingStdin = !1;
  #lineCount = 0;
  #frameIndex = -1;
  #lastSpinnerFrameTime = 0;
  #options;
  #spinner;
  #stream;
  #id;
  #initialInterval;
  #isEnabled;
  #isSilent;
  #indent;
  #text;
  #prefixText;
  #suffixText;
  color;
  constructor(options2) {
    typeof options2 == "string" && (options2 = {
      text: options2
    }), this.#options = {
      color: "cyan",
      stream: process__default.default.stderr,
      discardStdin: !0,
      hideCursor: !0,
      ...options2
    }, this.color = this.#options.color, this.spinner = this.#options.spinner, this.#initialInterval = this.#options.interval, this.#stream = this.#options.stream, this.#isEnabled = typeof this.#options.isEnabled == "boolean" ? this.#options.isEnabled : isInteractive({ stream: this.#stream }), this.#isSilent = typeof this.#options.isSilent == "boolean" ? this.#options.isSilent : !1, this.text = this.#options.text, this.prefixText = this.#options.prefixText, this.suffixText = this.#options.suffixText, this.indent = this.#options.indent, process__default.default.env.NODE_ENV === "test" && (this._stream = this.#stream, this._isEnabled = this.#isEnabled, Object.defineProperty(this, "_linesToClear", {
      get() {
        return this.#linesToClear;
      },
      set(newValue) {
        this.#linesToClear = newValue;
      }
    }), Object.defineProperty(this, "_frameIndex", {
      get() {
        return this.#frameIndex;
      }
    }), Object.defineProperty(this, "_lineCount", {
      get() {
        return this.#lineCount;
      }
    }));
  }
  get indent() {
    return this.#indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent)))
      throw new Error("The `indent` option must be an integer from 0 and up");
    this.#indent = indent, this.#updateLineCount();
  }
  get interval() {
    return this.#initialInterval ?? this.#spinner.interval ?? 100;
  }
  get spinner() {
    return this.#spinner;
  }
  set spinner(spinner) {
    if (this.#frameIndex = -1, this.#initialInterval = void 0, typeof spinner == "object") {
      if (spinner.frames === void 0)
        throw new Error("The given spinner must have a `frames` property");
      this.#spinner = spinner;
    } else if (!isUnicodeSupported())
      this.#spinner = cliSpinners.line;
    else if (spinner === void 0)
      this.#spinner = cliSpinners.dots;
    else if (spinner !== "default" && cliSpinners[spinner])
      this.#spinner = cliSpinners[spinner];
    else
      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
  }
  get text() {
    return this.#text;
  }
  set text(value = "") {
    this.#text = value, this.#updateLineCount();
  }
  get prefixText() {
    return this.#prefixText;
  }
  set prefixText(value = "") {
    this.#prefixText = value, this.#updateLineCount();
  }
  get suffixText() {
    return this.#suffixText;
  }
  set suffixText(value = "") {
    this.#suffixText = value, this.#updateLineCount();
  }
  get isSpinning() {
    return this.#id !== void 0;
  }
  #getFullPrefixText(prefixText = this.#prefixText, postfix = " ") {
    return typeof prefixText == "string" && prefixText !== "" ? prefixText + postfix : typeof prefixText == "function" ? prefixText() + postfix : "";
  }
  #getFullSuffixText(suffixText = this.#suffixText, prefix = " ") {
    return typeof suffixText == "string" && suffixText !== "" ? prefix + suffixText : typeof suffixText == "function" ? prefix + suffixText() : "";
  }
  #updateLineCount() {
    const columns = this.#stream.columns ?? 80, fullPrefixText = this.#getFullPrefixText(this.#prefixText, "-"), fullSuffixText = this.#getFullSuffixText(this.#suffixText, "-"), fullText = " ".repeat(this.#indent) + fullPrefixText + "--" + this.#text + "--" + fullSuffixText;
    this.#lineCount = 0;
    for (const line3 of stripAnsi$3(fullText).split(`
`))
      this.#lineCount += Math.max(1, Math.ceil(stringWidth$2(line3, { countAnsiEscapeCodes: !0 }) / columns));
  }
  get isEnabled() {
    return this.#isEnabled && !this.#isSilent;
  }
  set isEnabled(value) {
    if (typeof value != "boolean")
      throw new TypeError("The `isEnabled` option must be a boolean");
    this.#isEnabled = value;
  }
  get isSilent() {
    return this.#isSilent;
  }
  set isSilent(value) {
    if (typeof value != "boolean")
      throw new TypeError("The `isSilent` option must be a boolean");
    this.#isSilent = value;
  }
  frame() {
    const now = Date.now();
    (this.#frameIndex === -1 || now - this.#lastSpinnerFrameTime >= this.interval) && (this.#frameIndex = ++this.#frameIndex % this.#spinner.frames.length, this.#lastSpinnerFrameTime = now);
    const { frames } = this.#spinner;
    let frame = frames[this.#frameIndex];
    this.color && (frame = chalk__default.default[this.color](frame));
    const fullPrefixText = typeof this.#prefixText == "string" && this.#prefixText !== "" ? this.#prefixText + " " : "", fullText = typeof this.text == "string" ? " " + this.text : "", fullSuffixText = typeof this.#suffixText == "string" && this.#suffixText !== "" ? " " + this.#suffixText : "";
    return fullPrefixText + frame + fullText + fullSuffixText;
  }
  clear() {
    if (!this.#isEnabled || !this.#stream.isTTY)
      return this;
    this.#stream.cursorTo(0);
    for (let index = 0; index < this.#linesToClear; index++)
      index > 0 && this.#stream.moveCursor(0, -1), this.#stream.clearLine(1);
    return (this.#indent || this.lastIndent !== this.#indent) && this.#stream.cursorTo(this.#indent), this.lastIndent = this.#indent, this.#linesToClear = 0, this;
  }
  render() {
    return this.#isSilent ? this : (this.clear(), this.#stream.write(this.frame()), this.#linesToClear = this.#lineCount, this);
  }
  start(text) {
    return text && (this.text = text), this.#isSilent ? this : this.#isEnabled ? this.isSpinning ? this : (this.#options.hideCursor && cliCursor$1.hide(this.#stream), this.#options.discardStdin && process__default.default.stdin.isTTY && (this.#isDiscardingStdin = !0, stdinDiscarder.start()), this.render(), this.#id = setInterval(this.render.bind(this), this.interval), this) : (this.text && this.#stream.write(`- ${this.text}
`), this);
  }
  stop() {
    return this.#isEnabled ? (clearInterval(this.#id), this.#id = void 0, this.#frameIndex = 0, this.clear(), this.#options.hideCursor && cliCursor$1.show(this.#stream), this.#options.discardStdin && process__default.default.stdin.isTTY && this.#isDiscardingStdin && (stdinDiscarder.stop(), this.#isDiscardingStdin = !1), this) : this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: logSymbols.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: logSymbols.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: logSymbols.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: logSymbols.info, text });
  }
  stopAndPersist(options2 = {}) {
    if (this.#isSilent)
      return this;
    const prefixText = options2.prefixText ?? this.#prefixText, fullPrefixText = this.#getFullPrefixText(prefixText, " "), symbolText = options2.symbol ?? " ", text = options2.text ?? this.text, fullText = typeof text == "string" ? (symbolText ? " " : "") + text : "", suffixText = options2.suffixText ?? this.#suffixText, fullSuffixText = this.#getFullSuffixText(suffixText, " "), textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + `
`;
    return this.stop(), this.#stream.write(textToWrite), this;
  }
}
function ora(options2) {
  return new Ora(options2);
}
const SYMBOL_CHECK = chalk__default.default.green("\u2713"), SYMBOL_WARN = chalk__default.default.yellow("\u26A0"), SYMBOL_FAIL = chalk__default.default.red("\u2717");
let isFirstClear = !0;
var cliOutputter = {
  print(...args) {
    console.log(...args);
  },
  success(firstPartOfMessage, ...args) {
    console.log(`${SYMBOL_CHECK} ${firstPartOfMessage}`, ...args);
  },
  warn(firstPartOfMessage, ...args) {
    console.warn(`${SYMBOL_WARN} ${firstPartOfMessage}`, ...args);
  },
  error(firstPartOfMessage, ...args) {
    firstPartOfMessage instanceof Error ? console.error(`${SYMBOL_FAIL} ${chalk__default.default.red(firstPartOfMessage.stack)}`) : console.error(`${SYMBOL_FAIL} ${firstPartOfMessage}`, ...args);
  },
  clear: () => {
    process.stdout.write(isFirstClear ? "\x1Bc" : "\x1B[2J\x1B[0f"), isFirstClear = !1;
  },
  spinner(options2) {
    const spinner = ora(options2);
    return spinner.succeed = (text) => spinner.stopAndPersist({ text, symbol: SYMBOL_CHECK }), spinner.warn = (text) => spinner.stopAndPersist({ text, symbol: SYMBOL_WARN }), spinner.fail = (text) => spinner.stopAndPersist({ text, symbol: SYMBOL_FAIL }), spinner;
  }
}, inquirer$1 = { exports: {} }, escapeStringRegexp$1, hasRequiredEscapeStringRegexp$1;
function requireEscapeStringRegexp$1() {
  if (hasRequiredEscapeStringRegexp$1) return escapeStringRegexp$1;
  hasRequiredEscapeStringRegexp$1 = 1;
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  return escapeStringRegexp$1 = function(str2) {
    if (typeof str2 != "string")
      throw new TypeError("Expected a string");
    return str2.replace(matchOperatorsRe, "\\$&");
  }, escapeStringRegexp$1;
}
var figures_1, hasRequiredFigures;
function requireFigures() {
  if (hasRequiredFigures) return figures_1;
  hasRequiredFigures = 1;
  const escapeStringRegexp2 = requireEscapeStringRegexp$1(), platform2 = process.platform, main2 = {
    tick: "\u2714",
    cross: "\u2716",
    star: "\u2605",
    square: "\u2587",
    squareSmall: "\u25FB",
    squareSmallFilled: "\u25FC",
    play: "\u25B6",
    circle: "\u25EF",
    circleFilled: "\u25C9",
    circleDotted: "\u25CC",
    circleDouble: "\u25CE",
    circleCircle: "\u24DE",
    circleCross: "\u24E7",
    circlePipe: "\u24BE",
    circleQuestionMark: "?\u20DD",
    bullet: "\u25CF",
    dot: "\u2024",
    line: "\u2500",
    ellipsis: "\u2026",
    pointer: "\u276F",
    pointerSmall: "\u203A",
    info: "\u2139",
    warning: "\u26A0",
    hamburger: "\u2630",
    smiley: "\u32E1",
    mustache: "\u0DF4",
    heart: "\u2665",
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    checkboxOn: "\u2612",
    checkboxOff: "\u2610",
    checkboxCircleOn: "\u24E7",
    checkboxCircleOff: "\u24BE",
    questionMarkPrefix: "?\u20DD",
    oneHalf: "\xBD",
    oneThird: "\u2153",
    oneQuarter: "\xBC",
    oneFifth: "\u2155",
    oneSixth: "\u2159",
    oneSeventh: "\u2150",
    oneEighth: "\u215B",
    oneNinth: "\u2151",
    oneTenth: "\u2152",
    twoThirds: "\u2154",
    twoFifths: "\u2156",
    threeQuarters: "\xBE",
    threeFifths: "\u2157",
    threeEighths: "\u215C",
    fourFifths: "\u2158",
    fiveSixths: "\u215A",
    fiveEighths: "\u215D",
    sevenEighths: "\u215E"
  }, win = {
    tick: "\u221A",
    cross: "\xD7",
    star: "*",
    square: "\u2588",
    squareSmall: "[ ]",
    squareSmallFilled: "[\u2588]",
    play: "\u25BA",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "(\u25CB)",
    circleCross: "(\xD7)",
    circlePipe: "(\u2502)",
    circleQuestionMark: "(?)",
    bullet: "*",
    dot: ".",
    line: "\u2500",
    ellipsis: "...",
    pointer: ">",
    pointerSmall: "\xBB",
    info: "i",
    warning: "\u203C",
    hamburger: "\u2261",
    smiley: "\u263A",
    mustache: "\u250C\u2500\u2510",
    heart: main2.heart,
    arrowUp: main2.arrowUp,
    arrowDown: main2.arrowDown,
    arrowLeft: main2.arrowLeft,
    arrowRight: main2.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[\xD7]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "(\xD7)",
    checkboxCircleOff: "( )",
    questionMarkPrefix: "\uFF1F",
    oneHalf: "1/2",
    oneThird: "1/3",
    oneQuarter: "1/4",
    oneFifth: "1/5",
    oneSixth: "1/6",
    oneSeventh: "1/7",
    oneEighth: "1/8",
    oneNinth: "1/9",
    oneTenth: "1/10",
    twoThirds: "2/3",
    twoFifths: "2/5",
    threeQuarters: "3/4",
    threeFifths: "3/5",
    threeEighths: "3/8",
    fourFifths: "4/5",
    fiveSixths: "5/6",
    fiveEighths: "5/8",
    sevenEighths: "7/8"
  };
  platform2 === "linux" && (main2.questionMarkPrefix = "?");
  const figures = platform2 === "win32" ? win : main2;
  return figures_1 = Object.assign((str2) => (figures === main2 || Object.keys(main2).forEach((key2) => {
    main2[key2] !== figures[key2] && (str2 = str2.replace(new RegExp(escapeStringRegexp2(main2[key2]), "g"), figures[key2]));
  }), str2), figures), figures_1;
}
var separator, hasRequiredSeparator;
function requireSeparator() {
  if (hasRequiredSeparator) return separator;
  hasRequiredSeparator = 1;
  var chalk2 = chalk__default.default, figures = requireFigures();
  class Separator {
    constructor(line3) {
      this.type = "separator", this.line = chalk2.dim(line3 || new Array(15).join(figures.line));
    }
    /**
     * Stringify separator
     * @return {String} the separator display string
     */
    toString() {
      return this.line;
    }
  }
  return Separator.exclude = function(obj) {
    return obj.type !== "separator";
  }, separator = Separator, separator;
}
var through = { exports: {} }, hasRequiredThrough;
function requireThrough() {
  return hasRequiredThrough || (hasRequiredThrough = 1, function(module2, exports2) {
    var Stream2 = require$$0__default$4.default;
    module2.exports = through2, through2.through = through2;
    function through2(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      }, end = end || function() {
        this.queue(null);
      };
      var ended = !1, destroyed = !1, buffer2 = [], _ended = !1, stream2 = new Stream2();
      stream2.readable = stream2.writable = !0, stream2.paused = !1, stream2.autoDestroy = !(opts && opts.autoDestroy === !1), stream2.write = function(data) {
        return write.call(this, data), !stream2.paused;
      };
      function drain() {
        for (; buffer2.length && !stream2.paused; ) {
          var data = buffer2.shift();
          if (data === null)
            return stream2.emit("end");
          stream2.emit("data", data);
        }
      }
      stream2.queue = stream2.push = function(data) {
        return _ended || (data === null && (_ended = !0), buffer2.push(data), drain()), stream2;
      }, stream2.on("end", function() {
        stream2.readable = !1, !stream2.writable && stream2.autoDestroy && process.nextTick(function() {
          stream2.destroy();
        });
      });
      function _end() {
        stream2.writable = !1, end.call(stream2), !stream2.readable && stream2.autoDestroy && stream2.destroy();
      }
      return stream2.end = function(data) {
        if (!ended)
          return ended = !0, arguments.length && stream2.write(data), _end(), stream2;
      }, stream2.destroy = function() {
        if (!destroyed)
          return destroyed = !0, ended = !0, buffer2.length = 0, stream2.writable = stream2.readable = !1, stream2.emit("close"), stream2;
      }, stream2.pause = function() {
        if (!stream2.paused)
          return stream2.paused = !0, stream2;
      }, stream2.resume = function() {
        return stream2.paused && (stream2.paused = !1, stream2.emit("resume")), drain(), stream2.paused || stream2.emit("drain"), stream2;
      }, stream2;
    }
  }(through)), through.exports;
}
var mute, hasRequiredMute;
function requireMute() {
  if (hasRequiredMute) return mute;
  hasRequiredMute = 1;
  var Stream2 = require$$0__default$4.default;
  mute = MuteStream;
  function MuteStream(opts) {
    Stream2.apply(this), opts = opts || {}, this.writable = this.readable = !0, this.muted = !1, this.on("pipe", this._onpipe), this.replace = opts.replace, this._prompt = opts.prompt || null, this._hadControl = !1;
  }
  MuteStream.prototype = Object.create(Stream2.prototype), Object.defineProperty(MuteStream.prototype, "constructor", {
    value: MuteStream,
    enumerable: !1
  }), MuteStream.prototype.mute = function() {
    this.muted = !0;
  }, MuteStream.prototype.unmute = function() {
    this.muted = !1;
  }, Object.defineProperty(MuteStream.prototype, "_onpipe", {
    value: onPipe,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
  function onPipe(src2) {
    this._src = src2;
  }
  Object.defineProperty(MuteStream.prototype, "isTTY", {
    get: getIsTTY,
    set: setIsTTY,
    enumerable: !0,
    configurable: !0
  });
  function getIsTTY() {
    return this._dest ? this._dest.isTTY : this._src ? this._src.isTTY : !1;
  }
  function setIsTTY(isTTY) {
    Object.defineProperty(this, "isTTY", {
      value: isTTY,
      enumerable: !0,
      writable: !0,
      configurable: !0
    });
  }
  Object.defineProperty(MuteStream.prototype, "rows", {
    get: function() {
      return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(MuteStream.prototype, "columns", {
    get: function() {
      return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0;
    },
    enumerable: !0,
    configurable: !0
  }), MuteStream.prototype.pipe = function(dest, options2) {
    return this._dest = dest, Stream2.prototype.pipe.call(this, dest, options2);
  }, MuteStream.prototype.pause = function() {
    if (this._src) return this._src.pause();
  }, MuteStream.prototype.resume = function() {
    if (this._src) return this._src.resume();
  }, MuteStream.prototype.write = function(c2) {
    if (this.muted) {
      if (!this.replace) return !0;
      if (c2.match(/^\u001b/))
        return c2.indexOf(this._prompt) === 0 && (c2 = c2.substr(this._prompt.length), c2 = c2.replace(/./g, this.replace), c2 = this._prompt + c2), this._hadControl = !0, this.emit("data", c2);
      this._prompt && this._hadControl && c2.indexOf(this._prompt) === 0 && (this._hadControl = !1, this.emit("data", this._prompt), c2 = c2.substr(this._prompt.length)), c2 = c2.toString().replace(/./g, this.replace);
    }
    this.emit("data", c2);
  }, MuteStream.prototype.end = function(c2) {
    this.muted && (c2 && this.replace ? c2 = c2.toString().replace(/./g, this.replace) : c2 = null), c2 && this.emit("data", c2), this.emit("end");
  };
  function proxy(fn) {
    return function() {
      var d = this._dest, s = this._src;
      d && d[fn] && d[fn].apply(d, arguments), s && s[fn] && s[fn].apply(s, arguments);
    };
  }
  return MuteStream.prototype.destroy = proxy("destroy"), MuteStream.prototype.destroySoon = proxy("destroySoon"), MuteStream.prototype.close = proxy("close"), mute;
}
var baseUI, hasRequiredBaseUI;
function requireBaseUI() {
  if (hasRequiredBaseUI) return baseUI;
  hasRequiredBaseUI = 1;
  var _ = requireLodash(), MuteStream = requireMute(), readline2 = require$$2__default$2.default;
  class UI {
    constructor(opt) {
      this.rl || (this.rl = readline2.createInterface(setupReadlineOptions(opt))), this.rl.resume(), this.onForceClose = this.onForceClose.bind(this), process.on("exit", this.onForceClose), this.rl.on("SIGINT", this.onForceClose);
    }
    /**
     * Handle the ^C exit
     * @return {null}
     */
    onForceClose() {
      this.close(), process.kill(process.pid, "SIGINT"), console.log("");
    }
    /**
     * Close the interface and cleanup listeners
     */
    close() {
      this.rl.removeListener("SIGINT", this.onForceClose), process.removeListener("exit", this.onForceClose), this.rl.output.unmute(), this.activePrompt && typeof this.activePrompt.close == "function" && this.activePrompt.close(), this.rl.output.end(), this.rl.pause(), this.rl.close();
    }
  }
  function setupReadlineOptions(opt) {
    opt = opt || {};
    var input2 = opt.input || process.stdin, ms = new MuteStream();
    ms.pipe(opt.output || process.stdout);
    var output = ms;
    return _.extend(
      {
        terminal: !0,
        input: input2,
        output
      },
      _.omit(opt, ["input", "output"])
    );
  }
  return baseUI = UI, baseUI;
}
var readline = {}, ansiEscapes = { exports: {} }, hasRequiredAnsiEscapes;
function requireAnsiEscapes() {
  return hasRequiredAnsiEscapes || (hasRequiredAnsiEscapes = 1, function(module2) {
    const x = module2.exports, ESC = "\x1B[", OSC = "\x1B]", BEL = "\x07", SEP = ";", isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    x.cursorTo = (x2, y) => {
      if (typeof x2 != "number")
        throw new TypeError("The `x` argument is required");
      return typeof y != "number" ? ESC + (x2 + 1) + "G" : ESC + (y + 1) + ";" + (x2 + 1) + "H";
    }, x.cursorMove = (x2, y) => {
      if (typeof x2 != "number")
        throw new TypeError("The `x` argument is required");
      let ret = "";
      return x2 < 0 ? ret += ESC + -x2 + "D" : x2 > 0 && (ret += ESC + x2 + "C"), y < 0 ? ret += ESC + -y + "A" : y > 0 && (ret += ESC + y + "B"), ret;
    }, x.cursorUp = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "A", x.cursorDown = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "B", x.cursorForward = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "C", x.cursorBackward = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "D", x.cursorLeft = ESC + "G", x.cursorSavePosition = ESC + (isTerminalApp ? "7" : "s"), x.cursorRestorePosition = ESC + (isTerminalApp ? "8" : "u"), x.cursorGetPosition = ESC + "6n", x.cursorNextLine = ESC + "E", x.cursorPrevLine = ESC + "F", x.cursorHide = ESC + "?25l", x.cursorShow = ESC + "?25h", x.eraseLines = (count2) => {
      let clear = "";
      for (let i = 0; i < count2; i++)
        clear += x.eraseLine + (i < count2 - 1 ? x.cursorUp() : "");
      return count2 && (clear += x.cursorLeft), clear;
    }, x.eraseEndLine = ESC + "K", x.eraseStartLine = ESC + "1K", x.eraseLine = ESC + "2K", x.eraseDown = ESC + "J", x.eraseUp = ESC + "1J", x.eraseScreen = ESC + "2J", x.scrollUp = ESC + "S", x.scrollDown = ESC + "T", x.clearScreen = "\x1Bc", x.clearTerminal = process.platform === "win32" ? `${x.eraseScreen}${ESC}0f` : (
      // 1. Erases the screen (Only done in case `2` is not supported)
      // 2. Erases the whole screen including scrollback buffer
      // 3. Moves cursor to the top-left position
      // More info: https://www.real-world-systems.com/docs/ANSIcode.html
      `${x.eraseScreen}${ESC}3J${ESC}H`
    ), x.beep = BEL, x.link = (text, url) => [
      OSC,
      "8",
      SEP,
      SEP,
      url,
      BEL,
      text,
      OSC,
      "8",
      SEP,
      SEP,
      BEL
    ].join(""), x.image = (buf, opts) => {
      opts = opts || {};
      let ret = OSC + "1337;File=inline=1";
      return opts.width && (ret += `;width=${opts.width}`), opts.height && (ret += `;height=${opts.height}`), opts.preserveAspectRatio === !1 && (ret += ";preserveAspectRatio=0"), ret + ":" + buf.toString("base64") + BEL;
    }, x.iTerm = {}, x.iTerm.setCwd = (cwd) => OSC + "50;CurrentDir=" + (cwd || process.cwd()) + BEL;
  }(ansiEscapes)), ansiEscapes.exports;
}
var hasRequiredReadline;
function requireReadline() {
  if (hasRequiredReadline) return readline;
  hasRequiredReadline = 1;
  var ansiEscapes2 = requireAnsiEscapes();
  return readline.left = function(rl, x) {
    rl.output.write(ansiEscapes2.cursorBackward(x));
  }, readline.right = function(rl, x) {
    rl.output.write(ansiEscapes2.cursorForward(x));
  }, readline.up = function(rl, x) {
    rl.output.write(ansiEscapes2.cursorUp(x));
  }, readline.down = function(rl, x) {
    rl.output.write(ansiEscapes2.cursorDown(x));
  }, readline.clearLine = function(rl, len) {
    rl.output.write(ansiEscapes2.eraseLines(len));
  }, readline;
}
var bottomBar, hasRequiredBottomBar;
function requireBottomBar() {
  if (hasRequiredBottomBar) return bottomBar;
  hasRequiredBottomBar = 1;
  var through2 = requireThrough(), Base = requireBaseUI(), rlUtils = requireReadline(), _ = requireLodash();
  class BottomBar extends Base {
    constructor(opt) {
      opt = opt || {}, super(opt), this.log = through2(this.writeLog.bind(this)), this.bottomBar = opt.bottomBar || "", this.render();
    }
    /**
     * Render the prompt to screen
     * @return {BottomBar} self
     */
    render() {
      return this.write(this.bottomBar), this;
    }
    clean() {
      return rlUtils.clearLine(this.rl, this.bottomBar.split(`
`).length), this;
    }
    /**
     * Update the bottom bar content and rerender
     * @param  {String} bottomBar Bottom bar content
     * @return {BottomBar}           self
     */
    updateBottomBar(bottomBar2) {
      return rlUtils.clearLine(this.rl, 1), this.rl.output.unmute(), this.clean(), this.bottomBar = bottomBar2, this.render(), this.rl.output.mute(), this;
    }
    /**
     * Write out log data
     * @param {String} data - The log data to be output
     * @return {BottomBar} self
     */
    writeLog(data) {
      return this.rl.output.unmute(), this.clean(), this.rl.output.write(this.enforceLF(data.toString())), this.render(), this.rl.output.mute(), this;
    }
    /**
     * Make sure line end on a line feed
     * @param  {String} str Input string
     * @return {String}     The input string with a final line feed
     */
    enforceLF(str2) {
      return str2.match(/[\r\n]$/) ? str2 : str2 + `
`;
    }
    /**
     * Helper for writing message in Prompt
     * @param {BottomBar} prompt  - The Prompt object that extends tty
     * @param {String} message - The message to be output
     */
    write(message) {
      var msgLines = message.split(/\n/);
      this.height = msgLines.length, this.rl.setPrompt(_.last(msgLines)), this.rl.output.rows === 0 && this.rl.output.columns === 0 && rlUtils.left(this.rl, message.length + this.rl.line.length), this.rl.output.write(message);
    }
  }
  return bottomBar = BottomBar, bottomBar;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
  }, extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function isFunction(x) {
  return typeof x == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$1 = {
  closed: !0,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling)
      throw err;
    hostReportError(err);
  },
  complete: function() {
  }
}, isArray = /* @__PURE__ */ function() {
  return Array.isArray || function(x) {
    return x && typeof x.length == "number";
  };
}();
function isObject(x) {
  return x !== null && typeof x == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors) {
    return Error.call(this), this.message = errors ? errors.length + ` errors occurred during unsubscription:
` + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = errors, this;
  }
  return UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), UnsubscriptionErrorImpl2;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, unsubscribe && (this._ctorUnsubscribe = !0, this._unsubscribe = unsubscribe);
  }
  return Subscription2.prototype.unsubscribe = function() {
    var errors;
    if (!this.closed) {
      var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, _parentOrParents instanceof Subscription2)
        _parentOrParents.remove(this);
      else if (_parentOrParents !== null)
        for (var index = 0; index < _parentOrParents.length; ++index) {
          var parent_1 = _parentOrParents[index];
          parent_1.remove(this);
        }
      if (isFunction(_unsubscribe)) {
        _ctorUnsubscribe && (this._unsubscribe = void 0);
        try {
          _unsubscribe.call(this);
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
        }
      }
      if (isArray(_subscriptions))
        for (var index = -1, len = _subscriptions.length; ++index < len; ) {
          var sub = _subscriptions[index];
          if (isObject(sub))
            try {
              sub.unsubscribe();
            } catch (e) {
              errors = errors || [], e instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(e.errors)) : errors.push(e);
            }
        }
      if (errors)
        throw new UnsubscriptionError(errors);
    }
  }, Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown)
      return Subscription2.EMPTY;
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe != "function")
          return subscription;
        if (this.closed)
          return subscription.unsubscribe(), subscription;
        if (!(subscription instanceof Subscription2)) {
          var tmp2 = subscription;
          subscription = new Subscription2(), subscription._subscriptions = [tmp2];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null)
      subscription._parentOrParents = this;
    else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this)
        return subscription;
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1)
      _parentOrParents.push(this);
    else
      return subscription;
    var subscriptions = this._subscriptions;
    return subscriptions === null ? this._subscriptions = [subscription] : subscriptions.push(subscription), subscription;
  }, Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      subscriptionIndex !== -1 && subscriptions.splice(subscriptionIndex, 1);
    }
  }, Subscription2.EMPTY = function(empty2) {
    return empty2.closed = !0, empty2;
  }(new Subscription2()), Subscription2;
}();
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, _this.isStopped = !1, arguments.length) {
      case 0:
        _this.destination = empty$1;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$1;
          break;
        }
        if (typeof destinationOrNext == "object") {
          destinationOrNext instanceof Subscriber2 ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, _this.destination = destinationOrNext, destinationOrNext.add(_this)) : (_this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext));
          break;
        }
      default:
        _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error2, complete);
        break;
    }
    return _this;
  }
  return Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  }, Subscriber2.create = function(next, error2, complete) {
    var subscriber = new Subscriber2(next, error2, complete);
    return subscriber.syncErrorThrowable = !1, subscriber;
  }, Subscriber2.prototype.next = function(value) {
    this.isStopped || this._next(value);
  }, Subscriber2.prototype.error = function(err) {
    this.isStopped || (this.isStopped = !0, this._error(err));
  }, Subscriber2.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, Subscriber2.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
  }, Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  }, Subscriber2.prototype._error = function(err) {
    this.destination.error(err), this.unsubscribe();
  }, Subscriber2.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = _parentOrParents, this;
  }, Subscriber2;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next, context = _this;
    return isFunction(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, error2 = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== empty$1 && (context = Object.create(observerOrNext), isFunction(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, _this._next = next, _this._error = error2, _this._complete = complete, _this;
  }
  return SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      !config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable ? this.__tryOrUnsub(this._next, value) : this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe();
    }
  }, SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable ? (this.__tryOrUnsub(this._error, err), this.unsubscribe()) : (this.__tryOrSetError(_parentSubscriber, this._error, err), this.unsubscribe());
      else if (_parentSubscriber.syncErrorThrowable)
        useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, _parentSubscriber.syncErrorThrown = !0) : hostReportError(err), this.unsubscribe();
      else {
        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling)
          throw err;
        hostReportError(err);
      }
    }
  }, SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        !config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable ? (this.__tryOrUnsub(wrappedComplete), this.unsubscribe()) : (this.__tryOrSetError(_parentSubscriber, wrappedComplete), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (this.unsubscribe(), config.useDeprecatedSynchronousErrorHandling)
        throw err;
      hostReportError(err);
    }
  }, SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
    if (!config.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      fn.call(this._context, value);
    } catch (err) {
      return config.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, parent.syncErrorThrown = !0, !0) : (hostReportError(err), !0);
    }
    return !1;
  }, SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
  }, SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  for (; observer; ) {
    var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
    if (closed_1 || isStopped)
      return !1;
    destination && destination instanceof Subscriber ? observer = destination : observer = null;
  }
  return !0;
}
function toSubscriber(nextOrObserver, error2, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber)
      return nextOrObserver;
    if (nextOrObserver[rxSubscriber])
      return nextOrObserver[rxSubscriber]();
  }
  return !nextOrObserver && !error2 && !complete ? new Subscriber(empty$1) : new Subscriber(nextOrObserver, error2, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipe() {
  for (var fns = [], _i = 0; _i < arguments.length; _i++)
    fns[_i] = arguments[_i];
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  return fns.length === 0 ? identity : fns.length === 1 ? fns[0] : function(input2) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input2);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe) {
    this._isScalar = !1, subscribe && (this._subscribe = subscribe);
  }
  return Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    return observable2.source = this, observable2.operator = operator, observable2;
  }, Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var operator = this.operator, sink = toSubscriber(observerOrNext, error2, complete);
    if (operator ? sink.add(operator.call(sink, this.source)) : sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), config.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, sink.syncErrorThrown))
      throw sink.syncErrorValue;
    return sink;
  }, Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      config.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), canReportError(sink) ? sink.error(err) : console.warn(err);
    }
  }, Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    return promiseCtor = getPromiseCtor(promiseCtor), new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err), subscription && subscription.unsubscribe();
        }
      }, reject, resolve);
    });
  }, Observable2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    return source2 && source2.subscribe(subscriber);
  }, Observable2.prototype[observable] = function() {
    return this;
  }, Observable2.prototype.pipe = function() {
    for (var operations = [], _i = 0; _i < arguments.length; _i++)
      operations[_i] = arguments[_i];
    return operations.length === 0 ? this : pipeFromArray(operations)(this);
  }, Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    return promiseCtor = getPromiseCtor(promiseCtor), new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  }, Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  }, Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (promiseCtor || (promiseCtor = config.Promise || Promise), !promiseCtor)
    throw new Error("no Promise impl found");
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), ObjectUnsubscribedErrorImpl2;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, _this;
  }
  return SubjectSubscription2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var subject = this.subject, observers = subject.observers;
      if (this.subject = null, !(!observers || observers.length === 0 || subject.isStopped || subject.closed)) {
        var subscriberIndex = observers.indexOf(this.subscriber);
        subscriberIndex !== -1 && observers.splice(subscriberIndex, 1);
      }
    }
  }, SubjectSubscription2;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this;
  }
  return SubjectSubscriber2;
}(Subscriber), Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, _this.thrownError = null, _this;
  }
  return Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    return subject.operator = operator, subject;
  }, Subject2.prototype.next = function(value) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var observers = this.observers, len = observers.length, copy2 = observers.slice(), i = 0; i < len; i++)
        copy2[i].next(value);
  }, Subject2.prototype.error = function(err) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = err, this.isStopped = !0;
    for (var observers = this.observers, len = observers.length, copy2 = observers.slice(), i = 0; i < len; i++)
      copy2[i].error(err);
    this.observers.length = 0;
  }, Subject2.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var observers = this.observers, len = observers.length, copy2 = observers.slice(), i = 0; i < len; i++)
      copy2[i].complete();
    this.observers.length = 0;
  }, Subject2.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return _super.prototype._trySubscribe.call(this, subscriber);
  }, Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (subscriber.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (subscriber.complete(), Subscription.EMPTY) : (this.observers.push(subscriber), new SubjectSubscription(this, subscriber));
  }, Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    return observable2.source = this, observable2;
  }, Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  }, Subject2;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    return _this.destination = destination, _this.source = source2, _this;
  }
  return AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    destination && destination.next && destination.next(value);
  }, AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    destination && destination.error && this.destination.error(err);
  }, AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    destination && destination.complete && this.destination.complete();
  }, AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    return source2 ? this.source.subscribe(subscriber) : Subscription.EMPTY;
  }, AnonymousSubject2;
}(Subject);
function refCount() {
  return function(source2) {
    return source2.lift(new RefCountOperator(source2));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  return RefCountOperator2.prototype.call = function(subscriber, source2) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source2.subscribe(refCounter);
    return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
  }, RefCountOperator2;
}(), RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    return _this.connectable = connectable, _this;
  }
  return RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    if (connectable._refCount = refCount2 - 1, refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection, sharedConnection = connectable._connection;
    this.connection = null, sharedConnection && (!connection || sharedConnection === connection) && sharedConnection.unsubscribe();
  }, RefCountSubscriber2;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source2, subjectFactory) {
    var _this = _super.call(this) || this;
    return _this.source = source2, _this.subjectFactory = subjectFactory, _this._refCount = 0, _this._isComplete = !1, _this;
  }
  return ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  }, ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    return (!subject || subject.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    return connection || (this._isComplete = !1, connection = this._connection = new Subscription(), connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), connection.closed && (this._connection = null, connection = Subscription.EMPTY)), connection;
  }, ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  }, ConnectableObservable2;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: !0 },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    return _this.connectable = connectable, _this;
  }
  return ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe(), _super.prototype._error.call(this, err);
  }, ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
  }, ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0, connectable._subject = null, connectable._connection = null, connection && connection.unsubscribe();
    }
  }, ConnectableSubscriber2;
}(SubjectSubscriber);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source2) {
    return source2.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector, this.elementSelector = elementSelector, this.durationSelector = durationSelector, this.subjectSelector = subjectSelector;
  }
  return GroupByOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, GroupByOperator2;
}(), GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.keySelector = keySelector, _this.elementSelector = elementSelector, _this.durationSelector = durationSelector, _this.subjectSelector = subjectSelector, _this.groups = null, _this.attemptedToUnsubscribe = !1, _this.count = 0, _this;
  }
  return GroupBySubscriber2.prototype._next = function(value) {
    var key2;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key2);
  }, GroupBySubscriber2.prototype._group = function(value, key2) {
    var groups = this.groups;
    groups || (groups = this.groups = /* @__PURE__ */ new Map());
    var group = groups.get(key2), element;
    if (this.elementSelector)
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    else
      element = value;
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject(), groups.set(key2, group);
      var groupedObservable = new GroupedObservable(key2, group, this);
      if (this.destination.next(groupedObservable), this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key2, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
      }
    }
    group.closed || group.next(element);
  }, GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    groups && (groups.forEach(function(group, key2) {
      group.error(err);
    }), groups.clear()), this.destination.error(err);
  }, GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    groups && (groups.forEach(function(group, key2) {
      group.complete();
    }), groups.clear()), this.destination.complete();
  }, GroupBySubscriber2.prototype.removeGroup = function(key2) {
    this.groups.delete(key2);
  }, GroupBySubscriber2.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && _super.prototype.unsubscribe.call(this));
  }, GroupBySubscriber2;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key2, group, parent) {
    var _this = _super.call(this, group) || this;
    return _this.key = key2, _this.group = group, _this.parent = parent, _this;
  }
  return GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  }, GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a = this, parent = _a.parent, key2 = _a.key;
    this.key = this.parent = null, parent && parent.removeGroup(key2);
  }, GroupDurationSubscriber2;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key2, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    return _this.key = key2, _this.groupSubject = groupSubject, _this.refCountSubscription = refCountSubscription, _this;
  }
  return GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription(), _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
    return refCountSubscription && !refCountSubscription.closed && subscription.add(new InnerRefCountSubscription(refCountSubscription)), subscription.add(groupSubject.subscribe(subscriber)), subscription;
  }, GroupedObservable2;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, parent.count++, _this;
  }
  return InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent = this.parent;
    !parent.closed && !this.closed && (_super.prototype.unsubscribe.call(this), parent.count -= 1, parent.count === 0 && parent.attemptedToUnsubscribe && parent.unsubscribe());
  }, InnerRefCountSubscription2;
}(Subscription), BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    return _this._value = _value, _this;
  }
  return Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    return subscription && !subscription.closed && subscriber.next(this._value), subscription;
  }, BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  }, BehaviorSubject2;
}(Subject), Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  return Action2.prototype.schedule = function(state, delay2) {
    return this;
  }, Action2;
}(Subscription), AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
  }
  return AsyncAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0 && (delay2 = 0), this.closed)
      return this;
    this.state = state;
    var id = this.id, scheduler = this.scheduler;
    return id != null && (this.id = this.recycleAsyncId(scheduler, id, delay2)), this.pending = !0, this.delay = delay2, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2), this;
  }, AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), setInterval(scheduler.flush.bind(scheduler, this), delay2);
  }, AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0 && (delay2 = 0), delay2 !== null && this.delay === delay2 && this.pending === !1)
      return id;
    clearInterval(id);
  }, AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var error2 = this._execute(state, delay2);
    if (error2)
      return error2;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, AsyncAction2.prototype._execute = function(state, delay2) {
    var errored = !1, errorValue = void 0;
    try {
      this.work(state);
    } catch (e) {
      errored = !0, errorValue = !!e && e || new Error(e);
    }
    if (errored)
      return this.unsubscribe(), errorValue;
  }, AsyncAction2.prototype._unsubscribe = function() {
    var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, index !== -1 && actions.splice(index, 1), id != null && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
  }, AsyncAction2;
}(Action), QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this;
  }
  return QueueAction2.prototype.schedule = function(state, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 > 0 ? _super.prototype.schedule.call(this, state, delay2) : (this.delay = delay2, this.state = state, this.scheduler.flush(this), this);
  }, QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  }, QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay2) : scheduler.flush(this);
  }, QueueAction2;
}(AsyncAction), Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    now === void 0 && (now = Scheduler2.now), this.SchedulerAction = SchedulerAction, this.now = now;
  }
  return Scheduler2.prototype.schedule = function(work, delay2, state) {
    return delay2 === void 0 && (delay2 = 0), new this.SchedulerAction(this, work).schedule(state, delay2);
  }, Scheduler2.now = function() {
    return Date.now();
  }, Scheduler2;
}(), AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    now === void 0 && (now = Scheduler.now);
    var _this = _super.call(this, SchedulerAction, function() {
      return AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this ? AsyncScheduler2.delegate.now() : now();
    }) || this;
    return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
  }
  return AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
    return delay2 === void 0 && (delay2 = 0), AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this ? AsyncScheduler2.delegate.schedule(work, delay2, state) : _super.prototype.schedule.call(this, work, delay2, state);
  }, AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error2;
    this.active = !0;
    do
      if (error2 = action.execute(action.state, action.delay))
        break;
    while (action = actions.shift());
    if (this.active = !1, error2) {
      for (; action = actions.shift(); )
        action.unsubscribe();
      throw error2;
    }
  }, AsyncScheduler2;
}(Scheduler), QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue = queueScheduler, EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value) {
  return value && typeof value.schedule == "function";
}
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++)
      subscriber.next(array[i]);
    subscriber.complete();
  };
};
function scheduleArray(input2, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription(), i = 0;
    return sub.add(scheduler.schedule(function() {
      if (i === input2.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input2[i++]), subscriber.closed || sub.add(this.schedule());
    })), sub;
  });
}
function fromArray(input2, scheduler) {
  return scheduler ? scheduleArray(input2, scheduler) : new Observable(subscribeToArray(input2));
}
function of() {
  for (var args = [], _i = 0; _i < arguments.length; _i++)
    args[_i] = arguments[_i];
  var scheduler = args[args.length - 1];
  return isScheduler(scheduler) ? (args.pop(), scheduleArray(args, scheduler)) : fromArray(args);
}
function throwError(error2, scheduler) {
  return scheduler ? new Observable(function(subscriber) {
    return scheduler.schedule(dispatch$7, 0, { error: error2, subscriber });
  }) : new Observable(function(subscriber) {
    return subscriber.error(error2);
  });
}
function dispatch$7(_a) {
  var error2 = _a.error, subscriber = _a.subscriber;
  subscriber.error(error2);
}
var NotificationKind;
NotificationKind || (NotificationKind = {});
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error2) {
    this.kind = kind, this.value = value, this.error = error2, this.hasValue = kind === "N";
  }
  return Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  }, Notification2.prototype.do = function(next, error2, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error2 && error2(this.error);
      case "C":
        return complete && complete();
    }
  }, Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
    return nextOrObserver && typeof nextOrObserver.next == "function" ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
  }, Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty();
    }
    throw new Error("unexpected notification kind value");
  }, Notification2.createNext = function(value) {
    return typeof value < "u" ? new Notification2("N", value) : Notification2.undefinedValueNotification;
  }, Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  }, Notification2.createComplete = function() {
    return Notification2.completeNotification;
  }, Notification2.completeNotification = new Notification2("C"), Notification2.undefinedValueNotification = new Notification2("N", void 0), Notification2;
}();
function observeOn(scheduler, delay2) {
  return delay2 === void 0 && (delay2 = 0), function(source2) {
    return source2.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler, delay2) {
    delay2 === void 0 && (delay2 = 0), this.scheduler = scheduler, this.delay = delay2;
  }
  return ObserveOnOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  }, ObserveOnOperator2;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay2) {
    delay2 === void 0 && (delay2 = 0);
    var _this = _super.call(this, destination) || this;
    return _this.scheduler = scheduler, _this.delay = delay2, _this;
  }
  return ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination), this.unsubscribe();
  }, ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  }, ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  }, ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err)), this.unsubscribe();
  }, ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, ObserveOnSubscriber2;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification, this.destination = destination;
  }
  return ObserveOnMessage2;
}(), ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler) {
    bufferSize === void 0 && (bufferSize = Number.POSITIVE_INFINITY), windowTime2 === void 0 && (windowTime2 = Number.POSITIVE_INFINITY);
    var _this = _super.call(this) || this;
    return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime2 < 1 ? 1 : windowTime2, windowTime2 === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, _this;
  }
  return ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value), _events.length > this._bufferSize && _events.shift();
    }
    _super.prototype.next.call(this, value);
  }, ReplaySubject2.prototype.nextTimeWindow = function(value) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents()), _super.prototype.next.call(this, value);
  }, ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length, subscription;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? subscription = Subscription.EMPTY : (this.observers.push(subscriber), subscription = new SubjectSubscription(this, subscriber)), scheduler && subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler)), _infiniteTimeWindow)
      for (var i = 0; i < len && !subscriber.closed; i++)
        subscriber.next(_events[i]);
    else
      for (var i = 0; i < len && !subscriber.closed; i++)
        subscriber.next(_events[i].value);
    return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), subscription;
  }, ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  }, ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); )
      spliceCount++;
    return eventsCount > _bufferSize && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), spliceCount > 0 && _events.splice(0, spliceCount), _events;
  }, ReplaySubject2;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value) {
    this.time = time, this.value = value;
  }
  return ReplayEvent2;
}(), AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this.value = null, _this.hasNext = !1, _this.hasCompleted = !1, _this;
  }
  return AsyncSubject2.prototype._subscribe = function(subscriber) {
    return this.hasError ? (subscriber.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (subscriber.next(this.value), subscriber.complete(), Subscription.EMPTY) : _super.prototype._subscribe.call(this, subscriber);
  }, AsyncSubject2.prototype.next = function(value) {
    this.hasCompleted || (this.value = value, this.hasNext = !0);
  }, AsyncSubject2.prototype.error = function(error2) {
    this.hasCompleted || _super.prototype.error.call(this, error2);
  }, AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && _super.prototype.next.call(this, this.value), _super.prototype.complete.call(this);
  }, AsyncSubject2;
}(Subject), nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(handle) {
  return handle in activeHandles ? (delete activeHandles[handle], !0) : !1;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    return activeHandles[handle] = !0, RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb();
    }), handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
}, AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this;
  }
  return AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay2) : (scheduler.actions.push(this), scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null))));
  }, AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0)
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    scheduler.actions.length === 0 && (Immediate.clearImmediate(id), scheduler.scheduled = void 0);
  }, AsapAction2;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return AsapScheduler2.prototype.flush = function(action) {
    this.active = !0, this.scheduled = void 0;
    var actions = this.actions, error2, index = -1, count2 = actions.length;
    action = action || actions.shift();
    do
      if (error2 = action.execute(action.state, action.delay))
        break;
    while (++index < count2 && (action = actions.shift()));
    if (this.active = !1, error2) {
      for (; ++index < count2 && (action = actions.shift()); )
        action.unsubscribe();
      throw error2;
    }
  }, AsapScheduler2;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async = asyncScheduler, AnimationFrameAction = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this;
  }
  return AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay2) : (scheduler.actions.push(this), scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
      return scheduler.flush(null);
    })));
  }, AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0)
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    scheduler.actions.length === 0 && (cancelAnimationFrame(id), scheduler.scheduled = void 0);
  }, AnimationFrameAction2;
}(AsyncAction), AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = !0, this.scheduled = void 0;
    var actions = this.actions, error2, index = -1, count2 = actions.length;
    action = action || actions.shift();
    do
      if (error2 = action.execute(action.state, action.delay))
        break;
    while (++index < count2 && (action = actions.shift()));
    if (this.active = !1, error2) {
      for (; ++index < count2 && (action = actions.shift()); )
        action.unsubscribe();
      throw error2;
    }
  }, AnimationFrameScheduler2;
}(AsyncScheduler), animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction), animationFrame = animationFrameScheduler, VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    SchedulerAction === void 0 && (SchedulerAction = VirtualAction), maxFrames === void 0 && (maxFrames = Number.POSITIVE_INFINITY);
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    return _this.maxFrames = maxFrames, _this.frame = 0, _this.index = -1, _this;
  }
  return VirtualTimeScheduler2.prototype.flush = function() {
    for (var _a = this, actions = _a.actions, maxFrames = _a.maxFrames, error2, action; (action = actions[0]) && action.delay <= maxFrames && (actions.shift(), this.frame = action.delay, !(error2 = action.execute(action.state, action.delay))); )
      ;
    if (error2) {
      for (; action = actions.shift(); )
        action.unsubscribe();
      throw error2;
    }
  }, VirtualTimeScheduler2.frameTimeFactor = 10, VirtualTimeScheduler2;
}(AsyncScheduler), VirtualAction = /* @__PURE__ */ function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    index === void 0 && (index = scheduler.index += 1);
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this.index = index, _this.active = !0, _this.index = scheduler.index = index, _this;
  }
  return VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0 && (delay2 = 0), !this.id)
      return _super.prototype.schedule.call(this, state, delay2);
    this.active = !1;
    var action = new VirtualAction2(this.scheduler, this.work);
    return this.add(action), action.schedule(state, delay2);
  }, VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    delay2 === void 0 && (delay2 = 0), this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    return actions.push(this), actions.sort(VirtualAction2.sortActions), !0;
  }, VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
  }, VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === !0)
      return _super.prototype._execute.call(this, state, delay2);
  }, VirtualAction2.sortActions = function(a, b) {
    return a.delay === b.delay ? a.index === b.index ? 0 : a.index > b.index ? 1 : -1 : a.delay > b.delay ? 1 : -1;
  }, VirtualAction2;
}(AsyncAction);
function noop() {
}
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift == "function" && typeof obj.subscribe == "function");
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), ArgumentOutOfRangeErrorImpl2;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl, EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), EmptyErrorImpl2;
}(), EmptyError = EmptyErrorImpl, TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), TimeoutErrorImpl2;
}(), TimeoutError = TimeoutErrorImpl;
function map(project, thisArg) {
  return function(source2) {
    if (typeof project != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return source2.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project, this.thisArg = thisArg;
  }
  return MapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  }, MapOperator2;
}(), MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, _this;
  }
  return MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, MapSubscriber2;
}(Subscriber);
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector)
    if (isScheduler(resultSelector))
      scheduler = resultSelector;
    else
      return function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
  return function() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    var context = this, subject, params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (scheduler) {
        var state = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch$6, 0, state);
      } else {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            for (var innerArgs = [], _i2 = 0; _i2 < arguments.length; _i2++)
              innerArgs[_i2] = arguments[_i2];
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs), subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            canReportError(subject) ? subject.error(err) : console.warn(err);
          }
        }
        return subject.subscribe(subscriber);
      }
    });
  };
}
function dispatch$6(state) {
  var _this = this, args = state.args, subscriber = state.subscriber, params = state.params, callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler, subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      for (var innerArgs = [], _i = 0; _i < arguments.length; _i++)
        innerArgs[_i] = arguments[_i];
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext$3, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$3(state) {
  var value = state.value, subject = state.subject;
  subject.next(value), subject.complete();
}
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector)
    if (isScheduler(resultSelector))
      scheduler = resultSelector;
    else
      return function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
  return function() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context, subject = params.subject;
      if (scheduler)
        return scheduler.schedule(dispatch$5, 0, { params, subscriber, context });
      if (!subject) {
        subject = params.subject = new AsyncSubject();
        var handler = function() {
          for (var innerArgs = [], _i2 = 0; _i2 < arguments.length; _i2++)
            innerArgs[_i2] = arguments[_i2];
          var err = innerArgs.shift();
          if (err) {
            subject.error(err);
            return;
          }
          subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs), subject.complete();
        };
        try {
          callbackFunc.apply(context, args.concat([handler]));
        } catch (err) {
          canReportError(subject) ? subject.error(err) : console.warn(err);
        }
      }
      return subject.subscribe(subscriber);
    });
  };
}
function dispatch$5(state) {
  var _this = this, params = state.params, subscriber = state.subscriber, context = state.context, callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler, subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      for (var innerArgs = [], _i = 0; _i < arguments.length; _i++)
        innerArgs[_i] = arguments[_i];
      var err = innerArgs.shift();
      if (err)
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext$2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value), subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }, OuterSubscriber2.prototype.notifyError = function(error2, innerSub) {
    this.destination.error(error2);
  }, OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  }, OuterSubscriber2;
}(Subscriber), InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, _this.index = 0, _this;
  }
  return InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  }, InnerSubscriber2.prototype._error = function(error2) {
    this.parent.notifyError(error2, this), this.unsubscribe();
  }, InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, InnerSubscriber2;
}(Subscriber), subscribeToPromise = function(promise2) {
  return function(subscriber) {
    return promise2.then(function(value) {
      subscriber.closed || (subscriber.next(value), subscriber.complete());
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError), subscriber;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$12 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$12.next();
      } catch (err) {
        return subscriber.error(err), subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      if (subscriber.next(item.value), subscriber.closed)
        break;
    } while (!0);
    return typeof iterator$12.return == "function" && subscriber.add(function() {
      iterator$12.return && iterator$12.return();
    }), subscriber;
  };
}, subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return obs.subscribe(subscriber);
  };
}, isArrayLike = function(x) {
  return x && typeof x.length == "number" && typeof x != "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe != "function" && typeof value.then == "function";
}
var subscribeTo = function(result) {
  if (result && typeof result[observable] == "function")
    return subscribeToObservable(result);
  if (isArrayLike(result))
    return subscribeToArray(result);
  if (isPromise(result))
    return subscribeToPromise(result);
  if (result && typeof result[iterator] == "function")
    return subscribeToIterable(result);
  var value = isObject(result) ? "an invalid object" : "'" + result + "'", msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(msg);
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0 && (innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)), !innerSubscriber.closed)
    return result instanceof Observable ? result.subscribe(innerSubscriber) : subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var resultSelector = void 0, scheduler = void 0;
  return isScheduler(observables[observables.length - 1]) && (scheduler = observables.pop()), typeof observables[observables.length - 1] == "function" && (resultSelector = observables.pop()), observables.length === 1 && isArray(observables[0]) && (observables = observables[0]), fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  return CombineLatestOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  }, CombineLatestOperator2;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], _this.observables = [], _this;
  }
  return CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE), this.observables.push(observable2);
  }, CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables, len = observables.length;
    if (len === 0)
      this.destination.complete();
    else {
      this.active = len, this.toRespond = len;
      for (var i = 0; i < len; i++) {
        var observable2 = observables[i];
        this.add(subscribeToResult(this, observable2, void 0, i));
      }
    }
  }, CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values, oldVal = values[outerIndex], toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
    values[outerIndex] = innerValue, toRespond === 0 && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
  }, CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input2, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    return sub.add(scheduler.schedule(function() {
      var observable$1 = input2[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    })), sub;
  });
}
function schedulePromise(input2, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    return sub.add(scheduler.schedule(function() {
      return input2.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value), sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    })), sub;
  });
}
function scheduleIterable(input2, scheduler) {
  if (!input2)
    throw new Error("Iterable cannot be null");
  return new Observable(function(subscriber) {
    var sub = new Subscription(), iterator$12;
    return sub.add(function() {
      iterator$12 && typeof iterator$12.return == "function" && iterator$12.return();
    }), sub.add(scheduler.schedule(function() {
      iterator$12 = input2[iterator](), sub.add(scheduler.schedule(function() {
        if (!subscriber.closed) {
          var value, done;
          try {
            var result = iterator$12.next();
            value = result.value, done = result.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          done ? subscriber.complete() : (subscriber.next(value), this.schedule());
        }
      }));
    })), sub;
  });
}
function isInteropObservable(input2) {
  return input2 && typeof input2[observable] == "function";
}
function isIterable(input2) {
  return input2 && typeof input2[iterator] == "function";
}
function scheduled(input2, scheduler) {
  if (input2 != null) {
    if (isInteropObservable(input2))
      return scheduleObservable(input2, scheduler);
    if (isPromise(input2))
      return schedulePromise(input2, scheduler);
    if (isArrayLike(input2))
      return scheduleArray(input2, scheduler);
    if (isIterable(input2) || typeof input2 == "string")
      return scheduleIterable(input2, scheduler);
  }
  throw new TypeError((input2 !== null && typeof input2 || input2) + " is not observable");
}
function from(input2, scheduler) {
  return scheduler ? scheduled(input2, scheduler) : input2 instanceof Observable ? input2 : new Observable(subscribeTo(input2));
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, _this;
  }
  return SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  }, SimpleInnerSubscriber2.prototype._error = function(error2) {
    this.parent.notifyError(error2), this.unsubscribe();
  }, SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, SimpleInnerSubscriber2;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  }, SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  }, SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (!innerSubscriber.closed) {
    if (result instanceof Observable)
      return result.subscribe(innerSubscriber);
    var subscription;
    try {
      subscription = subscribeTo(result)(innerSubscriber);
    } catch (error2) {
      innerSubscriber.error(error2);
    }
    return subscription;
  }
}
function mergeMap(project, resultSelector, concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), typeof resultSelector == "function" ? function(source2) {
    return source2.pipe(mergeMap(function(a, i) {
      return from(project(a, i)).pipe(map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      }));
    }, concurrent));
  } : (typeof resultSelector == "number" && (concurrent = resultSelector), function(source2) {
    return source2.lift(new MergeMapOperator(project, concurrent));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), this.project = project, this.concurrent = concurrent;
  }
  return MergeMapOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  }, MergeMapOperator2;
}(), MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY);
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, _this.buffer = [], _this.active = 0, _this.index = 0, _this;
  }
  return MergeMapSubscriber2.prototype._next = function(value) {
    this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
  }, MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result, index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++, this._innerSub(result);
  }, MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    innerSubscription !== innerSubscriber && destination.add(innerSubscription);
  }, MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--, buffer2.length > 0 ? this._next(buffer2.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, MergeMapSubscriber2;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return concatAll()(of.apply(void 0, observables));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input2;
    try {
      input2 = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return;
    }
    var source2 = input2 ? from(input2) : empty();
    return source2.subscribe(subscriber);
  });
}
function forkJoin() {
  for (var sources = [], _i = 0; _i < arguments.length; _i++)
    sources[_i] = arguments[_i];
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1))
      return forkJoinInternal(first_1, null);
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key2) {
        return first_1[key2];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] == "function") {
    var resultSelector_1 = sources.pop();
    return sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources, forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    for (var values = new Array(len), completed = 0, emitted = 0, _loop_1 = function(i2) {
      var source2 = from(sources[i2]), hasValue = !1;
      subscriber.add(source2.subscribe({
        next: function(value) {
          hasValue || (hasValue = !0, emitted++), values[i2] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++, (completed === len || !hasValue) && (emitted === len && subscriber.next(keys ? keys.reduce(function(result, key2, i3) {
            return result[key2] = values[i3], result;
          }, {}) : values), subscriber.complete());
        }
      }));
    }, i = 0; i < len; i++)
      _loop_1(i);
  });
}
function fromEvent(target, eventName, options2, resultSelector) {
  return isFunction(options2) && (resultSelector = options2, options2 = void 0), resultSelector ? fromEvent(target, eventName, options2).pipe(map(function(args) {
    return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
  })) : new Observable(function(subscriber) {
    function handler(e) {
      arguments.length > 1 ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
    }
    setupSubscription(target, eventName, handler, subscriber, options2);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options2) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options2), unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options2);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler), unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler), unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length)
    for (var i = 0, len = sourceObj.length; i < len; i++)
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options2);
  else
    throw new TypeError("Invalid event target");
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener == "function" && typeof sourceObj.removeListener == "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on == "function" && typeof sourceObj.off == "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener == "function" && typeof sourceObj.removeEventListener == "function";
}
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  return resultSelector ? fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
    return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
  })) : new Observable(function(subscriber) {
    var handler = function() {
      for (var e = [], _i = 0; _i < arguments.length; _i++)
        e[_i] = arguments[_i];
      return subscriber.next(e.length === 1 ? e[0] : e);
    }, retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return;
    }
    if (isFunction(removeHandler))
      return function() {
        return removeHandler(handler, retValue);
      };
  });
}
function generate(initialStateOrOptions, condition, iterate2, resultSelectorOrObservable, scheduler) {
  var resultSelector, initialState;
  if (arguments.length == 1) {
    var options2 = initialStateOrOptions;
    initialState = options2.initialState, condition = options2.condition, iterate2 = options2.iterate, resultSelector = options2.resultSelector || identity, scheduler = options2.scheduler;
  } else resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable) ? (initialState = initialStateOrOptions, resultSelector = identity, scheduler = resultSelectorOrObservable) : (initialState = initialStateOrOptions, resultSelector = resultSelectorOrObservable);
  return new Observable(function(subscriber) {
    var state = initialState;
    if (scheduler)
      return scheduler.schedule(dispatch$4, 0, {
        subscriber,
        iterate: iterate2,
        condition,
        resultSelector,
        state
      });
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return;
      }
      if (subscriber.next(value), subscriber.closed)
        break;
      try {
        state = iterate2(state);
      } catch (err) {
        subscriber.error(err);
        return;
      }
    } while (!0);
  });
}
function dispatch$4(state) {
  var subscriber = state.subscriber, condition = state.condition;
  if (!subscriber.closed) {
    if (state.needIterate)
      try {
        state.state = state.iterate(state.state);
      } catch (err) {
        subscriber.error(err);
        return;
      }
    else
      state.needIterate = !0;
    if (condition) {
      var conditionResult = void 0;
      try {
        conditionResult = condition(state.state);
      } catch (err) {
        subscriber.error(err);
        return;
      }
      if (!conditionResult) {
        subscriber.complete();
        return;
      }
      if (subscriber.closed)
        return;
    }
    var value;
    try {
      value = state.resultSelector(state.state);
    } catch (err) {
      subscriber.error(err);
      return;
    }
    if (!subscriber.closed && (subscriber.next(value), !subscriber.closed))
      return this.schedule(state);
  }
}
function iif(condition, trueResult, falseResult) {
  return trueResult === void 0 && (trueResult = EMPTY), falseResult === void 0 && (falseResult = EMPTY), defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
function interval(period, scheduler) {
  return period === void 0 && (period = 0), scheduler === void 0 && (scheduler = async), (!isNumeric(period) || period < 0) && (period = 0), (!scheduler || typeof scheduler.schedule != "function") && (scheduler = async), new Observable(function(subscriber) {
    return subscriber.add(scheduler.schedule(dispatch$3, period, { subscriber, counter: 0, period })), subscriber;
  });
}
function dispatch$3(state) {
  var subscriber = state.subscriber, counter = state.counter, period = state.period;
  subscriber.next(counter), this.schedule({ subscriber, counter: counter + 1, period }, period);
}
function merge$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last2 = observables[observables.length - 1];
  return isScheduler(last2) ? (scheduler = observables.pop(), observables.length > 1 && typeof observables[observables.length - 1] == "number" && (concurrent = observables.pop())) : typeof last2 == "number" && (concurrent = observables.pop()), scheduler === null && observables.length === 1 && observables[0] instanceof Observable ? observables[0] : mergeAll(concurrent)(fromArray(observables, scheduler));
}
var NEVER = /* @__PURE__ */ new Observable(noop);
function never() {
  return NEVER;
}
function onErrorResumeNext$1() {
  for (var sources = [], _i = 0; _i < arguments.length; _i++)
    sources[_i] = arguments[_i];
  if (sources.length === 0)
    return EMPTY;
  var first2 = sources[0], remainder = sources.slice(1);
  return sources.length === 1 && isArray(first2) ? onErrorResumeNext$1.apply(void 0, first2) : new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
function pairs(obj, scheduler) {
  return scheduler ? new Observable(function(subscriber) {
    var keys = Object.keys(obj), subscription = new Subscription();
    return subscription.add(scheduler.schedule(dispatch$2, 0, { keys, index: 0, subscriber, subscription, obj })), subscription;
  }) : new Observable(function(subscriber) {
    for (var keys = Object.keys(obj), i = 0; i < keys.length && !subscriber.closed; i++) {
      var key2 = keys[i];
      obj.hasOwnProperty(key2) && subscriber.next([key2, obj[key2]]);
    }
    subscriber.complete();
  });
}
function dispatch$2(state) {
  var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
  if (!subscriber.closed)
    if (index < keys.length) {
      var key2 = keys[index];
      subscriber.next([key2, obj[key2]]), subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));
    } else
      subscriber.complete();
}
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  return notPred.pred = pred, notPred.thisArg = thisArg, notPred;
}
function filter(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate, this.thisArg = thisArg;
  }
  return FilterOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  }, FilterOperator2;
}(), FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
  }
  return FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result && this.destination.next(value);
  }, FilterSubscriber2;
}(Subscriber);
function partition$1(source2, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source2))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source2)))
  ];
}
function race$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  if (observables.length === 1)
    if (isArray(observables[0]))
      observables = observables[0];
    else
      return observables[0];
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  return RaceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RaceSubscriber(subscriber));
  }, RaceOperator2;
}(), RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
  }
  return RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  }, RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables, len = observables.length;
    if (len === 0)
      this.destination.complete();
    else {
      for (var i = 0; i < len && !this.hasFirst; i++) {
        var observable2 = observables[i], subscription = subscribeToResult(this, observable2, void 0, i);
        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
      }
      this.observables = null;
    }
  }, RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var i = 0; i < this.subscriptions.length; i++)
        if (i !== outerIndex) {
          var subscription = this.subscriptions[i];
          subscription.unsubscribe(), this.remove(subscription);
        }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  }, RaceSubscriber2;
}(OuterSubscriber);
function range(start, count2, scheduler) {
  return start === void 0 && (start = 0), new Observable(function(subscriber) {
    count2 === void 0 && (count2 = start, start = 0);
    var index = 0, current = start;
    if (scheduler)
      return scheduler.schedule(dispatch$1, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    do {
      if (index++ >= count2) {
        subscriber.complete();
        break;
      }
      if (subscriber.next(current++), subscriber.closed)
        break;
    } while (!0);
  });
}
function dispatch$1(state) {
  var start = state.start, index = state.index, count2 = state.count, subscriber = state.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start), !subscriber.closed && (state.index = index + 1, state.start = start + 1, this.schedule(state));
}
function timer(dueTime, periodOrScheduler, scheduler) {
  dueTime === void 0 && (dueTime = 0);
  var period = -1;
  return isNumeric(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler) : isScheduler(periodOrScheduler) && (scheduler = periodOrScheduler), isScheduler(scheduler) || (scheduler = async), new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state) {
  var index = state.index, period = state.period, subscriber = state.subscriber;
  if (subscriber.next(index), !subscriber.closed) {
    if (period === -1)
      return subscriber.complete();
    state.index = index + 1, this.schedule(state, period);
  }
}
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return;
    }
    var source2 = result ? from(result) : EMPTY, subscription = source2.subscribe(subscriber);
    return function() {
      subscription.unsubscribe(), resource && resource.unsubscribe();
    };
  });
}
function zip$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var resultSelector = observables[observables.length - 1];
  return typeof resultSelector == "function" && observables.pop(), fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  return ZipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  }, ZipOperator2;
}(), ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    var _this = _super.call(this, destination) || this;
    return _this.resultSelector = resultSelector, _this.iterators = [], _this.active = 0, _this.resultSelector = typeof resultSelector == "function" ? resultSelector : void 0, _this;
  }
  return ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    isArray(value) ? iterators.push(new StaticArrayIterator(value)) : typeof value[iterator] == "function" ? iterators.push(new StaticIterator(value[iterator]())) : iterators.push(new ZipBufferIterator(this.destination, this, value));
  }, ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators, len = iterators.length;
    if (this.unsubscribe(), len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else
        this.active--;
    }
  }, ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, ZipSubscriber2.prototype.checkIterators = function() {
    for (var iterators = this.iterators, len = iterators.length, destination = this.destination, i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      if (typeof iterator2.hasValue == "function" && !iterator2.hasValue())
        return;
    }
    for (var shouldComplete = !1, args = [], i = 0; i < len; i++) {
      var iterator2 = iterators[i], result = iterator2.next();
      if (iterator2.hasCompleted() && (shouldComplete = !0), result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    this.resultSelector ? this._tryresultSelector(args) : destination.next(args), shouldComplete && destination.complete();
  }, ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, ZipSubscriber2;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2, this.nextResult = iterator2.next();
  }
  return StaticIterator2.prototype.hasValue = function() {
    return !0;
  }, StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    return this.nextResult = this.iterator.next(), result;
  }, StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return !!(nextResult && nextResult.done);
  }, StaticIterator2;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array) {
    this.array = array, this.index = 0, this.length = 0, this.length = array.length;
  }
  return StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  }, StaticArrayIterator2.prototype.next = function(value) {
    var i = this.index++, array = this.array;
    return i < this.length ? { value: array[i], done: !1 } : { value: null, done: !0 };
  }, StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, StaticArrayIterator2;
}(), ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent, observable2) {
    var _this = _super.call(this, destination) || this;
    return _this.parent = parent, _this.observable = observable2, _this.stillUnsubscribed = !0, _this.buffer = [], _this.isComplete = !1, _this;
  }
  return ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  }, ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    return buffer2.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: buffer2.shift(), done: !1 };
  }, ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, ZipBufferIterator2.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue), this.parent.checkIterators();
  }, ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, ZipBufferIterator2;
}(SimpleOuterSubscriber), _esm5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArgumentOutOfRangeError,
  AsyncSubject,
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  EmptyError,
  GroupedObservable,
  NEVER,
  Notification,
  get NotificationKind() {
    return NotificationKind;
  },
  ObjectUnsubscribedError,
  Observable,
  ReplaySubject,
  Scheduler,
  Subject,
  Subscriber,
  Subscription,
  TimeoutError,
  UnsubscriptionError,
  VirtualAction,
  VirtualTimeScheduler,
  animationFrame,
  animationFrameScheduler,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  bindCallback,
  bindNodeCallback,
  combineLatest: combineLatest$1,
  concat: concat$1,
  config,
  defer,
  empty,
  forkJoin,
  from,
  fromEvent,
  fromEventPattern,
  generate,
  identity,
  iif,
  interval,
  isObservable,
  merge: merge$1,
  never,
  noop,
  observable,
  of,
  onErrorResumeNext: onErrorResumeNext$1,
  pairs,
  partition: partition$1,
  pipe,
  queue,
  queueScheduler,
  race: race$1,
  range,
  scheduled,
  throwError,
  timer,
  using,
  zip: zip$1
}), require$$4$1 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(_esm5);
function audit(durationSelector) {
  return function(source2) {
    return source2.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  return AuditOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  }, AuditOperator2;
}(), AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.durationSelector = durationSelector, _this.hasValue = !1, _this;
  }
  return AuditSubscriber2.prototype._next = function(value) {
    if (this.value = value, this.hasValue = !0, !this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      !innerSubscription || innerSubscription.closed ? this.clearThrottle() : this.add(this.throttled = innerSubscription);
    }
  }, AuditSubscriber2.prototype.clearThrottle = function() {
    var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
    throttled && (this.remove(throttled), this.throttled = void 0, throttled.unsubscribe()), hasValue && (this.value = void 0, this.hasValue = !1, this.destination.next(value));
  }, AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  }, AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, AuditSubscriber2;
}(SimpleOuterSubscriber);
function auditTime(duration, scheduler) {
  return scheduler === void 0 && (scheduler = async), audit(function() {
    return timer(duration, scheduler);
  });
}
function buffer(closingNotifier) {
  return function(source2) {
    return source2.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  return BufferOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  }, BufferOperator2;
}(), BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    return _this.buffer = [], _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this))), _this;
  }
  return BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  }, BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [], this.destination.next(buffer2);
  }, BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  return startBufferEvery === void 0 && (startBufferEvery = null), function(source2) {
    return source2.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize, this.startBufferEvery = startBufferEvery, !startBufferEvery || bufferSize === startBufferEvery ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return BufferCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  }, BufferCountOperator2;
}(), BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    return _this.bufferSize = bufferSize, _this.buffer = [], _this;
  }
  return BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value), buffer2.length == this.bufferSize && (this.destination.next(buffer2), this.buffer = []);
  }, BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    buffer2.length > 0 && this.destination.next(buffer2), _super.prototype._complete.call(this);
  }, BufferCountSubscriber2;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    return _this.bufferSize = bufferSize, _this.startBufferEvery = startBufferEvery, _this.buffers = [], _this.count = 0, _this;
  }
  return BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count2 = _a.count;
    this.count++, count2 % startBufferEvery === 0 && buffers.push([]);
    for (var i = buffers.length; i--; ) {
      var buffer2 = buffers[i];
      buffer2.push(value), buffer2.length === bufferSize && (buffers.splice(i, 1), this.destination.next(buffer2));
    }
  }, BufferSkipCountSubscriber2.prototype._complete = function() {
    for (var _a = this, buffers = _a.buffers, destination = _a.destination; buffers.length > 0; ) {
      var buffer2 = buffers.shift();
      buffer2.length > 0 && destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  }, BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length = arguments.length, scheduler = async;
  isScheduler(arguments[arguments.length - 1]) && (scheduler = arguments[arguments.length - 1], length--);
  var bufferCreationInterval = null;
  length >= 2 && (bufferCreationInterval = arguments[1]);
  var maxBufferSize = Number.POSITIVE_INFINITY;
  return length >= 3 && (maxBufferSize = arguments[2]), function(source2) {
    return source2.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan, this.bufferCreationInterval = bufferCreationInterval, this.maxBufferSize = maxBufferSize, this.scheduler = scheduler;
  }
  return BufferTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, BufferTimeOperator2;
}(), Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan, _this.bufferCreationInterval = bufferCreationInterval, _this.maxBufferSize = maxBufferSize, _this.scheduler = scheduler, _this.contexts = [];
    var context = _this.openContext();
    if (_this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0, _this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context }, creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState)), _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  return BufferTimeSubscriber2.prototype._next = function(value) {
    for (var contexts = this.contexts, len = contexts.length, filledBufferContext, i = 0; i < len; i++) {
      var context_1 = contexts[i], buffer2 = context_1.buffer;
      buffer2.push(value), buffer2.length == this.maxBufferSize && (filledBufferContext = context_1);
    }
    filledBufferContext && this.onBufferFull(filledBufferContext);
  }, BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0, _super.prototype._error.call(this, err);
  }, BufferTimeSubscriber2.prototype._complete = function() {
    for (var _a = this, contexts = _a.contexts, destination = _a.destination; contexts.length > 0; ) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  }, BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  }, BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
    this.closeContext(context);
    var closeAction = context.closeAction;
    if (closeAction.unsubscribe(), this.remove(closeAction), !this.closed && this.timespanOnly) {
      context = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan, timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  }, BufferTimeSubscriber2.prototype.openContext = function() {
    var context = new Context();
    return this.contexts.push(context), context;
  }, BufferTimeSubscriber2.prototype.closeContext = function(context) {
    this.destination.next(context.buffer);
    var contexts = this.contexts, spliceIndex = contexts ? contexts.indexOf(context) : -1;
    spliceIndex >= 0 && contexts.splice(contexts.indexOf(context), 1);
  }, BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber, prevContext = state.context;
  prevContext && subscriber.closeContext(prevContext), subscriber.closed || (state.context = subscriber.openContext(), state.context.closeAction = this.schedule(state, state.bufferTimeSpan));
}
function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, context = subscriber.openContext(), action = this;
  subscriber.closed || (subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context })), action.schedule(state, bufferCreationInterval));
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
function bufferToggle(openings, closingSelector) {
  return function(source2) {
    return source2.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings, this.closingSelector = closingSelector;
  }
  return BufferToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  }, BufferToggleOperator2;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.closingSelector = closingSelector, _this.contexts = [], _this.add(subscribeToResult(_this, openings)), _this;
  }
  return BufferToggleSubscriber2.prototype._next = function(value) {
    for (var contexts = this.contexts, len = contexts.length, i = 0; i < len; i++)
      contexts[i].buffer.push(value);
  }, BufferToggleSubscriber2.prototype._error = function(err) {
    for (var contexts = this.contexts; contexts.length > 0; ) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe(), context_1.buffer = null, context_1.subscription = null;
    }
    this.contexts = null, _super.prototype._error.call(this, err);
  }, BufferToggleSubscriber2.prototype._complete = function() {
    for (var contexts = this.contexts; contexts.length > 0; ) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer), context_2.subscription.unsubscribe(), context_2.buffer = null, context_2.subscription = null;
    }
    this.contexts = null, _super.prototype._complete.call(this);
  }, BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  }, BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  }, BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector, closingNotifier = closingSelector.call(this, value);
      closingNotifier && this.trySubscribe(closingNotifier);
    } catch (err) {
      this._error(err);
    }
  }, BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
    var contexts = this.contexts;
    if (contexts && context) {
      var buffer2 = context.buffer, subscription = context.subscription;
      this.destination.next(buffer2), contexts.splice(contexts.indexOf(context), 1), this.remove(subscription), subscription.unsubscribe();
    }
  }, BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts, buffer2 = [], subscription = new Subscription(), context = { buffer: buffer2, subscription };
    contexts.push(context);
    var innerSubscription = subscribeToResult(this, closingNotifier, context);
    !innerSubscription || innerSubscription.closed ? this.closeBuffer(context) : (innerSubscription.context = context, this.add(innerSubscription), subscription.add(innerSubscription));
  }, BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source2) {
    return source2.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  return BufferWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  }, BufferWhenOperator2;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.closingSelector = closingSelector, _this.subscribing = !1, _this.openBuffer(), _this;
  }
  return BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  }, BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    buffer2 && this.destination.next(buffer2), _super.prototype._complete.call(this);
  }, BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  }, BufferWhenSubscriber2.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    closingSubscription && (this.remove(closingSubscription), closingSubscription.unsubscribe());
    var buffer2 = this.buffer;
    this.buffer && this.destination.next(buffer2), this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription(), this.closingSubscription = closingSubscription, this.add(closingSubscription), this.subscribing = !0, closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function(source2) {
    var operator = new CatchOperator(selector), caught = source2.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  return CatchOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  }, CatchOperator2;
}(), CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    return _this.selector = selector, _this.caught = caught, _this;
  }
  return CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      innerSubscription !== innerSubscriber && this.add(innerSubscription);
    }
  }, CatchSubscriber2;
}(SimpleOuterSubscriber);
function combineAll(project) {
  return function(source2) {
    return source2.lift(new CombineLatestOperator(project));
  };
}
function combineLatest() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var project = null;
  return typeof observables[observables.length - 1] == "function" && (project = observables.pop()), observables.length === 1 && isArray(observables[0]) && (observables = observables[0].slice()), function(source2) {
    return source2.lift.call(from([source2].concat(observables)), new CombineLatestOperator(project));
  };
}
function concat() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return source2.lift.call(concat$1.apply(void 0, [source2].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source2) {
    return source2.lift(new CountOperator(predicate, source2));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source2) {
    this.predicate = predicate, this.source = source2;
  }
  return CountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  }, CountOperator2;
}(), CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.source = source2, _this.count = 0, _this.index = 0, _this;
  }
  return CountSubscriber2.prototype._next = function(value) {
    this.predicate ? this._tryPredicate(value) : this.count++;
  }, CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result && this.count++;
  }, CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source2) {
    return source2.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  return DebounceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  }, DebounceOperator2;
}(), DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.durationSelector = durationSelector, _this.hasValue = !1, _this;
  }
  return DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      result && this._tryNext(value, result);
    } catch (err) {
      this.destination.error(err);
    }
  }, DebounceSubscriber2.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value, this.hasValue = !0, subscription && (subscription.unsubscribe(), this.remove(subscription)), subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this)), subscription && !subscription.closed && this.add(this.durationSubscription = subscription);
  }, DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  }, DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  }, DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value, subscription = this.durationSubscription;
      subscription && (this.durationSubscription = void 0, subscription.unsubscribe(), this.remove(subscription)), this.value = void 0, this.hasValue = !1, _super.prototype._next.call(this, value);
    }
  }, DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    return source2.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler) {
    this.dueTime = dueTime, this.scheduler = scheduler;
  }
  return DebounceTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  }, DebounceTimeOperator2;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.dueTime = dueTime, _this.scheduler = scheduler, _this.debouncedSubscription = null, _this.lastValue = null, _this.hasValue = !1, _this;
  }
  return DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
    }
  }, DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    debouncedSubscription !== null && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), this.debouncedSubscription = null);
  }, DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  return defaultValue === void 0 && (defaultValue = null), function(source2) {
    return source2.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  return DefaultIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  }, DefaultIfEmptyOperator2;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    return _this.defaultValue = defaultValue, _this.isEmpty = !0, _this;
  }
  return DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = !1, this.destination.next(value);
  }, DefaultIfEmptySubscriber2.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function delay(delay2, scheduler) {
  scheduler === void 0 && (scheduler = async);
  var absoluteDelay = isDate(delay2), delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source2) {
    return source2.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler) {
    this.delay = delay2, this.scheduler = scheduler;
  }
  return DelayOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  }, DelayOperator2;
}(), DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.delay = delay2, _this.scheduler = scheduler, _this.queue = [], _this.active = !1, _this.errored = !1, _this;
  }
  return DelaySubscriber2.dispatch = function(state) {
    for (var source2 = state.source, queue2 = source2.queue, scheduler = state.scheduler, destination = state.destination; queue2.length > 0 && queue2[0].time - scheduler.now() <= 0; )
      queue2.shift().notification.observe(destination);
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
      this.schedule(state, delay_1);
    } else
      this.unsubscribe(), source2.active = !1;
  }, DelaySubscriber2.prototype._schedule = function(scheduler) {
    this.active = !0;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler
    }));
  }, DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored !== !0) {
      var scheduler = this.scheduler, message = new DelayMessage(scheduler.now() + this.delay, notification);
      this.queue.push(message), this.active === !1 && this._schedule(scheduler);
    }
  }, DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  }, DelaySubscriber2.prototype._error = function(err) {
    this.errored = !0, this.queue = [], this.destination.error(err), this.unsubscribe();
  }, DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, DelaySubscriber2;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time, notification) {
    this.time = time, this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  return subscriptionDelay ? function(source2) {
    return new SubscriptionDelayObservable(source2, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
  } : function(source2) {
    return source2.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  return DelayWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  }, DelayWhenOperator2;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.delayDurationSelector = delayDurationSelector, _this.completed = !1, _this.delayNotifierSubscriptions = [], _this.index = 0, _this;
  }
  return DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue), this.removeSubscription(innerSub), this.tryComplete();
  }, DelayWhenSubscriber2.prototype.notifyError = function(error2, innerSub) {
    this._error(error2);
  }, DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    value && this.destination.next(value), this.tryComplete();
  }, DelayWhenSubscriber2.prototype._next = function(value) {
    var index = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index);
      delayNotifier && this.tryDelay(delayNotifier, value);
    } catch (err) {
      this.destination.error(err);
    }
  }, DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    return subscriptionIdx !== -1 && this.delayNotifierSubscriptions.splice(subscriptionIdx, 1), subscription.outerValue;
  }, DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription), this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  }, DelayWhenSubscriber2.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, DelayWhenSubscriber2;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source2, subscriptionDelay) {
    var _this = _super.call(this) || this;
    return _this.source = source2, _this.subscriptionDelay = subscriptionDelay, _this;
  }
  return SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  }, SubscriptionDelayObservable2;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent, source2) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, _this.source = source2, _this.sourceSubscribed = !1, _this;
  }
  return SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  }, SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe(), this.parent.error(err);
  }, SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function(source2) {
    return source2.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  return DeMaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DeMaterializeSubscriber(subscriber));
  }, DeMaterializeOperator2;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  return DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  }, DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source2) {
    return source2.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector, this.flushes = flushes;
  }
  return DistinctOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  }, DistinctOperator2;
}(), DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    return _this.keySelector = keySelector, _this.values = /* @__PURE__ */ new Set(), flushes && _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this))), _this;
  }
  return DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  }, DistinctSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  }, DistinctSubscriber2.prototype._next = function(value) {
    this.keySelector ? this._useKeySelector(value) : this._finalizeNext(value, value);
  }, DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key2, destination = this.destination;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key2, value);
  }, DistinctSubscriber2.prototype._finalizeNext = function(key2, value) {
    var values = this.values;
    values.has(key2) || (values.add(key2), this.destination.next(value));
  }, DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare, keySelector) {
  return function(source2) {
    return source2.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare, keySelector) {
    this.compare = compare, this.keySelector = keySelector;
  }
  return DistinctUntilChangedOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  }, DistinctUntilChangedOperator2;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
    var _this = _super.call(this, destination) || this;
    return _this.keySelector = keySelector, _this.hasKey = !1, typeof compare == "function" && (_this.compare = compare), _this;
  }
  return DistinctUntilChangedSubscriber2.prototype.compare = function(x, y) {
    return x === y;
  }, DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key2;
    try {
      var keySelector = this.keySelector;
      key2 = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = !1;
    if (this.hasKey)
      try {
        var compare = this.compare;
        result = compare(this.key, key2);
      } catch (err) {
        return this.destination.error(err);
      }
    else
      this.hasKey = !0;
    result || (this.key = key2, this.destination.next(value));
  }, DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key2, compare) {
  return distinctUntilChanged(function(x, y) {
    return compare ? compare(x[key2], y[key2]) : x[key2] === y[key2];
  });
}
function throwIfEmpty(errorFactory) {
  return errorFactory === void 0 && (errorFactory = defaultErrorFactory), function(source2) {
    return source2.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  return ThrowIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  }, ThrowIfEmptyOperator2;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    return _this.errorFactory = errorFactory, _this.hasValue = !1, _this;
  }
  return ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = !0, this.destination.next(value);
  }, ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var err = void 0;
    try {
      err = this.errorFactory();
    } catch (e) {
      err = e;
    }
    this.destination.error(err);
  }, ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source2) {
    return count2 === 0 ? empty() : source2.lift(new TakeOperator(count2));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    if (this.total = total, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return TakeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeSubscriber(subscriber, this.total));
  }, TakeOperator2;
}(), TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    return _this.total = total, _this.count = 0, _this;
  }
  return TakeSubscriber2.prototype._next = function(value) {
    var total = this.total, count2 = ++this.count;
    count2 <= total && (this.destination.next(value), count2 === total && (this.destination.complete(), this.unsubscribe()));
  }, TakeSubscriber2;
}(Subscriber);
function elementAt(index, defaultValue) {
  if (index < 0)
    throw new ArgumentOutOfRangeError();
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(filter(function(v, i) {
      return i === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var array = [], _i = 0; _i < arguments.length; _i++)
    array[_i] = arguments[_i];
  return function(source2) {
    return concat$1(source2, of.apply(void 0, array));
  };
}
function every(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new EveryOperator(predicate, thisArg, source2));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source2) {
    this.predicate = predicate, this.thisArg = thisArg, this.source = source2;
  }
  return EveryOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  }, EveryOperator2;
}(), EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.thisArg = thisArg, _this.source = source2, _this.index = 0, _this.thisArg = thisArg || _this, _this;
  }
  return EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch), this.destination.complete();
  }, EverySubscriber2.prototype._next = function(value) {
    var result = !1;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result || this.notifyComplete(!1);
  }, EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(!0);
  }, EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source2) {
    return source2.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  return SwitchFirstOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchFirstSubscriber(subscriber));
  }, SwitchFirstOperator2;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.hasCompleted = !1, _this.hasSubscription = !1, _this;
  }
  return SwitchFirstSubscriber2.prototype._next = function(value) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(value, new SimpleInnerSubscriber(this))));
  }, SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  return resultSelector ? function(source2) {
    return source2.pipe(exhaustMap(function(a, i) {
      return from(project(a, i)).pipe(map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      }));
    }));
  } : function(source2) {
    return source2.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  return ExhaustMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  }, ExhaustMapOperator2;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.hasSubscription = !1, _this.hasCompleted = !1, _this.index = 0, _this;
  }
  return ExhaustMapSubscriber2.prototype._next = function(value) {
    this.hasSubscription || this.tryNext(value);
  }, ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result, index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = !0, this._innerSub(result);
  }, ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    innerSubscription !== innerSubscriber && destination.add(innerSubscription);
  }, ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  }, ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand$1(project, concurrent, scheduler) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent, function(source2) {
    return source2.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler) {
    this.project = project, this.concurrent = concurrent, this.scheduler = scheduler;
  }
  return ExpandOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  }, ExpandOperator2;
}(), ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.concurrent = concurrent, _this.scheduler = scheduler, _this.index = 0, _this.active = 0, _this.hasCompleted = !1, concurrent < Number.POSITIVE_INFINITY && (_this.buffer = []), _this;
  }
  return ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
    subscriber.subscribeToProjection(result, value, index);
  }, ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project, result = project(value, index);
        if (!this.scheduler)
          this.subscribeToProjection(result, value, index);
        else {
          var state = { subscriber: this, result, value, index }, destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
        }
      } catch (e) {
        destination.error(e);
      }
    } else
      this.buffer.push(value);
  }, ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  }, ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  }, ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--, buffer2 && buffer2.length > 0 && this._next(buffer2.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source2) {
    return source2.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  return FinallyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FinallySubscriber(subscriber, this.callback));
  }, FinallyOperator2;
}(), FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    return _this.add(new Subscription(callback)), _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find(predicate, thisArg) {
  if (typeof predicate != "function")
    throw new TypeError("predicate is not a function");
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, !1, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source2, yieldIndex, thisArg) {
    this.predicate = predicate, this.source = source2, this.yieldIndex = yieldIndex, this.thisArg = thisArg;
  }
  return FindValueOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, FindValueOperator2;
}(), FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source2, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.source = source2, _this.yieldIndex = yieldIndex, _this.thisArg = thisArg, _this.index = 0, _this;
  }
  return FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value), destination.complete(), this.unsubscribe();
  }, FindValueSubscriber2.prototype._next = function(value) {
    var _a = this, predicate = _a.predicate, thisArg = _a.thisArg, index = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index, this.source);
      result && this.notifyComplete(this.yieldIndex ? index : value);
    } catch (err) {
      this.destination.error(err);
    }
  }, FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, !0, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source2);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function ignoreElements() {
  return function(source2) {
    return source2.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  return IgnoreElementsOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new IgnoreElementsSubscriber(subscriber));
  }, IgnoreElementsOperator2;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return IgnoreElementsSubscriber2.prototype._next = function(unused) {
  }, IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source2) {
    return source2.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  return IsEmptyOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new IsEmptySubscriber(observer));
  }, IsEmptyOperator2;
}(), IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  return IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2), destination.complete();
  }, IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(!1);
  }, IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(!0);
  }, IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function(source2) {
    return count2 === 0 ? empty() : source2.lift(new TakeLastOperator(count2));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    if (this.total = total, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return TakeLastOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeLastSubscriber(subscriber, this.total));
  }, TakeLastOperator2;
}(), TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    return _this.total = total, _this.ring = new Array(), _this.count = 0, _this;
  }
  return TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring, total = this.total, count2 = this.count++;
    if (ring.length < total)
      ring.push(value);
    else {
      var index = count2 % total;
      ring[index] = value;
    }
  }, TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination, count2 = this.count;
    if (count2 > 0)
      for (var total = this.count >= this.total ? this.total : this.count, ring = this.ring, i = 0; i < total; i++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    destination.complete();
  }, TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source2);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source2) {
    return source2.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  return MapToOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapToSubscriber(subscriber, this.value));
  }, MapToOperator2;
}(), MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    return _this.value = value, _this;
  }
  return MapToSubscriber2.prototype._next = function(x) {
    this.destination.next(this.value);
  }, MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function(source2) {
    return source2.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  return MaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MaterializeSubscriber(subscriber));
  }, MaterializeOperator2;
}(), MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  return MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  }, MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err)), destination.complete();
  }, MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete()), destination.complete();
  }, MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = !1;
  return arguments.length >= 2 && (hasSeed = !0), function(source2) {
    return source2.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    hasSeed === void 0 && (hasSeed = !1), this.accumulator = accumulator, this.seed = seed, this.hasSeed = hasSeed;
  }
  return ScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  }, ScanOperator2;
}(), ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    return _this.accumulator = accumulator, _this._seed = _seed, _this.hasSeed = hasSeed, _this.index = 0, _this;
  }
  return Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value) {
      this.hasSeed = !0, this._seed = value;
    },
    enumerable: !0,
    configurable: !0
  }), ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed)
      this.seed = value, this.destination.next(value);
    else
      return this._tryNext(value);
  }, ScanSubscriber2.prototype._tryNext = function(value) {
    var index = this.index++, result;
    try {
      result = this.accumulator(this.seed, value, index);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result, this.destination.next(result);
  }, ScanSubscriber2;
}(Subscriber);
function reduce(accumulator, seed) {
  return arguments.length >= 2 ? function(source2) {
    return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source2);
  } : function(source2) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source2);
  };
}
function max(comparer) {
  var max2 = typeof comparer == "function" ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  };
  return reduce(max2);
}
function merge() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return source2.lift.call(merge$1.apply(void 0, [source2].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), typeof resultSelector == "function" ? mergeMap(function() {
    return innerObservable;
  }, resultSelector, concurrent) : (typeof resultSelector == "number" && (concurrent = resultSelector), mergeMap(function() {
    return innerObservable;
  }, concurrent));
}
function mergeScan(accumulator, seed, concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), function(source2) {
    return source2.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator, this.seed = seed, this.concurrent = concurrent;
  }
  return MergeScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  }, MergeScanOperator2;
}(), MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    return _this.accumulator = accumulator, _this.acc = acc, _this.concurrent = concurrent, _this.hasValue = !1, _this.hasCompleted = !1, _this.buffer = [], _this.active = 0, _this.index = 0, _this;
  }
  return MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index = this.index++, destination = this.destination, ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index);
      } catch (e) {
        return destination.error(e);
      }
      this.active++, this._innerSub(ish);
    } else
      this.buffer.push(value);
  }, MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    innerSubscription !== innerSubscriber && destination.add(innerSubscription);
  }, MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue, this.hasValue = !0, destination.next(innerValue);
  }, MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--, buffer2.length > 0 ? this._next(buffer2.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer == "function" ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  };
  return reduce(min2);
}
function multicast(subjectOrSubjectFactory, selector) {
  return function(source2) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory == "function" ? subjectFactory = subjectOrSubjectFactory : subjectFactory = function() {
      return subjectOrSubjectFactory;
    }, typeof selector == "function")
      return source2.lift(new MulticastOperator(subjectFactory, selector));
    var connectable = Object.create(source2, connectableObservableDescriptor);
    return connectable.source = source2, connectable.subjectFactory = subjectFactory, connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory, this.selector = selector;
  }
  return MulticastOperator2.prototype.call = function(subscriber, source2) {
    var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
    return subscription.add(source2.subscribe(subject)), subscription;
  }, MulticastOperator2;
}();
function onErrorResumeNext() {
  for (var nextSources = [], _i = 0; _i < arguments.length; _i++)
    nextSources[_i] = arguments[_i];
  return nextSources.length === 1 && isArray(nextSources[0]) && (nextSources = nextSources[0]), function(source2) {
    return source2.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  return OnErrorResumeNextOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  }, OnErrorResumeNextOperator2;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.nextSources = nextSources, _this;
  }
  return OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (next) {
      var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      innerSubscription !== innerSubscriber && destination.add(innerSubscription);
    } else
      this.destination.complete();
  }, OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source2) {
    return source2.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  return PairwiseOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new PairwiseSubscriber(subscriber));
  }, PairwiseOperator2;
}(), PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.hasPrev = !1, _this;
  }
  return PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    this.hasPrev ? pair = [this.prev, value] : this.hasPrev = !0, this.prev = value, pair && this.destination.next(pair);
  }, PairwiseSubscriber2;
}(Subscriber);
function partition(predicate, thisArg) {
  return function(source2) {
    return [
      filter(predicate, thisArg)(source2),
      filter(not(predicate, thisArg))(source2)
    ];
  };
}
function pluck() {
  for (var properties = [], _i = 0; _i < arguments.length; _i++)
    properties[_i] = arguments[_i];
  var length = properties.length;
  if (length === 0)
    throw new Error("list of properties cannot be empty.");
  return function(source2) {
    return map(plucker(properties, length))(source2);
  };
}
function plucker(props, length) {
  var mapper = function(x) {
    for (var currentProp = x, i = 0; i < length; i++) {
      var p = currentProp?.[props[i]];
      if (p !== void 0)
        currentProp = p;
      else
        return;
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishBehavior(value) {
  return function(source2) {
    return multicast(new BehaviorSubject(value))(source2);
  };
}
function publishLast() {
  return function(source2) {
    return multicast(new AsyncSubject())(source2);
  };
}
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  selectorOrScheduler && typeof selectorOrScheduler != "function" && (scheduler = selectorOrScheduler);
  var selector = typeof selectorOrScheduler == "function" ? selectorOrScheduler : void 0, subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source2) {
    return multicast(function() {
      return subject;
    }, selector)(source2);
  };
}
function race() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return observables.length === 1 && isArray(observables[0]) && (observables = observables[0]), source2.lift.call(race$1.apply(void 0, [source2].concat(observables)));
  };
}
function repeat(count2) {
  return count2 === void 0 && (count2 = -1), function(source2) {
    return count2 === 0 ? empty() : count2 < 0 ? source2.lift(new RepeatOperator(-1, source2)) : source2.lift(new RepeatOperator(count2 - 1, source2));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source2) {
    this.count = count2, this.source = source2;
  }
  return RepeatOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  }, RepeatOperator2;
}(), RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.count = count2, _this.source = source2, _this;
  }
  return RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a = this, source2 = _a.source, count2 = _a.count;
      if (count2 === 0)
        return _super.prototype.complete.call(this);
      count2 > -1 && (this.count = count2 - 1), source2.subscribe(this._unsubscribeAndRecycle());
    }
  }, RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source2) {
    return source2.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  return RepeatWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source2));
  }, RepeatWhenOperator2;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.notifier = notifier, _this.source = source2, _this.sourceIsBeingSubscribedTo = !0, _this;
  }
  return RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return _super.prototype.complete.call(this);
  }, RepeatWhenSubscriber2.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return _super.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
    notifications && (notifications.unsubscribe(), this.notifications = void 0), retriesSubscription && (retriesSubscription.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    return this._unsubscribe = null, _super.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = _unsubscribe, this;
  }, RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries, this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  }, RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  return count2 === void 0 && (count2 = -1), function(source2) {
    return source2.lift(new RetryOperator(count2, source2));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source2) {
    this.count = count2, this.source = source2;
  }
  return RetryOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  }, RetryOperator2;
}(), RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.count = count2, _this.source = source2, _this;
  }
  return RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a = this, source2 = _a.source, count2 = _a.count;
      if (count2 === 0)
        return _super.prototype.error.call(this, err);
      count2 > -1 && (this.count = count2 - 1), source2.subscribe(this._unsubscribeAndRecycle());
    }
  }, RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source2) {
    return source2.lift(new RetryWhenOperator(notifier, source2));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source2) {
    this.notifier = notifier, this.source = source2;
  }
  return RetryWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  }, RetryWhenOperator2;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.notifier = notifier, _this.source = source2, _this;
  }
  return RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors = this.errors, retries = this.retries, retriesSubscription = this.retriesSubscription;
      if (retries)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        errors = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors);
        } catch (e) {
          return _super.prototype.error.call(this, e);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = errors, this.retries = retries, this.retriesSubscription = retriesSubscription, errors.next(err);
    }
  }, RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
    errors && (errors.unsubscribe(), this.errors = void 0), retriesSubscription && (retriesSubscription.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = _unsubscribe, this.source.subscribe(this);
  }, RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample$1(notifier) {
  return function(source2) {
    return source2.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  return SampleOperator2.prototype.call = function(subscriber, source2) {
    var sampleSubscriber = new SampleSubscriber(subscriber), subscription = source2.subscribe(sampleSubscriber);
    return subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber))), subscription;
  }, SampleOperator2;
}(), SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this.hasValue = !1, _this;
  }
  return SampleSubscriber2.prototype._next = function(value) {
    this.value = value, this.hasValue = !0;
  }, SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  }, SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  }, SampleSubscriber2.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    return source2.lift(new SampleTimeOperator(period, scheduler));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler) {
    this.period = period, this.scheduler = scheduler;
  }
  return SampleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  }, SampleTimeOperator2;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.period = period, _this.scheduler = scheduler, _this.hasValue = !1, _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period })), _this;
  }
  return SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value, this.hasValue = !0;
  }, SampleTimeSubscriber2.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state) {
  var subscriber = state.subscriber, period = state.period;
  subscriber.notifyNext(), this.schedule(state, period);
}
function sequenceEqual(compareTo, comparator) {
  return function(source2) {
    return source2.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator) {
    this.compareTo = compareTo, this.comparator = comparator;
  }
  return SequenceEqualOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  }, SequenceEqualOperator2;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;
    return _this.compareTo = compareTo, _this.comparator = comparator, _this._a = [], _this._b = [], _this._oneComplete = !1, _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this))), _this;
  }
  return SequenceEqualSubscriber2.prototype._next = function(value) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(value), this.checkValues());
  }, SequenceEqualSubscriber2.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, SequenceEqualSubscriber2.prototype.checkValues = function() {
    for (var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator; _a.length > 0 && _b.length > 0; ) {
      var a = _a.shift(), b = _b.shift(), areEqual = !1;
      try {
        areEqual = comparator ? comparator(a, b) : a === b;
      } catch (e) {
        this.destination.error(e);
      }
      areEqual || this.emit(!1);
    }
  }, SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value), destination.complete();
  }, SequenceEqualSubscriber2.prototype.nextB = function(value) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(value), this.checkValues());
  }, SequenceEqualSubscriber2.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, SequenceEqualSubscriber2;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent) {
    var _this = _super.call(this, destination) || this;
    return _this.parent = parent, _this;
  }
  return SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  }, SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err), this.unsubscribe();
  }, SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source2) {
    return refCount()(multicast(shareSubjectFactory)(source2));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  return configOrBufferSize && typeof configOrBufferSize == "object" ? config2 = configOrBufferSize : config2 = {
    bufferSize: configOrBufferSize,
    windowTime: windowTime2,
    refCount: !1,
    scheduler
  }, function(source2) {
    return source2.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a) {
  var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler, subject, refCount2 = 0, subscription, hasError = !1, isComplete = !1;
  return function(source2) {
    refCount2++;
    var innerSub;
    !subject || hasError ? (hasError = !1, subject = new ReplaySubject(bufferSize, windowTime2, scheduler), innerSub = subject.subscribe(this), subscription = source2.subscribe({
      next: function(value) {
        subject.next(value);
      },
      error: function(err) {
        hasError = !0, subject.error(err);
      },
      complete: function() {
        isComplete = !0, subscription = void 0, subject.complete();
      }
    }), isComplete && (subscription = void 0)) : innerSub = subject.subscribe(this), this.add(function() {
      refCount2--, innerSub.unsubscribe(), innerSub = void 0, subscription && !isComplete && useRefCount && refCount2 === 0 && (subscription.unsubscribe(), subscription = void 0, subject = void 0);
    });
  };
}
function single$1(predicate) {
  return function(source2) {
    return source2.lift(new SingleOperator(predicate, source2));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source2) {
    this.predicate = predicate, this.source = source2;
  }
  return SingleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  }, SingleOperator2;
}(), SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.source = source2, _this.seenValue = !1, _this.index = 0, _this;
  }
  return SingleSubscriber2.prototype.applySingleValue = function(value) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = value);
  }, SingleSubscriber2.prototype._next = function(value) {
    var index = this.index++;
    this.predicate ? this.tryNext(value, index) : this.applySingleValue(value);
  }, SingleSubscriber2.prototype.tryNext = function(value, index) {
    try {
      this.predicate(value, index, this.source) && this.applySingleValue(value);
    } catch (err) {
      this.destination.error(err);
    }
  }, SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    this.index > 0 ? (destination.next(this.seenValue ? this.singleValue : void 0), destination.complete()) : destination.error(new EmptyError());
  }, SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source2) {
    return source2.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  return SkipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipSubscriber(subscriber, this.total));
  }, SkipOperator2;
}(), SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    return _this.total = total, _this.count = 0, _this;
  }
  return SkipSubscriber2.prototype._next = function(x) {
    ++this.count > this.total && this.destination.next(x);
  }, SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source2) {
    return source2.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    if (this._skipCount = _skipCount, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return SkipLastOperator2.prototype.call = function(subscriber, source2) {
    return this._skipCount === 0 ? source2.subscribe(new Subscriber(subscriber)) : source2.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
  }, SkipLastOperator2;
}(), SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    return _this._skipCount = _skipCount, _this._count = 0, _this._ring = new Array(_skipCount), _this;
  }
  return SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount, count2 = this._count++;
    if (count2 < skipCount)
      this._ring[count2] = value;
    else {
      var currentIndex = count2 % skipCount, ring = this._ring, oldValue = ring[currentIndex];
      ring[currentIndex] = value, this.destination.next(oldValue);
    }
  }, SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source2) {
    return source2.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  return SkipUntilOperator2.prototype.call = function(destination, source2) {
    return source2.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  }, SkipUntilOperator2;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = !1;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber), _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    return innerSubscription !== innerSubscriber && (_this.add(innerSubscription), _this.innerSubscription = innerSubscription), _this;
  }
  return SkipUntilSubscriber2.prototype._next = function(value) {
    this.hasValue && _super.prototype._next.call(this, value);
  }, SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, SkipUntilSubscriber2.prototype.notifyComplete = function() {
  }, SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source2) {
    return source2.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  return SkipWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  }, SkipWhileOperator2;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.skipping = !0, _this.index = 0, _this;
  }
  return SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    this.skipping && this.tryCallPredicate(value), this.skipping || destination.next(value);
  }, SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = !!result;
    } catch (err) {
      this.destination.error(err);
    }
  }, SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  for (var array = [], _i = 0; _i < arguments.length; _i++)
    array[_i] = arguments[_i];
  var scheduler = array[array.length - 1];
  return isScheduler(scheduler) ? (array.pop(), function(source2) {
    return concat$1(array, source2, scheduler);
  }) : function(source2) {
    return concat$1(array, source2);
  };
}
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source2, delayTime, scheduler) {
    delayTime === void 0 && (delayTime = 0), scheduler === void 0 && (scheduler = asap);
    var _this = _super.call(this) || this;
    return _this.source = source2, _this.delayTime = delayTime, _this.scheduler = scheduler, (!isNumeric(delayTime) || delayTime < 0) && (_this.delayTime = 0), (!scheduler || typeof scheduler.schedule != "function") && (_this.scheduler = asap), _this;
  }
  return SubscribeOnObservable2.create = function(source2, delay2, scheduler) {
    return delay2 === void 0 && (delay2 = 0), scheduler === void 0 && (scheduler = asap), new SubscribeOnObservable2(source2, delay2, scheduler);
  }, SubscribeOnObservable2.dispatch = function(arg) {
    var source2 = arg.source, subscriber = arg.subscriber;
    return this.add(source2.subscribe(subscriber));
  }, SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime, source2 = this.source, scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source: source2,
      subscriber
    });
  }, SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler, delay2) {
  return delay2 === void 0 && (delay2 = 0), function(source2) {
    return source2.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler, delay2) {
    this.scheduler = scheduler, this.delay = delay2;
  }
  return SubscribeOnOperator2.prototype.call = function(subscriber, source2) {
    return new SubscribeOnObservable(source2, this.delay, this.scheduler).subscribe(subscriber);
  }, SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  return typeof resultSelector == "function" ? function(source2) {
    return source2.pipe(switchMap(function(a, i) {
      return from(project(a, i)).pipe(map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      }));
    }));
  } : function(source2) {
    return source2.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  return SwitchMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  }, SwitchMapOperator2;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.index = 0, _this;
  }
  return SwitchMapSubscriber2.prototype._next = function(value) {
    var result, index = this.index++;
    try {
      result = this.project(value, index);
    } catch (error2) {
      this.destination.error(error2);
      return;
    }
    this._innerSub(result);
  }, SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    innerSubscription && innerSubscription.unsubscribe();
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber), this.innerSubscription = innerSubscribe(result, innerSubscriber), this.innerSubscription !== innerSubscriber && destination.add(this.innerSubscription);
  }, SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    (!innerSubscription || innerSubscription.closed) && _super.prototype._complete.call(this), this.unsubscribe();
  }, SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && _super.prototype._complete.call(this);
  }, SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source2) {
    return source2.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  return TakeUntilOperator2.prototype.call = function(subscriber, source2) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), source2.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
  }, TakeUntilOperator2;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.seenValue = !1, _this;
  }
  return TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, TakeUntilSubscriber2.prototype.notifyComplete = function() {
  }, TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  return inclusive === void 0 && (inclusive = !1), function(source2) {
    return source2.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate, this.inclusive = inclusive;
  }
  return TakeWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  }, TakeWhileOperator2;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.inclusive = inclusive, _this.index = 0, _this;
  }
  return TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination, result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  }, TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    predicateResult ? destination.next(value) : (this.inclusive && destination.next(value), destination.complete());
  }, TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error2, complete) {
  return function(source2) {
    return source2.lift(new DoOperator(nextOrObserver, error2, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error2, complete) {
    this.nextOrObserver = nextOrObserver, this.error = error2, this.complete = complete;
  }
  return DoOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  }, DoOperator2;
}(), TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error2, complete) {
    var _this = _super.call(this, destination) || this;
    return _this._tapNext = noop, _this._tapError = noop, _this._tapComplete = noop, _this._tapError = error2 || noop, _this._tapComplete = complete || noop, isFunction(observerOrNext) ? (_this._context = _this, _this._tapNext = observerOrNext) : observerOrNext && (_this._context = observerOrNext, _this._tapNext = observerOrNext.next || noop, _this._tapError = observerOrNext.error || noop, _this._tapComplete = observerOrNext.complete || noop), _this;
  }
  return TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  }, TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  }, TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  }, TapSubscriber2;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(durationSelector, config2) {
  return config2 === void 0 && (config2 = defaultThrottleConfig), function(source2) {
    return source2.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector, this.leading = leading, this.trailing = trailing;
  }
  return ThrottleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  }, ThrottleOperator2;
}(), ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.durationSelector = durationSelector, _this._leading = _leading, _this._trailing = _trailing, _this._hasValue = !1, _this;
  }
  return ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = !0, this._sendValue = value, this._throttled || (this._leading ? this.send() : this.throttle(value));
  }, ThrottleSubscriber2.prototype.send = function() {
    var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
    _hasValue && (this.destination.next(_sendValue), this.throttle(_sendValue)), this._hasValue = !1, this._sendValue = void 0;
  }, ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    duration && this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
  }, ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      return this.destination.error(err), null;
    }
  }, ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
    _throttled && _throttled.unsubscribe(), this._throttled = void 0, _trailing && this.send();
  }, ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  }, ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler, config2) {
  return scheduler === void 0 && (scheduler = async), config2 === void 0 && (config2 = defaultThrottleConfig), function(source2) {
    return source2.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
    this.duration = duration, this.scheduler = scheduler, this.leading = leading, this.trailing = trailing;
  }
  return ThrottleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  }, ThrottleTimeOperator2;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    return _this.duration = duration, _this.scheduler = scheduler, _this.leading = leading, _this.trailing = trailing, _this._hasTrailingValue = !1, _this._trailingValue = null, _this;
  }
  return ThrottleTimeSubscriber2.prototype._next = function(value) {
    this.throttled ? this.trailing && (this._trailingValue = value, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(value) : this.trailing && (this._trailingValue = value, this._hasTrailingValue = !0));
  }, ThrottleTimeSubscriber2.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    throttled && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), throttled.unsubscribe(), this.remove(throttled), this.throttled = null);
  }, ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function timeInterval(scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    return defer(function() {
      return source2.pipe(scan(function(_a, value) {
        var current = _a.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a) {
        var current = _a.current, last2 = _a.last, value = _a.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value, this.interval = interval2;
  }
  return TimeInterval2;
}();
function timeoutWith(due, withObservable, scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    var absoluteTimeout = isDate(due), waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source2.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor, this.absoluteTimeout = absoluteTimeout, this.withObservable = withObservable, this.scheduler = scheduler;
  }
  return TimeoutWithOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, TimeoutWithOperator2;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.absoluteTimeout = absoluteTimeout, _this.waitFor = waitFor, _this.withObservable = withObservable, _this.scheduler = scheduler, _this.scheduleTimeout(), _this;
  }
  return TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle(), subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  }, TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    action ? this.action = action.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
  }, TimeoutWithSubscriber2.prototype._next = function(value) {
    this.absoluteTimeout || this.scheduleTimeout(), _super.prototype._next.call(this, value);
  }, TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  return scheduler === void 0 && (scheduler = async), timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
function timestamp(scheduler) {
  return scheduler === void 0 && (scheduler = async), map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value, this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr, item, index) {
  return index === 0 ? [item] : (arr.push(item), arr);
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function(source2) {
    return source2.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  return WindowOperator2.prototype.call = function(subscriber, source2) {
    var windowSubscriber = new WindowSubscriber$1(subscriber), sourceSubscription = source2.subscribe(windowSubscriber);
    return sourceSubscription.closed || windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber))), sourceSubscription;
  }, WindowOperator2;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.window = new Subject(), destination.next(_this.window), _this;
  }
  return WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  }, WindowSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  }, WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  }, WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  }, WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err), this.destination.error(err);
  }, WindowSubscriber2.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  }, WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    prevWindow && prevWindow.complete();
    var destination = this.destination, newWindow = this.window = new Subject();
    destination.next(newWindow);
  }, WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  return startWindowEvery === void 0 && (startWindowEvery = 0), function(source2) {
    return source2.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize, this.startWindowEvery = startWindowEvery;
  }
  return WindowCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  }, WindowCountOperator2;
}(), WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.windowSize = windowSize, _this.startWindowEvery = startWindowEvery, _this.windows = [new Subject()], _this.count = 0, destination.next(_this.windows[0]), _this;
  }
  return WindowCountSubscriber2.prototype._next = function(value) {
    for (var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, destination = this.destination, windowSize = this.windowSize, windows2 = this.windows, len = windows2.length, i = 0; i < len && !this.closed; i++)
      windows2[i].next(value);
    var c2 = this.count - windowSize + 1;
    if (c2 >= 0 && c2 % startWindowEvery === 0 && !this.closed && windows2.shift().complete(), ++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows2.push(window_1), destination.next(window_1);
    }
  }, WindowCountSubscriber2.prototype._error = function(err) {
    var windows2 = this.windows;
    if (windows2)
      for (; windows2.length > 0 && !this.closed; )
        windows2.shift().error(err);
    this.destination.error(err);
  }, WindowCountSubscriber2.prototype._complete = function() {
    var windows2 = this.windows;
    if (windows2)
      for (; windows2.length > 0 && !this.closed; )
        windows2.shift().complete();
    this.destination.complete();
  }, WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler = async, windowCreationInterval = null, maxWindowSize = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (scheduler = arguments[3]), isScheduler(arguments[2]) ? scheduler = arguments[2] : isNumeric(arguments[2]) && (maxWindowSize = Number(arguments[2])), isScheduler(arguments[1]) ? scheduler = arguments[1] : isNumeric(arguments[1]) && (windowCreationInterval = Number(arguments[1])), function(source2) {
    return source2.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan, this.windowCreationInterval = windowCreationInterval, this.maxWindowSize = maxWindowSize, this.scheduler = scheduler;
  }
  return WindowTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, WindowTimeOperator2;
}(), CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this._numberOfNextedValues = 0, _this;
  }
  return CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++, _super.prototype.next.call(this, value);
  }, Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), CountedSubject2;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination, _this.windowTimeSpan = windowTimeSpan, _this.windowCreationInterval = windowCreationInterval, _this.maxWindowSize = maxWindowSize, _this.scheduler = scheduler, _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null }, creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState)), _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  return WindowTimeSubscriber2.prototype._next = function(value) {
    for (var windows2 = this.windows, len = windows2.length, i = 0; i < len; i++) {
      var window_1 = windows2[i];
      window_1.closed || (window_1.next(value), window_1.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(window_1));
    }
  }, WindowTimeSubscriber2.prototype._error = function(err) {
    for (var windows2 = this.windows; windows2.length > 0; )
      windows2.shift().error(err);
    this.destination.error(err);
  }, WindowTimeSubscriber2.prototype._complete = function() {
    for (var windows2 = this.windows; windows2.length > 0; ) {
      var window_2 = windows2.shift();
      window_2.closed || window_2.complete();
    }
    this.destination.complete();
  }, WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    return destination.next(window2), window2;
  }, WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows2 = this.windows;
    windows2.splice(windows2.indexOf(window2), 1);
  }, WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window2 = state.window;
  window2 && subscriber.closeWindow(window2), state.window = subscriber.openWindow(), this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval, window2 = subscriber.openWindow(), action = this, context = { action, subscription: null }, timeSpanState = { subscriber, window: window2, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState), action.add(context.subscription), action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
  var subscriber = state.subscriber, window2 = state.window, context = state.context;
  context && context.action && context.subscription && context.action.remove(context.subscription), subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source2) {
    return source2.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings, this.closingSelector = closingSelector;
  }
  return WindowToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  }, WindowToggleOperator2;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.openings = openings, _this.closingSelector = closingSelector, _this.contexts = [], _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings)), _this;
  }
  return WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts)
      for (var len = contexts.length, i = 0; i < len; i++)
        contexts[i].window.next(value);
  }, WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    if (this.contexts = null, contexts)
      for (var len = contexts.length, index = -1; ++index < len; ) {
        var context_1 = contexts[index];
        context_1.window.error(err), context_1.subscription.unsubscribe();
      }
    _super.prototype._error.call(this, err);
  }, WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    if (this.contexts = null, contexts)
      for (var len = contexts.length, index = -1; ++index < len; ) {
        var context_2 = contexts[index];
        context_2.window.complete(), context_2.subscription.unsubscribe();
      }
    _super.prototype._complete.call(this);
  }, WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    if (this.contexts = null, contexts)
      for (var len = contexts.length, index = -1; ++index < len; ) {
        var context_3 = contexts[index];
        context_3.window.unsubscribe(), context_3.subscription.unsubscribe();
      }
  }, WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e) {
        return this.error(e);
      }
      var window_1 = new Subject(), subscription = new Subscription(), context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      innerSubscription.closed ? this.closeWindow(this.contexts.length - 1) : (innerSubscription.context = context_4, subscription.add(innerSubscription)), this.destination.next(window_1);
    } else
      this.closeWindow(this.contexts.indexOf(outerValue));
  }, WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  }, WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    inner !== this.openSubscription && this.closeWindow(this.contexts.indexOf(inner.context));
  }, WindowToggleSubscriber2.prototype.closeWindow = function(index) {
    if (index !== -1) {
      var contexts = this.contexts, context = contexts[index], window2 = context.window, subscription = context.subscription;
      contexts.splice(index, 1), window2.complete(), subscription.unsubscribe();
    }
  }, WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function(source2) {
    return source2.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  return WindowOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  }, WindowOperator2;
}(), WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.closingSelector = closingSelector, _this.openWindow(), _this;
  }
  return WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  }, WindowSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  }, WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  }, WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  }, WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err), this.destination.error(err), this.unsubscribeClosingNotification();
  }, WindowSubscriber2.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, WindowSubscriber2.prototype.openWindow = function(innerSub) {
    innerSub === void 0 && (innerSub = null), innerSub && (this.remove(innerSub), innerSub.unsubscribe());
    var prevWindow = this.window;
    prevWindow && prevWindow.complete();
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e) {
      this.destination.error(e), this.window.error(e);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  }, WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  for (var args = [], _i = 0; _i < arguments.length; _i++)
    args[_i] = arguments[_i];
  return function(source2) {
    var project;
    typeof args[args.length - 1] == "function" && (project = args.pop());
    var observables = args;
    return source2.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables, this.project = project;
  }
  return WithLatestFromOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  }, WithLatestFromOperator2;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables, _this.project = project, _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);
    for (var i = 0; i < len; i++)
      _this.toRespond.push(i);
    for (var i = 0; i < len; i++) {
      var observable2 = observables[i];
      _this.add(subscribeToResult(_this, observable2, void 0, i));
    }
    return _this;
  }
  return WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      found !== -1 && toRespond.splice(found, 1);
    }
  }, WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  }, WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      this.project ? this._tryProject(args) : this.destination.next(args);
    }
  }, WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return source2.lift.call(zip$1.apply(void 0, [source2].concat(observables)));
  };
}
function zipAll(project) {
  return function(source2) {
    return source2.lift(new ZipOperator(project));
  };
}
var operators = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand: expand$1,
  filter,
  finalize,
  find,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample: sample$1,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single: single$1,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}), require$$1$1 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(operators), runAsync = { exports: {} }, hasRequiredRunAsync;
function requireRunAsync() {
  if (hasRequiredRunAsync) return runAsync.exports;
  hasRequiredRunAsync = 1;
  function isPromise2(obj) {
    return !!obj && (typeof obj == "object" || typeof obj == "function") && typeof obj.then == "function";
  }
  var runAsync$1 = runAsync.exports = function(func, cb) {
    return cb = cb || function() {
    }, function() {
      var args = arguments, promise2 = new Promise(function(resolve, reject) {
        var resolved = !1;
        const wrappedResolve = function(value) {
          resolved && console.warn("Run-async promise already resolved."), resolved = !0, resolve(value);
        };
        var rejected = !1;
        const wrappedReject = function(value) {
          rejected && console.warn("Run-async promise already rejected."), rejected = !0, reject(value);
        };
        var usingCallback = !1, callbackConflict = !1, contextEnded = !1, answer = func.apply({
          async: function() {
            return contextEnded ? (console.warn("Run-async async() called outside a valid run-async context, callback will be ignored."), function() {
            }) : (callbackConflict && console.warn(`Run-async wrapped function (async) returned a promise.
Calls to async() callback can have unexpected results.`), usingCallback = !0, function(err, value) {
              err ? wrappedReject(err) : wrappedResolve(value);
            });
          }
        }, Array.prototype.slice.call(args));
        usingCallback ? isPromise2(answer) && console.warn("Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.") : isPromise2(answer) ? (callbackConflict = !0, answer.then(wrappedResolve, wrappedReject)) : wrappedResolve(answer), contextEnded = !0;
      });
      return promise2.then(cb.bind(null, null), cb), promise2;
    };
  };
  return runAsync$1.cb = function(func, cb) {
    return runAsync$1(function() {
      var args = Array.prototype.slice.call(arguments);
      return args.length === func.length - 1 && args.push(this.async()), func.apply(this, args);
    }, cb);
  }, runAsync.exports;
}
var utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var _ = requireLodash(), { from: from2, of: of2 } = require$$4$1, runAsync2 = requireRunAsync();
  return utils.fetchAsyncQuestionProperty = function(question, prop, answers) {
    return _.isFunction(question[prop]) ? from2(
      runAsync2(question[prop])(answers).then((value) => (question[prop] = value, question))
    ) : of2(question);
  }, utils;
}
var prompt$1, hasRequiredPrompt;
function requirePrompt() {
  if (hasRequiredPrompt) return prompt$1;
  hasRequiredPrompt = 1;
  var _ = requireLodash(), { defer: defer2, empty: empty2, from: from2, of: of2 } = require$$4$1, { concatMap: concatMap2, filter: filter2, publish: publish2, reduce: reduce2 } = require$$1$1, runAsync2 = requireRunAsync(), utils2 = requireUtils(), Base = requireBaseUI();
  class PromptUI extends Base {
    constructor(prompts, opt) {
      super(opt), this.prompts = prompts;
    }
    run(questions) {
      this.answers = {}, _.isPlainObject(questions) && (questions = [questions]);
      var obs = _.isArray(questions) ? from2(questions) : questions;
      return this.process = obs.pipe(
        concatMap2(this.processQuestion.bind(this)),
        publish2()
        // Creates a hot Observable. It prevents duplicating prompts.
      ), this.process.connect(), this.process.pipe(
        reduce2((answers, answer) => (_.set(this.answers, answer.name, answer.answer), this.answers), {})
      ).toPromise(Promise).then(this.onCompletion.bind(this));
    }
    /**
     * Once all prompt are over
     */
    onCompletion() {
      return this.close(), this.answers;
    }
    processQuestion(question) {
      return question = _.clone(question), defer2(() => {
        var obs = of2(question);
        return obs.pipe(
          concatMap2(this.setDefaultType.bind(this)),
          concatMap2(this.filterIfRunnable.bind(this)),
          concatMap2(
            () => utils2.fetchAsyncQuestionProperty(question, "message", this.answers)
          ),
          concatMap2(
            () => utils2.fetchAsyncQuestionProperty(question, "default", this.answers)
          ),
          concatMap2(
            () => utils2.fetchAsyncQuestionProperty(question, "choices", this.answers)
          ),
          concatMap2(this.fetchAnswer.bind(this))
        );
      });
    }
    fetchAnswer(question) {
      var Prompt = this.prompts[question.type];
      return this.activePrompt = new Prompt(question, this.rl, this.answers), defer2(
        () => from2(
          this.activePrompt.run().then((answer) => ({ name: question.name, answer }))
        )
      );
    }
    setDefaultType(question) {
      return this.prompts[question.type] || (question.type = "input"), defer2(() => of2(question));
    }
    filterIfRunnable(question) {
      if (question.when === !1)
        return empty2();
      if (!_.isFunction(question.when))
        return of2(question);
      var answers = this.answers;
      return defer2(
        () => from2(
          runAsync2(question.when)(answers).then((shouldRun) => {
            if (shouldRun)
              return question;
          })
        ).pipe(filter2((val) => val != null))
      );
    }
  }
  return prompt$1 = PromptUI, prompt$1;
}
var cliCursor = {}, mimicFn, hasRequiredMimicFn;
function requireMimicFn() {
  return hasRequiredMimicFn || (hasRequiredMimicFn = 1, mimicFn = (to, from2) => {
    for (const prop of Object.getOwnPropertyNames(from2).concat(Object.getOwnPropertySymbols(from2)))
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
    return to;
  }), mimicFn;
}
var onetime, hasRequiredOnetime;
function requireOnetime() {
  if (hasRequiredOnetime) return onetime;
  hasRequiredOnetime = 1;
  const mimicFn2 = requireMimicFn();
  return onetime = (fn, opts) => {
    if (opts === !0)
      throw new TypeError("The second argument is now an options object");
    if (typeof fn != "function")
      throw new TypeError("Expected a function");
    opts = opts || {};
    let ret, called = !1;
    const fnName = fn.displayName || fn.name || "<anonymous>", onetime2 = function() {
      if (called) {
        if (opts.throw === !0)
          throw new Error(`Function \`${fnName}\` can only be called once`);
        return ret;
      }
      return called = !0, ret = fn.apply(this, arguments), fn = null, ret;
    };
    return mimicFn2(onetime2, fn), onetime2;
  }, onetime;
}
var restoreCursor, hasRequiredRestoreCursor;
function requireRestoreCursor() {
  if (hasRequiredRestoreCursor) return restoreCursor;
  hasRequiredRestoreCursor = 1;
  const onetime2 = requireOnetime(), signalExit2 = requireSignalExit();
  return restoreCursor = onetime2(() => {
    signalExit2(() => {
      process.stderr.write("\x1B[?25h");
    }, { alwaysLast: !0 });
  }), restoreCursor;
}
var hasRequiredCliCursor;
function requireCliCursor() {
  return hasRequiredCliCursor || (hasRequiredCliCursor = 1, function(exports2) {
    const restoreCursor2 = requireRestoreCursor();
    let hidden = !1;
    exports2.show = (stream2) => {
      const s = stream2 || process.stderr;
      s.isTTY && (hidden = !1, s.write("\x1B[?25h"));
    }, exports2.hide = (stream2) => {
      const s = stream2 || process.stderr;
      s.isTTY && (restoreCursor2(), hidden = !0, s.write("\x1B[?25l"));
    }, exports2.toggle = (force, stream2) => {
      force !== void 0 && (hidden = force), hidden ? exports2.show(stream2) : exports2.hide(stream2);
    };
  }(cliCursor)), cliCursor;
}
var choice, hasRequiredChoice;
function requireChoice() {
  if (hasRequiredChoice) return choice;
  hasRequiredChoice = 1;
  var _ = requireLodash();
  return choice = class Choice {
    constructor(val, answers) {
      if (val instanceof Choice || val.type === "separator")
        return val;
      _.isString(val) || _.isNumber(val) ? (this.name = String(val), this.value = val, this.short = String(val)) : _.extend(this, val, {
        name: val.name || val.value,
        value: "value" in val ? val.value : val.name,
        short: val.short || val.name || val.value
      }), _.isFunction(val.disabled) ? this.disabled = val.disabled(answers) : this.disabled = val.disabled;
    }
  }, choice;
}
var choices, hasRequiredChoices;
function requireChoices() {
  if (hasRequiredChoices) return choices;
  hasRequiredChoices = 1;
  var assert = require$$0__default$5.default, _ = requireLodash(), Separator = requireSeparator(), Choice = requireChoice();
  return choices = class {
    constructor(choices2, answers) {
      this.choices = choices2.map((val) => val.type === "separator" ? (val instanceof Separator || (val = new Separator(val.line)), val) : new Choice(val, answers)), this.realChoices = this.choices.filter(Separator.exclude).filter((item) => !item.disabled), Object.defineProperty(this, "length", {
        get() {
          return this.choices.length;
        },
        set(val) {
          this.choices.length = val;
        }
      }), Object.defineProperty(this, "realLength", {
        get() {
          return this.realChoices.length;
        },
        set() {
          throw new Error("Cannot set `realLength` of a Choices collection");
        }
      });
    }
    /**
     * Get a valid choice from the collection
     * @param  {Number} selector  The selected choice index
     * @return {Choice|Undefined} Return the matched choice or undefined
     */
    getChoice(selector) {
      return assert(_.isNumber(selector)), this.realChoices[selector];
    }
    /**
     * Get a raw element from the collection
     * @param  {Number} selector  The selected index value
     * @return {Choice|Undefined} Return the matched choice or undefined
     */
    get(selector) {
      return assert(_.isNumber(selector)), this.choices[selector];
    }
    /**
     * Match the valid choices against a where clause
     * @param  {Object} whereClause Lodash `where` clause
     * @return {Array}              Matching choices or empty array
     */
    where(whereClause) {
      return _.filter(this.realChoices, whereClause);
    }
    /**
     * Pluck a particular key from the choices
     * @param  {String} propertyName Property name to select
     * @return {Array}               Selected properties
     */
    pluck(propertyName) {
      return _.map(this.realChoices, propertyName);
    }
    // Expose usual Array methods
    indexOf() {
      return this.choices.indexOf.apply(this.choices, arguments);
    }
    forEach() {
      return this.choices.forEach.apply(this.choices, arguments);
    }
    filter() {
      return this.choices.filter.apply(this.choices, arguments);
    }
    find(func) {
      return _.find(this.choices, func);
    }
    push() {
      var objs = _.map(arguments, (val) => new Choice(val));
      return this.choices.push.apply(this.choices, objs), this.realChoices = this.choices.filter(Separator.exclude), this.choices;
    }
  }, choices;
}
var cliWidth = { exports: {} }, hasRequiredCliWidth;
function requireCliWidth() {
  return hasRequiredCliWidth || (hasRequiredCliWidth = 1, function(module2, exports2) {
    module2.exports = cliWidth2;
    function normalizeOpts(options2) {
      var defaultOpts = {
        defaultWidth: 0,
        output: process.stdout,
        tty: require$$0__default$c.default
      };
      return options2 ? (Object.keys(defaultOpts).forEach(function(key2) {
        options2[key2] || (options2[key2] = defaultOpts[key2]);
      }), options2) : defaultOpts;
    }
    function cliWidth2(options2) {
      var opts = normalizeOpts(options2);
      if (opts.output.getWindowSize)
        return opts.output.getWindowSize()[0] || opts.defaultWidth;
      if (opts.tty.getWindowSize)
        return opts.tty.getWindowSize()[1] || opts.defaultWidth;
      if (opts.output.columns)
        return opts.output.columns;
      if (process.env.CLI_WIDTH) {
        var width = parseInt(process.env.CLI_WIDTH, 10);
        if (!isNaN(width) && width !== 0)
          return width;
      }
      return opts.defaultWidth;
    }
  }(cliWidth)), cliWidth.exports;
}
var stripAnsi$2 = { exports: {} }, ansiRegex$2, hasRequiredAnsiRegex$2;
function requireAnsiRegex$2() {
  return hasRequiredAnsiRegex$2 || (hasRequiredAnsiRegex$2 = 1, ansiRegex$2 = (options2) => {
    options2 = Object.assign({
      onlyFirst: !1
    }, options2);
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, options2.onlyFirst ? void 0 : "g");
  }), ansiRegex$2;
}
var hasRequiredStripAnsi$2;
function requireStripAnsi$2() {
  if (hasRequiredStripAnsi$2) return stripAnsi$2.exports;
  hasRequiredStripAnsi$2 = 1;
  const ansiRegex2 = requireAnsiRegex$2(), stripAnsi2 = (string) => typeof string == "string" ? string.replace(ansiRegex2(), "") : string;
  return stripAnsi$2.exports = stripAnsi2, stripAnsi$2.exports.default = stripAnsi2, stripAnsi$2.exports;
}
var ansiRegex$1, hasRequiredAnsiRegex$1;
function requireAnsiRegex$1() {
  return hasRequiredAnsiRegex$1 || (hasRequiredAnsiRegex$1 = 1, ansiRegex$1 = () => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[a-zA-Z\\d]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, "g");
  }), ansiRegex$1;
}
var stripAnsi$1, hasRequiredStripAnsi$1;
function requireStripAnsi$1() {
  if (hasRequiredStripAnsi$1) return stripAnsi$1;
  hasRequiredStripAnsi$1 = 1;
  const ansiRegex2 = requireAnsiRegex$1();
  return stripAnsi$1 = (input2) => typeof input2 == "string" ? input2.replace(ansiRegex2(), "") : input2, stripAnsi$1;
}
var isFullwidthCodePoint$1, hasRequiredIsFullwidthCodePoint$1;
function requireIsFullwidthCodePoint$1() {
  return hasRequiredIsFullwidthCodePoint$1 || (hasRequiredIsFullwidthCodePoint$1 = 1, isFullwidthCodePoint$1 = (x) => Number.isNaN(x) ? !1 : x >= 4352 && (x <= 4447 || // Hangul Jamo
  x === 9001 || // LEFT-POINTING ANGLE BRACKET
  x === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= x && x <= 12871 && x !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= x && x <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= x && x <= 42182 || // Hangul Jamo Extended-A
  43360 <= x && x <= 43388 || // Hangul Syllables
  44032 <= x && x <= 55203 || // CJK Compatibility Ideographs
  63744 <= x && x <= 64255 || // Vertical Forms
  65040 <= x && x <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= x && x <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= x && x <= 65376 || 65504 <= x && x <= 65510 || // Kana Supplement
  110592 <= x && x <= 110593 || // Enclosed Ideographic Supplement
  127488 <= x && x <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= x && x <= 262141)), isFullwidthCodePoint$1;
}
var stringWidth$1, hasRequiredStringWidth$1;
function requireStringWidth$1() {
  if (hasRequiredStringWidth$1) return stringWidth$1;
  hasRequiredStringWidth$1 = 1;
  const stripAnsi2 = requireStripAnsi$1(), isFullwidthCodePoint2 = requireIsFullwidthCodePoint$1();
  return stringWidth$1 = (str2) => {
    if (typeof str2 != "string" || str2.length === 0)
      return 0;
    str2 = stripAnsi2(str2);
    let width = 0;
    for (let i = 0; i < str2.length; i++) {
      const code = str2.codePointAt(i);
      code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || (code > 65535 && i++, width += isFullwidthCodePoint2(code) ? 2 : 1);
    }
    return width;
  }, stringWidth$1;
}
var screenManager, hasRequiredScreenManager;
function requireScreenManager() {
  if (hasRequiredScreenManager) return screenManager;
  hasRequiredScreenManager = 1;
  var _ = requireLodash(), util2 = requireReadline(), cliWidth2 = requireCliWidth(), stripAnsi2 = requireStripAnsi$2(), stringWidth2 = requireStringWidth$1();
  function height(content) {
    return content.split(`
`).length;
  }
  function lastLine(content) {
    return _.last(content.split(`
`));
  }
  class ScreenManager {
    constructor(rl) {
      this.height = 0, this.extraLinesUnderPrompt = 0, this.rl = rl;
    }
    render(content, bottomContent) {
      this.rl.output.unmute(), this.clean(this.extraLinesUnderPrompt);
      var promptLine = lastLine(content), rawPromptLine = stripAnsi2(promptLine), prompt2 = rawPromptLine;
      this.rl.line.length && (prompt2 = prompt2.slice(0, -this.rl.line.length)), this.rl.setPrompt(prompt2);
      var cursorPos = this.rl._getCursorPos(), width = this.normalizedCliWidth();
      content = this.forceLineReturn(content, width), bottomContent && (bottomContent = this.forceLineReturn(bottomContent, width)), rawPromptLine.length % width === 0 && (content += `
`);
      var fullContent = content + (bottomContent ? `
` + bottomContent : "");
      this.rl.output.write(fullContent);
      var promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows, bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
      bottomContentHeight > 0 && util2.up(this.rl, bottomContentHeight), util2.left(this.rl, stringWidth2(lastLine(fullContent))), cursorPos.cols > 0 && util2.right(this.rl, cursorPos.cols), this.extraLinesUnderPrompt = bottomContentHeight, this.height = height(fullContent), this.rl.output.mute();
    }
    clean(extraLines) {
      extraLines > 0 && util2.down(this.rl, extraLines), util2.clearLine(this.rl, this.height);
    }
    done() {
      this.rl.setPrompt(""), this.rl.output.unmute(), this.rl.output.write(`
`);
    }
    releaseCursor() {
      this.extraLinesUnderPrompt > 0 && util2.down(this.rl, this.extraLinesUnderPrompt);
    }
    normalizedCliWidth() {
      var width = cliWidth2({
        defaultWidth: 80,
        output: this.rl.output
      });
      return width;
    }
    breakLines(lines2, width) {
      width = width || this.normalizedCliWidth();
      var regex2 = new RegExp("(?:(?:\\033[[0-9;]*m)*.?){1," + width + "}", "g");
      return lines2.map((line3) => {
        var chunk = line3.match(regex2);
        return chunk.pop(), chunk || "";
      });
    }
    forceLineReturn(content, width) {
      return width = width || this.normalizedCliWidth(), _.flatten(this.breakLines(content.split(`
`), width)).join(`
`);
    }
  }
  return screenManager = ScreenManager, screenManager;
}
var base, hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default, runAsync2 = requireRunAsync(), { filter: filter2, flatMap: flatMap2, share: share2, take: take2, takeUntil: takeUntil2 } = require$$1$1, Choices = requireChoices(), ScreenManager = requireScreenManager();
  class Prompt {
    constructor(question, rl, answers) {
      _.assign(this, {
        answers,
        status: "pending"
      }), this.opt = _.defaults(_.clone(question), {
        validate: () => !0,
        filter: (val) => val,
        when: () => !0,
        suffix: "",
        prefix: chalk2.green("?")
      }), this.opt.name || this.throwParamError("name"), this.opt.message || (this.opt.message = this.opt.name + ":"), Array.isArray(this.opt.choices) && (this.opt.choices = new Choices(this.opt.choices, answers)), this.rl = rl, this.screen = new ScreenManager(this.rl);
    }
    /**
     * Start the Inquiry session and manage output value filtering
     * @return {Promise}
     */
    run() {
      return new Promise((resolve) => {
        this._run((value) => resolve(value));
      });
    }
    // Default noop (this one should be overwritten in prompts)
    _run(cb) {
      cb();
    }
    /**
     * Throw an error telling a required parameter is missing
     * @param  {String} name Name of the missing param
     * @return {Throw Error}
     */
    throwParamError(name) {
      throw new Error("You must provide a `" + name + "` parameter");
    }
    /**
     * Called when the UI closes. Override to do any specific cleanup necessary
     */
    close() {
      this.screen.releaseCursor();
    }
    /**
     * Run the provided validation method each time a submit event occur.
     * @param  {Rx.Observable} submit - submit event flow
     * @return {Object}        Object containing two observables: `success` and `error`
     */
    handleSubmitEvents(submit) {
      var self2 = this, validate2 = runAsync2(this.opt.validate), asyncFilter = runAsync2(this.opt.filter), validation = submit.pipe(
        flatMap2(
          (value) => asyncFilter(value, self2.answers).then(
            (filteredValue) => validate2(filteredValue, self2.answers).then(
              (isValid) => ({ isValid, value: filteredValue }),
              (err) => ({ isValid: err })
            ),
            (err) => ({ isValid: err })
          )
        ),
        share2()
      ), success = validation.pipe(
        filter2((state) => state.isValid === !0),
        take2(1)
      ), error2 = validation.pipe(
        filter2((state) => state.isValid !== !0),
        takeUntil2(success)
      );
      return {
        success,
        error: error2
      };
    }
    /**
     * Generate the prompt question string
     * @return {String} prompt question string
     */
    getQuestion() {
      var message = this.opt.prefix + " " + chalk2.bold(this.opt.message) + this.opt.suffix + chalk2.reset(" ");
      return this.opt.default != null && this.status !== "answered" && (this.opt.type === "password" ? message += chalk2.italic.dim("[hidden] ") : message += chalk2.dim("(" + this.opt.default + ") ")), message;
    }
  }
  return base = Prompt, base;
}
var events, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  var { fromEvent: fromEvent2 } = require$$4$1, { filter: filter2, map: map2, share: share2 } = require$$1$1;
  function normalizeKeypressEvents(value, key2) {
    return { value, key: key2 || {} };
  }
  return events = function(rl) {
    var keypress = fromEvent2(rl.input, "keypress", normalizeKeypressEvents).pipe(filter2(({ key: key2 }) => key2.name !== "enter" && key2.name !== "return"));
    return {
      line: fromEvent2(rl, "line"),
      keypress,
      normalizedUpKey: keypress.pipe(
        filter2(
          ({ key: key2 }) => key2.name === "up" || key2.name === "k" || key2.name === "p" && key2.ctrl
        ),
        share2()
      ),
      normalizedDownKey: keypress.pipe(
        filter2(
          ({ key: key2 }) => key2.name === "down" || key2.name === "j" || key2.name === "n" && key2.ctrl
        ),
        share2()
      ),
      numberKey: keypress.pipe(
        filter2((e) => e.value && "123456789".indexOf(e.value) >= 0),
        map2((e) => Number(e.value)),
        share2()
      ),
      spaceKey: keypress.pipe(
        filter2(({ key: key2 }) => key2 && key2.name === "space"),
        share2()
      ),
      aKey: keypress.pipe(
        filter2(({ key: key2 }) => key2 && key2.name === "a"),
        share2()
      ),
      iKey: keypress.pipe(
        filter2(({ key: key2 }) => key2 && key2.name === "i"),
        share2()
      )
    };
  }, events;
}
var paginator, hasRequiredPaginator;
function requirePaginator() {
  if (hasRequiredPaginator) return paginator;
  hasRequiredPaginator = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default;
  class Paginator {
    constructor(screen) {
      this.pointer = 0, this.lastIndex = 0, this.screen = screen;
    }
    paginate(output, active, pageSize) {
      pageSize = pageSize || 7;
      var middleOfList = Math.floor(pageSize / 2), lines2 = output.split(`
`);
      if (this.screen && (lines2 = this.screen.breakLines(lines2), active = _.sum(lines2.map((lineParts) => lineParts.length).splice(0, active)), lines2 = _.flatten(lines2)), lines2.length <= pageSize)
        return output;
      this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize && (this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex)), this.lastIndex = active;
      var infinite = _.flatten([lines2, lines2, lines2]), topIndex = Math.max(0, active + lines2.length - this.pointer), section = infinite.splice(topIndex, pageSize).join(`
`);
      return section + `
` + chalk2.dim("(Move up and down to reveal more choices)");
    }
  }
  return paginator = Paginator, paginator;
}
var list, hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default, figures = requireFigures(), cliCursor2 = requireCliCursor(), runAsync2 = requireRunAsync(), { flatMap: flatMap2, map: map2, take: take2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), observe = requireEvents(), Paginator = requirePaginator();
  class ListPrompt extends Base {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), this.firstRender = !0, this.selected = 0;
      var def = this.opt.default;
      if (_.isNumber(def) && def >= 0 && def < this.opt.choices.realLength)
        this.selected = def;
      else if (!_.isNumber(def) && def != null) {
        let index = _.findIndex(this.opt.choices.realChoices, ({ value }) => value === def);
        this.selected = Math.max(index, 0);
      }
      this.opt.default = null, this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var self2 = this, events2 = observe(this.rl);
      return events2.normalizedUpKey.pipe(takeUntil2(events2.line)).forEach(this.onUpKey.bind(this)), events2.normalizedDownKey.pipe(takeUntil2(events2.line)).forEach(this.onDownKey.bind(this)), events2.numberKey.pipe(takeUntil2(events2.line)).forEach(this.onNumberKey.bind(this)), events2.line.pipe(
        take2(1),
        map2(this.getCurrentValue.bind(this)),
        flatMap2((value) => runAsync2(self2.opt.filter)(value).catch((err) => err))
      ).forEach(this.onSubmit.bind(this)), cliCursor2.hide(), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {ListPrompt} self
     */
    render() {
      var message = this.getQuestion();
      if (this.firstRender && (message += chalk2.dim("(Use arrow keys)")), this.status === "answered")
        message += chalk2.cyan(this.opt.choices.getChoice(this.selected).short);
      else {
        var choicesStr = listRender(this.opt.choices, this.selected), indexPosition = this.opt.choices.indexOf(
          this.opt.choices.getChoice(this.selected)
        );
        message += `
` + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
      }
      this.firstRender = !1, this.screen.render(message);
    }
    /**
     * When user press `enter` key
     */
    onSubmit(value) {
      this.status = "answered", this.render(), this.screen.done(), cliCursor2.show(), this.done(value);
    }
    getCurrentValue() {
      return this.opt.choices.getChoice(this.selected).value;
    }
    /**
     * When user press a key
     */
    onUpKey() {
      var len = this.opt.choices.realLength;
      this.selected = this.selected > 0 ? this.selected - 1 : len - 1, this.render();
    }
    onDownKey() {
      var len = this.opt.choices.realLength;
      this.selected = this.selected < len - 1 ? this.selected + 1 : 0, this.render();
    }
    onNumberKey(input2) {
      input2 <= this.opt.choices.realLength && (this.selected = input2 - 1), this.render();
    }
  }
  function listRender(choices2, pointer) {
    var output = "", separatorOffset = 0;
    return choices2.forEach((choice2, i) => {
      if (choice2.type === "separator") {
        separatorOffset++, output += "  " + choice2 + `
`;
        return;
      }
      if (choice2.disabled) {
        separatorOffset++, output += "  - " + choice2.name, output += " (" + (_.isString(choice2.disabled) ? choice2.disabled : "Disabled") + ")", output += `
`;
        return;
      }
      var isSelected = i - separatorOffset === pointer, line3 = (isSelected ? figures.pointer + " " : "  ") + choice2.name;
      isSelected && (line3 = chalk2.cyan(line3)), output += line3 + ` 
`;
    }), output.replace(/\n$/, "");
  }
  return list = ListPrompt, list;
}
var input, hasRequiredInput;
function requireInput() {
  if (hasRequiredInput) return input;
  hasRequiredInput = 1;
  var chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), observe = requireEvents();
  class InputPrompt extends Base {
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), submit = events2.line.pipe(map2(this.filterInput.bind(this))), validation = this.handleSubmitEvents(submit);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {InputPrompt} self
     */
    render(error2) {
      var bottomContent = "", appendContent = "", message = this.getQuestion(), transformer = this.opt.transformer, isFinal = this.status === "answered";
      isFinal ? appendContent = this.answer : appendContent = this.rl.line, transformer ? message += transformer(appendContent, this.answers, { isFinal }) : message += isFinal ? chalk2.cyan(appendContent) : appendContent, error2 && (bottomContent = chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    filterInput(input2) {
      return input2 || (this.opt.default == null ? "" : this.opt.default);
    }
    onEnd(state) {
      this.answer = state.value, this.status = "answered", this.render(), this.screen.done(), this.done(state.value);
    }
    onError(state) {
      this.rl.line += state.value, this.rl.cursor += state.value.length, this.render(state.isValid);
    }
    /**
     * When user press a key
     */
    onKeypress() {
      this.opt.default && (this.opt.default = void 0), this.render();
    }
  }
  return input = InputPrompt, input;
}
var number, hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber) return number;
  hasRequiredNumber = 1;
  var Input = requireInput();
  class NumberPrompt extends Input {
    filterInput(input2) {
      if (input2 && typeof input2 == "string") {
        input2 = input2.trim();
        let numberMatch = input2.match(/(^-?\d+|^\d+\.\d*|^\d*\.\d+)(e\d+)?$/);
        if (numberMatch)
          return Number(numberMatch[0]);
      }
      return this.opt.default == null ? NaN : this.opt.default;
    }
  }
  return number = NumberPrompt, number;
}
var confirm, hasRequiredConfirm;
function requireConfirm() {
  if (hasRequiredConfirm) return confirm;
  hasRequiredConfirm = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default, { take: take2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), observe = requireEvents();
  class ConfirmPrompt extends Base {
    constructor(questions, rl, answers) {
      super(questions, rl, answers);
      var rawDefault = !0;
      return _.extend(this.opt, {
        filter: function(input2) {
          var value = rawDefault;
          return input2 != null && input2 !== "" && (value = /^y(es)?/i.test(input2)), value;
        }
      }), _.isBoolean(this.opt.default) && (rawDefault = this.opt.default), this.opt.default = rawDefault ? "Y/n" : "y/N", this;
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb   Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl);
      return events2.keypress.pipe(takeUntil2(events2.line)).forEach(this.onKeypress.bind(this)), events2.line.pipe(take2(1)).forEach(this.onEnd.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {ConfirmPrompt} self
     */
    render(answer) {
      var message = this.getQuestion();
      return typeof answer == "boolean" ? message += chalk2.cyan(answer ? "Yes" : "No") : message += this.rl.line, this.screen.render(message), this;
    }
    /**
     * When user press `enter` key
     */
    onEnd(input2) {
      this.status = "answered";
      var output = this.opt.filter(input2);
      this.render(output), this.screen.done(), this.done(output);
    }
    /**
     * When user press a key
     */
    onKeypress() {
      this.render();
    }
  }
  return confirm = ConfirmPrompt, confirm;
}
var rawlist, hasRequiredRawlist;
function requireRawlist() {
  if (hasRequiredRawlist) return rawlist;
  hasRequiredRawlist = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), Separator = requireSeparator(), observe = requireEvents(), Paginator = requirePaginator();
  class RawListPrompt extends Base {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), this.opt.validChoices = this.opt.choices.filter(Separator.exclude), this.selected = 0, this.rawDefault = 0, _.extend(this.opt, {
        validate: function(val) {
          return val != null;
        }
      });
      var def = this.opt.default;
      if (_.isNumber(def) && def >= 0 && def < this.opt.choices.realLength)
        this.selected = def, this.rawDefault = def;
      else if (!_.isNumber(def) && def != null) {
        let index = _.findIndex(this.opt.choices.realChoices, ({ value }) => value === def), safeIndex = Math.max(index, 0);
        this.selected = safeIndex, this.rawDefault = safeIndex;
      }
      this.opt.default = null, this.paginator = new Paginator();
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), submit = events2.line.pipe(map2(this.getCurrentValue.bind(this))), validation = this.handleSubmitEvents(submit);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), events2.normalizedUpKey.pipe(takeUntil2(events2.line)).forEach(this.onUpKey.bind(this)), events2.normalizedDownKey.pipe(takeUntil2(events2.line)).forEach(this.onDownKey.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {RawListPrompt} self
     */
    render(error2) {
      var message = this.getQuestion(), bottomContent = "";
      if (this.status === "answered")
        message += chalk2.cyan(this.answer);
      else {
        var choicesStr = renderChoices(this.opt.choices, this.selected);
        message += `
` + this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize), message += `
  Answer: `;
      }
      message += this.rl.line, error2 && (bottomContent = `
` + chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    getCurrentValue(index) {
      index == null || index === "" ? index = this.rawDefault : index -= 1;
      var choice2 = this.opt.choices.getChoice(index);
      return choice2 ? choice2.value : null;
    }
    onEnd(state) {
      this.status = "answered", this.answer = state.value, this.render(), this.screen.done(), this.done(state.value);
    }
    onError() {
      this.render("Please enter a valid index");
    }
    /**
     * When user press a key
     */
    onKeypress() {
      var index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;
      this.opt.choices.getChoice(index) ? this.selected = index : this.selected = void 0, this.render();
    }
    /**
     * When user press up key
     */
    onUpKey() {
      this.onArrowKey("up");
    }
    /**
     * When user press down key
     */
    onDownKey() {
      this.onArrowKey("down");
    }
    /**
     * When user press up or down key
     * @param {String} type Arrow type: up or down
     */
    onArrowKey(type2) {
      var index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;
      type2 === "up" ? index = index === 0 ? this.opt.choices.length - 1 : index - 1 : index = index === this.opt.choices.length - 1 ? 0 : index + 1, this.rl.line = String(index + 1), this.onKeypress();
    }
  }
  function renderChoices(choices2, pointer) {
    var output = "", separatorOffset = 0;
    return choices2.forEach(function(choice2, i) {
      if (output += `
  `, choice2.type === "separator") {
        separatorOffset++, output += " " + choice2;
        return;
      }
      var index = i - separatorOffset, display = index + 1 + ") " + choice2.name;
      index === pointer && (display = chalk2.cyan(display)), output += display;
    }), output;
  }
  return rawlist = RawListPrompt, rawlist;
}
var expand, hasRequiredExpand;
function requireExpand() {
  if (hasRequiredExpand) return expand;
  hasRequiredExpand = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), Separator = requireSeparator(), observe = requireEvents(), Paginator = requirePaginator();
  class ExpandPrompt extends Base {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), this.validateChoices(this.opt.choices), this.opt.choices.push({
        key: "h",
        name: "Help, list all options",
        value: "help"
      }), this.opt.validate = (choice2) => choice2 == null ? "Please enter a valid command" : choice2 !== "help", this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default), this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), validation = this.handleSubmitEvents(
        events2.line.pipe(map2(this.getCurrentValue.bind(this)))
      );
      return validation.success.forEach(this.onSubmit.bind(this)), validation.error.forEach(this.onError.bind(this)), this.keypressObs = events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {ExpandPrompt} self
     */
    render(error2, hint) {
      var message = this.getQuestion(), bottomContent = "";
      if (this.status === "answered")
        message += chalk2.cyan(this.answer);
      else if (this.status === "expanded") {
        var choicesStr = renderChoices(this.opt.choices, this.selectedKey);
        message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize), message += `
  Answer: `;
      }
      message += this.rl.line, error2 && (bottomContent = chalk2.red(">> ") + error2), hint && (bottomContent = chalk2.cyan(">> ") + hint), this.screen.render(message, bottomContent);
    }
    getCurrentValue(input2) {
      input2 || (input2 = this.rawDefault);
      var selected = this.opt.choices.where({ key: input2.toLowerCase().trim() })[0];
      return selected ? selected.value : null;
    }
    /**
     * Generate the prompt choices string
     * @return {String}  Choices string
     */
    getChoices() {
      var output = "";
      return this.opt.choices.forEach((choice2) => {
        if (output += `
  `, choice2.type === "separator") {
          output += " " + choice2;
          return;
        }
        var choiceStr = choice2.key + ") " + choice2.name;
        this.selectedKey === choice2.key && (choiceStr = chalk2.cyan(choiceStr)), output += choiceStr;
      }), output;
    }
    onError(state) {
      if (state.value === "help") {
        this.selectedKey = "", this.status = "expanded", this.render();
        return;
      }
      this.render(state.isValid);
    }
    /**
     * When user press `enter` key
     */
    onSubmit(state) {
      this.status = "answered";
      var choice2 = this.opt.choices.where({ value: state.value })[0];
      this.answer = choice2.short || choice2.name, this.render(), this.screen.done(), this.done(state.value);
    }
    /**
     * When user press a key
     */
    onKeypress() {
      this.selectedKey = this.rl.line.toLowerCase();
      var selected = this.opt.choices.where({ key: this.selectedKey })[0];
      this.status === "expanded" ? this.render() : this.render(null, selected ? selected.name : null);
    }
    /**
     * Validate the choices
     * @param {Array} choices
     */
    validateChoices(choices2) {
      var formatError, errors = [], keymap = {};
      if (choices2.filter(Separator.exclude).forEach((choice2) => {
        (!choice2.key || choice2.key.length !== 1) && (formatError = !0), keymap[choice2.key] && errors.push(choice2.key), keymap[choice2.key] = !0, choice2.key = String(choice2.key).toLowerCase();
      }), formatError)
        throw new Error(
          "Format error: `key` param must be a single letter and is required."
        );
      if (keymap.h)
        throw new Error(
          "Reserved key error: `key` param cannot be `h` - this value is reserved."
        );
      if (errors.length)
        throw new Error(
          "Duplicate key error: `key` param must be unique. Duplicates: " + _.uniq(errors).join(", ")
        );
    }
    /**
     * Generate a string out of the choices keys
     * @param  {Array}  choices
     * @param  {Number|String} default - the choice index or name to capitalize
     * @return {String} The rendered choices key string
     */
    generateChoicesString(choices2, defaultChoice) {
      var defIndex = choices2.realLength - 1;
      if (_.isNumber(defaultChoice) && this.opt.choices.getChoice(defaultChoice))
        defIndex = defaultChoice;
      else if (_.isString(defaultChoice)) {
        let index = _.findIndex(
          choices2.realChoices,
          ({ value }) => value === defaultChoice
        );
        defIndex = index === -1 ? defIndex : index;
      }
      var defStr = this.opt.choices.pluck("key");
      return this.rawDefault = defStr[defIndex], defStr[defIndex] = String(defStr[defIndex]).toUpperCase(), defStr.join("");
    }
  }
  function renderChoices(choices2, pointer) {
    var output = "";
    return choices2.forEach((choice2) => {
      if (output += `
  `, choice2.type === "separator") {
        output += " " + choice2;
        return;
      }
      var choiceStr = choice2.key + ") " + choice2.name;
      pointer === choice2.key && (choiceStr = chalk2.cyan(choiceStr)), output += choiceStr;
    }), output;
  }
  return expand = ExpandPrompt, expand;
}
var checkbox, hasRequiredCheckbox;
function requireCheckbox() {
  if (hasRequiredCheckbox) return checkbox;
  hasRequiredCheckbox = 1;
  var _ = requireLodash(), chalk2 = chalk__default.default, cliCursor2 = requireCliCursor(), figures = requireFigures(), { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), observe = requireEvents(), Paginator = requirePaginator();
  class CheckboxPrompt extends Base {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), _.isArray(this.opt.default) && this.opt.choices.forEach(function(choice2) {
        this.opt.default.indexOf(choice2.value) >= 0 && (choice2.checked = !0);
      }, this), this.pointer = 0, this.opt.default = null, this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), validation = this.handleSubmitEvents(
        events2.line.pipe(map2(this.getCurrentValue.bind(this)))
      );
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.normalizedUpKey.pipe(takeUntil2(validation.success)).forEach(this.onUpKey.bind(this)), events2.normalizedDownKey.pipe(takeUntil2(validation.success)).forEach(this.onDownKey.bind(this)), events2.numberKey.pipe(takeUntil2(validation.success)).forEach(this.onNumberKey.bind(this)), events2.spaceKey.pipe(takeUntil2(validation.success)).forEach(this.onSpaceKey.bind(this)), events2.aKey.pipe(takeUntil2(validation.success)).forEach(this.onAllKey.bind(this)), events2.iKey.pipe(takeUntil2(validation.success)).forEach(this.onInverseKey.bind(this)), cliCursor2.hide(), this.render(), this.firstRender = !1, this;
    }
    /**
     * Render the prompt to screen
     * @return {CheckboxPrompt} self
     */
    render(error2) {
      var message = this.getQuestion(), bottomContent = "";
      if (this.spaceKeyPressed || (message += "(Press " + chalk2.cyan.bold("<space>") + " to select, " + chalk2.cyan.bold("<a>") + " to toggle all, " + chalk2.cyan.bold("<i>") + " to invert selection)"), this.status === "answered")
        message += chalk2.cyan(this.selection.join(", "));
      else {
        var choicesStr = renderChoices(this.opt.choices, this.pointer), indexPosition = this.opt.choices.indexOf(
          this.opt.choices.getChoice(this.pointer)
        );
        message += `
` + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
      }
      error2 && (bottomContent = chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    onEnd(state) {
      this.status = "answered", this.render(), this.screen.done(), cliCursor2.show(), this.done(state.value);
    }
    onError(state) {
      this.render(state.isValid);
    }
    getCurrentValue() {
      var choices2 = this.opt.choices.filter(function(choice2) {
        return !!choice2.checked && !choice2.disabled;
      });
      return this.selection = _.map(choices2, "short"), _.map(choices2, "value");
    }
    onUpKey() {
      var len = this.opt.choices.realLength;
      this.pointer = this.pointer > 0 ? this.pointer - 1 : len - 1, this.render();
    }
    onDownKey() {
      var len = this.opt.choices.realLength;
      this.pointer = this.pointer < len - 1 ? this.pointer + 1 : 0, this.render();
    }
    onNumberKey(input2) {
      input2 <= this.opt.choices.realLength && (this.pointer = input2 - 1, this.toggleChoice(this.pointer)), this.render();
    }
    onSpaceKey() {
      this.spaceKeyPressed = !0, this.toggleChoice(this.pointer), this.render();
    }
    onAllKey() {
      var shouldBeChecked = !!this.opt.choices.find(function(choice2) {
        return choice2.type !== "separator" && !choice2.checked;
      });
      this.opt.choices.forEach(function(choice2) {
        choice2.type !== "separator" && (choice2.checked = shouldBeChecked);
      }), this.render();
    }
    onInverseKey() {
      this.opt.choices.forEach(function(choice2) {
        choice2.type !== "separator" && (choice2.checked = !choice2.checked);
      }), this.render();
    }
    toggleChoice(index) {
      var item = this.opt.choices.getChoice(index);
      item !== void 0 && (this.opt.choices.getChoice(index).checked = !item.checked);
    }
  }
  function renderChoices(choices2, pointer) {
    var output = "", separatorOffset = 0;
    return choices2.forEach(function(choice2, i) {
      if (choice2.type === "separator") {
        separatorOffset++, output += " " + choice2 + `
`;
        return;
      }
      if (choice2.disabled)
        separatorOffset++, output += " - " + choice2.name, output += " (" + (_.isString(choice2.disabled) ? choice2.disabled : "Disabled") + ")";
      else {
        var line3 = getCheckbox(choice2.checked) + " " + choice2.name;
        i - separatorOffset === pointer ? output += chalk2.cyan(figures.pointer + line3) : output += " " + line3;
      }
      output += `
`;
    }), output.replace(/\n$/, "");
  }
  function getCheckbox(checked) {
    return checked ? chalk2.green(figures.radioOn) : figures.radioOff;
  }
  return checkbox = CheckboxPrompt, checkbox;
}
var password, hasRequiredPassword;
function requirePassword() {
  if (hasRequiredPassword) return password;
  hasRequiredPassword = 1;
  var chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base = requireBase(), observe = requireEvents();
  function mask(input2, maskChar) {
    return input2 = String(input2), maskChar = typeof maskChar == "string" ? maskChar : "*", input2.length === 0 ? "" : new Array(input2.length + 1).join(maskChar);
  }
  class PasswordPrompt extends Base {
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), submit = events2.line.pipe(map2(this.filterInput.bind(this))), validation = this.handleSubmitEvents(submit);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {PasswordPrompt} self
     */
    render(error2) {
      var message = this.getQuestion(), bottomContent = "";
      this.status === "answered" ? message += this.opt.mask ? chalk2.cyan(mask(this.answer, this.opt.mask)) : chalk2.italic.dim("[hidden]") : this.opt.mask ? message += mask(this.rl.line || "", this.opt.mask) : message += chalk2.italic.dim("[input is hidden] "), error2 && (bottomContent = `
` + chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    filterInput(input2) {
      return input2 || (this.opt.default == null ? "" : this.opt.default);
    }
    onEnd(state) {
      this.status = "answered", this.answer = state.value, this.render(), this.screen.done(), this.done(state.value);
    }
    onError(state) {
      this.render(state.isValid);
    }
    onKeypress() {
      this.opt.default && (this.opt.default = void 0), this.render();
    }
  }
  return password = PasswordPrompt, password;
}
var main = {}, chardet = {}, match, hasRequiredMatch;
function requireMatch() {
  return hasRequiredMatch || (hasRequiredMatch = 1, match = function(det, rec, confidence, name, lang) {
    this.confidence = confidence, this.name = name || rec.name(det), this.lang = lang;
  }), match;
}
var utf8, hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  var Match = requireMatch();
  return utf8 = function() {
    this.name = function() {
      return "UTF-8";
    }, this.match = function(det) {
      var hasBOM = !1, numValid = 0, numInvalid = 0, input2 = det.fRawInput, trailBytes = 0, confidence;
      det.fRawLength >= 3 && (input2[0] & 255) == 239 && (input2[1] & 255) == 187 && (input2[2] & 255) == 191 && (hasBOM = !0);
      for (var i = 0; i < det.fRawLength; i++) {
        var b = input2[i];
        if (b & 128) {
          if ((b & 224) == 192)
            trailBytes = 1;
          else if ((b & 240) == 224)
            trailBytes = 2;
          else if ((b & 248) == 240)
            trailBytes = 3;
          else {
            if (numInvalid++, numInvalid > 5)
              break;
            trailBytes = 0;
          }
          for (; i++, !(i >= det.fRawLength); ) {
            if ((input2[i] & 192) != 128) {
              numInvalid++;
              break;
            }
            if (--trailBytes == 0) {
              numValid++;
              break;
            }
          }
        }
      }
      if (confidence = 0, hasBOM && numInvalid == 0)
        confidence = 100;
      else if (hasBOM && numValid > numInvalid * 10)
        confidence = 80;
      else if (numValid > 3 && numInvalid == 0)
        confidence = 100;
      else if (numValid > 0 && numInvalid == 0)
        confidence = 80;
      else if (numValid == 0 && numInvalid == 0)
        confidence = 10;
      else if (numValid > numInvalid * 10)
        confidence = 25;
      else
        return null;
      return new Match(det, this, confidence);
    };
  }, utf8;
}
var unicode = { exports: {} }, hasRequiredUnicode;
function requireUnicode() {
  return hasRequiredUnicode || (hasRequiredUnicode = 1, function(module2) {
    var util2 = require$$0__default$6.default, Match = requireMatch();
    module2.exports.UTF_16BE = function() {
      this.name = function() {
        return "UTF-16BE";
      }, this.match = function(det) {
        var input2 = det.fRawInput;
        return input2.length >= 2 && (input2[0] & 255) == 254 && (input2[1] & 255) == 255 ? new Match(det, this, 100) : null;
      };
    }, module2.exports.UTF_16LE = function() {
      this.name = function() {
        return "UTF-16LE";
      }, this.match = function(det) {
        var input2 = det.fRawInput;
        return input2.length >= 2 && (input2[0] & 255) == 255 && (input2[1] & 255) == 254 ? input2.length >= 4 && input2[2] == 0 && input2[3] == 0 ? null : new Match(det, this, 100) : null;
      };
    };
    function UTF_32() {
    }
    UTF_32.prototype.match = function(det) {
      var input2 = det.fRawInput, limit = det.fRawLength / 4 * 4, numValid = 0, numInvalid = 0, hasBOM = !1, confidence = 0;
      if (limit == 0)
        return null;
      this.getChar(input2, 0) == 65279 && (hasBOM = !0);
      for (var i = 0; i < limit; i += 4) {
        var ch = this.getChar(input2, i);
        ch < 0 || ch >= 1114111 || ch >= 55296 && ch <= 57343 ? numInvalid += 1 : numValid += 1;
      }
      return hasBOM && numInvalid == 0 ? confidence = 100 : hasBOM && numValid > numInvalid * 10 ? confidence = 80 : numValid > 3 && numInvalid == 0 ? confidence = 100 : numValid > 0 && numInvalid == 0 ? confidence = 80 : numValid > numInvalid * 10 && (confidence = 25), confidence == 0 ? null : new Match(det, this, confidence);
    }, module2.exports.UTF_32BE = function() {
      this.name = function() {
        return "UTF-32BE";
      }, this.getChar = function(input2, index) {
        return (input2[index + 0] & 255) << 24 | (input2[index + 1] & 255) << 16 | (input2[index + 2] & 255) << 8 | input2[index + 3] & 255;
      };
    }, util2.inherits(module2.exports.UTF_32BE, UTF_32), module2.exports.UTF_32LE = function() {
      this.name = function() {
        return "UTF-32LE";
      }, this.getChar = function(input2, index) {
        return (input2[index + 3] & 255) << 24 | (input2[index + 2] & 255) << 16 | (input2[index + 1] & 255) << 8 | input2[index + 0] & 255;
      };
    }, util2.inherits(module2.exports.UTF_32LE, UTF_32);
  }(unicode)), unicode.exports;
}
var mbcs = { exports: {} }, hasRequiredMbcs;
function requireMbcs() {
  return hasRequiredMbcs || (hasRequiredMbcs = 1, function(module2) {
    var util2 = require$$0__default$6.default, Match = requireMatch();
    function binarySearch2(arr, searchValue) {
      function find2(arr2, searchValue2, left, right) {
        if (right < left)
          return -1;
        var mid = Math.floor(left + right >>> 1);
        return searchValue2 > arr2[mid] ? find2(arr2, searchValue2, mid + 1, right) : searchValue2 < arr2[mid] ? find2(arr2, searchValue2, left, mid - 1) : mid;
      }
      return find2(arr, searchValue, 0, arr.length - 1);
    }
    function IteratedChar() {
      this.charValue = 0, this.index = 0, this.nextIndex = 0, this.error = !1, this.done = !1, this.reset = function() {
        this.charValue = 0, this.index = -1, this.nextIndex = 0, this.error = !1, this.done = !1;
      }, this.nextByte = function(det) {
        if (this.nextIndex >= det.fRawLength)
          return this.done = !0, -1;
        var byteValue = det.fRawInput[this.nextIndex++] & 255;
        return byteValue;
      };
    }
    function mbcs2() {
    }
    mbcs2.prototype.match = function(det) {
      var doubleByteCharCount = 0, commonCharCount = 0, badCharCount = 0, totalCharCount = 0, confidence = 0, iter = new IteratedChar();
      detectBlock: {
        for (iter.reset(); this.nextChar(iter, det); ) {
          if (totalCharCount++, iter.error)
            badCharCount++;
          else {
            var cv = iter.charValue & 4294967295;
            cv <= 255 || (doubleByteCharCount++, this.commonChars != null && binarySearch2(this.commonChars, cv) >= 0 && commonCharCount++);
          }
          if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount)
            break detectBlock;
        }
        if (doubleByteCharCount <= 10 && badCharCount == 0) {
          doubleByteCharCount == 0 && totalCharCount < 10 ? confidence = 0 : confidence = 10;
          break detectBlock;
        }
        if (doubleByteCharCount < 20 * badCharCount) {
          confidence = 0;
          break detectBlock;
        }
        if (this.commonChars == null)
          confidence = 30 + doubleByteCharCount - 20 * badCharCount, confidence > 100 && (confidence = 100);
        else {
          var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4), scaleFactor = 90 / maxVal;
          confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10), confidence = Math.min(confidence, 100);
        }
      }
      return confidence == 0 ? null : new Match(det, this, confidence);
    }, mbcs2.prototype.nextChar = function(iter, det) {
    }, module2.exports.sjis = function() {
      this.name = function() {
        return "Shift-JIS";
      }, this.language = function() {
        return "ja";
      }, this.commonChars = [
        33088,
        33089,
        33090,
        33093,
        33115,
        33129,
        33130,
        33141,
        33142,
        33440,
        33442,
        33444,
        33449,
        33450,
        33451,
        33453,
        33455,
        33457,
        33459,
        33461,
        33463,
        33469,
        33470,
        33473,
        33476,
        33477,
        33478,
        33480,
        33481,
        33484,
        33485,
        33500,
        33504,
        33511,
        33512,
        33513,
        33514,
        33520,
        33521,
        33601,
        33603,
        33614,
        33615,
        33624,
        33630,
        33634,
        33639,
        33653,
        33654,
        33673,
        33674,
        33675,
        33677,
        33683,
        36502,
        37882,
        38314
      ], this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex, iter.error = !1;
        var firstByte;
        if (firstByte = iter.charValue = iter.nextByte(det), firstByte < 0)
          return !1;
        if (firstByte <= 127 || firstByte > 160 && firstByte <= 223)
          return !0;
        var secondByte = iter.nextByte(det);
        return secondByte < 0 ? !1 : (iter.charValue = firstByte << 8 | secondByte, secondByte >= 64 && secondByte <= 127 || secondByte >= 128 && secondByte <= 255 || (iter.error = !0), !0);
      };
    }, util2.inherits(module2.exports.sjis, mbcs2), module2.exports.big5 = function() {
      this.name = function() {
        return "Big5";
      }, this.language = function() {
        return "zh";
      }, this.commonChars = [
        41280,
        41281,
        41282,
        41283,
        41287,
        41289,
        41333,
        41334,
        42048,
        42054,
        42055,
        42056,
        42065,
        42068,
        42071,
        42084,
        42090,
        42092,
        42103,
        42147,
        42148,
        42151,
        42177,
        42190,
        42193,
        42207,
        42216,
        42237,
        42304,
        42312,
        42328,
        42345,
        42445,
        42471,
        42583,
        42593,
        42594,
        42600,
        42608,
        42664,
        42675,
        42681,
        42707,
        42715,
        42726,
        42738,
        42816,
        42833,
        42841,
        42970,
        43171,
        43173,
        43181,
        43217,
        43219,
        43236,
        43260,
        43456,
        43474,
        43507,
        43627,
        43706,
        43710,
        43724,
        43772,
        44103,
        44111,
        44208,
        44242,
        44377,
        44745,
        45024,
        45290,
        45423,
        45747,
        45764,
        45935,
        46156,
        46158,
        46412,
        46501,
        46525,
        46544,
        46552,
        46705,
        47085,
        47207,
        47428,
        47832,
        47940,
        48033,
        48593,
        49860,
        50105,
        50240,
        50271
      ], this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex, iter.error = !1;
        var firstByte = iter.charValue = iter.nextByte(det);
        if (firstByte < 0)
          return !1;
        if (firstByte <= 127 || firstByte == 255)
          return !0;
        var secondByte = iter.nextByte(det);
        return secondByte < 0 ? !1 : (iter.charValue = iter.charValue << 8 | secondByte, (secondByte < 64 || secondByte == 127 || secondByte == 255) && (iter.error = !0), !0);
      };
    }, util2.inherits(module2.exports.big5, mbcs2);
    function eucNextChar(iter, det) {
      iter.index = iter.nextIndex, iter.error = !1;
      var firstByte = 0, secondByte = 0, thirdByte = 0;
      buildChar: {
        if (firstByte = iter.charValue = iter.nextByte(det), firstByte < 0) {
          iter.done = !0;
          break buildChar;
        }
        if (firstByte <= 141)
          break buildChar;
        if (secondByte = iter.nextByte(det), iter.charValue = iter.charValue << 8 | secondByte, firstByte >= 161 && firstByte <= 254) {
          secondByte < 161 && (iter.error = !0);
          break buildChar;
        }
        if (firstByte == 142) {
          secondByte < 161 && (iter.error = !0);
          break buildChar;
        }
        firstByte == 143 && (thirdByte = iter.nextByte(det), iter.charValue = iter.charValue << 8 | thirdByte, thirdByte < 161 && (iter.error = !0));
      }
      return iter.done == !1;
    }
    module2.exports.euc_jp = function() {
      this.name = function() {
        return "EUC-JP";
      }, this.language = function() {
        return "ja";
      }, this.commonChars = [
        41377,
        41378,
        41379,
        41382,
        41404,
        41418,
        41419,
        41430,
        41431,
        42146,
        42148,
        42150,
        42152,
        42154,
        42155,
        42156,
        42157,
        42159,
        42161,
        42163,
        42165,
        42167,
        42169,
        42171,
        42173,
        42175,
        42176,
        42177,
        42179,
        42180,
        42182,
        42183,
        42184,
        42185,
        42186,
        42187,
        42190,
        42191,
        42192,
        42206,
        42207,
        42209,
        42210,
        42212,
        42216,
        42217,
        42218,
        42219,
        42220,
        42223,
        42226,
        42227,
        42402,
        42403,
        42404,
        42406,
        42407,
        42410,
        42413,
        42415,
        42416,
        42419,
        42421,
        42423,
        42424,
        42425,
        42431,
        42435,
        42438,
        42439,
        42440,
        42441,
        42443,
        42448,
        42453,
        42454,
        42455,
        42462,
        42464,
        42465,
        42469,
        42473,
        42474,
        42475,
        42476,
        42477,
        42483,
        47273,
        47572,
        47854,
        48072,
        48880,
        49079,
        50410,
        50940,
        51133,
        51896,
        51955,
        52188,
        52689
      ], this.nextChar = eucNextChar;
    }, util2.inherits(module2.exports.euc_jp, mbcs2), module2.exports.euc_kr = function() {
      this.name = function() {
        return "EUC-KR";
      }, this.language = function() {
        return "ko";
      }, this.commonChars = [
        45217,
        45235,
        45253,
        45261,
        45268,
        45286,
        45293,
        45304,
        45306,
        45308,
        45496,
        45497,
        45511,
        45527,
        45538,
        45994,
        46011,
        46274,
        46287,
        46297,
        46315,
        46501,
        46517,
        46527,
        46535,
        46569,
        46835,
        47023,
        47042,
        47054,
        47270,
        47278,
        47286,
        47288,
        47291,
        47337,
        47531,
        47534,
        47564,
        47566,
        47613,
        47800,
        47822,
        47824,
        47857,
        48103,
        48115,
        48125,
        48301,
        48314,
        48338,
        48374,
        48570,
        48576,
        48579,
        48581,
        48838,
        48840,
        48863,
        48878,
        48888,
        48890,
        49057,
        49065,
        49088,
        49124,
        49131,
        49132,
        49144,
        49319,
        49327,
        49336,
        49338,
        49339,
        49341,
        49351,
        49356,
        49358,
        49359,
        49366,
        49370,
        49381,
        49403,
        49404,
        49572,
        49574,
        49590,
        49622,
        49631,
        49654,
        49656,
        50337,
        50637,
        50862,
        51151,
        51153,
        51154,
        51160,
        51173,
        51373
      ], this.nextChar = eucNextChar;
    }, util2.inherits(module2.exports.euc_kr, mbcs2), module2.exports.gb_18030 = function() {
      this.name = function() {
        return "GB18030";
      }, this.language = function() {
        return "zh";
      }, this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex, iter.error = !1;
        var firstByte = 0, secondByte = 0, thirdByte = 0, fourthByte = 0;
        buildChar: {
          if (firstByte = iter.charValue = iter.nextByte(det), firstByte < 0) {
            iter.done = !0;
            break buildChar;
          }
          if (firstByte <= 128)
            break buildChar;
          if (secondByte = iter.nextByte(det), iter.charValue = iter.charValue << 8 | secondByte, firstByte >= 129 && firstByte <= 254) {
            if (secondByte >= 64 && secondByte <= 126 || secondByte >= 80 && secondByte <= 254)
              break buildChar;
            if (secondByte >= 48 && secondByte <= 57 && (thirdByte = iter.nextByte(det), thirdByte >= 129 && thirdByte <= 254 && (fourthByte = iter.nextByte(det), fourthByte >= 48 && fourthByte <= 57))) {
              iter.charValue = iter.charValue << 16 | thirdByte << 8 | fourthByte;
              break buildChar;
            }
            iter.error = !0;
            break buildChar;
          }
        }
        return iter.done == !1;
      }, this.commonChars = [
        41377,
        41378,
        41379,
        41380,
        41392,
        41393,
        41457,
        41459,
        41889,
        41900,
        41914,
        45480,
        45496,
        45502,
        45755,
        46025,
        46070,
        46323,
        46525,
        46532,
        46563,
        46767,
        46804,
        46816,
        47010,
        47016,
        47037,
        47062,
        47069,
        47284,
        47327,
        47350,
        47531,
        47561,
        47576,
        47610,
        47613,
        47821,
        48039,
        48086,
        48097,
        48122,
        48316,
        48347,
        48382,
        48588,
        48845,
        48861,
        49076,
        49094,
        49097,
        49332,
        49389,
        49611,
        49883,
        50119,
        50396,
        50410,
        50636,
        50935,
        51192,
        51371,
        51403,
        51413,
        51431,
        51663,
        51706,
        51889,
        51893,
        51911,
        51920,
        51926,
        51957,
        51965,
        52460,
        52728,
        52906,
        52932,
        52946,
        52965,
        53173,
        53186,
        53206,
        53442,
        53445,
        53456,
        53460,
        53671,
        53930,
        53938,
        53941,
        53947,
        53972,
        54211,
        54224,
        54269,
        54466,
        54490,
        54754,
        54992
      ];
    }, util2.inherits(module2.exports.gb_18030, mbcs2);
  }(mbcs)), mbcs.exports;
}
var sbcs = { exports: {} }, hasRequiredSbcs;
function requireSbcs() {
  return hasRequiredSbcs || (hasRequiredSbcs = 1, function(module2) {
    var util2 = require$$0__default$6.default, Match = requireMatch();
    function NGramParser(theNgramList, theByteMap) {
      var N_GRAM_MASK = 16777215;
      this.byteIndex = 0, this.ngram = 0, this.ngramList = theNgramList, this.byteMap = theByteMap, this.ngramCount = 0, this.hitCount = 0, this.search = function(table, value) {
        var index = 0;
        return table[index + 32] <= value && (index += 32), table[index + 16] <= value && (index += 16), table[index + 8] <= value && (index += 8), table[index + 4] <= value && (index += 4), table[index + 2] <= value && (index += 2), table[index + 1] <= value && (index += 1), table[index] > value && (index -= 1), index < 0 || table[index] != value ? -1 : index;
      }, this.lookup = function(thisNgram) {
        this.ngramCount += 1, this.search(this.ngramList, thisNgram) >= 0 && (this.hitCount += 1);
      }, this.addByte = function(b) {
        this.ngram = (this.ngram << 8) + (b & 255) & N_GRAM_MASK, this.lookup(this.ngram);
      }, this.nextByte = function(det) {
        return this.byteIndex >= det.fInputLen ? -1 : det.fInputBytes[this.byteIndex++] & 255;
      }, this.parse = function(det, spaceCh) {
        var b, ignoreSpace = !1;
        for (this.spaceChar = spaceCh; (b = this.nextByte(det)) >= 0; ) {
          var mb = this.byteMap[b];
          mb != 0 && (mb == this.spaceChar && ignoreSpace || this.addByte(mb), ignoreSpace = mb == this.spaceChar);
        }
        this.addByte(this.spaceChar);
        var rawPercent = this.hitCount / this.ngramCount;
        return rawPercent > 0.33 ? 98 : Math.floor(rawPercent * 300);
      };
    }
    function NGramsPlusLang(la, ng) {
      this.fLang = la, this.fNGrams = ng;
    }
    function sbcs2() {
    }
    sbcs2.prototype.spaceChar = 32, sbcs2.prototype.ngrams = function() {
    }, sbcs2.prototype.byteMap = function() {
    }, sbcs2.prototype.match = function(det) {
      var ngrams = this.ngrams(), multiple = Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang;
      if (!multiple) {
        var parser2 = new NGramParser(ngrams, this.byteMap()), confidence = parser2.parse(det, this.spaceChar);
        return confidence <= 0 ? null : new Match(det, this, confidence);
      }
      for (var bestConfidenceSoFar = -1, lang = null, i = ngrams.length - 1; i >= 0; i--) {
        var ngl = ngrams[i], parser2 = new NGramParser(ngl.fNGrams, this.byteMap()), confidence = parser2.parse(det, this.spaceChar);
        confidence > bestConfidenceSoFar && (bestConfidenceSoFar = confidence, lang = ngl.fLang);
      }
      var name = this.name(det);
      return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
    }, module2.exports.ISO_8859_1 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          170,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          186,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          new NGramsPlusLang("da", [
            2122086,
            2122100,
            2122853,
            2123118,
            2123122,
            2123375,
            2123873,
            2124064,
            2125157,
            2125671,
            2126053,
            2126697,
            2126708,
            2126953,
            2127465,
            6383136,
            6385184,
            6385252,
            6386208,
            6386720,
            6579488,
            6579566,
            6579570,
            6579572,
            6627443,
            6644768,
            6644837,
            6647328,
            6647396,
            6648352,
            6648421,
            6648608,
            6648864,
            6713202,
            6776096,
            6776174,
            6776178,
            6907749,
            6908960,
            6909543,
            7038240,
            7039845,
            7103858,
            7104871,
            7105637,
            7169380,
            7234661,
            7234848,
            7235360,
            7235429,
            7300896,
            7302432,
            7303712,
            7398688,
            7479396,
            7479397,
            7479411,
            7496992,
            7566437,
            7610483,
            7628064,
            7628146,
            7629164,
            7759218
          ]),
          new NGramsPlusLang("de", [
            2122094,
            2122101,
            2122341,
            2122849,
            2122853,
            2122857,
            2123113,
            2123621,
            2123873,
            2124142,
            2125161,
            2126691,
            2126693,
            2127214,
            2127461,
            2127471,
            2127717,
            2128501,
            6448498,
            6514720,
            6514789,
            6514804,
            6578547,
            6579566,
            6579570,
            6580581,
            6627428,
            6627443,
            6646126,
            6646132,
            6647328,
            6648352,
            6648608,
            6776174,
            6841710,
            6845472,
            6906728,
            6907168,
            6909472,
            6909541,
            6911008,
            7104867,
            7105637,
            7217249,
            7217252,
            7217267,
            7234592,
            7234661,
            7234848,
            7235360,
            7235429,
            7238757,
            7479396,
            7496805,
            7497065,
            7562088,
            7566437,
            7610468,
            7628064,
            7628142,
            7628146,
            7695972,
            7695975,
            7759218
          ]),
          new NGramsPlusLang("en", [
            2122016,
            2122094,
            2122341,
            2122607,
            2123375,
            2123873,
            2123877,
            2124142,
            2125153,
            2125670,
            2125938,
            2126437,
            2126689,
            2126708,
            2126952,
            2126959,
            2127720,
            6383972,
            6384672,
            6385184,
            6385252,
            6386464,
            6386720,
            6386789,
            6386793,
            6561889,
            6561908,
            6627425,
            6627443,
            6627444,
            6644768,
            6647412,
            6648352,
            6648608,
            6713202,
            6840692,
            6841632,
            6841714,
            6906912,
            6909472,
            6909543,
            6909806,
            6910752,
            7217249,
            7217268,
            7234592,
            7235360,
            7238688,
            7300640,
            7302688,
            7303712,
            7496992,
            7500576,
            7544929,
            7544948,
            7561577,
            7566368,
            7610484,
            7628146,
            7628897,
            7628901,
            7629167,
            7630624,
            7631648
          ]),
          new NGramsPlusLang("es", [
            2122016,
            2122593,
            2122607,
            2122853,
            2123116,
            2123118,
            2123123,
            2124142,
            2124897,
            2124911,
            2125921,
            2125935,
            2125938,
            2126197,
            2126437,
            2126693,
            2127214,
            2128160,
            6365283,
            6365284,
            6365285,
            6365292,
            6365296,
            6382441,
            6382703,
            6384672,
            6386208,
            6386464,
            6515187,
            6516590,
            6579488,
            6579564,
            6582048,
            6627428,
            6627429,
            6627436,
            6646816,
            6647328,
            6647412,
            6648608,
            6648692,
            6907246,
            6943598,
            7102752,
            7106419,
            7217253,
            7238757,
            7282788,
            7282789,
            7302688,
            7303712,
            7303968,
            7364978,
            7435621,
            7495968,
            7497075,
            7544932,
            7544933,
            7544944,
            7562528,
            7628064,
            7630624,
            7693600,
            15953440
          ]),
          new NGramsPlusLang("fr", [
            2122101,
            2122607,
            2122849,
            2122853,
            2122869,
            2123118,
            2123124,
            2124897,
            2124901,
            2125921,
            2125935,
            2125938,
            2126197,
            2126693,
            2126703,
            2127214,
            2154528,
            6385268,
            6386793,
            6513952,
            6516590,
            6579488,
            6579571,
            6583584,
            6627425,
            6627427,
            6627428,
            6627429,
            6627436,
            6627440,
            6627443,
            6647328,
            6647412,
            6648352,
            6648608,
            6648864,
            6649202,
            6909806,
            6910752,
            6911008,
            7102752,
            7103776,
            7103859,
            7169390,
            7217252,
            7234848,
            7238432,
            7238688,
            7302688,
            7302772,
            7304562,
            7435621,
            7479404,
            7496992,
            7544929,
            7544932,
            7544933,
            7544940,
            7544944,
            7610468,
            7628064,
            7629167,
            7693600,
            7696928
          ]),
          new NGramsPlusLang("it", [
            2122092,
            2122600,
            2122607,
            2122853,
            2122857,
            2123040,
            2124140,
            2124142,
            2124897,
            2125925,
            2125938,
            2127214,
            6365283,
            6365284,
            6365296,
            6365299,
            6386799,
            6514789,
            6516590,
            6579564,
            6580512,
            6627425,
            6627427,
            6627428,
            6627433,
            6627436,
            6627440,
            6627443,
            6646816,
            6646892,
            6647412,
            6648352,
            6841632,
            6889569,
            6889571,
            6889572,
            6889587,
            6906144,
            6908960,
            6909472,
            6909806,
            7102752,
            7103776,
            7104800,
            7105633,
            7234848,
            7235872,
            7237408,
            7238757,
            7282785,
            7282788,
            7282793,
            7282803,
            7302688,
            7302757,
            7366002,
            7495968,
            7496992,
            7563552,
            7627040,
            7628064,
            7629088,
            7630624,
            8022383
          ]),
          new NGramsPlusLang("nl", [
            2122092,
            2122341,
            2122849,
            2122853,
            2122857,
            2123109,
            2123118,
            2123621,
            2123877,
            2124142,
            2125153,
            2125157,
            2125680,
            2126949,
            2127457,
            2127461,
            2127471,
            2127717,
            2128489,
            6381934,
            6381938,
            6385184,
            6385252,
            6386208,
            6386720,
            6514804,
            6579488,
            6579566,
            6579570,
            6627426,
            6627446,
            6645102,
            6645106,
            6647328,
            6648352,
            6648435,
            6648864,
            6776174,
            6841716,
            6907168,
            6909472,
            6909543,
            6910752,
            7217250,
            7217252,
            7217253,
            7217256,
            7217263,
            7217270,
            7234661,
            7235360,
            7302756,
            7303026,
            7303200,
            7303712,
            7562088,
            7566437,
            7610468,
            7628064,
            7628142,
            7628146,
            7758190,
            7759218,
            7761775
          ]),
          new NGramsPlusLang("no", [
            2122100,
            2122102,
            2122853,
            2123118,
            2123122,
            2123375,
            2123873,
            2124064,
            2125157,
            2125671,
            2126053,
            2126693,
            2126699,
            2126703,
            2126708,
            2126953,
            2127465,
            2155808,
            6385252,
            6386208,
            6386720,
            6579488,
            6579566,
            6579572,
            6627443,
            6644768,
            6647328,
            6647397,
            6648352,
            6648421,
            6648864,
            6648948,
            6713202,
            6776174,
            6908779,
            6908960,
            6909543,
            7038240,
            7039845,
            7103776,
            7105637,
            7169380,
            7169390,
            7217267,
            7234848,
            7235360,
            7235429,
            7237221,
            7300896,
            7302432,
            7303712,
            7398688,
            7479411,
            7496992,
            7565165,
            7566437,
            7610483,
            7628064,
            7628142,
            7628146,
            7629164,
            7631904,
            7631973,
            7759218
          ]),
          new NGramsPlusLang("pt", [
            2122016,
            2122607,
            2122849,
            2122853,
            2122863,
            2123040,
            2123123,
            2125153,
            2125423,
            2125600,
            2125921,
            2125935,
            2125938,
            2126197,
            2126437,
            2126693,
            2127213,
            6365281,
            6365283,
            6365284,
            6365296,
            6382693,
            6382703,
            6384672,
            6386208,
            6386273,
            6386464,
            6516589,
            6516590,
            6578464,
            6579488,
            6582048,
            6582131,
            6627425,
            6627428,
            6647072,
            6647412,
            6648608,
            6648692,
            6906144,
            6906721,
            7169390,
            7238757,
            7238767,
            7282785,
            7282787,
            7282788,
            7282789,
            7282800,
            7303968,
            7364978,
            7435621,
            7495968,
            7497075,
            7544929,
            7544932,
            7544933,
            7544944,
            7566433,
            7628064,
            7630624,
            7693600,
            14905120,
            15197039
          ]),
          new NGramsPlusLang("sv", [
            2122100,
            2122102,
            2122853,
            2123118,
            2123510,
            2123873,
            2124064,
            2124142,
            2124655,
            2125157,
            2125667,
            2126053,
            2126699,
            2126703,
            2126708,
            2126953,
            2127457,
            2127465,
            2155634,
            6382693,
            6385184,
            6385252,
            6386208,
            6386804,
            6514720,
            6579488,
            6579566,
            6579570,
            6579572,
            6644768,
            6647328,
            6648352,
            6648864,
            6747762,
            6776174,
            6909036,
            6909543,
            7037216,
            7105568,
            7169380,
            7217267,
            7233824,
            7234661,
            7235360,
            7235429,
            7235950,
            7299944,
            7302432,
            7302688,
            7398688,
            7479393,
            7479411,
            7495968,
            7564129,
            7565165,
            7610483,
            7627040,
            7628064,
            7628146,
            7629164,
            7631904,
            7758194,
            14971424,
            16151072
          ])
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1252" : "ISO-8859-1";
      };
    }, util2.inherits(module2.exports.ISO_8859_1, sbcs2), module2.exports.ISO_8859_2 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          177,
          32,
          179,
          32,
          181,
          182,
          32,
          32,
          185,
          186,
          187,
          188,
          32,
          190,
          191,
          32,
          177,
          32,
          179,
          32,
          181,
          182,
          183,
          32,
          185,
          186,
          187,
          188,
          32,
          190,
          191,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          32
        ];
      }, this.ngrams = function() {
        return [
          new NGramsPlusLang("cs", [
            2122016,
            2122361,
            2122863,
            2124389,
            2125409,
            2125413,
            2125600,
            2125668,
            2125935,
            2125938,
            2126072,
            2126447,
            2126693,
            2126703,
            2126708,
            2126959,
            2127392,
            2127481,
            2128481,
            6365296,
            6513952,
            6514720,
            6627440,
            6627443,
            6627446,
            6647072,
            6647533,
            6844192,
            6844260,
            6910836,
            6972704,
            7042149,
            7103776,
            7104800,
            7233824,
            7268640,
            7269408,
            7269664,
            7282800,
            7300206,
            7301737,
            7304052,
            7304480,
            7304801,
            7368548,
            7368554,
            7369327,
            7403621,
            7562528,
            7565173,
            7566433,
            7566441,
            7566446,
            7628146,
            7630573,
            7630624,
            7676016,
            12477728,
            14773997,
            15296623,
            15540336,
            15540339,
            15559968,
            16278884
          ]),
          new NGramsPlusLang("hu", [
            2122016,
            2122106,
            2122341,
            2123111,
            2123116,
            2123365,
            2123873,
            2123887,
            2124147,
            2124645,
            2124649,
            2124790,
            2124901,
            2125153,
            2125157,
            2125161,
            2125413,
            2126714,
            2126949,
            2156915,
            6365281,
            6365291,
            6365293,
            6365299,
            6384416,
            6385184,
            6388256,
            6447470,
            6448494,
            6645625,
            6646560,
            6646816,
            6646885,
            6647072,
            6647328,
            6648421,
            6648864,
            6648933,
            6648948,
            6781216,
            6844263,
            6909556,
            6910752,
            7020641,
            7075450,
            7169383,
            7170414,
            7217249,
            7233899,
            7234923,
            7234925,
            7238688,
            7300985,
            7544929,
            7567973,
            7567988,
            7568097,
            7596391,
            7610465,
            7631904,
            7659891,
            8021362,
            14773792,
            15299360
          ]),
          new NGramsPlusLang("pl", [
            2122618,
            2122863,
            2124064,
            2124389,
            2124655,
            2125153,
            2125161,
            2125409,
            2125417,
            2125668,
            2125935,
            2125938,
            2126697,
            2127648,
            2127721,
            2127737,
            2128416,
            2128481,
            6365296,
            6365303,
            6385257,
            6514720,
            6519397,
            6519417,
            6582048,
            6584937,
            6627440,
            6627443,
            6627447,
            6627450,
            6645615,
            6646304,
            6647072,
            6647401,
            6778656,
            6906144,
            6907168,
            6907242,
            7037216,
            7039264,
            7039333,
            7170405,
            7233824,
            7235937,
            7235941,
            7282800,
            7305057,
            7305065,
            7368556,
            7369313,
            7369327,
            7369338,
            7502437,
            7502457,
            7563754,
            7564137,
            7566433,
            7825765,
            7955304,
            7957792,
            8021280,
            8022373,
            8026400,
            15955744
          ]),
          new NGramsPlusLang("ro", [
            2122016,
            2122083,
            2122593,
            2122597,
            2122607,
            2122613,
            2122853,
            2122857,
            2124897,
            2125153,
            2125925,
            2125938,
            2126693,
            2126819,
            2127214,
            2144873,
            2158190,
            6365283,
            6365284,
            6386277,
            6386720,
            6386789,
            6386976,
            6513010,
            6516590,
            6518048,
            6546208,
            6579488,
            6627425,
            6627427,
            6627428,
            6627440,
            6627443,
            6644e3,
            6646048,
            6646885,
            6647412,
            6648692,
            6889569,
            6889571,
            6889572,
            6889584,
            6907168,
            6908192,
            6909472,
            7102752,
            7103776,
            7106418,
            7107945,
            7234848,
            7238770,
            7303712,
            7365998,
            7496992,
            7497057,
            7501088,
            7594784,
            7628064,
            7631477,
            7660320,
            7694624,
            7695392,
            12216608,
            15625760
          ])
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1250" : "ISO-8859-2";
      };
    }, util2.inherits(module2.exports.ISO_8859_2, sbcs2), module2.exports.ISO_8859_5 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          32,
          254,
          255,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          32,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          32,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          2150944,
          2151134,
          2151646,
          2152400,
          2152480,
          2153168,
          2153182,
          2153936,
          2153941,
          2154193,
          2154462,
          2154464,
          2154704,
          2154974,
          2154978,
          2155230,
          2156514,
          2158050,
          13688280,
          13689580,
          13884960,
          14015468,
          14015960,
          14016994,
          14017056,
          14164191,
          14210336,
          14211104,
          14216992,
          14407133,
          14407712,
          14413021,
          14536736,
          14538016,
          14538965,
          14538991,
          14540320,
          14540498,
          14557394,
          14557407,
          14557409,
          14602784,
          14602960,
          14603230,
          14604576,
          14605292,
          14605344,
          14606818,
          14671579,
          14672085,
          14672088,
          14672094,
          14733522,
          14734804,
          14803664,
          14803666,
          14803672,
          14806816,
          14865883,
          14868e3,
          14868192,
          14871584,
          15196894,
          15459616
        ];
      }, this.name = function(det) {
        return "ISO-8859-5";
      }, this.language = function() {
        return "ru";
      };
    }, util2.inherits(module2.exports.ISO_8859_5, sbcs2), module2.exports.ISO_8859_6 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32
        ];
      }, this.ngrams = function() {
        return [
          2148324,
          2148326,
          2148551,
          2152932,
          2154986,
          2155748,
          2156006,
          2156743,
          13050055,
          13091104,
          13093408,
          13095200,
          13100064,
          13100227,
          13100231,
          13100232,
          13100234,
          13100236,
          13100237,
          13100239,
          13100243,
          13100249,
          13100258,
          13100261,
          13100264,
          13100266,
          13100320,
          13100576,
          13100746,
          13115591,
          13181127,
          13181153,
          13181156,
          13181157,
          13181160,
          13246663,
          13574343,
          13617440,
          13705415,
          13748512,
          13836487,
          14229703,
          14279913,
          14805536,
          14950599,
          14993696,
          15001888,
          15002144,
          15016135,
          15058720,
          15059232,
          15066656,
          15081671,
          15147207,
          15189792,
          15255524,
          15263264,
          15278279,
          15343815,
          15343845,
          15343848,
          15386912,
          15388960,
          15394336
        ];
      }, this.name = function(det) {
        return "ISO-8859-6";
      }, this.language = function() {
        return "ar";
      };
    }, util2.inherits(module2.exports.ISO_8859_6, sbcs2), module2.exports.ISO_8859_7 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          161,
          162,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          220,
          32,
          221,
          222,
          223,
          32,
          252,
          32,
          253,
          254,
          192,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          32,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          32
        ];
      }, this.ngrams = function() {
        return [
          2154989,
          2154992,
          2155497,
          2155753,
          2156016,
          2156320,
          2157281,
          2157797,
          2158049,
          2158368,
          2158817,
          2158831,
          2158833,
          2159604,
          2159605,
          2159847,
          2159855,
          14672160,
          14754017,
          14754036,
          14805280,
          14806304,
          14807292,
          14807584,
          14936545,
          15067424,
          15069728,
          15147252,
          15199520,
          15200800,
          15278324,
          15327520,
          15330014,
          15331872,
          15393257,
          15393268,
          15525152,
          15540449,
          15540453,
          15540464,
          15589664,
          15725088,
          15725856,
          15790069,
          15790575,
          15793184,
          15868129,
          15868133,
          15868138,
          15868144,
          15868148,
          15983904,
          15984416,
          15987951,
          16048416,
          16048617,
          16050157,
          16050162,
          16050666,
          16052e3,
          16052213,
          16054765,
          16379168,
          16706848
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1253" : "ISO-8859-7";
      }, this.language = function() {
        return "el";
      };
    }, util2.inherits(module2.exports.ISO_8859_7, sbcs2), module2.exports.ISO_8859_8 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          32,
          32,
          32,
          32,
          32
        ];
      }, this.ngrams = function() {
        return [
          new NGramsPlusLang("he", [
            2154725,
            2154727,
            2154729,
            2154746,
            2154985,
            2154990,
            2155744,
            2155749,
            2155753,
            2155758,
            2155762,
            2155769,
            2155770,
            2157792,
            2157796,
            2158304,
            2159340,
            2161132,
            14744096,
            14950624,
            14950625,
            14950628,
            14950636,
            14950638,
            14950649,
            15001056,
            15065120,
            15068448,
            15068960,
            15071264,
            15071776,
            15278308,
            15328288,
            15328762,
            15329773,
            15330592,
            15331104,
            15333408,
            15333920,
            15474912,
            15474916,
            15523872,
            15524896,
            15540448,
            15540449,
            15540452,
            15540460,
            15540462,
            15540473,
            15655968,
            15671524,
            15787040,
            15788320,
            15788525,
            15920160,
            16261348,
            16312813,
            16378912,
            16392416,
            16392417,
            16392420,
            16392428,
            16392430,
            16392441
          ]),
          new NGramsPlusLang("he", [
            2154725,
            2154732,
            2155753,
            2155756,
            2155758,
            2155760,
            2157040,
            2157810,
            2157817,
            2158053,
            2158057,
            2158565,
            2158569,
            2160869,
            2160873,
            2161376,
            2161381,
            2161385,
            14688484,
            14688492,
            14688493,
            14688506,
            14738464,
            14738916,
            14740512,
            14741024,
            14754020,
            14754029,
            14754042,
            14950628,
            14950633,
            14950636,
            14950637,
            14950639,
            14950648,
            14950650,
            15002656,
            15065120,
            15066144,
            15196192,
            15327264,
            15327520,
            15328288,
            15474916,
            15474925,
            15474938,
            15528480,
            15530272,
            15591913,
            15591920,
            15591928,
            15605988,
            15605997,
            15606010,
            15655200,
            15655968,
            15918112,
            16326884,
            16326893,
            16326906,
            16376864,
            16441376,
            16442400,
            16442857
          ])
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1255" : "ISO-8859-8";
      }, this.language = function() {
        return "he";
      };
    }, util2.inherits(module2.exports.ISO_8859_8, sbcs2), module2.exports.ISO_8859_9 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          170,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          186,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          105,
          254,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          2122337,
          2122345,
          2122357,
          2122849,
          2122853,
          2123621,
          2123873,
          2124140,
          2124641,
          2124655,
          2125153,
          2125676,
          2126689,
          2126945,
          2127461,
          2128225,
          6365282,
          6384416,
          6384737,
          6384993,
          6385184,
          6385405,
          6386208,
          6386273,
          6386429,
          6386685,
          6388065,
          6449522,
          6578464,
          6579488,
          6580512,
          6627426,
          6627435,
          6644841,
          6647328,
          6648352,
          6648425,
          6648681,
          6909029,
          6909472,
          6909545,
          6910496,
          7102830,
          7102834,
          7103776,
          7103858,
          7217249,
          7217250,
          7217259,
          7234657,
          7234661,
          7234848,
          7235872,
          7235950,
          7273760,
          7498094,
          7535982,
          7759136,
          7954720,
          7958386,
          16608800,
          16608868,
          16609021,
          16642301
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1254" : "ISO-8859-9";
      }, this.language = function() {
        return "tr";
      };
    }, util2.inherits(module2.exports.ISO_8859_9, sbcs2), module2.exports.windows_1251 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          144,
          131,
          32,
          131,
          32,
          32,
          32,
          32,
          32,
          32,
          154,
          32,
          156,
          157,
          158,
          159,
          144,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          154,
          32,
          156,
          157,
          158,
          159,
          32,
          162,
          162,
          188,
          32,
          180,
          32,
          32,
          184,
          32,
          186,
          32,
          32,
          32,
          32,
          191,
          32,
          32,
          179,
          179,
          180,
          181,
          32,
          32,
          184,
          32,
          186,
          32,
          188,
          190,
          190,
          191,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          2155040,
          2155246,
          2155758,
          2156512,
          2156576,
          2157280,
          2157294,
          2158048,
          2158053,
          2158305,
          2158574,
          2158576,
          2158816,
          2159086,
          2159090,
          2159342,
          2160626,
          2162162,
          14740968,
          14742268,
          14937632,
          15068156,
          15068648,
          15069682,
          15069728,
          15212783,
          15263008,
          15263776,
          15269664,
          15459821,
          15460384,
          15465709,
          15589408,
          15590688,
          15591653,
          15591679,
          15592992,
          15593186,
          15605986,
          15605999,
          15606001,
          15655456,
          15655648,
          15655918,
          15657248,
          15657980,
          15658016,
          15659506,
          15724267,
          15724773,
          15724776,
          15724782,
          15786210,
          15787492,
          15856352,
          15856354,
          15856360,
          15859488,
          15918571,
          15920672,
          15920880,
          15924256,
          16249582,
          16512288
        ];
      }, this.name = function(det) {
        return "windows-1251";
      }, this.language = function() {
        return "ru";
      };
    }, util2.inherits(module2.exports.windows_1251, sbcs2), module2.exports.windows_1256 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          129,
          32,
          131,
          32,
          32,
          32,
          32,
          136,
          32,
          138,
          32,
          156,
          141,
          142,
          143,
          144,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          152,
          32,
          154,
          32,
          156,
          32,
          32,
          159,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          170,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          32,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          32,
          32,
          32,
          32,
          244,
          32,
          32,
          32,
          32,
          249,
          32,
          251,
          252,
          32,
          32,
          255
        ];
      }, this.ngrams = function() {
        return [
          2148321,
          2148324,
          2148551,
          2153185,
          2153965,
          2154977,
          2155492,
          2156231,
          13050055,
          13091104,
          13093408,
          13095200,
          13099296,
          13099459,
          13099463,
          13099464,
          13099466,
          13099468,
          13099469,
          13099471,
          13099475,
          13099482,
          13099486,
          13099491,
          13099494,
          13099501,
          13099808,
          13100064,
          13100234,
          13115591,
          13181127,
          13181149,
          13181153,
          13181155,
          13181158,
          13246663,
          13574343,
          13617440,
          13705415,
          13748512,
          13836487,
          14295239,
          14344684,
          14544160,
          14753991,
          14797088,
          14806048,
          14806304,
          14885063,
          14927648,
          14928160,
          14935072,
          14950599,
          15016135,
          15058720,
          15124449,
          15131680,
          15474887,
          15540423,
          15540451,
          15540454,
          15583520,
          15585568,
          15590432
        ];
      }, this.name = function(det) {
        return "windows-1256";
      }, this.language = function() {
        return "ar";
      };
    }, util2.inherits(module2.exports.windows_1256, sbcs2), module2.exports.KOI8_R = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          163,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          163,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223
        ];
      }, this.ngrams = function() {
        return [
          2147535,
          2148640,
          2149313,
          2149327,
          2150081,
          2150085,
          2150338,
          2150607,
          2150610,
          2151105,
          2151375,
          2151380,
          2151631,
          2152224,
          2152399,
          2153153,
          2153684,
          2154196,
          12701385,
          12702936,
          12963032,
          12963529,
          12964820,
          12964896,
          13094688,
          13181136,
          13223200,
          13224224,
          13226272,
          13419982,
          13420832,
          13424846,
          13549856,
          13550880,
          13552069,
          13552081,
          13553440,
          13553623,
          13574352,
          13574355,
          13574359,
          13617103,
          13617696,
          13618392,
          13618464,
          13620180,
          13621024,
          13621185,
          13684684,
          13685445,
          13685449,
          13685455,
          13812183,
          13813188,
          13881632,
          13882561,
          13882569,
          13882583,
          13944268,
          13946656,
          13946834,
          13948960,
          14272544,
          14603471
        ];
      }, this.name = function(det) {
        return "KOI8-R";
      }, this.language = function() {
        return "ru";
      };
    }, util2.inherits(module2.exports.KOI8_R, sbcs2);
  }(sbcs)), sbcs.exports;
}
var iso2022 = { exports: {} }, hasRequiredIso2022;
function requireIso2022() {
  return hasRequiredIso2022 || (hasRequiredIso2022 = 1, function(module2) {
    var util2 = require$$0__default$6.default, Match = requireMatch();
    function ISO_2022() {
    }
    ISO_2022.prototype.match = function(det) {
      var i, j, escN, hits = 0, misses = 0, shifts = 0, quality, text = det.fInputBytes, textLen = det.fInputLen;
      scanInput:
        for (i = 0; i < textLen; i++) {
          if (text[i] == 27) {
            checkEscapes:
              for (escN = 0; escN < this.escapeSequences.length; escN++) {
                var seq2 = this.escapeSequences[escN];
                if (textLen - i < seq2.length)
                  continue checkEscapes;
                for (j = 1; j < seq2.length; j++)
                  if (seq2[j] != text[i + j])
                    continue checkEscapes;
                hits++, i += seq2.length - 1;
                continue scanInput;
              }
            misses++;
          }
          (text[i] == 14 || text[i] == 15) && shifts++;
        }
      return hits == 0 ? null : (quality = (100 * hits - 100 * misses) / (hits + misses), hits + shifts < 5 && (quality -= (5 - (hits + shifts)) * 10), quality <= 0 ? null : new Match(det, this, quality));
    }, module2.exports.ISO_2022_JP = function() {
      this.name = function() {
        return "ISO-2022-JP";
      }, this.escapeSequences = [
        [27, 36, 40, 67],
        // KS X 1001:1992
        [27, 36, 40, 68],
        // JIS X 212-1990
        [27, 36, 64],
        // JIS C 6226-1978
        [27, 36, 65],
        // GB 2312-80
        [27, 36, 66],
        // JIS X 208-1983
        [27, 38, 64],
        // JIS X 208 1990, 1997
        [27, 40, 66],
        // ASCII
        [27, 40, 72],
        // JIS-Roman
        [27, 40, 73],
        // Half-width katakana
        [27, 40, 74],
        // JIS-Roman
        [27, 46, 65],
        // ISO 8859-1
        [27, 46, 70]
        // ISO 8859-7
      ];
    }, util2.inherits(module2.exports.ISO_2022_JP, ISO_2022), module2.exports.ISO_2022_KR = function() {
      this.name = function() {
        return "ISO-2022-KR";
      }, this.escapeSequences = [
        [27, 36, 41, 67]
      ];
    }, util2.inherits(module2.exports.ISO_2022_KR, ISO_2022), module2.exports.ISO_2022_CN = function() {
      this.name = function() {
        return "ISO-2022-CN";
      }, this.escapeSequences = [
        [27, 36, 41, 65],
        // GB 2312-80
        [27, 36, 41, 71],
        // CNS 11643-1992 Plane 1
        [27, 36, 42, 72],
        // CNS 11643-1992 Plane 2
        [27, 36, 41, 69],
        // ISO-IR-165
        [27, 36, 43, 73],
        // CNS 11643-1992 Plane 3
        [27, 36, 43, 74],
        // CNS 11643-1992 Plane 4
        [27, 36, 43, 75],
        // CNS 11643-1992 Plane 5
        [27, 36, 43, 76],
        // CNS 11643-1992 Plane 6
        [27, 36, 43, 77],
        // CNS 11643-1992 Plane 7
        [27, 78],
        // SS2
        [27, 79]
        // SS3
      ];
    }, util2.inherits(module2.exports.ISO_2022_CN, ISO_2022);
  }(iso2022)), iso2022.exports;
}
var hasRequiredChardet;
function requireChardet() {
  if (hasRequiredChardet) return chardet;
  hasRequiredChardet = 1;
  var fs2 = require$$0__default$1.default, utf82 = requireUtf8(), unicode2 = requireUnicode(), mbcs2 = requireMbcs(), sbcs2 = requireSbcs(), iso20222 = requireIso2022(), self2 = chardet, recognisers = [
    new utf82(),
    new unicode2.UTF_16BE(),
    new unicode2.UTF_16LE(),
    new unicode2.UTF_32BE(),
    new unicode2.UTF_32LE(),
    new mbcs2.sjis(),
    new mbcs2.big5(),
    new mbcs2.euc_jp(),
    new mbcs2.euc_kr(),
    new mbcs2.gb_18030(),
    new iso20222.ISO_2022_JP(),
    new iso20222.ISO_2022_KR(),
    new iso20222.ISO_2022_CN(),
    new sbcs2.ISO_8859_1(),
    new sbcs2.ISO_8859_2(),
    new sbcs2.ISO_8859_5(),
    new sbcs2.ISO_8859_6(),
    new sbcs2.ISO_8859_7(),
    new sbcs2.ISO_8859_8(),
    new sbcs2.ISO_8859_9(),
    new sbcs2.windows_1251(),
    new sbcs2.windows_1256(),
    new sbcs2.KOI8_R()
  ];
  return chardet.detect = function(buffer2, opts) {
    for (var fByteStats = [], i = 0; i < 256; i++)
      fByteStats[i] = 0;
    for (var i = buffer2.length - 1; i >= 0; i--)
      fByteStats[buffer2[i] & 255]++;
    for (var fC1Bytes = !1, i = 128; i <= 159; i += 1)
      if (fByteStats[i] != 0) {
        fC1Bytes = !0;
        break;
      }
    var context = {
      fByteStats,
      fC1Bytes,
      fRawInput: buffer2,
      fRawLength: buffer2.length,
      fInputBytes: buffer2,
      fInputLen: buffer2.length
    }, matches = recognisers.map(function(rec) {
      return rec.match(context);
    }).filter(function(match2) {
      return !!match2;
    }).sort(function(a, b) {
      return b.confidence - a.confidence;
    });
    return opts && opts.returnAllMatches === !0 ? matches : matches.length > 0 ? matches[0].name : null;
  }, chardet.detectFile = function(filepath, opts, cb) {
    typeof opts == "function" && (cb = opts, opts = void 0);
    var fd, handler = function(err, buffer2) {
      if (fd && fs2.closeSync(fd), err) return cb(err, null);
      cb(null, self2.detect(buffer2, opts));
    };
    if (opts && opts.sampleSize) {
      fd = fs2.openSync(filepath, "r"), sample = Buffer.allocUnsafe(opts.sampleSize), fs2.read(fd, sample, 0, opts.sampleSize, null, function(err) {
        handler(err, sample);
      });
      return;
    }
    fs2.readFile(filepath, handler);
  }, chardet.detectFileSync = function(filepath, opts) {
    if (opts && opts.sampleSize) {
      var fd = fs2.openSync(filepath, "r"), sample2 = Buffer.allocUnsafe(opts.sampleSize);
      return fs2.readSync(fd, sample2, 0, opts.sampleSize), fs2.closeSync(fd), self2.detect(sample2, opts);
    }
    return self2.detect(fs2.readFileSync(filepath), opts);
  }, chardet.detectAll = function(buffer2, opts) {
    return typeof opts != "object" && (opts = {}), opts.returnAllMatches = !0, self2.detect(buffer2, opts);
  }, chardet.detectFileAll = function(filepath, opts, cb) {
    typeof opts == "function" && (cb = opts, opts = void 0), typeof opts != "object" && (opts = {}), opts.returnAllMatches = !0, self2.detectFile(filepath, opts, cb);
  }, chardet.detectFileAllSync = function(filepath, opts) {
    return typeof opts != "object" && (opts = {}), opts.returnAllMatches = !0, self2.detectFileSync(filepath, opts);
  }, chardet;
}
var lib = { exports: {} }, safer_1, hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0__default$a.default, Buffer2 = buffer2.Buffer, safer = {}, key2;
  for (key2 in buffer2)
    buffer2.hasOwnProperty(key2) && (key2 === "SlowBuffer" || key2 === "Buffer" || (safer[key2] = buffer2[key2]));
  var Safer = safer.Buffer = {};
  for (key2 in Buffer2)
    Buffer2.hasOwnProperty(key2) && (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow" || (Safer[key2] = Buffer2[key2]));
  if (safer.Buffer.prototype = Buffer2.prototype, (!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    if (value && typeof value.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    return Buffer2(value, encodingOrOffset, length);
  }), Safer.alloc || (Safer.alloc = function(size, fill, encoding) {
    if (typeof size != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    if (size < 0 || size >= 2 * (1 << 30))
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    var buf = Buffer2(size);
    return !fill || fill.length === 0 ? buf.fill(0) : typeof encoding == "string" ? buf.fill(fill, encoding) : buf.fill(fill), buf;
  }), !safer.kStringMaxLength)
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {
    }
  return safer.constants || (safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength)), safer_1 = safer, safer_1;
}
var bomHandling = {}, hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options2) {
    this.encoder = encoder, this.addBOM = !0;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    return this.addBOM && (str2 = BOMChar + str2, this.addBOM = !1), this.encoder.write(str2);
  }, PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  }, bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options2) {
    this.decoder = decoder, this.pass = !1, this.options = options2 || {};
  }
  return StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    return this.pass || !res || (res[0] === BOMChar && (res = res.slice(1), typeof this.options.stripBOM == "function" && this.options.stripBOM()), this.pass = !0), res;
  }, StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  }, bomHandling;
}
var encodings = {}, internal, hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName, this.bomAware = codecOptions.bomAware, this.enc === "base64" ? this.encoder = InternalEncoderBase64 : this.enc === "cesu8" && (this.enc = "utf8", this.encoder = InternalEncoderCesu8, Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}" && (this.decoder = InternalDecoderCesu8, this.defaultCharUnicode = iconv.defaultCharUnicode));
  }
  InternalCodec.prototype.encoder = InternalEncoder, InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$2__default$1.default.StringDecoder;
  StringDecoder.prototype.end || (StringDecoder.prototype.end = function() {
  });
  function InternalDecoder(options2, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options2, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  }, InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options2, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    return this.prevStr = str2.slice(completeQuads), str2 = str2.slice(0, completeQuads), Buffer2.from(str2, "base64");
  }, InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options2, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    for (var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0, i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      charCode < 128 ? buf[bufIdx++] = charCode : charCode < 2048 ? (buf[bufIdx++] = 192 + (charCode >>> 6), buf[bufIdx++] = 128 + (charCode & 63)) : (buf[bufIdx++] = 224 + (charCode >>> 12), buf[bufIdx++] = 128 + (charCode >>> 6 & 63), buf[bufIdx++] = 128 + (charCode & 63));
    }
    return buf.slice(0, bufIdx);
  }, InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options2, codec) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  return InternalDecoderCesu8.prototype.write = function(buf) {
    for (var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "", i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      (curByte & 192) !== 128 ? (contBytes > 0 && (res += this.defaultCharUnicode, contBytes = 0), curByte < 128 ? res += String.fromCharCode(curByte) : curByte < 224 ? (acc = curByte & 31, contBytes = 1, accBytes = 1) : curByte < 240 ? (acc = curByte & 15, contBytes = 2, accBytes = 1) : res += this.defaultCharUnicode) : contBytes > 0 ? (acc = acc << 6 | curByte & 63, contBytes--, accBytes++, contBytes === 0 && (accBytes === 2 && acc < 128 && acc > 0 ? res += this.defaultCharUnicode : accBytes === 3 && acc < 2048 ? res += this.defaultCharUnicode : res += String.fromCharCode(acc))) : res += this.defaultCharUnicode;
    }
    return this.acc = acc, this.contBytes = contBytes, this.accBytes = accBytes, res;
  }, InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    return this.contBytes > 0 && (res += this.defaultCharUnicode), res;
  }, internal;
}
var utf16 = {}, hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder, Utf16BECodec.prototype.decoder = Utf16BEDecoder, Utf16BECodec.prototype.bomAware = !0;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    for (var buf = Buffer2.from(str2, "ucs2"), i = 0; i < buf.length; i += 2) {
      var tmp2 = buf[i];
      buf[i] = buf[i + 1], buf[i + 1] = tmp2;
    }
    return buf;
  }, Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    for (this.overflowByte !== -1 && (buf2[0] = buf[0], buf2[1] = this.overflowByte, i = 1, j = 2); i < buf.length - 1; i += 2, j += 2)
      buf2[j] = buf[i + 1], buf2[j + 1] = buf[i];
    return this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1, buf2.slice(0, j).toString("ucs2");
  }, Utf16BEDecoder.prototype.end = function() {
  }, utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder, Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options2, codec) {
    options2 = options2 || {}, options2.addBOM === void 0 && (options2.addBOM = !0), this.encoder = codec.iconv.getEncoder("utf-16le", options2);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  }, Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options2, codec) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = options2 || {}, this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      if (this.initialBytes.push(buf), this.initialBytesLen += buf.length, this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  }, Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2)
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        for (var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64), i = 0; i < _len; i += 2)
          buf[i] === 0 && buf[i + 1] !== 0 && asciiCharsBE++, buf[i] !== 0 && buf[i + 1] === 0 && asciiCharsLE++;
        asciiCharsBE > asciiCharsLE ? enc = "utf-16be" : asciiCharsBE < asciiCharsLE && (enc = "utf-16le");
      }
    return enc;
  }
  return utf16;
}
var utf7 = {}, hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec, utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder, Utf7Codec.prototype.decoder = Utf7Decoder, Utf7Codec.prototype.bomAware = !0;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options2, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  }, Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options2, codec) {
    this.iconv = codec.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  for (var base64Regex = /[A-Za-z0-9\/+]/, base64Chars = [], i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = 43, minusChar = 45, andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    for (var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum, i2 = 0; i2 < buf.length; i2++)
      if (!inBase64)
        buf[i2] == plusChar && (res += this.iconv.decode(buf.slice(lastI, i2), "ascii"), lastI = i2 + 1, inBase64 = !0);
      else if (!base64Chars[buf[i2]]) {
        if (i2 == lastI && buf[i2] == minusChar)
          res += "+";
        else {
          var b64str = base64Accum + buf.slice(lastI, i2).toString();
          res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
        }
        buf[i2] != minusChar && i2--, lastI = i2 + 1, inBase64 = !1, base64Accum = "";
      }
    if (!inBase64)
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    else {
      var b64str = base64Accum + buf.slice(lastI).toString(), canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded), b64str = b64str.slice(0, canBeDecoded), res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    return this.inBase64 = inBase64, this.base64Accum = base64Accum, res;
  }, Utf7Decoder.prototype.end = function() {
    var res = "";
    return this.inBase64 && this.base64Accum.length > 0 && (res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", res;
  }, utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder, Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder, Utf7IMAPCodec.prototype.bomAware = !0;
  function Utf7IMAPEncoder(options2, codec) {
    this.iconv = codec.iconv, this.inBase64 = !1, this.base64Accum = Buffer2.alloc(6), this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    for (var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0, i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      32 <= uChar && uChar <= 126 ? (inBase64 && (base64AccumIdx > 0 && (bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx), base64AccumIdx = 0), buf[bufIdx++] = minusChar, inBase64 = !1), inBase64 || (buf[bufIdx++] = uChar, uChar === andChar && (buf[bufIdx++] = minusChar))) : (inBase64 || (buf[bufIdx++] = andChar, inBase64 = !0), inBase64 && (base64Accum[base64AccumIdx++] = uChar >> 8, base64Accum[base64AccumIdx++] = uChar & 255, base64AccumIdx == base64Accum.length && (bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx), base64AccumIdx = 0)));
    }
    return this.inBase64 = inBase64, this.base64AccumIdx = base64AccumIdx, buf.slice(0, bufIdx);
  }, Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx), this.base64AccumIdx = 0), buf[bufIdx++] = minusChar, this.inBase64 = !1), buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options2, codec) {
    this.iconv = codec.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  return base64IMAPChars[44] = !0, Utf7IMAPDecoder.prototype.write = function(buf) {
    for (var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum, i2 = 0; i2 < buf.length; i2++)
      if (!inBase64)
        buf[i2] == andChar && (res += this.iconv.decode(buf.slice(lastI, i2), "ascii"), lastI = i2 + 1, inBase64 = !0);
      else if (!base64IMAPChars[buf[i2]]) {
        if (i2 == lastI && buf[i2] == minusChar)
          res += "&";
        else {
          var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
          res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
        }
        buf[i2] != minusChar && i2--, lastI = i2 + 1, inBase64 = !1, base64Accum = "";
      }
    if (!inBase64)
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/"), canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded), b64str = b64str.slice(0, canBeDecoded), res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    return this.inBase64 = inBase64, this.base64Accum = base64Accum, res;
  }, Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    return this.inBase64 && this.base64Accum.length > 0 && (res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", res;
  }, utf7;
}
var sbcsCodec = {}, hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      for (var asciiString = "", i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    for (var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0)), i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder, SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options2, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    for (var buf = Buffer2.alloc(str2.length), i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
  }, SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options2, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  return SBCSDecoder.prototype.write = function(buf) {
    for (var decodeBuf = this.decodeBuf, newBuf = Buffer2.alloc(buf.length * 2), idx1 = 0, idx2 = 0, i = 0; i < buf.length; i++)
      idx1 = buf[i] * 2, idx2 = i * 2, newBuf[idx2] = decodeBuf[idx1], newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    return newBuf.toString("ucs2");
  }, SBCSDecoder.prototype.end = function() {
  }, sbcsCodec;
}
var sbcsData, hasRequiredSbcsData;
function requireSbcsData() {
  return hasRequiredSbcsData || (hasRequiredSbcsData = 1, sbcsData = {
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
    },
    mik: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    // Aliases of generated encodings.
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  }), sbcsData;
}
var sbcsDataGenerated, hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  return hasRequiredSbcsDataGenerated || (hasRequiredSbcsDataGenerated = 1, sbcsDataGenerated = {
    437: "cp437",
    737: "cp737",
    775: "cp775",
    850: "cp850",
    852: "cp852",
    855: "cp855",
    856: "cp856",
    857: "cp857",
    858: "cp858",
    860: "cp860",
    861: "cp861",
    862: "cp862",
    863: "cp863",
    864: "cp864",
    865: "cp865",
    866: "cp866",
    869: "cp869",
    874: "windows874",
    922: "cp922",
    1046: "cp1046",
    1124: "cp1124",
    1125: "cp1125",
    1129: "cp1129",
    1133: "cp1133",
    1161: "cp1161",
    1162: "cp1162",
    1163: "cp1163",
    1250: "windows1250",
    1251: "windows1251",
    1252: "windows1252",
    1253: "windows1253",
    1254: "windows1254",
    1255: "windows1255",
    1256: "windows1256",
    1257: "windows1257",
    1258: "windows1258",
    28591: "iso88591",
    28592: "iso88592",
    28593: "iso88593",
    28594: "iso88594",
    28595: "iso88595",
    28596: "iso88596",
    28597: "iso88597",
    28598: "iso88598",
    28599: "iso88599",
    28600: "iso885910",
    28601: "iso885911",
    28603: "iso885913",
    28604: "iso885914",
    28605: "iso885915",
    28606: "iso885916",
    windows874: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
    },
    maccyrillic: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    macgreek: {
      type: "_sbcs",
      chars: "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
    },
    maciceland: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macroman: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macromania: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macthai: {
      type: "_sbcs",
      chars: "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    macturkish: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macukraine: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    koi8r: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8u: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8ru: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8t: {
      type: "_sbcs",
      chars: "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    armscii8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
    },
    rk1048: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	
\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    georgianps: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    pt154: {
      type: "_sbcs",
      chars: "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\u1EB2\u1EB4\u1EAA\x07\b	
\v\f\r\u1EF6\u1EF8\x1B\u1EF4 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_\`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD`
    },
    hproman8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
    },
    macintosh: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    ascii: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    tis620: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    }
  }), sbcsDataGenerated;
}
var dbcsCodec = {}, hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  for (var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1, i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    if (this.encodingName = codecOptions.encodingName, !codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [], this.decodeTables[0] = UNASSIGNED_NODE.slice(0), this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val == "number")
          skipEncodeChars[val] = !0;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = !0;
      }
    if (this._fillEncodeTable(0, 0, skipEncodeChars), codecOptions.encodeAdd)
      for (var uChar in codecOptions.encodeAdd)
        Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar) && this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    if (this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === UNASSIGNED && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === UNASSIGNED && (this.defCharSB = 63), typeof codecOptions.gb18030 == "function") {
      this.gb18030 = codecOptions.gb18030();
      for (var thirdByteNodeIdx = this.decodeTables.length, thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0), fourthByteNodeIdx = this.decodeTables.length, fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0), i2 = 129; i2 <= 254; i2++)
        for (var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2], secondByteNode = this.decodeTables[secondByteNodeIdx], j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder, DBCSCodec.prototype.decoder = DBCSDecoder, DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    for (var bytes = []; addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    bytes.length == 0 && bytes.push(0);
    for (var node = this.decodeTables[0], i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED)
        node[bytes[i2]] = NODE_START - this.decodeTables.length, this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      else if (val <= NODE_START)
        node = this.decodeTables[NODE_START - val];
      else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  }, DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16), writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part == "string")
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            for (var len = 4095 - code + 2, seq2 = [], m = 0; m < len; m++)
              seq2.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length, this.decodeTableSeq.push(seq2);
          } else
            writeTable[curAddr++] = code;
        }
      else if (typeof part == "number")
        for (var charCode = writeTable[curAddr - 1] + 1, l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  }, DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    return this.encodeTable[high] === void 0 && (this.encodeTable[high] = UNASSIGNED_NODE.slice(0)), this.encodeTable[high];
  }, DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode), low = uCode & 255;
    bucket[low] <= SEQ_START ? this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode : bucket[low] == UNASSIGNED && (bucket[low] = dbcsCode);
  }, DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0], bucket = this._getEncodeBucket(uCode), low = uCode & 255, node;
    bucket[low] <= SEQ_START ? node = this.encodeTableSeq[SEQ_START - bucket[low]] : (node = {}, bucket[low] !== UNASSIGNED && (node[DEF_CHAR] = bucket[low]), bucket[low] = SEQ_START - this.encodeTableSeq.length, this.encodeTableSeq.push(node));
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node[uCode];
      typeof oldVal == "object" ? node = oldVal : (node = node[uCode] = {}, oldVal !== void 0 && (node[DEF_CHAR] = oldVal));
    }
    uCode = seq2[seq2.length - 1], node[uCode] = dbcsCode;
  }, DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    for (var node = this.decodeTables[nodeIdx], i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2], mbCode = prefix + i2;
      skipEncodeChars[mbCode] || (uCode >= 0 ? this._setEncodeChar(uCode, mbCode) : uCode <= NODE_START ? this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars) : uCode <= SEQ_START && this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode));
    }
  };
  function DBCSEncoder(options2, codec) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = codec.encodeTable, this.encodeTableSeq = codec.encodeTableSeq, this.defaultCharSingleByte = codec.defCharSB, this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    for (var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0; ; ) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344)
        if (uCode < 56320)
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else
            leadSurrogate = uCode, uCode = UNASSIGNED;
        else
          leadSurrogate !== -1 ? (uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320), leadSurrogate = -1) : uCode = UNASSIGNED;
      else leadSurrogate !== -1 && (nextChar = uCode, uCode = UNASSIGNED, leadSurrogate = -1);
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode == "object") {
          seqObj = resCode;
          continue;
        } else typeof resCode == "number" ? dbcsCode = resCode : resCode == null && (resCode = seqObj[DEF_CHAR], resCode !== void 0 && (dbcsCode = resCode, nextChar = uCode));
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0 && (dbcsCode = subtable[uCode & 255]), dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600), dbcsCode = dbcsCode % 12600, newBuf[j++] = 48 + Math.floor(dbcsCode / 1260), dbcsCode = dbcsCode % 1260, newBuf[j++] = 129 + Math.floor(dbcsCode / 10), dbcsCode = dbcsCode % 10, newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      dbcsCode === UNASSIGNED && (dbcsCode = this.defaultCharSingleByte), dbcsCode < 256 ? newBuf[j++] = dbcsCode : dbcsCode < 65536 ? (newBuf[j++] = dbcsCode >> 8, newBuf[j++] = dbcsCode & 255) : (newBuf[j++] = dbcsCode >> 16, newBuf[j++] = dbcsCode >> 8 & 255, newBuf[j++] = dbcsCode & 255);
    }
    return this.seqObj = seqObj, this.leadSurrogate = leadSurrogate, newBuf.slice(0, j);
  }, DBCSEncoder.prototype.end = function() {
    if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        dbcsCode !== void 0 && (dbcsCode < 256 ? newBuf[j++] = dbcsCode : (newBuf[j++] = dbcsCode >> 8, newBuf[j++] = dbcsCode & 255)), this.seqObj = void 0;
      }
      return this.leadSurrogate !== -1 && (newBuf[j++] = this.defaultCharSingleByte, this.leadSurrogate = -1), newBuf.slice(0, j);
    }
  }, DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options2, codec) {
    this.nodeIdx = 0, this.prevBuf = Buffer2.alloc(0), this.decodeTables = codec.decodeTables, this.decodeTableSeq = codec.decodeTableSeq, this.defaultCharUnicode = codec.defaultCharUnicode, this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    prevBufOffset > 0 && (prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]));
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset], uCode = this.decodeTables[nodeIdx][curByte];
      if (!(uCode >= 0)) if (uCode === UNASSIGNED)
        i2 = seqStart, uCode = this.defaultCharUnicode.charCodeAt(0);
      else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset), ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48), idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        for (var seq2 = this.decodeTableSeq[SEQ_START - uCode], k = 0; k < seq2.length - 1; k++)
          uCode = seq2[k], newBuf[j++] = uCode & 255, newBuf[j++] = uCode >> 8;
        uCode = seq2[seq2.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255, newBuf[j++] = uCodeLead >> 8, uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255, newBuf[j++] = uCode >> 8, nodeIdx = 0, seqStart = i2 + 1;
    }
    return this.nodeIdx = nodeIdx, this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset), newBuf.slice(0, j).toString("ucs2");
  }, DBCSDecoder.prototype.end = function() {
    for (var ret = ""; this.prevBuf.length > 0; ) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0), this.nodeIdx = 0, buf.length > 0 && (ret += this.write(buf));
    }
    return this.nodeIdx = 0, ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    for (var l = 0, r = table.length; l < r - 1; ) {
      var mid = l + Math.floor((r - l + 1) / 2);
      table[mid] <= val ? l = mid : r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
var require$$0$1 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "\uFF61",
    62
  ],
  [
    "8140",
    "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008",
    9,
    "\uFF0B\uFF0D\xB1\xD7"
  ],
  [
    "8180",
    "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"
  ],
  [
    "81b8",
    "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"
  ],
  [
    "81c8",
    "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"
  ],
  [
    "81da",
    "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"
  ],
  [
    "81f0",
    "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"
  ],
  [
    "81fc",
    "\u25EF"
  ],
  [
    "824f",
    "\uFF10",
    9
  ],
  [
    "8260",
    "\uFF21",
    25
  ],
  [
    "8281",
    "\uFF41",
    25
  ],
  [
    "829f",
    "\u3041",
    82
  ],
  [
    "8340",
    "\u30A1",
    62
  ],
  [
    "8380",
    "\u30E0",
    22
  ],
  [
    "839f",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "83bf",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "8440",
    "\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "8470",
    "\u0430",
    5,
    "\u0451\u0436",
    7
  ],
  [
    "8480",
    "\u043E",
    17
  ],
  [
    "849f",
    "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"
  ],
  [
    "8740",
    "\u2460",
    19,
    "\u2160",
    9
  ],
  [
    "875f",
    "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"
  ],
  [
    "877e",
    "\u337B"
  ],
  [
    "8780",
    "\u301D\u301F\u2116\u33CD\u2121\u32A4",
    4,
    "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"
  ],
  [
    "889f",
    "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"
  ],
  [
    "8940",
    "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"
  ],
  [
    "8980",
    "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"
  ],
  [
    "8a40",
    "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"
  ],
  [
    "8a80",
    "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"
  ],
  [
    "8b40",
    "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"
  ],
  [
    "8b80",
    "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"
  ],
  [
    "8c40",
    "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"
  ],
  [
    "8c80",
    "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"
  ],
  [
    "8d40",
    "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"
  ],
  [
    "8d80",
    "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"
  ],
  [
    "8e40",
    "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"
  ],
  [
    "8e80",
    "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"
  ],
  [
    "8f40",
    "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"
  ],
  [
    "8f80",
    "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"
  ],
  [
    "9040",
    "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"
  ],
  [
    "9080",
    "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"
  ],
  [
    "9140",
    "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"
  ],
  [
    "9180",
    "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"
  ],
  [
    "9240",
    "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"
  ],
  [
    "9280",
    "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"
  ],
  [
    "9340",
    "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"
  ],
  [
    "9380",
    "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"
  ],
  [
    "9440",
    "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"
  ],
  [
    "9480",
    "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"
  ],
  [
    "9540",
    "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"
  ],
  [
    "9580",
    "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"
  ],
  [
    "9640",
    "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"
  ],
  [
    "9680",
    "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"
  ],
  [
    "9740",
    "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"
  ],
  [
    "9780",
    "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"
  ],
  [
    "9840",
    "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"
  ],
  [
    "989f",
    "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"
  ],
  [
    "9940",
    "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"
  ],
  [
    "9980",
    "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"
  ],
  [
    "9a40",
    "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"
  ],
  [
    "9a80",
    "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"
  ],
  [
    "9b40",
    "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"
  ],
  [
    "9b80",
    "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"
  ],
  [
    "9c40",
    "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"
  ],
  [
    "9c80",
    "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"
  ],
  [
    "9d40",
    "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"
  ],
  [
    "9d80",
    "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"
  ],
  [
    "9e40",
    "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"
  ],
  [
    "9e80",
    "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"
  ],
  [
    "9f40",
    "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"
  ],
  [
    "9f80",
    "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"
  ],
  [
    "e040",
    "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"
  ],
  [
    "e080",
    "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"
  ],
  [
    "e140",
    "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"
  ],
  [
    "e180",
    "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"
  ],
  [
    "e240",
    "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"
  ],
  [
    "e280",
    "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"
  ],
  [
    "e340",
    "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"
  ],
  [
    "e380",
    "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"
  ],
  [
    "e440",
    "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"
  ],
  [
    "e480",
    "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"
  ],
  [
    "e540",
    "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"
  ],
  [
    "e580",
    "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"
  ],
  [
    "e640",
    "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"
  ],
  [
    "e680",
    "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"
  ],
  [
    "e740",
    "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"
  ],
  [
    "e780",
    "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"
  ],
  [
    "e840",
    "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"
  ],
  [
    "e880",
    "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"
  ],
  [
    "e940",
    "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"
  ],
  [
    "e980",
    "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"
  ],
  [
    "ea40",
    "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"
  ],
  [
    "ea80",
    "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"
  ],
  [
    "ed40",
    "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"
  ],
  [
    "ed80",
    "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"
  ],
  [
    "ee40",
    "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"
  ],
  [
    "ee80",
    "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"
  ],
  [
    "eeef",
    "\u2170",
    9,
    "\uFFE2\uFFE4\uFF07\uFF02"
  ],
  [
    "f040",
    "\uE000",
    62
  ],
  [
    "f080",
    "\uE03F",
    124
  ],
  [
    "f140",
    "\uE0BC",
    62
  ],
  [
    "f180",
    "\uE0FB",
    124
  ],
  [
    "f240",
    "\uE178",
    62
  ],
  [
    "f280",
    "\uE1B7",
    124
  ],
  [
    "f340",
    "\uE234",
    62
  ],
  [
    "f380",
    "\uE273",
    124
  ],
  [
    "f440",
    "\uE2F0",
    62
  ],
  [
    "f480",
    "\uE32F",
    124
  ],
  [
    "f540",
    "\uE3AC",
    62
  ],
  [
    "f580",
    "\uE3EB",
    124
  ],
  [
    "f640",
    "\uE468",
    62
  ],
  [
    "f680",
    "\uE4A7",
    124
  ],
  [
    "f740",
    "\uE524",
    62
  ],
  [
    "f780",
    "\uE563",
    124
  ],
  [
    "f840",
    "\uE5E0",
    62
  ],
  [
    "f880",
    "\uE61F",
    124
  ],
  [
    "f940",
    "\uE69C"
  ],
  [
    "fa40",
    "\u2170",
    9,
    "\u2160",
    9,
    "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"
  ],
  [
    "fa80",
    "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"
  ],
  [
    "fb40",
    "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"
  ],
  [
    "fb80",
    "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"
  ],
  [
    "fc40",
    "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"
  ]
], require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "\uFF61",
    62
  ],
  [
    "a1a1",
    "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008",
    9,
    "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"
  ],
  [
    "a2a1",
    "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"
  ],
  [
    "a2ba",
    "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"
  ],
  [
    "a2ca",
    "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"
  ],
  [
    "a2dc",
    "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"
  ],
  [
    "a2f2",
    "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"
  ],
  [
    "a2fe",
    "\u25EF"
  ],
  [
    "a3b0",
    "\uFF10",
    9
  ],
  [
    "a3c1",
    "\uFF21",
    25
  ],
  [
    "a3e1",
    "\uFF41",
    25
  ],
  [
    "a4a1",
    "\u3041",
    82
  ],
  [
    "a5a1",
    "\u30A1",
    85
  ],
  [
    "a6a1",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "a6c1",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "a7a1",
    "\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "a7d1",
    "\u0430",
    5,
    "\u0451\u0436",
    25
  ],
  [
    "a8a1",
    "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"
  ],
  [
    "ada1",
    "\u2460",
    19,
    "\u2160",
    9
  ],
  [
    "adc0",
    "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"
  ],
  [
    "addf",
    "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4",
    4,
    "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"
  ],
  [
    "b0a1",
    "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"
  ],
  [
    "b1a1",
    "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"
  ],
  [
    "b2a1",
    "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"
  ],
  [
    "b3a1",
    "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"
  ],
  [
    "b4a1",
    "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"
  ],
  [
    "b5a1",
    "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"
  ],
  [
    "b6a1",
    "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"
  ],
  [
    "b7a1",
    "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"
  ],
  [
    "b8a1",
    "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"
  ],
  [
    "b9a1",
    "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"
  ],
  [
    "baa1",
    "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"
  ],
  [
    "bba1",
    "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"
  ],
  [
    "bca1",
    "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"
  ],
  [
    "bda1",
    "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"
  ],
  [
    "bea1",
    "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"
  ],
  [
    "bfa1",
    "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"
  ],
  [
    "c0a1",
    "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"
  ],
  [
    "c1a1",
    "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"
  ],
  [
    "c2a1",
    "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"
  ],
  [
    "c3a1",
    "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"
  ],
  [
    "c4a1",
    "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"
  ],
  [
    "c5a1",
    "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"
  ],
  [
    "c6a1",
    "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"
  ],
  [
    "c7a1",
    "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"
  ],
  [
    "c8a1",
    "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"
  ],
  [
    "c9a1",
    "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"
  ],
  [
    "caa1",
    "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"
  ],
  [
    "cba1",
    "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"
  ],
  [
    "cca1",
    "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"
  ],
  [
    "cda1",
    "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"
  ],
  [
    "cea1",
    "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"
  ],
  [
    "cfa1",
    "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"
  ],
  [
    "d0a1",
    "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"
  ],
  [
    "d1a1",
    "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"
  ],
  [
    "d2a1",
    "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"
  ],
  [
    "d3a1",
    "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"
  ],
  [
    "d4a1",
    "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"
  ],
  [
    "d5a1",
    "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"
  ],
  [
    "d6a1",
    "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"
  ],
  [
    "d7a1",
    "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"
  ],
  [
    "d8a1",
    "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"
  ],
  [
    "d9a1",
    "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"
  ],
  [
    "daa1",
    "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"
  ],
  [
    "dba1",
    "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"
  ],
  [
    "dca1",
    "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"
  ],
  [
    "dda1",
    "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"
  ],
  [
    "dea1",
    "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"
  ],
  [
    "dfa1",
    "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"
  ],
  [
    "e0a1",
    "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"
  ],
  [
    "e1a1",
    "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"
  ],
  [
    "e2a1",
    "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"
  ],
  [
    "e3a1",
    "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"
  ],
  [
    "e4a1",
    "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"
  ],
  [
    "e5a1",
    "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"
  ],
  [
    "e6a1",
    "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"
  ],
  [
    "e7a1",
    "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"
  ],
  [
    "e8a1",
    "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"
  ],
  [
    "e9a1",
    "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"
  ],
  [
    "eaa1",
    "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"
  ],
  [
    "eba1",
    "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"
  ],
  [
    "eca1",
    "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"
  ],
  [
    "eda1",
    "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"
  ],
  [
    "eea1",
    "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"
  ],
  [
    "efa1",
    "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"
  ],
  [
    "f0a1",
    "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"
  ],
  [
    "f1a1",
    "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"
  ],
  [
    "f2a1",
    "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"
  ],
  [
    "f3a1",
    "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"
  ],
  [
    "f4a1",
    "\u582F\u69C7\u9059\u7464\u51DC\u7199"
  ],
  [
    "f9a1",
    "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"
  ],
  [
    "faa1",
    "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"
  ],
  [
    "fba1",
    "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"
  ],
  [
    "fca1",
    "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"
  ],
  [
    "fcf1",
    "\u2170",
    9,
    "\uFFE2\uFFE4\uFF07\uFF02"
  ],
  [
    "8fa2af",
    "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"
  ],
  [
    "8fa2c2",
    "\xA1\xA6\xBF"
  ],
  [
    "8fa2eb",
    "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"
  ],
  [
    "8fa6e1",
    "\u0386\u0388\u0389\u038A\u03AA"
  ],
  [
    "8fa6e7",
    "\u038C"
  ],
  [
    "8fa6e9",
    "\u038E\u03AB"
  ],
  [
    "8fa6ec",
    "\u038F"
  ],
  [
    "8fa6f1",
    "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"
  ],
  [
    "8fa7c2",
    "\u0402",
    10,
    "\u040E\u040F"
  ],
  [
    "8fa7f2",
    "\u0452",
    10,
    "\u045E\u045F"
  ],
  [
    "8fa9a1",
    "\xC6\u0110"
  ],
  [
    "8fa9a4",
    "\u0126"
  ],
  [
    "8fa9a6",
    "\u0132"
  ],
  [
    "8fa9a8",
    "\u0141\u013F"
  ],
  [
    "8fa9ab",
    "\u014A\xD8\u0152"
  ],
  [
    "8fa9af",
    "\u0166\xDE"
  ],
  [
    "8fa9c1",
    "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"
  ],
  [
    "8faaa1",
    "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"
  ],
  [
    "8faaba",
    "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"
  ],
  [
    "8faba1",
    "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"
  ],
  [
    "8fabbd",
    "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"
  ],
  [
    "8fabc5",
    "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"
  ],
  [
    "8fb0a1",
    "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"
  ],
  [
    "8fb1a1",
    "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"
  ],
  [
    "8fb2a1",
    "\u5092\u5093\u5094\u5096\u509B\u509C\u509E",
    4,
    "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"
  ],
  [
    "8fb3a1",
    "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"
  ],
  [
    "8fb4a1",
    "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"
  ],
  [
    "8fb5a1",
    "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"
  ],
  [
    "8fb6a1",
    "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D",
    5,
    "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4",
    4,
    "\u56F1\u56EB\u56ED"
  ],
  [
    "8fb7a1",
    "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D",
    4,
    "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"
  ],
  [
    "8fb8a1",
    "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"
  ],
  [
    "8fb9a1",
    "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"
  ],
  [
    "8fbaa1",
    "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6",
    4,
    "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"
  ],
  [
    "8fbba1",
    "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"
  ],
  [
    "8fbca1",
    "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A",
    4,
    "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"
  ],
  [
    "8fbda1",
    "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0",
    4,
    "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"
  ],
  [
    "8fbea1",
    "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110",
    4,
    "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"
  ],
  [
    "8fbfa1",
    "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"
  ],
  [
    "8fc0a1",
    "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"
  ],
  [
    "8fc1a1",
    "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"
  ],
  [
    "8fc2a1",
    "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"
  ],
  [
    "8fc3a1",
    "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E",
    4,
    "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"
  ],
  [
    "8fc4a1",
    "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"
  ],
  [
    "8fc5a1",
    "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"
  ],
  [
    "8fc6a1",
    "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"
  ],
  [
    "8fc7a1",
    "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"
  ],
  [
    "8fc8a1",
    "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"
  ],
  [
    "8fc9a1",
    "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094",
    4,
    "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103",
    4,
    "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"
  ],
  [
    "8fcaa1",
    "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"
  ],
  [
    "8fcba1",
    "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"
  ],
  [
    "8fcca1",
    "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428",
    9,
    "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"
  ],
  [
    "8fcda1",
    "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579",
    5,
    "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"
  ],
  [
    "8fcea1",
    "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2",
    6,
    "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"
  ],
  [
    "8fcfa1",
    "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"
  ],
  [
    "8fd0a1",
    "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"
  ],
  [
    "8fd1a1",
    "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"
  ],
  [
    "8fd2a1",
    "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59",
    5
  ],
  [
    "8fd3a1",
    "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"
  ],
  [
    "8fd4a1",
    "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2",
    4,
    "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"
  ],
  [
    "8fd5a1",
    "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"
  ],
  [
    "8fd6a1",
    "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"
  ],
  [
    "8fd7a1",
    "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"
  ],
  [
    "8fd8a1",
    "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"
  ],
  [
    "8fd9a1",
    "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F",
    4,
    "\u8556\u8559\u855C",
    6,
    "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"
  ],
  [
    "8fdaa1",
    "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660",
    4,
    "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"
  ],
  [
    "8fdba1",
    "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783",
    6,
    "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"
  ],
  [
    "8fdca1",
    "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA",
    4,
    "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"
  ],
  [
    "8fdda1",
    "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4",
    4,
    "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"
  ],
  [
    "8fdea1",
    "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42",
    4,
    "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"
  ],
  [
    "8fdfa1",
    "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"
  ],
  [
    "8fe0a1",
    "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"
  ],
  [
    "8fe1a1",
    "\u8F43\u8F47\u8F4F\u8F51",
    4,
    "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"
  ],
  [
    "8fe2a1",
    "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"
  ],
  [
    "8fe3a1",
    "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC",
    5,
    "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275",
    4,
    "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"
  ],
  [
    "8fe4a1",
    "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF",
    4,
    "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"
  ],
  [
    "8fe5a1",
    "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9",
    4,
    "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"
  ],
  [
    "8fe6a1",
    "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"
  ],
  [
    "8fe7a1",
    "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"
  ],
  [
    "8fe8a1",
    "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931",
    4,
    "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"
  ],
  [
    "8fe9a1",
    "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF",
    4
  ],
  [
    "8feaa1",
    "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A",
    4,
    "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"
  ],
  [
    "8feba1",
    "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26",
    4,
    "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"
  ],
  [
    "8feca1",
    "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"
  ],
  [
    "8feda1",
    "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43",
    4,
    "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D",
    4,
    "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"
  ]
], require$$2 = [
  [
    "0",
    "\0",
    127,
    "\u20AC"
  ],
  [
    "8140",
    "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A",
    5,
    "\u4E72\u4E74",
    9,
    "\u4E7F",
    6,
    "\u4E87\u4E8A"
  ],
  [
    "8180",
    "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02",
    6,
    "\u4F0B\u4F0C\u4F12",
    4,
    "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E",
    4,
    "\u4F44\u4F45\u4F47",
    5,
    "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"
  ],
  [
    "8240",
    "\u4FA4\u4FAB\u4FAD\u4FB0",
    4,
    "\u4FB6",
    8,
    "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2",
    4,
    "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF",
    11
  ],
  [
    "8280",
    "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F",
    10,
    "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050",
    4,
    "\u5056\u5057\u5058\u5059\u505B\u505D",
    7,
    "\u5066",
    5,
    "\u506D",
    8,
    "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E",
    20,
    "\u50A4\u50A6\u50AA\u50AB\u50AD",
    4,
    "\u50B3",
    6,
    "\u50BC"
  ],
  [
    "8340",
    "\u50BD",
    17,
    "\u50D0",
    5,
    "\u50D7\u50D8\u50D9\u50DB",
    10,
    "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6",
    4,
    "\u50FC",
    9,
    "\u5108"
  ],
  [
    "8380",
    "\u5109\u510A\u510C",
    5,
    "\u5113",
    13,
    "\u5122",
    28,
    "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D",
    4,
    "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6",
    4,
    "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2",
    5
  ],
  [
    "8440",
    "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5",
    5,
    "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244",
    5,
    "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"
  ],
  [
    "8480",
    "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273",
    9,
    "\u527E\u5280\u5283",
    4,
    "\u5289",
    6,
    "\u5291\u5292\u5294",
    6,
    "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4",
    9,
    "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9",
    5,
    "\u52E0\u52E1\u52E2\u52E3\u52E5",
    10,
    "\u52F1",
    7,
    "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"
  ],
  [
    "8540",
    "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F",
    9,
    "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"
  ],
  [
    "8580",
    "\u5390",
    4,
    "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF",
    6,
    "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3",
    4,
    "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D",
    4,
    "\u5463\u5465\u5467\u5469",
    7,
    "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"
  ],
  [
    "8640",
    "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0",
    4,
    "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4",
    5,
    "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A",
    4,
    "\u5512\u5513\u5515",
    5,
    "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"
  ],
  [
    "8680",
    "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B",
    4,
    "\u5551\u5552\u5553\u5554\u5557",
    4,
    "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F",
    5,
    "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0",
    6,
    "\u55A8",
    8,
    "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF",
    4,
    "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7",
    4,
    "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8",
    4,
    "\u55FF\u5602\u5603\u5604\u5605"
  ],
  [
    "8740",
    "\u5606\u5607\u560A\u560B\u560D\u5610",
    7,
    "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640",
    11,
    "\u564F",
    4,
    "\u5655\u5656\u565A\u565B\u565D",
    4
  ],
  [
    "8780",
    "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D",
    7,
    "\u5687",
    6,
    "\u5690\u5691\u5692\u5694",
    14,
    "\u56A4",
    10,
    "\u56B0",
    6,
    "\u56B8\u56B9\u56BA\u56BB\u56BD",
    12,
    "\u56CB",
    8,
    "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5",
    5,
    "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B",
    6
  ],
  [
    "8840",
    "\u5712",
    9,
    "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734",
    4,
    "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752",
    4,
    "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"
  ],
  [
    "8880",
    "\u5781\u5787\u5788\u5789\u578A\u578D",
    4,
    "\u5794",
    6,
    "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9",
    8,
    "\u57C4",
    6,
    "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5",
    7,
    "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825",
    4,
    "\u582B",
    4,
    "\u5831\u5832\u5833\u5834\u5836",
    7
  ],
  [
    "8940",
    "\u583E",
    5,
    "\u5845",
    6,
    "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859",
    4,
    "\u585F",
    5,
    "\u5866",
    4,
    "\u586D",
    16,
    "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"
  ],
  [
    "8980",
    "\u588D",
    4,
    "\u5894",
    4,
    "\u589B\u589C\u589D\u58A0",
    7,
    "\u58AA",
    17,
    "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6",
    10,
    "\u58D2\u58D3\u58D4\u58D6",
    13,
    "\u58E5",
    5,
    "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA",
    7,
    "\u5903\u5905\u5906\u5908",
    4,
    "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"
  ],
  [
    "8a40",
    "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B",
    4,
    "\u5961\u5963\u5964\u5966",
    12,
    "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"
  ],
  [
    "8a80",
    "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3",
    5,
    "\u59BA\u59BC\u59BD\u59BF",
    6,
    "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE",
    4,
    "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED",
    11,
    "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A",
    6,
    "\u5A33\u5A35\u5A37",
    4,
    "\u5A3D\u5A3E\u5A3F\u5A41",
    4,
    "\u5A47\u5A48\u5A4B",
    9,
    "\u5A56\u5A57\u5A58\u5A59\u5A5B",
    5
  ],
  [
    "8b40",
    "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B",
    8,
    "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80",
    17,
    "\u5A93",
    6,
    "\u5A9C",
    13,
    "\u5AAB\u5AAC"
  ],
  [
    "8b80",
    "\u5AAD",
    4,
    "\u5AB4\u5AB6\u5AB7\u5AB9",
    4,
    "\u5ABF\u5AC0\u5AC3",
    5,
    "\u5ACA\u5ACB\u5ACD",
    4,
    "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC",
    4,
    "\u5AF2",
    22,
    "\u5B0A",
    11,
    "\u5B18",
    25,
    "\u5B33\u5B35\u5B36\u5B38",
    7,
    "\u5B41",
    6
  ],
  [
    "8c40",
    "\u5B48",
    7,
    "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"
  ],
  [
    "8c80",
    "\u5BD1\u5BD4",
    8,
    "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9",
    4,
    "\u5BEF\u5BF1",
    6,
    "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67",
    6,
    "\u5C70\u5C72",
    6,
    "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83",
    4,
    "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D",
    4,
    "\u5CA4",
    4
  ],
  [
    "8d40",
    "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5",
    5,
    "\u5CCC",
    5,
    "\u5CD3",
    5,
    "\u5CDA",
    6,
    "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1",
    9,
    "\u5CFC",
    4
  ],
  [
    "8d80",
    "\u5D01\u5D04\u5D05\u5D08",
    5,
    "\u5D0F",
    4,
    "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F",
    4,
    "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F",
    4,
    "\u5D35",
    7,
    "\u5D3F",
    7,
    "\u5D48\u5D49\u5D4D",
    10,
    "\u5D59\u5D5A\u5D5C\u5D5E",
    10,
    "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75",
    12,
    "\u5D83",
    21,
    "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"
  ],
  [
    "8e40",
    "\u5DA1",
    21,
    "\u5DB8",
    12,
    "\u5DC6",
    6,
    "\u5DCE",
    12,
    "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"
  ],
  [
    "8e80",
    "\u5DF0\u5DF5\u5DF6\u5DF8",
    4,
    "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E",
    7,
    "\u5E28",
    4,
    "\u5E2F\u5E30\u5E32",
    4,
    "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46",
    5,
    "\u5E4D",
    6,
    "\u5E56",
    4,
    "\u5E5C\u5E5D\u5E5F\u5E60\u5E63",
    14,
    "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8",
    4,
    "\u5EAE",
    4,
    "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF",
    6
  ],
  [
    "8f40",
    "\u5EC6\u5EC7\u5EC8\u5ECB",
    5,
    "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC",
    11,
    "\u5EE9\u5EEB",
    8,
    "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"
  ],
  [
    "8f80",
    "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32",
    6,
    "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41",
    14,
    "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2",
    5,
    "\u5FA9\u5FAB\u5FAC\u5FAF",
    5,
    "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE",
    4,
    "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"
  ],
  [
    "9040",
    "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030",
    4,
    "\u6036",
    4,
    "\u603D\u603E\u6040\u6044",
    6,
    "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"
  ],
  [
    "9080",
    "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD",
    7,
    "\u60C7\u60C8\u60C9\u60CC",
    4,
    "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1",
    4,
    "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB",
    4,
    "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110",
    4,
    "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C",
    18,
    "\u6140",
    6
  ],
  [
    "9140",
    "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156",
    6,
    "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169",
    6,
    "\u6171\u6172\u6173\u6174\u6176\u6178",
    18,
    "\u618C\u618D\u618F",
    4,
    "\u6195"
  ],
  [
    "9180",
    "\u6196",
    6,
    "\u619E",
    8,
    "\u61AA\u61AB\u61AD",
    9,
    "\u61B8",
    5,
    "\u61BF\u61C0\u61C1\u61C3",
    4,
    "\u61C9\u61CC",
    4,
    "\u61D3\u61D5",
    16,
    "\u61E7",
    13,
    "\u61F6",
    8,
    "\u6200",
    5,
    "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238",
    4,
    "\u6242\u6244\u6245\u6246\u624A"
  ],
  [
    "9240",
    "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C",
    6,
    "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B",
    5,
    "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"
  ],
  [
    "9280",
    "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333",
    5,
    "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356",
    7,
    "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399",
    6,
    "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"
  ],
  [
    "9340",
    "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7",
    6,
    "\u63DF\u63E2\u63E4",
    4,
    "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406",
    4,
    "\u640D\u640E\u6411\u6412\u6415",
    5,
    "\u641D\u641F\u6422\u6423\u6424"
  ],
  [
    "9380",
    "\u6425\u6427\u6428\u6429\u642B\u642E",
    5,
    "\u6435",
    4,
    "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B",
    6,
    "\u6453\u6455\u6456\u6457\u6459",
    4,
    "\u645F",
    7,
    "\u6468\u646A\u646B\u646C\u646E",
    9,
    "\u647B",
    6,
    "\u6483\u6486\u6488",
    8,
    "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F",
    4,
    "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6",
    6,
    "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"
  ],
  [
    "9440",
    "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7",
    24,
    "\u6501",
    7,
    "\u650A",
    7,
    "\u6513",
    4,
    "\u6519",
    8
  ],
  [
    "9480",
    "\u6522\u6523\u6524\u6526",
    4,
    "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540",
    4,
    "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578",
    14,
    "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1",
    7,
    "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8",
    7,
    "\u65E1\u65E3\u65E4\u65EA\u65EB"
  ],
  [
    "9540",
    "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB",
    4,
    "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637",
    4,
    "\u663D\u663F\u6640\u6642\u6644",
    6,
    "\u664D\u664E\u6650\u6651\u6658"
  ],
  [
    "9580",
    "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669",
    4,
    "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698",
    4,
    "\u669E",
    8,
    "\u66A9",
    4,
    "\u66AF",
    4,
    "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF",
    25,
    "\u66DA\u66DE",
    7,
    "\u66E7\u66E8\u66EA",
    5,
    "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"
  ],
  [
    "9640",
    "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720",
    5,
    "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757",
    4,
    "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"
  ],
  [
    "9680",
    "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9",
    7,
    "\u67C2\u67C5",
    9,
    "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5",
    7,
    "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818",
    4,
    "\u681E\u681F\u6820\u6822",
    6,
    "\u682B",
    6,
    "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856",
    5
  ],
  [
    "9740",
    "\u685C\u685D\u685E\u685F\u686A\u686C",
    7,
    "\u6875\u6878",
    8,
    "\u6882\u6884\u6887",
    7,
    "\u6890\u6891\u6892\u6894\u6895\u6896\u6898",
    9,
    "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"
  ],
  [
    "9780",
    "\u68B9",
    6,
    "\u68C1\u68C3",
    5,
    "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB",
    4,
    "\u68E1\u68E2\u68E4",
    9,
    "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906",
    4,
    "\u690C\u690F\u6911\u6913",
    11,
    "\u6921\u6922\u6923\u6925",
    7,
    "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943",
    16,
    "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"
  ],
  [
    "9840",
    "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972",
    4,
    "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E",
    5,
    "\u6996\u6997\u6999\u699A\u699D",
    9,
    "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"
  ],
  [
    "9880",
    "\u69BE\u69BF\u69C0\u69C2",
    7,
    "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5",
    5,
    "\u69DC\u69DD\u69DE\u69E1",
    11,
    "\u69EE\u69EF\u69F0\u69F1\u69F3",
    9,
    "\u69FE\u6A00",
    9,
    "\u6A0B",
    11,
    "\u6A19",
    5,
    "\u6A20\u6A22",
    5,
    "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36",
    6,
    "\u6A3F",
    4,
    "\u6A45\u6A46\u6A48",
    7,
    "\u6A51",
    6,
    "\u6A5A"
  ],
  [
    "9940",
    "\u6A5C",
    4,
    "\u6A62\u6A63\u6A64\u6A66",
    10,
    "\u6A72",
    6,
    "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85",
    8,
    "\u6A8F\u6A92",
    4,
    "\u6A98",
    7,
    "\u6AA1",
    5
  ],
  [
    "9980",
    "\u6AA7\u6AA8\u6AAA\u6AAD",
    114,
    "\u6B25\u6B26\u6B28",
    6
  ],
  [
    "9a40",
    "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D",
    11,
    "\u6B5A",
    7,
    "\u6B68\u6B69\u6B6B",
    13,
    "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"
  ],
  [
    "9a80",
    "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C",
    4,
    "\u6BA2",
    7,
    "\u6BAB",
    7,
    "\u6BB6\u6BB8",
    6,
    "\u6BC0\u6BC3\u6BC4\u6BC6",
    4,
    "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC",
    4,
    "\u6BE2",
    7,
    "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE",
    6,
    "\u6C08",
    4,
    "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B",
    4,
    "\u6C51\u6C52\u6C53\u6C56\u6C58"
  ],
  [
    "9b40",
    "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B",
    4,
    "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"
  ],
  [
    "9b80",
    "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F",
    5,
    "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D",
    4,
    "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96",
    4,
    "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9",
    5,
    "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"
  ],
  [
    "9c40",
    "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD",
    7,
    "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"
  ],
  [
    "9c80",
    "\u6E36\u6E37\u6E39\u6E3B",
    7,
    "\u6E45",
    7,
    "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60",
    10,
    "\u6E6C\u6E6D\u6E6F",
    14,
    "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A",
    4,
    "\u6E91",
    6,
    "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA",
    5
  ],
  [
    "9d40",
    "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA",
    7,
    "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A",
    4,
    "\u6F10\u6F11\u6F12\u6F16",
    9,
    "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37",
    6,
    "\u6F3F\u6F40\u6F41\u6F42"
  ],
  [
    "9d80",
    "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E",
    9,
    "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67",
    5,
    "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D",
    6,
    "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F",
    12,
    "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2",
    4,
    "\u6FA8",
    10,
    "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA",
    5,
    "\u6FC1\u6FC3",
    5,
    "\u6FCA",
    6,
    "\u6FD3",
    10,
    "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"
  ],
  [
    "9e40",
    "\u6FE6",
    7,
    "\u6FF0",
    32,
    "\u7012",
    7,
    "\u701C",
    6,
    "\u7024",
    6
  ],
  [
    "9e80",
    "\u702B",
    9,
    "\u7036\u7037\u7038\u703A",
    17,
    "\u704D\u704E\u7050",
    13,
    "\u705F",
    11,
    "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E",
    12,
    "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB",
    12,
    "\u70DA"
  ],
  [
    "9f40",
    "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0",
    6,
    "\u70F8\u70FA\u70FB\u70FC\u70FE",
    10,
    "\u710B",
    4,
    "\u7111\u7112\u7114\u7117\u711B",
    10,
    "\u7127",
    7,
    "\u7132\u7133\u7134"
  ],
  [
    "9f80",
    "\u7135\u7137",
    13,
    "\u7146\u7147\u7148\u7149\u714B\u714D\u714F",
    12,
    "\u715D\u715F",
    4,
    "\u7165\u7169",
    4,
    "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E",
    5,
    "\u7185",
    4,
    "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A",
    4,
    "\u71A1",
    6,
    "\u71A9\u71AA\u71AB\u71AD",
    5,
    "\u71B4\u71B6\u71B7\u71B8\u71BA",
    8,
    "\u71C4",
    9,
    "\u71CF",
    4
  ],
  [
    "a040",
    "\u71D6",
    9,
    "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8",
    5,
    "\u71EF",
    9,
    "\u71FA",
    11,
    "\u7207",
    19
  ],
  [
    "a080",
    "\u721B\u721C\u721E",
    9,
    "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240",
    6,
    "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285",
    4,
    "\u728C\u728E\u7290\u7291\u7293",
    11,
    "\u72A0",
    11,
    "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA",
    6,
    "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"
  ],
  [
    "a1a1",
    "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008",
    7,
    "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"
  ],
  [
    "a2a1",
    "\u2170",
    9
  ],
  [
    "a2b1",
    "\u2488",
    19,
    "\u2474",
    19,
    "\u2460",
    9
  ],
  [
    "a2e5",
    "\u3220",
    9
  ],
  [
    "a2f1",
    "\u2160",
    11
  ],
  [
    "a3a1",
    "\uFF01\uFF02\uFF03\uFFE5\uFF05",
    88,
    "\uFFE3"
  ],
  [
    "a4a1",
    "\u3041",
    82
  ],
  [
    "a5a1",
    "\u30A1",
    85
  ],
  [
    "a6a1",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "a6c1",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "a6e0",
    "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"
  ],
  [
    "a6ee",
    "\uFE3B\uFE3C\uFE37\uFE38\uFE31"
  ],
  [
    "a6f4",
    "\uFE33\uFE34"
  ],
  [
    "a7a1",
    "\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "a7d1",
    "\u0430",
    5,
    "\u0451\u0436",
    25
  ],
  [
    "a840",
    "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550",
    35,
    "\u2581",
    6
  ],
  [
    "a880",
    "\u2588",
    7,
    "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"
  ],
  [
    "a8a1",
    "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"
  ],
  [
    "a8bd",
    "\u0144\u0148"
  ],
  [
    "a8c0",
    "\u0261"
  ],
  [
    "a8c5",
    "\u3105",
    36
  ],
  [
    "a940",
    "\u3021",
    8,
    "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"
  ],
  [
    "a959",
    "\u2121\u3231"
  ],
  [
    "a95c",
    "\u2010"
  ],
  [
    "a960",
    "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49",
    9,
    "\uFE54\uFE55\uFE56\uFE57\uFE59",
    8
  ],
  [
    "a980",
    "\uFE62",
    4,
    "\uFE68\uFE69\uFE6A\uFE6B"
  ],
  [
    "a996",
    "\u3007"
  ],
  [
    "a9a4",
    "\u2500",
    75
  ],
  [
    "aa40",
    "\u72DC\u72DD\u72DF\u72E2",
    5,
    "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304",
    5,
    "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340",
    8
  ],
  [
    "aa80",
    "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358",
    7,
    "\u7361",
    10,
    "\u736E\u7370\u7371"
  ],
  [
    "ab40",
    "\u7372",
    11,
    "\u737F",
    4,
    "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3",
    5,
    "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3",
    4
  ],
  [
    "ab80",
    "\u73CB\u73CC\u73CE\u73D2",
    6,
    "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3",
    4
  ],
  [
    "ac40",
    "\u73F8",
    10,
    "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411",
    8,
    "\u741C",
    5,
    "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437",
    4,
    "\u743D\u743E\u743F\u7440\u7442",
    11
  ],
  [
    "ac80",
    "\u744E",
    6,
    "\u7456\u7458\u745D\u7460",
    12,
    "\u746E\u746F\u7471",
    4,
    "\u7478\u7479\u747A"
  ],
  [
    "ad40",
    "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491",
    10,
    "\u749D\u749F",
    7,
    "\u74AA",
    15,
    "\u74BB",
    12
  ],
  [
    "ad80",
    "\u74C8",
    9,
    "\u74D3",
    8,
    "\u74DD\u74DF\u74E1\u74E5\u74E7",
    6,
    "\u74F0\u74F1\u74F2"
  ],
  [
    "ae40",
    "\u74F3\u74F5\u74F8",
    6,
    "\u7500\u7501\u7502\u7503\u7505",
    7,
    "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520",
    4,
    "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"
  ],
  [
    "ae80",
    "\u755D",
    7,
    "\u7567\u7568\u7569\u756B",
    6,
    "\u7573\u7575\u7576\u7577\u757A",
    4,
    "\u7580\u7581\u7582\u7584\u7585\u7587"
  ],
  [
    "af40",
    "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6",
    4,
    "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"
  ],
  [
    "af80",
    "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"
  ],
  [
    "b040",
    "\u7645",
    6,
    "\u764E",
    5,
    "\u7655\u7657",
    4,
    "\u765D\u765F\u7660\u7661\u7662\u7664",
    6,
    "\u766C\u766D\u766E\u7670",
    7,
    "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"
  ],
  [
    "b080",
    "\u769C",
    7,
    "\u76A5",
    8,
    "\u76AF\u76B0\u76B3\u76B5",
    9,
    "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"
  ],
  [
    "b140",
    "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0",
    4,
    "\u76E6",
    7,
    "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E",
    10,
    "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"
  ],
  [
    "b180",
    "\u772C\u772E\u7730",
    4,
    "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748",
    7,
    "\u7752",
    7,
    "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"
  ],
  [
    "b240",
    "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D",
    11,
    "\u777A\u777B\u777C\u7781\u7782\u7783\u7786",
    5,
    "\u778F\u7790\u7793",
    11,
    "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6",
    4
  ],
  [
    "b280",
    "\u77BC\u77BE\u77C0",
    12,
    "\u77CE",
    8,
    "\u77D8\u77D9\u77DA\u77DD",
    4,
    "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"
  ],
  [
    "b340",
    "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803",
    5,
    "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"
  ],
  [
    "b380",
    "\u785B\u785C\u785E",
    11,
    "\u786F",
    7,
    "\u7878\u7879\u787A\u787B\u787D",
    6,
    "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"
  ],
  [
    "b440",
    "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8",
    7,
    "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA",
    9
  ],
  [
    "b480",
    "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED",
    4,
    "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB",
    5,
    "\u7902\u7903\u7904\u7906",
    6,
    "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"
  ],
  [
    "b540",
    "\u790D",
    5,
    "\u7914",
    9,
    "\u791F",
    4,
    "\u7925",
    14,
    "\u7935",
    4,
    "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A",
    8,
    "\u7954\u7955\u7958\u7959\u7961\u7963"
  ],
  [
    "b580",
    "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970",
    6,
    "\u7979\u797B",
    4,
    "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"
  ],
  [
    "b640",
    "\u7993",
    6,
    "\u799B",
    11,
    "\u79A8",
    10,
    "\u79B4",
    4,
    "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9",
    5,
    "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"
  ],
  [
    "b680",
    "\u79EC\u79EE\u79F1",
    6,
    "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F",
    4,
    "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"
  ],
  [
    "b740",
    "\u7A1D\u7A1F\u7A21\u7A22\u7A24",
    14,
    "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40",
    5,
    "\u7A47",
    9,
    "\u7A52",
    4,
    "\u7A58",
    16
  ],
  [
    "b780",
    "\u7A69",
    6,
    "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"
  ],
  [
    "b840",
    "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE",
    4,
    "\u7AB4",
    10,
    "\u7AC0",
    10,
    "\u7ACC",
    9,
    "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7",
    5,
    "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"
  ],
  [
    "b880",
    "\u7AF4",
    4,
    "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"
  ],
  [
    "b940",
    "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F",
    5,
    "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63",
    10,
    "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86",
    6,
    "\u7B8E\u7B8F"
  ],
  [
    "b980",
    "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9",
    7,
    "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"
  ],
  [
    "ba40",
    "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4",
    4,
    "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2",
    4,
    "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF",
    7,
    "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10",
    5,
    "\u7C17\u7C18\u7C19"
  ],
  [
    "ba80",
    "\u7C1A",
    4,
    "\u7C20",
    5,
    "\u7C28\u7C29\u7C2B",
    12,
    "\u7C39",
    5,
    "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"
  ],
  [
    "bb40",
    "\u7C43",
    9,
    "\u7C4E",
    36,
    "\u7C75",
    5,
    "\u7C7E",
    9
  ],
  [
    "bb80",
    "\u7C88\u7C8A",
    6,
    "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4",
    4,
    "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"
  ],
  [
    "bc40",
    "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE",
    6,
    "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1",
    6,
    "\u7CE9",
    5,
    "\u7CF0",
    7,
    "\u7CF9\u7CFA\u7CFC",
    13,
    "\u7D0B",
    5
  ],
  [
    "bc80",
    "\u7D11",
    14,
    "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30",
    6,
    "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"
  ],
  [
    "bd40",
    "\u7D37",
    54,
    "\u7D6F",
    7
  ],
  [
    "bd80",
    "\u7D78",
    32,
    "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"
  ],
  [
    "be40",
    "\u7D99",
    12,
    "\u7DA7",
    6,
    "\u7DAF",
    42
  ],
  [
    "be80",
    "\u7DDA",
    32,
    "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"
  ],
  [
    "bf40",
    "\u7DFB",
    62
  ],
  [
    "bf80",
    "\u7E3A\u7E3C",
    4,
    "\u7E42",
    4,
    "\u7E48",
    21,
    "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"
  ],
  [
    "c040",
    "\u7E5E",
    35,
    "\u7E83",
    23,
    "\u7E9C\u7E9D\u7E9E"
  ],
  [
    "c080",
    "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B",
    6,
    "\u7F43\u7F46",
    9,
    "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"
  ],
  [
    "c140",
    "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63",
    4,
    "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82",
    7,
    "\u7F8B\u7F8D\u7F8F",
    4,
    "\u7F95",
    4,
    "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8",
    6,
    "\u7FB1"
  ],
  [
    "c180",
    "\u7FB3",
    4,
    "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF",
    4,
    "\u7FD6\u7FD7\u7FD9",
    5,
    "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"
  ],
  [
    "c240",
    "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4",
    6,
    "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B",
    5,
    "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"
  ],
  [
    "c280",
    "\u8059\u805B",
    13,
    "\u806B",
    5,
    "\u8072",
    11,
    "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"
  ],
  [
    "c340",
    "\u807E\u8081\u8082\u8085\u8088\u808A\u808D",
    5,
    "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7",
    4,
    "\u80CF",
    6,
    "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"
  ],
  [
    "c380",
    "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F",
    12,
    "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139",
    4,
    "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"
  ],
  [
    "c440",
    "\u8140",
    5,
    "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B",
    4,
    "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183",
    4,
    "\u8189\u818B\u818C\u818D\u818E\u8190\u8192",
    5,
    "\u8199\u819A\u819E",
    4,
    "\u81A4\u81A5"
  ],
  [
    "c480",
    "\u81A7\u81A9\u81AB",
    7,
    "\u81B4",
    5,
    "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD",
    6,
    "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"
  ],
  [
    "c540",
    "\u81D4",
    14,
    "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE",
    4,
    "\u81F5",
    5,
    "\u81FD\u81FF\u8203\u8207",
    4,
    "\u820E\u820F\u8211\u8213\u8215",
    5,
    "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"
  ],
  [
    "c580",
    "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250",
    7,
    "\u8259\u825B\u825C\u825D\u825E\u8260",
    7,
    "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"
  ],
  [
    "c640",
    "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"
  ],
  [
    "c680",
    "\u82FA\u82FC",
    4,
    "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D",
    9,
    "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"
  ],
  [
    "c740",
    "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A",
    4,
    "\u8353\u8355",
    4,
    "\u835D\u8362\u8370",
    6,
    "\u8379\u837A\u837E",
    6,
    "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1",
    6,
    "\u83AC\u83AD\u83AE"
  ],
  [
    "c780",
    "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"
  ],
  [
    "c840",
    "\u83EE\u83EF\u83F3",
    4,
    "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412",
    5,
    "\u8419\u841A\u841B\u841E",
    5,
    "\u8429",
    7,
    "\u8432",
    5,
    "\u8439\u843A\u843B\u843E",
    7,
    "\u8447\u8448\u8449"
  ],
  [
    "c880",
    "\u844A",
    6,
    "\u8452",
    4,
    "\u8458\u845D\u845E\u845F\u8460\u8462\u8464",
    4,
    "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"
  ],
  [
    "c940",
    "\u847D",
    4,
    "\u8483\u8484\u8485\u8486\u848A\u848D\u848F",
    7,
    "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2",
    12,
    "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"
  ],
  [
    "c980",
    "\u84D8",
    4,
    "\u84DE\u84E1\u84E2\u84E4\u84E7",
    4,
    "\u84ED\u84EE\u84EF\u84F1",
    10,
    "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"
  ],
  [
    "ca40",
    "\u8503",
    8,
    "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522",
    8,
    "\u852D",
    9,
    "\u853E",
    4,
    "\u8544\u8545\u8546\u8547\u854B",
    10
  ],
  [
    "ca80",
    "\u8557\u8558\u855A\u855B\u855C\u855D\u855F",
    4,
    "\u8565\u8566\u8567\u8569",
    8,
    "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"
  ],
  [
    "cb40",
    "\u8582\u8583\u8586\u8588",
    6,
    "\u8590",
    10,
    "\u859D",
    6,
    "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1",
    5,
    "\u85B8\u85BA",
    6,
    "\u85C2",
    6,
    "\u85CA",
    4,
    "\u85D1\u85D2"
  ],
  [
    "cb80",
    "\u85D4\u85D6",
    5,
    "\u85DD",
    6,
    "\u85E5\u85E6\u85E7\u85E8\u85EA",
    14,
    "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"
  ],
  [
    "cc40",
    "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600",
    4,
    "\u8606",
    10,
    "\u8612\u8613\u8614\u8615\u8617",
    15,
    "\u8628\u862A",
    13,
    "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"
  ],
  [
    "cc80",
    "\u8641",
    11,
    "\u8652\u8653\u8655",
    4,
    "\u865B\u865C\u865D\u865F\u8660\u8661\u8663",
    7,
    "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"
  ],
  [
    "cd40",
    "\u866D\u866F\u8670\u8672",
    6,
    "\u8683",
    6,
    "\u868E",
    4,
    "\u8694\u8696",
    5,
    "\u869E",
    4,
    "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB",
    4,
    "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"
  ],
  [
    "cd80",
    "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"
  ],
  [
    "ce40",
    "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740",
    6,
    "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A",
    5,
    "\u8761\u8762\u8766",
    7,
    "\u876F\u8771\u8772\u8773\u8775"
  ],
  [
    "ce80",
    "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E",
    4,
    "\u8794\u8795\u8796\u8798",
    6,
    "\u87A0",
    4,
    "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"
  ],
  [
    "cf40",
    "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1",
    4,
    "\u87C7\u87C8\u87C9\u87CC",
    4,
    "\u87D4",
    6,
    "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF",
    9
  ],
  [
    "cf80",
    "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804",
    5,
    "\u880B",
    7,
    "\u8814\u8817\u8818\u8819\u881A\u881C",
    4,
    "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"
  ],
  [
    "d040",
    "\u8824",
    13,
    "\u8833",
    5,
    "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846",
    5,
    "\u884E",
    5,
    "\u8855\u8856\u8858\u885A",
    6,
    "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"
  ],
  [
    "d080",
    "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897",
    4,
    "\u889D",
    4,
    "\u88A3\u88A5",
    5,
    "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"
  ],
  [
    "d140",
    "\u88AC\u88AE\u88AF\u88B0\u88B2",
    4,
    "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA",
    4,
    "\u88E0\u88E1\u88E6\u88E7\u88E9",
    6,
    "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903",
    5
  ],
  [
    "d180",
    "\u8909\u890B",
    4,
    "\u8911\u8914",
    4,
    "\u891C",
    4,
    "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"
  ],
  [
    "d240",
    "\u8938",
    8,
    "\u8942\u8943\u8945",
    24,
    "\u8960",
    5,
    "\u8967",
    19,
    "\u897C"
  ],
  [
    "d280",
    "\u897D\u897E\u8980\u8982\u8984\u8985\u8987",
    26,
    "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"
  ],
  [
    "d340",
    "\u89A2",
    30,
    "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4",
    6
  ],
  [
    "d380",
    "\u89FB",
    4,
    "\u8A01",
    5,
    "\u8A08",
    21,
    "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"
  ],
  [
    "d440",
    "\u8A1E",
    31,
    "\u8A3F",
    8,
    "\u8A49",
    21
  ],
  [
    "d480",
    "\u8A5F",
    25,
    "\u8A7A",
    6,
    "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"
  ],
  [
    "d540",
    "\u8A81",
    7,
    "\u8A8B",
    7,
    "\u8A94",
    46
  ],
  [
    "d580",
    "\u8AC3",
    32,
    "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"
  ],
  [
    "d640",
    "\u8AE4",
    34,
    "\u8B08",
    27
  ],
  [
    "d680",
    "\u8B24\u8B25\u8B27",
    30,
    "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"
  ],
  [
    "d740",
    "\u8B46",
    31,
    "\u8B67",
    4,
    "\u8B6D",
    25
  ],
  [
    "d780",
    "\u8B87",
    24,
    "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"
  ],
  [
    "d840",
    "\u8C38",
    8,
    "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D",
    7,
    "\u8C56\u8C57\u8C58\u8C59\u8C5B",
    5,
    "\u8C63",
    6,
    "\u8C6C",
    6,
    "\u8C74\u8C75\u8C76\u8C77\u8C7B",
    6,
    "\u8C83\u8C84\u8C86\u8C87"
  ],
  [
    "d880",
    "\u8C88\u8C8B\u8C8D",
    6,
    "\u8C95\u8C96\u8C97\u8C99",
    20,
    "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"
  ],
  [
    "d940",
    "\u8CAE",
    62
  ],
  [
    "d980",
    "\u8CED",
    32,
    "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"
  ],
  [
    "da40",
    "\u8D0E",
    14,
    "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78",
    8,
    "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C",
    4,
    "\u8D92\u8D93\u8D95",
    9,
    "\u8DA0\u8DA1"
  ],
  [
    "da80",
    "\u8DA2\u8DA4",
    12,
    "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"
  ],
  [
    "db40",
    "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE",
    6,
    "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15",
    7,
    "\u8E20\u8E21\u8E24",
    4,
    "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"
  ],
  [
    "db80",
    "\u8E3F\u8E43\u8E45\u8E46\u8E4C",
    4,
    "\u8E53",
    5,
    "\u8E5A",
    11,
    "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"
  ],
  [
    "dc40",
    "\u8E73\u8E75\u8E77",
    4,
    "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88",
    6,
    "\u8E91\u8E92\u8E93\u8E95",
    6,
    "\u8E9D\u8E9F",
    11,
    "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3",
    6,
    "\u8EBB",
    7
  ],
  [
    "dc80",
    "\u8EC3",
    10,
    "\u8ECF",
    21,
    "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"
  ],
  [
    "dd40",
    "\u8EE5",
    62
  ],
  [
    "dd80",
    "\u8F24",
    32,
    "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"
  ],
  [
    "de40",
    "\u8F45",
    32,
    "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"
  ],
  [
    "de80",
    "\u8FC9",
    4,
    "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"
  ],
  [
    "df40",
    "\u9019\u901C\u9023\u9024\u9025\u9027",
    5,
    "\u9030",
    4,
    "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048",
    4,
    "\u904E\u9054\u9055\u9056\u9059\u905A\u905C",
    5,
    "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F",
    4,
    "\u9076",
    6,
    "\u907E\u9081"
  ],
  [
    "df80",
    "\u9084\u9085\u9086\u9087\u9089\u908A\u908C",
    4,
    "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"
  ],
  [
    "e040",
    "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105",
    19,
    "\u911A\u911B\u911C"
  ],
  [
    "e080",
    "\u911D\u911F\u9120\u9121\u9124",
    10,
    "\u9130\u9132",
    6,
    "\u913A",
    8,
    "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"
  ],
  [
    "e140",
    "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180",
    4,
    "\u9186\u9188\u918A\u918E\u918F\u9193",
    6,
    "\u919C",
    5,
    "\u91A4",
    5,
    "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"
  ],
  [
    "e180",
    "\u91BC",
    10,
    "\u91C8\u91CB\u91D0\u91D2",
    9,
    "\u91DD",
    8,
    "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"
  ],
  [
    "e240",
    "\u91E6",
    62
  ],
  [
    "e280",
    "\u9225",
    32,
    "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967",
    5,
    "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"
  ],
  [
    "e340",
    "\u9246",
    45,
    "\u9275",
    16
  ],
  [
    "e380",
    "\u9286",
    7,
    "\u928F",
    24,
    "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"
  ],
  [
    "e440",
    "\u92A8",
    5,
    "\u92AF",
    24,
    "\u92C9",
    31
  ],
  [
    "e480",
    "\u92E9",
    32,
    "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"
  ],
  [
    "e540",
    "\u930A",
    51,
    "\u933F",
    10
  ],
  [
    "e580",
    "\u934A",
    31,
    "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"
  ],
  [
    "e640",
    "\u936C",
    34,
    "\u9390",
    27
  ],
  [
    "e680",
    "\u93AC",
    29,
    "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"
  ],
  [
    "e740",
    "\u93CE",
    7,
    "\u93D7",
    54
  ],
  [
    "e780",
    "\u940E",
    32,
    "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21",
    6,
    "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F",
    4,
    "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"
  ],
  [
    "e840",
    "\u942F",
    14,
    "\u943F",
    43,
    "\u946C\u946D\u946E\u946F"
  ],
  [
    "e880",
    "\u9470",
    20,
    "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"
  ],
  [
    "e940",
    "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577",
    7,
    "\u9580",
    42
  ],
  [
    "e980",
    "\u95AB",
    32,
    "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"
  ],
  [
    "ea40",
    "\u95CC",
    27,
    "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623",
    6,
    "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"
  ],
  [
    "ea80",
    "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D",
    4,
    "\u9673\u9678",
    12,
    "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"
  ],
  [
    "eb40",
    "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D",
    9,
    "\u96A8",
    7,
    "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6",
    9,
    "\u96E1",
    6,
    "\u96EB"
  ],
  [
    "eb80",
    "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717",
    4,
    "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"
  ],
  [
    "ec40",
    "\u9721",
    8,
    "\u972B\u972C\u972E\u972F\u9731\u9733",
    4,
    "\u973A\u973B\u973C\u973D\u973F",
    18,
    "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A",
    7
  ],
  [
    "ec80",
    "\u9772\u9775\u9777",
    4,
    "\u977D",
    7,
    "\u9786",
    4,
    "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799",
    4,
    "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"
  ],
  [
    "ed40",
    "\u979E\u979F\u97A1\u97A2\u97A4",
    6,
    "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5",
    46
  ],
  [
    "ed80",
    "\u97E4\u97E5\u97E8\u97EE",
    4,
    "\u97F4\u97F7",
    23,
    "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"
  ],
  [
    "ee40",
    "\u980F",
    62
  ],
  [
    "ee80",
    "\u984E",
    32,
    "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6",
    4,
    "\u94BC\u94BD\u94BF\u94C4\u94C8",
    6,
    "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"
  ],
  [
    "ef40",
    "\u986F",
    5,
    "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8",
    37,
    "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0",
    4
  ],
  [
    "ef80",
    "\u98E5\u98E6\u98E9",
    30,
    "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512",
    4,
    "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564",
    8,
    "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"
  ],
  [
    "f040",
    "\u9908",
    4,
    "\u990E\u990F\u9911",
    28,
    "\u992F",
    26
  ],
  [
    "f080",
    "\u994A",
    9,
    "\u9956",
    12,
    "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28",
    4,
    "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66",
    6,
    "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"
  ],
  [
    "f140",
    "\u998C\u998E\u999A",
    10,
    "\u99A6\u99A7\u99A9",
    47
  ],
  [
    "f180",
    "\u99D9",
    32,
    "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"
  ],
  [
    "f240",
    "\u99FA",
    62
  ],
  [
    "f280",
    "\u9A39",
    32,
    "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"
  ],
  [
    "f340",
    "\u9A5A",
    17,
    "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9",
    6,
    "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6",
    4,
    "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"
  ],
  [
    "f380",
    "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0",
    8,
    "\u9AFA\u9AFC",
    6,
    "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"
  ],
  [
    "f440",
    "\u9B07\u9B09",
    5,
    "\u9B10\u9B11\u9B12\u9B14",
    10,
    "\u9B20\u9B21\u9B22\u9B24",
    10,
    "\u9B30\u9B31\u9B33",
    7,
    "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55",
    5
  ],
  [
    "f480",
    "\u9B5B",
    32,
    "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"
  ],
  [
    "f540",
    "\u9B7C",
    62
  ],
  [
    "f580",
    "\u9BBB",
    32,
    "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"
  ],
  [
    "f640",
    "\u9BDC",
    62
  ],
  [
    "f680",
    "\u9C1B",
    32,
    "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85",
    5,
    "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E",
    5,
    "\u9CA5",
    4,
    "\u9CAB\u9CAD\u9CAE\u9CB0",
    7,
    "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"
  ],
  [
    "f740",
    "\u9C3C",
    62
  ],
  [
    "f780",
    "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE",
    4,
    "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC",
    4,
    "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"
  ],
  [
    "f840",
    "\u9CE3",
    62
  ],
  [
    "f880",
    "\u9D22",
    32
  ],
  [
    "f940",
    "\u9D43",
    62
  ],
  [
    "f980",
    "\u9D82",
    32
  ],
  [
    "fa40",
    "\u9DA3",
    62
  ],
  [
    "fa80",
    "\u9DE2",
    32
  ],
  [
    "fb40",
    "\u9E03",
    27,
    "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74",
    9,
    "\u9E80"
  ],
  [
    "fb80",
    "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C",
    5,
    "\u9E94",
    8,
    "\u9E9E\u9EA0",
    5,
    "\u9EA7\u9EA8\u9EA9\u9EAA"
  ],
  [
    "fc40",
    "\u9EAB",
    8,
    "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF",
    4,
    "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0",
    8,
    "\u9EFA\u9EFD\u9EFF",
    6
  ],
  [
    "fc80",
    "\u9F06",
    4,
    "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A",
    5,
    "\u9F21\u9F23",
    8,
    "\u9F2D\u9F2E\u9F30\u9F31"
  ],
  [
    "fd40",
    "\u9F32",
    4,
    "\u9F38\u9F3A\u9F3C\u9F3F",
    4,
    "\u9F45",
    10,
    "\u9F52",
    38
  ],
  [
    "fd80",
    "\u9F79",
    5,
    "\u9F81\u9F82\u9F8D",
    11,
    "\u9F9C\u9F9D\u9F9E\u9FA1",
    4,
    "\uF92C\uF979\uF995\uF9E7\uF9F1"
  ],
  [
    "fe40",
    "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"
  ]
], require$$3 = [
  [
    "a140",
    "\uE4C6",
    62
  ],
  [
    "a180",
    "\uE505",
    32
  ],
  [
    "a240",
    "\uE526",
    62
  ],
  [
    "a280",
    "\uE565",
    32
  ],
  [
    "a2ab",
    "\uE766",
    5
  ],
  [
    "a2e3",
    "\u20AC\uE76D"
  ],
  [
    "a2ef",
    "\uE76E\uE76F"
  ],
  [
    "a2fd",
    "\uE770\uE771"
  ],
  [
    "a340",
    "\uE586",
    62
  ],
  [
    "a380",
    "\uE5C5",
    31,
    "\u3000"
  ],
  [
    "a440",
    "\uE5E6",
    62
  ],
  [
    "a480",
    "\uE625",
    32
  ],
  [
    "a4f4",
    "\uE772",
    10
  ],
  [
    "a540",
    "\uE646",
    62
  ],
  [
    "a580",
    "\uE685",
    32
  ],
  [
    "a5f7",
    "\uE77D",
    7
  ],
  [
    "a640",
    "\uE6A6",
    62
  ],
  [
    "a680",
    "\uE6E5",
    32
  ],
  [
    "a6b9",
    "\uE785",
    7
  ],
  [
    "a6d9",
    "\uE78D",
    6
  ],
  [
    "a6ec",
    "\uE794\uE795"
  ],
  [
    "a6f3",
    "\uE796"
  ],
  [
    "a6f6",
    "\uE797",
    8
  ],
  [
    "a740",
    "\uE706",
    62
  ],
  [
    "a780",
    "\uE745",
    32
  ],
  [
    "a7c2",
    "\uE7A0",
    14
  ],
  [
    "a7f2",
    "\uE7AF",
    12
  ],
  [
    "a896",
    "\uE7BC",
    10
  ],
  [
    "a8bc",
    "\uE7C7"
  ],
  [
    "a8bf",
    "\u01F9"
  ],
  [
    "a8c1",
    "\uE7C9\uE7CA\uE7CB\uE7CC"
  ],
  [
    "a8ea",
    "\uE7CD",
    20
  ],
  [
    "a958",
    "\uE7E2"
  ],
  [
    "a95b",
    "\uE7E3"
  ],
  [
    "a95d",
    "\uE7E4\uE7E5\uE7E6"
  ],
  [
    "a989",
    "\u303E\u2FF0",
    11
  ],
  [
    "a997",
    "\uE7F4",
    12
  ],
  [
    "a9f0",
    "\uE801",
    14
  ],
  [
    "aaa1",
    "\uE000",
    93
  ],
  [
    "aba1",
    "\uE05E",
    93
  ],
  [
    "aca1",
    "\uE0BC",
    93
  ],
  [
    "ada1",
    "\uE11A",
    93
  ],
  [
    "aea1",
    "\uE178",
    93
  ],
  [
    "afa1",
    "\uE1D6",
    93
  ],
  [
    "d7fa",
    "\uE810",
    4
  ],
  [
    "f8a1",
    "\uE234",
    93
  ],
  [
    "f9a1",
    "\uE292",
    93
  ],
  [
    "faa1",
    "\uE2F0",
    93
  ],
  [
    "fba1",
    "\uE34E",
    93
  ],
  [
    "fca1",
    "\uE3AC",
    93
  ],
  [
    "fda1",
    "\uE40A",
    93
  ],
  [
    "fe50",
    "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"
  ],
  [
    "fe80",
    "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13",
    6,
    "\u4DAE\uE864\uE468",
    93
  ]
], uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
], gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
], require$$4 = {
  uChars,
  gbChars
}, require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "\uAC02\uAC03\uAC05\uAC06\uAC0B",
    4,
    "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25",
    6,
    "\uAC2E\uAC32\uAC33\uAC34"
  ],
  [
    "8161",
    "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41",
    9,
    "\uAC4C\uAC4E",
    5,
    "\uAC55"
  ],
  [
    "8181",
    "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D",
    18,
    "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B",
    4,
    "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95",
    6,
    "\uAC9E\uACA2",
    5,
    "\uACAB\uACAD\uACAE\uACB1",
    6,
    "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD",
    7,
    "\uACD6\uACD8",
    7,
    "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7",
    4,
    "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07",
    4,
    "\uAD0E\uAD10\uAD12\uAD13"
  ],
  [
    "8241",
    "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21",
    7,
    "\uAD2A\uAD2B\uAD2E",
    5
  ],
  [
    "8261",
    "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D",
    6,
    "\uAD46\uAD48\uAD4A",
    5,
    "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"
  ],
  [
    "8281",
    "\uAD59",
    7,
    "\uAD62\uAD64",
    7,
    "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83",
    4,
    "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91",
    10,
    "\uAD9E",
    5,
    "\uADA5",
    17,
    "\uADB8",
    7,
    "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9",
    6,
    "\uADD2\uADD4",
    7,
    "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5",
    18
  ],
  [
    "8341",
    "\uADFA\uADFB\uADFD\uADFE\uAE02",
    5,
    "\uAE0A\uAE0C\uAE0E",
    5,
    "\uAE15",
    7
  ],
  [
    "8361",
    "\uAE1D",
    18,
    "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"
  ],
  [
    "8381",
    "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57",
    4,
    "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71",
    6,
    "\uAE7A\uAE7E",
    5,
    "\uAE86",
    5,
    "\uAE8D",
    46,
    "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5",
    6,
    "\uAECE\uAED2",
    5,
    "\uAEDA\uAEDB\uAEDD",
    8
  ],
  [
    "8441",
    "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE",
    5,
    "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD",
    8
  ],
  [
    "8461",
    "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11",
    18
  ],
  [
    "8481",
    "\uAF24",
    7,
    "\uAF2E\uAF2F\uAF31\uAF33\uAF35",
    6,
    "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A",
    5,
    "\uAF51",
    10,
    "\uAF5E",
    5,
    "\uAF66",
    18,
    "\uAF7A",
    5,
    "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89",
    6,
    "\uAF92\uAF93\uAF94\uAF96",
    5,
    "\uAF9D",
    26,
    "\uAFBA\uAFBB\uAFBD\uAFBE"
  ],
  [
    "8541",
    "\uAFBF\uAFC1",
    5,
    "\uAFCA\uAFCC\uAFCF",
    4,
    "\uAFD5",
    6,
    "\uAFDD",
    4
  ],
  [
    "8561",
    "\uAFE2",
    5,
    "\uAFEA",
    5,
    "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9",
    6,
    "\uB002\uB003"
  ],
  [
    "8581",
    "\uB005",
    6,
    "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015",
    6,
    "\uB01E",
    9,
    "\uB029",
    26,
    "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E",
    29,
    "\uB07E\uB07F\uB081\uB082\uB083\uB085",
    6,
    "\uB08E\uB090\uB092",
    5,
    "\uB09B\uB09D\uB09E\uB0A3\uB0A4"
  ],
  [
    "8641",
    "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD",
    6,
    "\uB0C6\uB0CA",
    5,
    "\uB0D2"
  ],
  [
    "8661",
    "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9",
    6,
    "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6",
    10
  ],
  [
    "8681",
    "\uB0F1",
    22,
    "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E",
    4,
    "\uB126\uB127\uB129\uB12A\uB12B\uB12D",
    6,
    "\uB136\uB13A",
    5,
    "\uB142\uB143\uB145\uB146\uB147\uB149",
    6,
    "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161",
    22,
    "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183",
    4,
    "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"
  ],
  [
    "8741",
    "\uB19E",
    9,
    "\uB1A9",
    15
  ],
  [
    "8761",
    "\uB1B9",
    18,
    "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"
  ],
  [
    "8781",
    "\uB1D6",
    5,
    "\uB1DE\uB1E0",
    7,
    "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1",
    7,
    "\uB1FA\uB1FC\uB1FE",
    5,
    "\uB206\uB207\uB209\uB20A\uB20D",
    6,
    "\uB216\uB218\uB21A",
    5,
    "\uB221",
    18,
    "\uB235",
    6,
    "\uB23D",
    26,
    "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261",
    6,
    "\uB26A",
    4
  ],
  [
    "8841",
    "\uB26F",
    4,
    "\uB276",
    5,
    "\uB27D",
    6,
    "\uB286\uB287\uB288\uB28A",
    4
  ],
  [
    "8861",
    "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B",
    4,
    "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"
  ],
  [
    "8881",
    "\uB2B8",
    15,
    "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3",
    4,
    "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309",
    6,
    "\uB312\uB316",
    5,
    "\uB31D",
    54,
    "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"
  ],
  [
    "8941",
    "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379",
    6,
    "\uB382\uB386",
    5,
    "\uB38D"
  ],
  [
    "8961",
    "\uB38E\uB38F\uB391\uB392\uB393\uB395",
    10,
    "\uB3A2",
    5,
    "\uB3A9\uB3AA\uB3AB\uB3AD"
  ],
  [
    "8981",
    "\uB3AE",
    21,
    "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9",
    18,
    "\uB3FD",
    18,
    "\uB411",
    6,
    "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421",
    6,
    "\uB42A\uB42C",
    7,
    "\uB435",
    15
  ],
  [
    "8a41",
    "\uB445",
    10,
    "\uB452\uB453\uB455\uB456\uB457\uB459",
    6,
    "\uB462\uB464\uB466"
  ],
  [
    "8a61",
    "\uB467",
    4,
    "\uB46D",
    18,
    "\uB481\uB482"
  ],
  [
    "8a81",
    "\uB483",
    4,
    "\uB489",
    19,
    "\uB49E",
    5,
    "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD",
    7,
    "\uB4B6\uB4B8\uB4BA",
    5,
    "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9",
    6,
    "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6",
    5,
    "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7",
    4,
    "\uB4EE\uB4F0\uB4F2",
    5,
    "\uB4F9",
    26,
    "\uB516\uB517\uB519\uB51A\uB51D"
  ],
  [
    "8b41",
    "\uB51E",
    5,
    "\uB526\uB52B",
    4,
    "\uB532\uB533\uB535\uB536\uB537\uB539",
    6,
    "\uB542\uB546"
  ],
  [
    "8b61",
    "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555",
    6,
    "\uB55E\uB562",
    8
  ],
  [
    "8b81",
    "\uB56B",
    52,
    "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6",
    4,
    "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5",
    6,
    "\uB5CE\uB5D2",
    5,
    "\uB5D9",
    18,
    "\uB5ED",
    18
  ],
  [
    "8c41",
    "\uB600",
    15,
    "\uB612\uB613\uB615\uB616\uB617\uB619",
    4
  ],
  [
    "8c61",
    "\uB61E",
    6,
    "\uB626",
    5,
    "\uB62D",
    6,
    "\uB635",
    5
  ],
  [
    "8c81",
    "\uB63B",
    12,
    "\uB649",
    26,
    "\uB665\uB666\uB667\uB669",
    50,
    "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5",
    5,
    "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2",
    16
  ],
  [
    "8d41",
    "\uB6C3",
    16,
    "\uB6D5",
    8
  ],
  [
    "8d61",
    "\uB6DE",
    17,
    "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"
  ],
  [
    "8d81",
    "\uB6FB",
    4,
    "\uB702\uB703\uB704\uB706",
    33,
    "\uB72A\uB72B\uB72D\uB72E\uB731",
    6,
    "\uB73A\uB73C",
    7,
    "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D",
    6,
    "\uB756",
    9,
    "\uB761\uB762\uB763\uB765\uB766\uB767\uB769",
    6,
    "\uB772\uB774\uB776",
    5,
    "\uB77E\uB77F\uB781\uB782\uB783\uB785",
    6,
    "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"
  ],
  [
    "8e41",
    "\uB79F\uB7A1",
    6,
    "\uB7AA\uB7AE",
    5,
    "\uB7B6\uB7B7\uB7B9",
    8
  ],
  [
    "8e61",
    "\uB7C2",
    4,
    "\uB7C8\uB7CA",
    19
  ],
  [
    "8e81",
    "\uB7DE",
    13,
    "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5",
    6,
    "\uB7FE\uB802",
    4,
    "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811",
    6,
    "\uB81A\uB81C\uB81E",
    5,
    "\uB826\uB827\uB829\uB82A\uB82B\uB82D",
    6,
    "\uB836\uB83A",
    5,
    "\uB841\uB842\uB843\uB845",
    11,
    "\uB852\uB854",
    7,
    "\uB85E\uB85F\uB861\uB862\uB863\uB865",
    6,
    "\uB86E\uB870\uB872",
    5,
    "\uB879\uB87A\uB87B\uB87D",
    7
  ],
  [
    "8f41",
    "\uB885",
    7,
    "\uB88E",
    17
  ],
  [
    "8f61",
    "\uB8A0",
    7,
    "\uB8A9",
    6,
    "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9",
    4
  ],
  [
    "8f81",
    "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6",
    5,
    "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5",
    7,
    "\uB8DE\uB8E0\uB8E2",
    5,
    "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1",
    6,
    "\uB8FA\uB8FC\uB8FE",
    5,
    "\uB905",
    18,
    "\uB919",
    6,
    "\uB921",
    26,
    "\uB93E\uB93F\uB941\uB942\uB943\uB945",
    6,
    "\uB94D\uB94E\uB950\uB952",
    5
  ],
  [
    "9041",
    "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961",
    6,
    "\uB96A\uB96C\uB96E",
    5,
    "\uB976\uB977\uB979\uB97A\uB97B\uB97D"
  ],
  [
    "9061",
    "\uB97E",
    5,
    "\uB986\uB988\uB98B\uB98C\uB98F",
    15
  ],
  [
    "9081",
    "\uB99F",
    12,
    "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5",
    6,
    "\uB9BE\uB9C0\uB9C2",
    5,
    "\uB9CA\uB9CB\uB9CD\uB9D3",
    4,
    "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED",
    6,
    "\uB9F6\uB9FB",
    4,
    "\uBA02",
    5,
    "\uBA09",
    11,
    "\uBA16",
    33,
    "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"
  ],
  [
    "9141",
    "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D",
    6,
    "\uBA66\uBA6A",
    5
  ],
  [
    "9161",
    "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79",
    9,
    "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D",
    5
  ],
  [
    "9181",
    "\uBA93",
    20,
    "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3",
    4,
    "\uBABA\uBABC\uBABE",
    5,
    "\uBAC5\uBAC6\uBAC7\uBAC9",
    14,
    "\uBADA",
    33,
    "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05",
    7,
    "\uBB0E\uBB10\uBB12",
    5,
    "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21",
    6
  ],
  [
    "9241",
    "\uBB28\uBB2A\uBB2C",
    7,
    "\uBB37\uBB39\uBB3A\uBB3F",
    4,
    "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"
  ],
  [
    "9261",
    "\uBB53\uBB55\uBB56\uBB57\uBB59",
    7,
    "\uBB62\uBB64",
    7,
    "\uBB6D",
    4
  ],
  [
    "9281",
    "\uBB72",
    21,
    "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91",
    18,
    "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD",
    6,
    "\uBBB5\uBBB6\uBBB8",
    7,
    "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9",
    6,
    "\uBBD1\uBBD2\uBBD4",
    35,
    "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"
  ],
  [
    "9341",
    "\uBC03",
    4,
    "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"
  ],
  [
    "9361",
    "\uBC36\uBC37\uBC39",
    6,
    "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51",
    8
  ],
  [
    "9381",
    "\uBC5A\uBC5B\uBC5C\uBC5E",
    37,
    "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F",
    4,
    "\uBC96\uBC98\uBC9B",
    4,
    "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9",
    6,
    "\uBCB2\uBCB6",
    5,
    "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5",
    7,
    "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD",
    22,
    "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"
  ],
  [
    "9441",
    "\uBCFE",
    5,
    "\uBD06\uBD08\uBD0A",
    5,
    "\uBD11\uBD12\uBD13\uBD15",
    8
  ],
  [
    "9461",
    "\uBD1E",
    5,
    "\uBD25",
    6,
    "\uBD2D",
    12
  ],
  [
    "9481",
    "\uBD3A",
    5,
    "\uBD41",
    6,
    "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51",
    6,
    "\uBD5A",
    9,
    "\uBD65\uBD66\uBD67\uBD69",
    22,
    "\uBD82\uBD83\uBD85\uBD86\uBD8B",
    4,
    "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D",
    6,
    "\uBDA5",
    10,
    "\uBDB1",
    6,
    "\uBDB9",
    24
  ],
  [
    "9541",
    "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD",
    11,
    "\uBDEA",
    5,
    "\uBDF1"
  ],
  [
    "9561",
    "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9",
    6,
    "\uBE01\uBE02\uBE04\uBE06",
    5,
    "\uBE0E\uBE0F\uBE11\uBE12\uBE13"
  ],
  [
    "9581",
    "\uBE15",
    6,
    "\uBE1E\uBE20",
    35,
    "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F",
    4,
    "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B",
    4,
    "\uBE72\uBE76",
    4,
    "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85",
    6,
    "\uBE8E\uBE92",
    5,
    "\uBE9A",
    13,
    "\uBEA9",
    14
  ],
  [
    "9641",
    "\uBEB8",
    23,
    "\uBED2\uBED3"
  ],
  [
    "9661",
    "\uBED5\uBED6\uBED9",
    6,
    "\uBEE1\uBEE2\uBEE6",
    5,
    "\uBEED",
    8
  ],
  [
    "9681",
    "\uBEF6",
    10,
    "\uBF02",
    5,
    "\uBF0A",
    13,
    "\uBF1A\uBF1E",
    33,
    "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49",
    6,
    "\uBF52\uBF53\uBF54\uBF56",
    44
  ],
  [
    "9741",
    "\uBF83",
    16,
    "\uBF95",
    8
  ],
  [
    "9761",
    "\uBF9E",
    17,
    "\uBFB1",
    7
  ],
  [
    "9781",
    "\uBFB9",
    11,
    "\uBFC6",
    5,
    "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5",
    6,
    "\uBFDD\uBFDE\uBFE0\uBFE2",
    89,
    "\uC03D\uC03E\uC03F"
  ],
  [
    "9841",
    "\uC040",
    16,
    "\uC052",
    5,
    "\uC059\uC05A\uC05B"
  ],
  [
    "9861",
    "\uC05D\uC05E\uC05F\uC061",
    6,
    "\uC06A",
    15
  ],
  [
    "9881",
    "\uC07A",
    21,
    "\uC092\uC093\uC095\uC096\uC097\uC099",
    6,
    "\uC0A2\uC0A4\uC0A6",
    5,
    "\uC0AE\uC0B1\uC0B2\uC0B7",
    4,
    "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1",
    6,
    "\uC0DA\uC0DE",
    5,
    "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED",
    6,
    "\uC0F6\uC0F8\uC0FA",
    5,
    "\uC101\uC102\uC103\uC105\uC106\uC107\uC109",
    6,
    "\uC111\uC112\uC113\uC114\uC116",
    5,
    "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"
  ],
  [
    "9941",
    "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141",
    6,
    "\uC14A\uC14E",
    5,
    "\uC156\uC157"
  ],
  [
    "9961",
    "\uC159\uC15A\uC15B\uC15D",
    6,
    "\uC166\uC16A",
    5,
    "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"
  ],
  [
    "9981",
    "\uC17C",
    8,
    "\uC186",
    5,
    "\uC18F\uC191\uC192\uC193\uC195\uC197",
    4,
    "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1",
    11,
    "\uC1BE",
    5,
    "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD",
    6,
    "\uC1D5\uC1D6\uC1D9",
    6,
    "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9",
    6,
    "\uC1F2\uC1F4",
    7,
    "\uC1FE\uC1FF\uC201\uC202\uC203\uC205",
    6,
    "\uC20E\uC210\uC212",
    5,
    "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"
  ],
  [
    "9a41",
    "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235",
    16
  ],
  [
    "9a61",
    "\uC246\uC247\uC249",
    6,
    "\uC252\uC253\uC255\uC256\uC257\uC259",
    6,
    "\uC261\uC262\uC263\uC264\uC266"
  ],
  [
    "9a81",
    "\uC267",
    4,
    "\uC26E\uC26F\uC271\uC272\uC273\uC275",
    6,
    "\uC27E\uC280\uC282",
    5,
    "\uC28A",
    5,
    "\uC291",
    6,
    "\uC299\uC29A\uC29C\uC29E",
    5,
    "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE",
    5,
    "\uC2B6\uC2B8\uC2BA",
    33,
    "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5",
    5,
    "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301",
    6,
    "\uC30A\uC30B\uC30E\uC30F"
  ],
  [
    "9b41",
    "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D",
    6,
    "\uC326\uC327\uC32A",
    8
  ],
  [
    "9b61",
    "\uC333",
    17,
    "\uC346",
    7
  ],
  [
    "9b81",
    "\uC34E",
    25,
    "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373",
    4,
    "\uC37A\uC37B\uC37E",
    5,
    "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D",
    50,
    "\uC3C1",
    22,
    "\uC3DA"
  ],
  [
    "9c41",
    "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3",
    4,
    "\uC3EA\uC3EB\uC3EC\uC3EE",
    5,
    "\uC3F6\uC3F7\uC3F9",
    5
  ],
  [
    "9c61",
    "\uC3FF",
    8,
    "\uC409",
    6,
    "\uC411",
    9
  ],
  [
    "9c81",
    "\uC41B",
    8,
    "\uC425",
    6,
    "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435",
    6,
    "\uC43E",
    9,
    "\uC449",
    26,
    "\uC466\uC467\uC469\uC46A\uC46B\uC46D",
    6,
    "\uC476\uC477\uC478\uC47A",
    5,
    "\uC481",
    18,
    "\uC495",
    6,
    "\uC49D",
    12
  ],
  [
    "9d41",
    "\uC4AA",
    13,
    "\uC4B9\uC4BA\uC4BB\uC4BD",
    8
  ],
  [
    "9d61",
    "\uC4C6",
    25
  ],
  [
    "9d81",
    "\uC4E0",
    8,
    "\uC4EA",
    5,
    "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502",
    9,
    "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515",
    6,
    "\uC51D",
    10,
    "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531",
    6,
    "\uC53A\uC53C\uC53E",
    5,
    "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569",
    6,
    "\uC572\uC576",
    5,
    "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"
  ],
  [
    "9e41",
    "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1",
    7,
    "\uC5AA",
    9,
    "\uC5B6"
  ],
  [
    "9e61",
    "\uC5B7\uC5BA\uC5BF",
    4,
    "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9",
    6,
    "\uC5E2\uC5E4\uC5E6\uC5E7"
  ],
  [
    "9e81",
    "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611",
    6,
    "\uC61A\uC61D",
    6,
    "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649",
    6,
    "\uC652\uC656",
    5,
    "\uC65E\uC65F\uC661",
    10,
    "\uC66D\uC66E\uC670\uC672",
    5,
    "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681",
    6,
    "\uC68A\uC68C\uC68E",
    5,
    "\uC696\uC697\uC699\uC69A\uC69B\uC69D",
    6,
    "\uC6A6"
  ],
  [
    "9f41",
    "\uC6A8\uC6AA",
    5,
    "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB",
    4,
    "\uC6C2\uC6C4\uC6C6",
    5,
    "\uC6CE"
  ],
  [
    "9f61",
    "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5",
    6,
    "\uC6DE\uC6DF\uC6E2",
    5,
    "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"
  ],
  [
    "9f81",
    "\uC6F3",
    4,
    "\uC6FA\uC6FB\uC6FC\uC6FE",
    5,
    "\uC706\uC707\uC709\uC70A\uC70B\uC70D",
    6,
    "\uC716\uC718\uC71A",
    5,
    "\uC722\uC723\uC725\uC726\uC727\uC729",
    6,
    "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745",
    4,
    "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761",
    6,
    "\uC769\uC76A\uC76C",
    7,
    "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B",
    4,
    "\uC7A2\uC7A7",
    4,
    "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"
  ],
  [
    "a041",
    "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2",
    5,
    "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1",
    6,
    "\uC7D9\uC7DA\uC7DB\uC7DC"
  ],
  [
    "a061",
    "\uC7DE",
    5,
    "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED",
    13
  ],
  [
    "a081",
    "\uC7FB",
    4,
    "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B",
    4,
    "\uC812\uC814\uC817",
    4,
    "\uC81E\uC81F\uC821\uC822\uC823\uC825",
    6,
    "\uC82E\uC830\uC832",
    5,
    "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841",
    6,
    "\uC84A\uC84B\uC84E",
    5,
    "\uC855",
    26,
    "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B",
    4,
    "\uC882\uC884\uC888\uC889\uC88A\uC88E",
    5,
    "\uC895",
    7,
    "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"
  ],
  [
    "a141",
    "\uC8A5\uC8A6\uC8A7\uC8A9",
    18,
    "\uC8BE\uC8BF\uC8C0\uC8C1"
  ],
  [
    "a161",
    "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD",
    6,
    "\uC8D6\uC8D8\uC8DA",
    5,
    "\uC8E2\uC8E3\uC8E5"
  ],
  [
    "a181",
    "\uC8E6",
    14,
    "\uC8F6",
    5,
    "\uC8FE\uC8FF\uC901\uC902\uC903\uC907",
    4,
    "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008",
    9,
    "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"
  ],
  [
    "a241",
    "\uC910\uC912",
    5,
    "\uC919",
    18
  ],
  [
    "a261",
    "\uC92D",
    6,
    "\uC935",
    18
  ],
  [
    "a281",
    "\uC948",
    7,
    "\uC952\uC953\uC955\uC956\uC957\uC959",
    6,
    "\uC962\uC964",
    7,
    "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"
  ],
  [
    "a341",
    "\uC971\uC972\uC973\uC975",
    6,
    "\uC97D",
    10,
    "\uC98A\uC98B\uC98D\uC98E\uC98F"
  ],
  [
    "a361",
    "\uC991",
    6,
    "\uC99A\uC99C\uC99E",
    16
  ],
  [
    "a381",
    "\uC9AF",
    16,
    "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB",
    4,
    "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01",
    58,
    "\uFFE6\uFF3D",
    32,
    "\uFFE3"
  ],
  [
    "a441",
    "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2",
    5,
    "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"
  ],
  [
    "a461",
    "\uCA05\uCA06\uCA07\uCA0A\uCA0E",
    5,
    "\uCA15\uCA16\uCA17\uCA19",
    12
  ],
  [
    "a481",
    "\uCA26\uCA27\uCA28\uCA2A",
    28,
    "\u3131",
    93
  ],
  [
    "a541",
    "\uCA47",
    4,
    "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55",
    6,
    "\uCA5E\uCA62",
    5,
    "\uCA69\uCA6A"
  ],
  [
    "a561",
    "\uCA6B",
    17,
    "\uCA7E",
    5,
    "\uCA85\uCA86"
  ],
  [
    "a581",
    "\uCA87",
    16,
    "\uCA99",
    14,
    "\u2170",
    9
  ],
  [
    "a5b0",
    "\u2160",
    9
  ],
  [
    "a5c1",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "a5e1",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "a641",
    "\uCAA8",
    19,
    "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"
  ],
  [
    "a661",
    "\uCAC6",
    5,
    "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA",
    5,
    "\uCAE1",
    6
  ],
  [
    "a681",
    "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED",
    6,
    "\uCAF5",
    18,
    "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543",
    7
  ],
  [
    "a741",
    "\uCB0B",
    4,
    "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19",
    6,
    "\uCB22",
    7
  ],
  [
    "a761",
    "\uCB2A",
    22,
    "\uCB42\uCB43\uCB44"
  ],
  [
    "a781",
    "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51",
    6,
    "\uCB5A\uCB5B\uCB5C\uCB5E",
    5,
    "\uCB65",
    7,
    "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399",
    9,
    "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0",
    9,
    "\u3380",
    4,
    "\u33BA",
    5,
    "\u3390",
    4,
    "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"
  ],
  [
    "a841",
    "\uCB6D",
    10,
    "\uCB7A",
    14
  ],
  [
    "a861",
    "\uCB89",
    18,
    "\uCB9D",
    6
  ],
  [
    "a881",
    "\uCBA4",
    19,
    "\uCBB9",
    11,
    "\xC6\xD0\xAA\u0126"
  ],
  [
    "a8a6",
    "\u0132"
  ],
  [
    "a8a8",
    "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"
  ],
  [
    "a8b1",
    "\u3260",
    27,
    "\u24D0",
    25,
    "\u2460",
    14,
    "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"
  ],
  [
    "a941",
    "\uCBC5",
    14,
    "\uCBD5",
    10
  ],
  [
    "a961",
    "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA",
    18
  ],
  [
    "a981",
    "\uCBFD",
    14,
    "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15",
    6,
    "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200",
    27,
    "\u249C",
    25,
    "\u2474",
    14,
    "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"
  ],
  [
    "aa41",
    "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31",
    6,
    "\uCC3A\uCC3F",
    4,
    "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"
  ],
  [
    "aa61",
    "\uCC4F",
    4,
    "\uCC56\uCC5A",
    5,
    "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69",
    6,
    "\uCC71\uCC72"
  ],
  [
    "aa81",
    "\uCC73\uCC74\uCC76",
    29,
    "\u3041",
    82
  ],
  [
    "ab41",
    "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1",
    6,
    "\uCCAA\uCCAE",
    5,
    "\uCCB6\uCCB7\uCCB9"
  ],
  [
    "ab61",
    "\uCCBA\uCCBB\uCCBD",
    6,
    "\uCCC6\uCCC8\uCCCA",
    5,
    "\uCCD1\uCCD2\uCCD3\uCCD5",
    5
  ],
  [
    "ab81",
    "\uCCDB",
    8,
    "\uCCE5",
    6,
    "\uCCED\uCCEE\uCCEF\uCCF1",
    12,
    "\u30A1",
    85
  ],
  [
    "ac41",
    "\uCCFE\uCCFF\uCD00\uCD02",
    5,
    "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11",
    6,
    "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"
  ],
  [
    "ac61",
    "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D",
    11,
    "\uCD3A",
    4
  ],
  [
    "ac81",
    "\uCD3F",
    28,
    "\uCD5D\uCD5E\uCD5F\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "acd1",
    "\u0430",
    5,
    "\u0451\u0436",
    25
  ],
  [
    "ad41",
    "\uCD61\uCD62\uCD63\uCD65",
    6,
    "\uCD6E\uCD70\uCD72",
    5,
    "\uCD79",
    7
  ],
  [
    "ad61",
    "\uCD81",
    6,
    "\uCD89",
    10,
    "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"
  ],
  [
    "ad81",
    "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA",
    5,
    "\uCDB1",
    18,
    "\uCDC5"
  ],
  [
    "ae41",
    "\uCDC6",
    5,
    "\uCDCD\uCDCE\uCDCF\uCDD1",
    16
  ],
  [
    "ae61",
    "\uCDE2",
    5,
    "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1",
    6,
    "\uCDFA\uCDFC\uCDFE",
    4
  ],
  [
    "ae81",
    "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D",
    6,
    "\uCE15\uCE16\uCE17\uCE18\uCE1A",
    5,
    "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"
  ],
  [
    "af41",
    "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36",
    19
  ],
  [
    "af61",
    "\uCE4A",
    13,
    "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62",
    5,
    "\uCE6A\uCE6C"
  ],
  [
    "af81",
    "\uCE6E",
    5,
    "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D",
    6,
    "\uCE86\uCE88\uCE8A",
    5,
    "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"
  ],
  [
    "b041",
    "\uCE9A",
    5,
    "\uCEA2\uCEA6",
    5,
    "\uCEAE",
    12
  ],
  [
    "b061",
    "\uCEBB",
    5,
    "\uCEC2",
    19
  ],
  [
    "b081",
    "\uCED6",
    13,
    "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED",
    6,
    "\uCEF6\uCEFA",
    5,
    "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10",
    7,
    "\uAC19",
    4,
    "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"
  ],
  [
    "b141",
    "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09",
    6,
    "\uCF12\uCF14\uCF16",
    5,
    "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"
  ],
  [
    "b161",
    "\uCF25",
    6,
    "\uCF2E\uCF32",
    5,
    "\uCF39",
    11
  ],
  [
    "b181",
    "\uCF45",
    14,
    "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D",
    6,
    "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"
  ],
  [
    "b241",
    "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79",
    6,
    "\uCF81\uCF82\uCF83\uCF84\uCF86",
    5,
    "\uCF8D"
  ],
  [
    "b261",
    "\uCF8E",
    18,
    "\uCFA2",
    5,
    "\uCFA9"
  ],
  [
    "b281",
    "\uCFAA",
    5,
    "\uCFB1",
    18,
    "\uCFC5",
    6,
    "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"
  ],
  [
    "b341",
    "\uCFCC",
    19,
    "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"
  ],
  [
    "b361",
    "\uCFEA",
    5,
    "\uCFF2\uCFF4\uCFF6",
    5,
    "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005",
    5
  ],
  [
    "b381",
    "\uD00B",
    5,
    "\uD012",
    5,
    "\uD019",
    19,
    "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB",
    4,
    "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"
  ],
  [
    "b441",
    "\uD02E",
    5,
    "\uD036\uD037\uD039\uD03A\uD03B\uD03D",
    6,
    "\uD046\uD048\uD04A",
    5
  ],
  [
    "b461",
    "\uD051\uD052\uD053\uD055\uD056\uD057\uD059",
    6,
    "\uD061",
    10,
    "\uD06E\uD06F"
  ],
  [
    "b481",
    "\uD071\uD072\uD073\uD075",
    6,
    "\uD07E\uD07F\uD080\uD082",
    18,
    "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB",
    4,
    "\uB2F3\uB2F4\uB2F5\uB2F7",
    4,
    "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"
  ],
  [
    "b541",
    "\uD095",
    14,
    "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD",
    5
  ],
  [
    "b561",
    "\uD0B3\uD0B6\uD0B8\uD0BA",
    5,
    "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA",
    5,
    "\uD0D2\uD0D6",
    4
  ],
  [
    "b581",
    "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5",
    6,
    "\uD0EE\uD0F2",
    5,
    "\uD0F9",
    11,
    "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"
  ],
  [
    "b641",
    "\uD105",
    7,
    "\uD10E",
    17
  ],
  [
    "b661",
    "\uD120",
    15,
    "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"
  ],
  [
    "b681",
    "\uD13F\uD142\uD146",
    5,
    "\uD14E\uD14F\uD151\uD152\uD153\uD155",
    6,
    "\uD15E\uD160\uD162",
    5,
    "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"
  ],
  [
    "b741",
    "\uD16E",
    13,
    "\uD17D",
    6,
    "\uD185\uD186\uD187\uD189\uD18A"
  ],
  [
    "b761",
    "\uD18B",
    20,
    "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"
  ],
  [
    "b781",
    "\uD1A9",
    6,
    "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1",
    14,
    "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"
  ],
  [
    "b841",
    "\uD1D0",
    7,
    "\uD1D9",
    17
  ],
  [
    "b861",
    "\uD1EB",
    8,
    "\uD1F5\uD1F6\uD1F7\uD1F9",
    13
  ],
  [
    "b881",
    "\uD208\uD20A",
    5,
    "\uD211",
    24,
    "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE",
    4,
    "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"
  ],
  [
    "b941",
    "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235",
    6,
    "\uD23E\uD240\uD242",
    5,
    "\uD249\uD24A\uD24B\uD24C"
  ],
  [
    "b961",
    "\uD24D",
    14,
    "\uD25D",
    6,
    "\uD265\uD266\uD267\uD268"
  ],
  [
    "b981",
    "\uD269",
    22,
    "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14",
    4,
    "\uBC1B",
    4,
    "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"
  ],
  [
    "ba41",
    "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296",
    5,
    "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5",
    6,
    "\uD2AD"
  ],
  [
    "ba61",
    "\uD2AE\uD2AF\uD2B0\uD2B2",
    5,
    "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3",
    4,
    "\uD2CA\uD2CC",
    5
  ],
  [
    "ba81",
    "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD",
    6,
    "\uD2E6",
    9,
    "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"
  ],
  [
    "bb41",
    "\uD2FB",
    4,
    "\uD302\uD304\uD306",
    5,
    "\uD30F\uD311\uD312\uD313\uD315\uD317",
    4,
    "\uD31E\uD322\uD323"
  ],
  [
    "bb61",
    "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331",
    6,
    "\uD33A\uD33E",
    5,
    "\uD346\uD347\uD348\uD349"
  ],
  [
    "bb81",
    "\uD34A",
    31,
    "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"
  ],
  [
    "bc41",
    "\uD36A",
    17,
    "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"
  ],
  [
    "bc61",
    "\uD388\uD389\uD38A\uD38B\uD38E\uD392",
    5,
    "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1",
    6,
    "\uD3AA\uD3AC\uD3AE"
  ],
  [
    "bc81",
    "\uD3AF",
    4,
    "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD",
    6,
    "\uD3C6\uD3C7\uD3CA",
    5,
    "\uD3D1",
    5,
    "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C",
    4,
    "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"
  ],
  [
    "bd41",
    "\uD3D7\uD3D9",
    7,
    "\uD3E2\uD3E4",
    7,
    "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"
  ],
  [
    "bd61",
    "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402",
    5,
    "\uD409",
    13
  ],
  [
    "bd81",
    "\uD417",
    5,
    "\uD41E",
    25,
    "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"
  ],
  [
    "be41",
    "\uD438",
    7,
    "\uD441\uD442\uD443\uD445",
    14
  ],
  [
    "be61",
    "\uD454",
    7,
    "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465",
    7,
    "\uD46E\uD470\uD471\uD472"
  ],
  [
    "be81",
    "\uD473",
    4,
    "\uD47A\uD47B\uD47D\uD47E\uD481\uD483",
    4,
    "\uD48A\uD48C\uD48E",
    5,
    "\uD495",
    8,
    "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4",
    6,
    "\uC5CC\uC5CE"
  ],
  [
    "bf41",
    "\uD49E",
    10,
    "\uD4AA",
    14
  ],
  [
    "bf61",
    "\uD4B9",
    18,
    "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"
  ],
  [
    "bf81",
    "\uD4D6",
    5,
    "\uD4DD\uD4DE\uD4E0",
    7,
    "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1",
    6,
    "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC",
    5,
    "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"
  ],
  [
    "c041",
    "\uD4FE",
    5,
    "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D",
    6,
    "\uD516\uD518",
    5
  ],
  [
    "c061",
    "\uD51E",
    25
  ],
  [
    "c081",
    "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545",
    6,
    "\uD54E\uD550\uD552",
    5,
    "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751",
    7,
    "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"
  ],
  [
    "c141",
    "\uD564\uD566\uD567\uD56A\uD56C\uD56E",
    5,
    "\uD576\uD577\uD579\uD57A\uD57B\uD57D",
    6,
    "\uD586\uD58A\uD58B"
  ],
  [
    "c161",
    "\uD58C\uD58D\uD58E\uD58F\uD591",
    19,
    "\uD5A6\uD5A7"
  ],
  [
    "c181",
    "\uD5A8",
    31,
    "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"
  ],
  [
    "c241",
    "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3",
    4,
    "\uD5DA\uD5DC\uD5DE",
    5,
    "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"
  ],
  [
    "c261",
    "\uD5EF",
    4,
    "\uD5F6\uD5F8\uD5FA",
    5,
    "\uD602\uD603\uD605\uD606\uD607\uD609",
    6,
    "\uD612"
  ],
  [
    "c281",
    "\uD616",
    5,
    "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625",
    7,
    "\uD62E",
    9,
    "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"
  ],
  [
    "c341",
    "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D",
    4
  ],
  [
    "c361",
    "\uD662",
    4,
    "\uD668\uD66A",
    5,
    "\uD672\uD673\uD675",
    11
  ],
  [
    "c381",
    "\uD681\uD682\uD684\uD686",
    5,
    "\uD68E\uD68F\uD691\uD692\uD693\uD695",
    7,
    "\uD69E\uD6A0\uD6A2",
    5,
    "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"
  ],
  [
    "c441",
    "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1",
    7,
    "\uD6BA\uD6BC",
    7,
    "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"
  ],
  [
    "c461",
    "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA",
    5,
    "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9",
    4
  ],
  [
    "c481",
    "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6",
    5,
    "\uD6FE\uD6FF\uD701\uD702\uD703\uD705",
    11,
    "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"
  ],
  [
    "c541",
    "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721",
    6,
    "\uD72A\uD72C\uD72E",
    5,
    "\uD736\uD737\uD739"
  ],
  [
    "c561",
    "\uD73A\uD73B\uD73D",
    6,
    "\uD745\uD746\uD748\uD74A",
    5,
    "\uD752\uD753\uD755\uD75A",
    4
  ],
  [
    "c581",
    "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775",
    6,
    "\uD77E\uD77F\uD780\uD782",
    5,
    "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"
  ],
  [
    "c641",
    "\uD78D\uD78E\uD78F\uD791",
    6,
    "\uD79A\uD79C\uD79E",
    5
  ],
  [
    "c6a1",
    "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"
  ],
  [
    "c7a1",
    "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"
  ],
  [
    "c8a1",
    "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"
  ],
  [
    "caa1",
    "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"
  ],
  [
    "cba1",
    "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"
  ],
  [
    "cca1",
    "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"
  ],
  [
    "cda1",
    "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"
  ],
  [
    "cea1",
    "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"
  ],
  [
    "cfa1",
    "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"
  ],
  [
    "d0a1",
    "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"
  ],
  [
    "d1a1",
    "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E",
    5,
    "\u90A3\uF914",
    4,
    "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"
  ],
  [
    "d2a1",
    "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928",
    4,
    "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933",
    5,
    "\u99D1\uF939",
    10,
    "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A",
    7,
    "\u5AE9\u8A25\u677B\u7D10\uF952",
    5,
    "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"
  ],
  [
    "d3a1",
    "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"
  ],
  [
    "d4a1",
    "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"
  ],
  [
    "d5a1",
    "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"
  ],
  [
    "d6a1",
    "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"
  ],
  [
    "d7a1",
    "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"
  ],
  [
    "d8a1",
    "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"
  ],
  [
    "d9a1",
    "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"
  ],
  [
    "daa1",
    "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"
  ],
  [
    "dba1",
    "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"
  ],
  [
    "dca1",
    "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"
  ],
  [
    "dda1",
    "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"
  ],
  [
    "dea1",
    "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"
  ],
  [
    "dfa1",
    "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"
  ],
  [
    "e0a1",
    "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"
  ],
  [
    "e1a1",
    "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"
  ],
  [
    "e2a1",
    "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"
  ],
  [
    "e3a1",
    "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"
  ],
  [
    "e4a1",
    "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"
  ],
  [
    "e5a1",
    "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"
  ],
  [
    "e6a1",
    "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"
  ],
  [
    "e7a1",
    "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"
  ],
  [
    "e8a1",
    "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"
  ],
  [
    "e9a1",
    "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"
  ],
  [
    "eaa1",
    "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"
  ],
  [
    "eba1",
    "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"
  ],
  [
    "eca1",
    "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"
  ],
  [
    "eda1",
    "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"
  ],
  [
    "eea1",
    "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"
  ],
  [
    "efa1",
    "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"
  ],
  [
    "f0a1",
    "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"
  ],
  [
    "f1a1",
    "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"
  ],
  [
    "f2a1",
    "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"
  ],
  [
    "f3a1",
    "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"
  ],
  [
    "f4a1",
    "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"
  ],
  [
    "f5a1",
    "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"
  ],
  [
    "f6a1",
    "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"
  ],
  [
    "f7a1",
    "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"
  ],
  [
    "f8a1",
    "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"
  ],
  [
    "f9a1",
    "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"
  ],
  [
    "faa1",
    "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"
  ],
  [
    "fba1",
    "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"
  ],
  [
    "fca1",
    "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"
  ],
  [
    "fda1",
    "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"
  ]
], require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"
  ],
  [
    "a1a1",
    "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62",
    4,
    "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"
  ],
  [
    "a240",
    "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581",
    7,
    "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"
  ],
  [
    "a2a1",
    "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10",
    9,
    "\u2160",
    9,
    "\u3021",
    8,
    "\u5341\u5344\u5345\uFF21",
    25,
    "\uFF41",
    21
  ],
  [
    "a340",
    "\uFF57\uFF58\uFF59\uFF5A\u0391",
    16,
    "\u03A3",
    6,
    "\u03B1",
    16,
    "\u03C3",
    6,
    "\u3105",
    10
  ],
  [
    "a3a1",
    "\u3110",
    25,
    "\u02D9\u02C9\u02CA\u02C7\u02CB"
  ],
  [
    "a3e1",
    "\u20AC"
  ],
  [
    "a440",
    "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"
  ],
  [
    "a4a1",
    "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"
  ],
  [
    "a540",
    "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"
  ],
  [
    "a5a1",
    "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"
  ],
  [
    "a640",
    "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"
  ],
  [
    "a6a1",
    "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"
  ],
  [
    "a740",
    "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"
  ],
  [
    "a7a1",
    "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"
  ],
  [
    "a840",
    "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"
  ],
  [
    "a8a1",
    "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"
  ],
  [
    "a940",
    "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"
  ],
  [
    "a9a1",
    "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"
  ],
  [
    "aa40",
    "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"
  ],
  [
    "aaa1",
    "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"
  ],
  [
    "ab40",
    "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"
  ],
  [
    "aba1",
    "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"
  ],
  [
    "ac40",
    "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"
  ],
  [
    "aca1",
    "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"
  ],
  [
    "ad40",
    "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"
  ],
  [
    "ada1",
    "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"
  ],
  [
    "ae40",
    "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"
  ],
  [
    "aea1",
    "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"
  ],
  [
    "af40",
    "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"
  ],
  [
    "afa1",
    "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"
  ],
  [
    "b040",
    "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"
  ],
  [
    "b0a1",
    "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"
  ],
  [
    "b140",
    "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"
  ],
  [
    "b1a1",
    "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"
  ],
  [
    "b240",
    "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"
  ],
  [
    "b2a1",
    "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"
  ],
  [
    "b340",
    "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"
  ],
  [
    "b3a1",
    "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"
  ],
  [
    "b440",
    "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"
  ],
  [
    "b4a1",
    "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"
  ],
  [
    "b540",
    "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"
  ],
  [
    "b5a1",
    "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"
  ],
  [
    "b640",
    "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"
  ],
  [
    "b6a1",
    "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"
  ],
  [
    "b740",
    "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"
  ],
  [
    "b7a1",
    "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"
  ],
  [
    "b840",
    "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"
  ],
  [
    "b8a1",
    "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"
  ],
  [
    "b940",
    "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"
  ],
  [
    "b9a1",
    "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"
  ],
  [
    "ba40",
    "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"
  ],
  [
    "baa1",
    "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"
  ],
  [
    "bb40",
    "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"
  ],
  [
    "bba1",
    "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"
  ],
  [
    "bc40",
    "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"
  ],
  [
    "bca1",
    "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"
  ],
  [
    "bd40",
    "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"
  ],
  [
    "bda1",
    "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"
  ],
  [
    "be40",
    "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"
  ],
  [
    "bea1",
    "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"
  ],
  [
    "bf40",
    "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"
  ],
  [
    "bfa1",
    "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"
  ],
  [
    "c040",
    "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"
  ],
  [
    "c0a1",
    "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"
  ],
  [
    "c140",
    "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"
  ],
  [
    "c1a1",
    "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"
  ],
  [
    "c240",
    "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"
  ],
  [
    "c2a1",
    "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"
  ],
  [
    "c340",
    "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"
  ],
  [
    "c3a1",
    "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"
  ],
  [
    "c440",
    "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"
  ],
  [
    "c4a1",
    "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"
  ],
  [
    "c540",
    "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"
  ],
  [
    "c5a1",
    "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"
  ],
  [
    "c640",
    "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"
  ],
  [
    "c940",
    "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"
  ],
  [
    "c9a1",
    "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"
  ],
  [
    "ca40",
    "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"
  ],
  [
    "caa1",
    "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"
  ],
  [
    "cb40",
    "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"
  ],
  [
    "cba1",
    "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"
  ],
  [
    "cc40",
    "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"
  ],
  [
    "cca1",
    "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"
  ],
  [
    "cd40",
    "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"
  ],
  [
    "cda1",
    "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"
  ],
  [
    "ce40",
    "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"
  ],
  [
    "cea1",
    "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"
  ],
  [
    "cf40",
    "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"
  ],
  [
    "cfa1",
    "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"
  ],
  [
    "d040",
    "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"
  ],
  [
    "d0a1",
    "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"
  ],
  [
    "d140",
    "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"
  ],
  [
    "d1a1",
    "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"
  ],
  [
    "d240",
    "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"
  ],
  [
    "d2a1",
    "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"
  ],
  [
    "d340",
    "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"
  ],
  [
    "d3a1",
    "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"
  ],
  [
    "d440",
    "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"
  ],
  [
    "d4a1",
    "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"
  ],
  [
    "d540",
    "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"
  ],
  [
    "d5a1",
    "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"
  ],
  [
    "d640",
    "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"
  ],
  [
    "d6a1",
    "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"
  ],
  [
    "d740",
    "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"
  ],
  [
    "d7a1",
    "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"
  ],
  [
    "d840",
    "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"
  ],
  [
    "d8a1",
    "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"
  ],
  [
    "d940",
    "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"
  ],
  [
    "d9a1",
    "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"
  ],
  [
    "da40",
    "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"
  ],
  [
    "daa1",
    "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"
  ],
  [
    "db40",
    "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"
  ],
  [
    "dba1",
    "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"
  ],
  [
    "dc40",
    "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"
  ],
  [
    "dca1",
    "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"
  ],
  [
    "dd40",
    "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"
  ],
  [
    "dda1",
    "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"
  ],
  [
    "de40",
    "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"
  ],
  [
    "dea1",
    "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"
  ],
  [
    "df40",
    "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"
  ],
  [
    "dfa1",
    "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"
  ],
  [
    "e040",
    "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"
  ],
  [
    "e0a1",
    "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"
  ],
  [
    "e140",
    "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"
  ],
  [
    "e1a1",
    "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"
  ],
  [
    "e240",
    "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"
  ],
  [
    "e2a1",
    "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"
  ],
  [
    "e340",
    "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"
  ],
  [
    "e3a1",
    "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"
  ],
  [
    "e440",
    "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"
  ],
  [
    "e4a1",
    "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"
  ],
  [
    "e540",
    "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"
  ],
  [
    "e5a1",
    "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"
  ],
  [
    "e640",
    "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"
  ],
  [
    "e6a1",
    "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"
  ],
  [
    "e740",
    "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"
  ],
  [
    "e7a1",
    "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"
  ],
  [
    "e840",
    "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"
  ],
  [
    "e8a1",
    "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"
  ],
  [
    "e940",
    "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"
  ],
  [
    "e9a1",
    "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"
  ],
  [
    "ea40",
    "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"
  ],
  [
    "eaa1",
    "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"
  ],
  [
    "eb40",
    "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"
  ],
  [
    "eba1",
    "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"
  ],
  [
    "ec40",
    "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"
  ],
  [
    "eca1",
    "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"
  ],
  [
    "ed40",
    "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"
  ],
  [
    "eda1",
    "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"
  ],
  [
    "ee40",
    "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"
  ],
  [
    "eea1",
    "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"
  ],
  [
    "ef40",
    "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"
  ],
  [
    "efa1",
    "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"
  ],
  [
    "f040",
    "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"
  ],
  [
    "f0a1",
    "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"
  ],
  [
    "f140",
    "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"
  ],
  [
    "f1a1",
    "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"
  ],
  [
    "f240",
    "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"
  ],
  [
    "f2a1",
    "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"
  ],
  [
    "f340",
    "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"
  ],
  [
    "f3a1",
    "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"
  ],
  [
    "f440",
    "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"
  ],
  [
    "f4a1",
    "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"
  ],
  [
    "f540",
    "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"
  ],
  [
    "f5a1",
    "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"
  ],
  [
    "f640",
    "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"
  ],
  [
    "f6a1",
    "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"
  ],
  [
    "f740",
    "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"
  ],
  [
    "f7a1",
    "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"
  ],
  [
    "f840",
    "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"
  ],
  [
    "f8a1",
    "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"
  ],
  [
    "f940",
    "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"
  ],
  [
    "f9a1",
    "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"
  ]
], require$$7 = [
  [
    "8740",
    "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"
  ],
  [
    "8767",
    "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"
  ],
  [
    "87a1",
    "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"
  ],
  [
    "8840",
    "\u31C0",
    4,
    "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"
  ],
  [
    "88a1",
    "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"
  ],
  [
    "8940",
    "\u{2A3A9}\u{21145}"
  ],
  [
    "8943",
    "\u650A"
  ],
  [
    "8946",
    "\u4E3D\u6EDD\u9D4E\u91DF"
  ],
  [
    "894c",
    "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"
  ],
  [
    "89a1",
    "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"
  ],
  [
    "89ab",
    "\u918C\u78B8\u915E\u80BC"
  ],
  [
    "89b0",
    "\u8D0B\u80F6\u{209E7}"
  ],
  [
    "89b5",
    "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"
  ],
  [
    "89c1",
    "\u6E9A\u823E\u7519"
  ],
  [
    "89c5",
    "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"
  ],
  [
    "8a40",
    "\u{27D84}\u5525"
  ],
  [
    "8a43",
    "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"
  ],
  [
    "8a64",
    "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"
  ],
  [
    "8a76",
    "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"
  ],
  [
    "8aa1",
    "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"
  ],
  [
    "8aac",
    "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"
  ],
  [
    "8ab2",
    "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"
  ],
  [
    "8abb",
    "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"
  ],
  [
    "8ac9",
    "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"
  ],
  [
    "8ace",
    "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"
  ],
  [
    "8adf",
    "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"
  ],
  [
    "8af6",
    "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"
  ],
  [
    "8b40",
    "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"
  ],
  [
    "8b55",
    "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"
  ],
  [
    "8ba1",
    "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"
  ],
  [
    "8bde",
    "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"
  ],
  [
    "8c40",
    "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"
  ],
  [
    "8ca1",
    "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"
  ],
  [
    "8ca7",
    "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"
  ],
  [
    "8cc9",
    "\u9868\u676B\u4276\u573D"
  ],
  [
    "8cce",
    "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"
  ],
  [
    "8ce6",
    "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"
  ],
  [
    "8d40",
    "\u{20B9F}"
  ],
  [
    "8d42",
    "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"
  ],
  [
    "8da1",
    "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"
  ],
  [
    "8e40",
    "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"
  ],
  [
    "8ea1",
    "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"
  ],
  [
    "8f40",
    "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"
  ],
  [
    "8fa1",
    "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"
  ],
  [
    "9040",
    "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"
  ],
  [
    "90a1",
    "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"
  ],
  [
    "9140",
    "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"
  ],
  [
    "91a1",
    "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"
  ],
  [
    "9240",
    "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"
  ],
  [
    "92a1",
    "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"
  ],
  [
    "9340",
    "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"
  ],
  [
    "93a1",
    "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"
  ],
  [
    "9440",
    "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"
  ],
  [
    "94a1",
    "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"
  ],
  [
    "9540",
    "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"
  ],
  [
    "95a1",
    "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"
  ],
  [
    "9640",
    "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"
  ],
  [
    "96a1",
    "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"
  ],
  [
    "9740",
    "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"
  ],
  [
    "97a1",
    "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"
  ],
  [
    "9840",
    "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"
  ],
  [
    "98a1",
    "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"
  ],
  [
    "9940",
    "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"
  ],
  [
    "99a1",
    "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"
  ],
  [
    "9a40",
    "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"
  ],
  [
    "9aa1",
    "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"
  ],
  [
    "9b40",
    "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"
  ],
  [
    "9b62",
    "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"
  ],
  [
    "9ba1",
    "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"
  ],
  [
    "9c40",
    "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"
  ],
  [
    "9ca1",
    "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"
  ],
  [
    "9d40",
    "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"
  ],
  [
    "9da1",
    "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"
  ],
  [
    "9e40",
    "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"
  ],
  [
    "9ea1",
    "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"
  ],
  [
    "9ead",
    "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"
  ],
  [
    "9ec5",
    "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"
  ],
  [
    "9ef5",
    "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"
  ],
  [
    "9f40",
    "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"
  ],
  [
    "9f4f",
    "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"
  ],
  [
    "9fa1",
    "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"
  ],
  [
    "9fae",
    "\u9159\u9681\u915C"
  ],
  [
    "9fb2",
    "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"
  ],
  [
    "9fc1",
    "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"
  ],
  [
    "9fc9",
    "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"
  ],
  [
    "9fdb",
    "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"
  ],
  [
    "9fe7",
    "\u6BFA\u8818\u7F78"
  ],
  [
    "9feb",
    "\u5620\u{2A64A}\u8E77\u9F53"
  ],
  [
    "9ff0",
    "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"
  ],
  [
    "a040",
    "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"
  ],
  [
    "a055",
    "\u{2183B}\u{26E05}"
  ],
  [
    "a058",
    "\u8A7E\u{2251B}"
  ],
  [
    "a05b",
    "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"
  ],
  [
    "a063",
    "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"
  ],
  [
    "a073",
    "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"
  ],
  [
    "a0a1",
    "\u5D57\u{28BC2}\u8FDA\u{28E39}"
  ],
  [
    "a0a6",
    "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"
  ],
  [
    "a0ae",
    "\u77FE"
  ],
  [
    "a0b0",
    "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"
  ],
  [
    "a0d4",
    "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"
  ],
  [
    "a0e2",
    "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"
  ],
  [
    "a3c0",
    "\u2400",
    31,
    "\u2421"
  ],
  [
    "c6a1",
    "\u2460",
    9,
    "\u2474",
    9,
    "\u2170",
    9,
    "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041",
    23
  ],
  [
    "c740",
    "\u3059",
    58,
    "\u30A1\u30A2\u30A3\u30A4"
  ],
  [
    "c7a1",
    "\u30A5",
    81,
    "\u0410",
    5,
    "\u0401\u0416",
    4
  ],
  [
    "c840",
    "\u041B",
    26,
    "\u0451\u0436",
    25,
    "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"
  ],
  [
    "c8a1",
    "\u9FB0\u5188\u9FB1\u{27607}"
  ],
  [
    "c8cd",
    "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"
  ],
  [
    "c8f5",
    "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"
  ],
  [
    "f9fe",
    "\uFFED"
  ],
  [
    "fa40",
    "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"
  ],
  [
    "faa1",
    "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"
  ],
  [
    "fb40",
    "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"
  ],
  [
    "fba1",
    "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"
  ],
  [
    "fc40",
    "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"
  ],
  [
    "fca1",
    "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"
  ],
  [
    "fd40",
    "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"
  ],
  [
    "fda1",
    "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"
  ],
  [
    "fe40",
    "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"
  ],
  [
    "fea1",
    "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"
  ]
], dbcsData, hasRequiredDbcsData;
function requireDbcsData() {
  return hasRequiredDbcsData || (hasRequiredDbcsData = 1, dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require$$0$1;
      },
      encodeAdd: { "\xA5": 92, "\u203E": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "\xA5": 92, "\u203E": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "\u20AC": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  }), dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  return hasRequiredEncodings || (hasRequiredEncodings = 1, function(exports2) {
    for (var modules = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ], i = 0; i < modules.length; i++) {
      var module2 = modules[i];
      for (var enc in module2)
        Object.prototype.hasOwnProperty.call(module2, enc) && (exports2[enc] = module2[enc]);
    }
  }(encodings)), encodings;
}
var streams, hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = require$$0__default$a.default.Buffer, Transform = require$$0__default$4.default.Transform;
  streams = function(iconv) {
    iconv.encodeStream = function(encoding, options2) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options2), options2);
    }, iconv.decodeStream = function(encoding, options2) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options2), options2);
    }, iconv.supportsStreams = !0, iconv.IconvLiteEncoderStream = IconvLiteEncoderStream, iconv.IconvLiteDecoderStream = IconvLiteDecoderStream, iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options2) {
    this.conv = conv, options2 = options2 || {}, options2.decodeStrings = !1, Transform.call(this, options2);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  }), IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      res && res.length && this.push(res), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      res && res.length && this.push(res), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    return this.on("error", cb), this.on("data", function(chunk) {
      chunks.push(chunk);
    }), this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    }), this;
  };
  function IconvLiteDecoderStream(conv, options2) {
    this.conv = conv, options2 = options2 || {}, options2.encoding = this.encoding = "utf8", Transform.call(this, options2);
  }
  return IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  }), IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      res && res.length && this.push(res, this.encoding), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      res && res.length && this.push(res, this.encoding), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    return this.on("error", cb), this.on("data", function(chunk) {
      res += chunk;
    }), this.on("end", function() {
      cb(null, res);
    }), this;
  }, streams;
}
var extendNode, hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode) return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0__default$a.default.Buffer;
  return extendNode = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array), iconv.extendNodeEncodings = function() {
      if (!original) {
        if (original = {}, !iconv.supportsNodeEncodingsExtension) {
          console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"), console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
          return;
        }
        var nodeNativeEncodings = {
          hex: !0,
          utf8: !0,
          "utf-8": !0,
          ascii: !0,
          binary: !0,
          base64: !0,
          ucs2: !0,
          "ucs-2": !0,
          utf16le: !0,
          "utf-16le": !0
        };
        Buffer2.isNativeEncoding = function(enc) {
          return enc && nodeNativeEncodings[enc.toLowerCase()];
        };
        var SlowBuffer = require$$0__default$a.default.SlowBuffer;
        if (original.SlowBufferToString = SlowBuffer.prototype.toString, SlowBuffer.prototype.toString = function(encoding, start, end) {
          return encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding) ? original.SlowBufferToString.call(this, encoding, start, end) : (typeof start > "u" && (start = 0), typeof end > "u" && (end = this.length), iconv.decode(this.slice(start, end), encoding));
        }, original.SlowBufferWrite = SlowBuffer.prototype.write, SlowBuffer.prototype.write = function(string, offset, length, encoding) {
          if (isFinite(offset))
            isFinite(length) || (encoding = length, length = void 0);
          else {
            var swap = encoding;
            encoding = offset, offset = length, length = swap;
          }
          offset = +offset || 0;
          var remaining = this.length - offset;
          if (length ? (length = +length, length > remaining && (length = remaining)) : length = remaining, encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding))
            return original.SlowBufferWrite.call(this, string, offset, length, encoding);
          if (string.length > 0 && (length < 0 || offset < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var buf = iconv.encode(string, encoding);
          return buf.length < length && (length = buf.length), buf.copy(this, offset, 0, length), length;
        }, original.BufferIsEncoding = Buffer2.isEncoding, Buffer2.isEncoding = function(encoding) {
          return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }, original.BufferByteLength = Buffer2.byteLength, Buffer2.byteLength = SlowBuffer.byteLength = function(str2, encoding) {
          return encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding) ? original.BufferByteLength.call(this, str2, encoding) : iconv.encode(str2, encoding).length;
        }, original.BufferToString = Buffer2.prototype.toString, Buffer2.prototype.toString = function(encoding, start, end) {
          return encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding) ? original.BufferToString.call(this, encoding, start, end) : (typeof start > "u" && (start = 0), typeof end > "u" && (end = this.length), iconv.decode(this.slice(start, end), encoding));
        }, original.BufferWrite = Buffer2.prototype.write, Buffer2.prototype.write = function(string, offset, length, encoding) {
          var _offset = offset, _length = length, _encoding = encoding;
          if (isFinite(offset))
            isFinite(length) || (encoding = length, length = void 0);
          else {
            var swap = encoding;
            encoding = offset, offset = length, length = swap;
          }
          if (encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding))
            return original.BufferWrite.call(this, string, _offset, _length, _encoding);
          offset = +offset || 0;
          var remaining = this.length - offset;
          if (length ? (length = +length, length > remaining && (length = remaining)) : length = remaining, string.length > 0 && (length < 0 || offset < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var buf = iconv.encode(string, encoding);
          return buf.length < length && (length = buf.length), buf.copy(this, offset, 0, length), length;
        }, iconv.supportsStreams) {
          var Readable = require$$0__default$4.default.Readable;
          original.ReadableSetEncoding = Readable.prototype.setEncoding, Readable.prototype.setEncoding = function(enc, options2) {
            this._readableState.decoder = iconv.getDecoder(enc, options2), this._readableState.encoding = enc;
          }, Readable.prototype.collect = iconv._collect;
        }
      }
    }, iconv.undoExtendNodeEncodings = function() {
      if (iconv.supportsNodeEncodingsExtension) {
        if (!original)
          throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
        delete Buffer2.isNativeEncoding;
        var SlowBuffer = require$$0__default$a.default.SlowBuffer;
        if (SlowBuffer.prototype.toString = original.SlowBufferToString, SlowBuffer.prototype.write = original.SlowBufferWrite, Buffer2.isEncoding = original.BufferIsEncoding, Buffer2.byteLength = original.BufferByteLength, Buffer2.prototype.toString = original.BufferToString, Buffer2.prototype.write = original.BufferWrite, iconv.supportsStreams) {
          var Readable = require$$0__default$4.default.Readable;
          Readable.prototype.setEncoding = original.ReadableSetEncoding, delete Readable.prototype.collect;
        }
        original = void 0;
      }
    };
  }, extendNode;
}
var hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, function(module2) {
    var Buffer2 = requireSafer().Buffer, bomHandling2 = requireBomHandling(), iconv = module2.exports;
    iconv.encodings = null, iconv.defaultCharUnicode = "\uFFFD", iconv.defaultCharSingleByte = "?", iconv.encode = function(str2, encoding, options2) {
      str2 = "" + (str2 || "");
      var encoder = iconv.getEncoder(encoding, options2), res = encoder.write(str2), trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    }, iconv.decode = function(buf, encoding, options2) {
      typeof buf == "string" && (iconv.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), iconv.skipDecodeWarning = !0), buf = Buffer2.from("" + (buf || ""), "binary"));
      var decoder = iconv.getDecoder(encoding, options2), res = decoder.write(buf), trail = decoder.end();
      return trail ? res + trail : res;
    }, iconv.encodingExists = function(enc) {
      try {
        return iconv.getCodec(enc), !0;
      } catch {
        return !1;
      }
    }, iconv.toEncoding = iconv.encode, iconv.fromEncoding = iconv.decode, iconv._codecDataCache = {}, iconv.getCodec = function(encoding) {
      iconv.encodings || (iconv.encodings = requireEncodings());
      for (var enc = iconv._canonicalizeEncoding(encoding), codecOptions = {}; ; ) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key2 in codecDef)
              codecOptions[key2] = codecDef[key2];
            codecOptions.encodingName || (codecOptions.encodingName = enc), enc = codecDef.type;
            break;
          case "function":
            return codecOptions.encodingName || (codecOptions.encodingName = enc), codec = new codecDef(codecOptions, iconv), iconv._codecDataCache[codecOptions.encodingName] = codec, codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    }, iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    }, iconv.getEncoder = function(encoding, options2) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options2, codec);
      return codec.bomAware && options2 && options2.addBOM && (encoder = new bomHandling2.PrependBOM(encoder, options2)), encoder;
    }, iconv.getDecoder = function(encoding, options2) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options2, codec);
      return codec.bomAware && !(options2 && options2.stripBOM === !1) && (decoder = new bomHandling2.StripBOM(decoder, options2)), decoder;
    };
    var nodeVer = typeof process < "u" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) && requireStreams()(iconv), requireExtendNode()(iconv);
    }
  }(lib)), lib.exports;
}
var tmp = {}, osTmpdir, hasRequiredOsTmpdir;
function requireOsTmpdir() {
  if (hasRequiredOsTmpdir) return osTmpdir;
  hasRequiredOsTmpdir = 1;
  var isWindows = process.platform === "win32", trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
  return osTmpdir = function() {
    var path2;
    return isWindows ? path2 = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp" : path2 = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp", trailingSlashRe.test(path2) && (path2 = path2.slice(0, -1)), path2;
  }, osTmpdir;
}
/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */
var hasRequiredTmp;
function requireTmp() {
  if (hasRequiredTmp) return tmp;
  hasRequiredTmp = 1;
  const fs2 = require$$0__default$1.default, path2 = require$$0__default.default, crypto = require$$3__default.default, osTmpDir = requireOsTmpdir(), _c = process.binding("constants"), tmpDir = osTmpDir(), RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT2 = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448, FILE_MODE = 384, _removeObjects = [];
  var _gracefulCleanup = !1, _uncaughtException = !1;
  function _randomChars(howMany) {
    var value = [], rnd = null;
    try {
      rnd = crypto.randomBytes(howMany);
    } catch {
      rnd = crypto.pseudoRandomBytes(howMany);
    }
    for (var i = 0; i < howMany; i++)
      value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    return value.join("");
  }
  function _isUndefined(obj) {
    return typeof obj > "u";
  }
  function _parseArguments(options2, callback) {
    return typeof options2 == "function" ? [callback || {}, options2] : _isUndefined(options2) ? [{}, callback] : [options2, callback];
  }
  function _generateTmpName(opts) {
    if (opts.name)
      return path2.join(opts.dir || tmpDir, opts.name);
    if (opts.template)
      return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
    const name = [
      opts.prefix || "tmp-",
      process.pid,
      _randomChars(12),
      opts.postfix || ""
    ].join("");
    return path2.join(opts.dir || tmpDir, name);
  }
  function tmpName(options2, callback) {
    var args = _parseArguments(options2, callback), opts = args[0], cb = args[1], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
    if (isNaN(tries) || tries < 0)
      return cb(new Error("Invalid tries"));
    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      return cb(new Error("Invalid template provided"));
    (function _getUniqueName() {
      const name = _generateTmpName(opts);
      fs2.stat(name, function(err) {
        if (!err)
          return tries-- > 0 ? _getUniqueName() : cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
        cb(null, name);
      });
    })();
  }
  function tmpNameSync(options2) {
    var args = _parseArguments(options2), opts = args[0], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
    if (isNaN(tries) || tries < 0)
      throw new Error("Invalid tries");
    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      throw new Error("Invalid template provided");
    do {
      const name = _generateTmpName(opts);
      try {
        fs2.statSync(name);
      } catch {
        return name;
      }
    } while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
  }
  function file(options2, callback) {
    var args = _parseArguments(options2, callback), opts = args[0], cb = args[1];
    opts.postfix = _isUndefined(opts.postfix) ? ".tmp" : opts.postfix, tmpName(opts, function(err, name) {
      if (err) return cb(err);
      fs2.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function(err2, fd) {
        if (err2) return cb(err2);
        if (opts.discardDescriptor)
          return fs2.close(fd, function(err3) {
            if (err3) {
              try {
                fs2.unlinkSync(name);
              } catch (e) {
                isENOENT(e) || (err3 = e);
              }
              return cb(err3);
            }
            cb(null, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts));
          });
        if (opts.detachDescriptor)
          return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
      });
    });
  }
  function fileSync(options2) {
    var args = _parseArguments(options2), opts = args[0];
    opts.postfix = opts.postfix || ".tmp";
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor, name = tmpNameSync(opts);
    var fd = fs2.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    return opts.discardDescriptor && (fs2.closeSync(fd), fd = void 0), {
      name,
      fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
    };
  }
  function _rmdirRecursiveSync(root2) {
    const dirs = [root2];
    do {
      for (var dir2 = dirs.pop(), deferred = !1, files = fs2.readdirSync(dir2), i = 0, length = files.length; i < length; i++) {
        var file2 = path2.join(dir2, files[i]), stat2 = fs2.lstatSync(file2);
        stat2.isDirectory() ? (deferred || (deferred = !0, dirs.push(dir2)), dirs.push(file2)) : fs2.unlinkSync(file2);
      }
      deferred || fs2.rmdirSync(dir2);
    } while (dirs.length !== 0);
  }
  function dir(options2, callback) {
    var args = _parseArguments(options2, callback), opts = args[0], cb = args[1];
    tmpName(opts, function(err, name) {
      if (err) return cb(err);
      fs2.mkdir(name, opts.mode || DIR_MODE, function(err2) {
        if (err2) return cb(err2);
        cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
      });
    });
  }
  function dirSync(options2) {
    var args = _parseArguments(options2), opts = args[0];
    const name = tmpNameSync(opts);
    return fs2.mkdirSync(name, opts.mode || DIR_MODE), {
      name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts)
    };
  }
  function _prepareTmpFileRemoveCallback(name, fd, opts) {
    const removeCallback = _prepareRemoveCallback(function(fdPath) {
      try {
        0 <= fdPath[0] && fs2.closeSync(fdPath[0]);
      } catch (e) {
        if (!isEBADF(e) && !isENOENT(e))
          throw e;
      }
      try {
        fs2.unlinkSync(fdPath[1]);
      } catch (e) {
        if (!isENOENT(e))
          throw e;
      }
    }, [fd, name]);
    return opts.keep || _removeObjects.unshift(removeCallback), removeCallback;
  }
  function _prepareTmpDirRemoveCallback(name, opts) {
    const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs2.rmdirSync.bind(fs2), removeCallback = _prepareRemoveCallback(removeFunction, name);
    return opts.keep || _removeObjects.unshift(removeCallback), removeCallback;
  }
  function _prepareRemoveCallback(removeFunction, arg) {
    var called = !1;
    return function _cleanupCallback(next) {
      if (!called) {
        const index = _removeObjects.indexOf(_cleanupCallback);
        index >= 0 && _removeObjects.splice(index, 1), called = !0, removeFunction(arg);
      }
      next && next(null);
    };
  }
  function _garbageCollector() {
    if (!(_uncaughtException && !_gracefulCleanup))
      for (; _removeObjects.length; )
        try {
          _removeObjects[0].call(null);
        } catch {
        }
  }
  function isEBADF(error2) {
    return isExpectedError(error2, -EBADF, "EBADF");
  }
  function isENOENT(error2) {
    return isExpectedError(error2, -ENOENT2, "ENOENT");
  }
  function isExpectedError(error2, code, errno) {
    return error2.code == code || error2.code == errno;
  }
  function setGracefulCleanup() {
    _gracefulCleanup = !0;
  }
  const version2 = process.versions.node.split(".").map(function(value) {
    return parseInt(value, 10);
  });
  return version2[0] === 0 && (version2[1] < 9 || version2[1] === 9 && version2[2] < 5) && process.addListener("uncaughtException", function(err) {
    throw _uncaughtException = !0, _garbageCollector(), err;
  }), process.addListener("exit", function(code) {
    code && (_uncaughtException = !0), _garbageCollector();
  }), tmp.tmpdir = tmpDir, tmp.dir = dir, tmp.dirSync = dirSync, tmp.file = file, tmp.fileSync = fileSync, tmp.tmpName = tmpName, tmp.tmpNameSync = tmpNameSync, tmp.setGracefulCleanup = setGracefulCleanup, tmp;
}
var CreateFileError = {}, hasRequiredCreateFileError;
function requireCreateFileError() {
  if (hasRequiredCreateFileError) return CreateFileError;
  hasRequiredCreateFileError = 1;
  var __extends2 = CreateFileError && CreateFileError.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(CreateFileError, "__esModule", { value: !0 });
  var CreateFileError$1 = (
    /** @class */
    function(_super) {
      __extends2(CreateFileError2, _super);
      function CreateFileError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed to create temporary file for editor") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return CreateFileError2;
    }(Error)
  );
  return CreateFileError.CreateFileError = CreateFileError$1, CreateFileError;
}
var LaunchEditorError = {}, hasRequiredLaunchEditorError;
function requireLaunchEditorError() {
  if (hasRequiredLaunchEditorError) return LaunchEditorError;
  hasRequiredLaunchEditorError = 1;
  var __extends2 = LaunchEditorError && LaunchEditorError.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(LaunchEditorError, "__esModule", { value: !0 });
  var LaunchEditorError$1 = (
    /** @class */
    function(_super) {
      __extends2(LaunchEditorError2, _super);
      function LaunchEditorError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed launch editor") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return LaunchEditorError2;
    }(Error)
  );
  return LaunchEditorError.LaunchEditorError = LaunchEditorError$1, LaunchEditorError;
}
var ReadFileError = {}, hasRequiredReadFileError;
function requireReadFileError() {
  if (hasRequiredReadFileError) return ReadFileError;
  hasRequiredReadFileError = 1;
  var __extends2 = ReadFileError && ReadFileError.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(ReadFileError, "__esModule", { value: !0 });
  var ReadFileError$1 = (
    /** @class */
    function(_super) {
      __extends2(ReadFileError2, _super);
      function ReadFileError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed to read temporary file") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return ReadFileError2;
    }(Error)
  );
  return ReadFileError.ReadFileError = ReadFileError$1, ReadFileError;
}
var RemoveFileError = {}, hasRequiredRemoveFileError;
function requireRemoveFileError() {
  if (hasRequiredRemoveFileError) return RemoveFileError;
  hasRequiredRemoveFileError = 1;
  var __extends2 = RemoveFileError && RemoveFileError.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(RemoveFileError, "__esModule", { value: !0 });
  var RemoveFileError$1 = (
    /** @class */
    function(_super) {
      __extends2(RemoveFileError2, _super);
      function RemoveFileError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed to cleanup temporary file") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return RemoveFileError2;
    }(Error)
  );
  return RemoveFileError.RemoveFileError = RemoveFileError$1, RemoveFileError;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1, Object.defineProperty(main, "__esModule", { value: !0 });
  var chardet_1 = requireChardet(), child_process_1 = require$$1__default$2.default, fs_1 = require$$0__default$1.default, iconv_lite_1 = requireLib(), tmp_1 = requireTmp(), CreateFileError_1 = requireCreateFileError();
  main.CreateFileError = CreateFileError_1.CreateFileError;
  var LaunchEditorError_1 = requireLaunchEditorError();
  main.LaunchEditorError = LaunchEditorError_1.LaunchEditorError;
  var ReadFileError_1 = requireReadFileError();
  main.ReadFileError = ReadFileError_1.ReadFileError;
  var RemoveFileError_1 = requireRemoveFileError();
  main.RemoveFileError = RemoveFileError_1.RemoveFileError;
  function edit(text, fileOptions) {
    text === void 0 && (text = "");
    var editor2 = new ExternalEditor(text, fileOptions);
    return editor2.run(), editor2.cleanup(), editor2.text;
  }
  main.edit = edit;
  function editAsync(text, callback, fileOptions) {
    text === void 0 && (text = "");
    var editor2 = new ExternalEditor(text, fileOptions);
    editor2.runAsync(function(err, result) {
      if (err)
        setImmediate(callback, err, null);
      else
        try {
          editor2.cleanup(), setImmediate(callback, null, result);
        } catch (cleanupError) {
          setImmediate(callback, cleanupError, null);
        }
    });
  }
  main.editAsync = editAsync;
  var ExternalEditor = (
    /** @class */
    function() {
      function ExternalEditor2(text, fileOptions) {
        text === void 0 && (text = ""), this.text = "", this.fileOptions = {}, this.text = text, fileOptions && (this.fileOptions = fileOptions), this.determineEditor(), this.createTemporaryFile();
      }
      return ExternalEditor2.splitStringBySpace = function(str2) {
        for (var pieces = [], currentString = "", strIndex = 0; strIndex < str2.length; strIndex++) {
          var currentLetter = str2[strIndex];
          strIndex > 0 && currentLetter === " " && str2[strIndex - 1] !== "\\" && currentString.length > 0 ? (pieces.push(currentString), currentString = "") : currentString += currentLetter;
        }
        return currentString.length > 0 && pieces.push(currentString), pieces;
      }, Object.defineProperty(ExternalEditor2.prototype, "temp_file", {
        get: function() {
          return console.log("DEPRECATED: temp_file. Use tempFile moving forward."), this.tempFile;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(ExternalEditor2.prototype, "last_exit_status", {
        get: function() {
          return console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward."), this.lastExitStatus;
        },
        enumerable: !0,
        configurable: !0
      }), ExternalEditor2.prototype.run = function() {
        return this.launchEditor(), this.readTemporaryFile(), this.text;
      }, ExternalEditor2.prototype.runAsync = function(callback) {
        var _this = this;
        try {
          this.launchEditorAsync(function() {
            try {
              _this.readTemporaryFile(), setImmediate(callback, null, _this.text);
            } catch (readError) {
              setImmediate(callback, readError, null);
            }
          });
        } catch (launchError) {
          setImmediate(callback, launchError, null);
        }
      }, ExternalEditor2.prototype.cleanup = function() {
        this.removeTemporaryFile();
      }, ExternalEditor2.prototype.determineEditor = function() {
        var editor2 = process.env.VISUAL ? process.env.VISUAL : process.env.EDITOR ? process.env.EDITOR : /^win/.test(process.platform) ? "notepad" : "vim", editorOpts = ExternalEditor2.splitStringBySpace(editor2).map(function(piece) {
          return piece.replace("\\ ", " ");
        }), bin = editorOpts.shift();
        this.editor = { args: editorOpts, bin };
      }, ExternalEditor2.prototype.createTemporaryFile = function() {
        try {
          this.tempFile = tmp_1.tmpNameSync(this.fileOptions);
          var opt = { encoding: "utf8" };
          this.fileOptions.hasOwnProperty("mode") && (opt.mode = this.fileOptions.mode), fs_1.writeFileSync(this.tempFile, this.text, opt);
        } catch (createFileError) {
          throw new CreateFileError_1.CreateFileError(createFileError);
        }
      }, ExternalEditor2.prototype.readTemporaryFile = function() {
        try {
          var tempFileBuffer = fs_1.readFileSync(this.tempFile);
          if (tempFileBuffer.length === 0)
            this.text = "";
          else {
            var encoding = chardet_1.detect(tempFileBuffer).toString();
            iconv_lite_1.encodingExists(encoding) || (encoding = "utf8"), this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
          }
        } catch (readFileError) {
          throw new ReadFileError_1.ReadFileError(readFileError);
        }
      }, ExternalEditor2.prototype.removeTemporaryFile = function() {
        try {
          fs_1.unlinkSync(this.tempFile);
        } catch (removeFileError) {
          throw new RemoveFileError_1.RemoveFileError(removeFileError);
        }
      }, ExternalEditor2.prototype.launchEditor = function() {
        try {
          var editorProcess = child_process_1.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
          this.lastExitStatus = editorProcess.status;
        } catch (launchError) {
          throw new LaunchEditorError_1.LaunchEditorError(launchError);
        }
      }, ExternalEditor2.prototype.launchEditorAsync = function(callback) {
        var _this = this;
        try {
          var editorProcess = child_process_1.spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
          editorProcess.on("exit", function(code) {
            _this.lastExitStatus = code, setImmediate(callback);
          });
        } catch (launchError) {
          throw new LaunchEditorError_1.LaunchEditorError(launchError);
        }
      }, ExternalEditor2;
    }()
  );
  return main.ExternalEditor = ExternalEditor, main;
}
var editor, hasRequiredEditor;
function requireEditor() {
  if (hasRequiredEditor) return editor;
  hasRequiredEditor = 1;
  var chalk2 = chalk__default.default, editAsync = requireMain().editAsync, Base = requireBase(), observe = requireEvents(), { Subject: Subject2 } = require$$4$1;
  class EditorPrompt extends Base {
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb, this.editorResult = new Subject2();
      var events2 = observe(this.rl);
      this.lineSubscription = events2.line.subscribe(this.startExternalEditor.bind(this));
      var validation = this.handleSubmitEvents(this.editorResult);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), this.currentText = this.opt.default, this.opt.default = null, this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {EditorPrompt} self
     */
    render(error2) {
      var bottomContent = "", message = this.getQuestion();
      this.status === "answered" ? message += chalk2.dim("Received") : message += chalk2.dim("Press <enter> to launch your preferred editor."), error2 && (bottomContent = chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * Launch $EDITOR on user press enter
     */
    startExternalEditor() {
      this.rl.pause(), editAsync(this.currentText, this.endExternalEditor.bind(this));
    }
    endExternalEditor(error2, result) {
      this.rl.resume(), error2 ? this.editorResult.error(error2) : this.editorResult.next(result);
    }
    onEnd(state) {
      this.editorResult.unsubscribe(), this.lineSubscription.unsubscribe(), this.answer = state.value, this.status = "answered", this.render(), this.screen.done(), this.done(this.answer);
    }
    onError(state) {
      this.render(state.isValid);
    }
  }
  return editor = EditorPrompt, editor;
}
var hasRequiredInquirer;
function requireInquirer() {
  return hasRequiredInquirer || (hasRequiredInquirer = 1, function(module2) {
    var inquirer2 = module2.exports;
    inquirer2.prompts = {}, inquirer2.Separator = requireSeparator(), inquirer2.ui = {
      BottomBar: requireBottomBar(),
      Prompt: requirePrompt()
    }, inquirer2.createPromptModule = function(opt) {
      var promptModule = function(questions) {
        var ui = new inquirer2.ui.Prompt(promptModule.prompts, opt), promise2 = ui.run(questions);
        return promise2.ui = ui, promise2;
      };
      return promptModule.prompts = {}, promptModule.registerPrompt = function(name, prompt2) {
        return promptModule.prompts[name] = prompt2, this;
      }, promptModule.restoreDefaultPrompts = function() {
        this.registerPrompt("list", requireList()), this.registerPrompt("input", requireInput()), this.registerPrompt("number", requireNumber()), this.registerPrompt("confirm", requireConfirm()), this.registerPrompt("rawlist", requireRawlist()), this.registerPrompt("expand", requireExpand()), this.registerPrompt("checkbox", requireCheckbox()), this.registerPrompt("password", requirePassword()), this.registerPrompt("editor", requireEditor());
      }, promptModule.restoreDefaultPrompts(), promptModule;
    }, inquirer2.prompt = inquirer2.createPromptModule(), inquirer2.registerPrompt = function(name, prompt2) {
      inquirer2.prompt.registerPrompt(name, prompt2);
    }, inquirer2.restoreDefaultPrompts = function() {
      inquirer2.prompt.restoreDefaultPrompts();
    };
  }(inquirer$1)), inquirer$1.exports;
}
var inquirerExports = requireInquirer(), inquirer = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(inquirerExports);
function prompt(questions) {
  return inquirer.prompt(questions);
}
prompt.Separator = inquirer.Separator;
prompt.single = (question) => prompt([{ ...question, name: "value" }]).then((answers) => answers.value);
class CommandRunner {
  handlers;
  commands;
  commandGroups;
  constructor(handlers, commands = baseCommands) {
    this.handlers = handlers, this.commands = lodashExports.sortBy(commands, "name"), this.commandGroups = {};
    for (const cmd of this.commands) {
      const group = "group" in cmd && cmd.group || "default";
      this.commandGroups[group] = this.commandGroups[group] || [], this.commandGroups[group].push(cmd);
    }
    if (!handlers.outputter || !handlers.prompter)
      throw new Error("`prompter` and `outputter` handlers must be defined");
  }
  async runCommand(commandOrGroup, args, options2) {
    if (!commandOrGroup)
      return this.handlers.outputter.print(generateCommandsDocumentation(this.commandGroups)), Promise.resolve();
    const cmdArgs = lodashExports.cloneDeep(args), subCommandName = args.argsWithoutOptions[0], commandInfo = this.resolveCommand(commandOrGroup, subCommandName);
    if (!commandInfo)
      throw new Error(getNoSuchCommandText(commandOrGroup, subCommandName, this.commandGroups));
    const command2 = commandInfo.command;
    !isCommandGroup(command2) && command2.group && command2.group !== "default" && (cmdArgs.argsWithoutOptions = args.argsWithoutOptions.slice(1));
    const output = this.handlers.outputter, prompt2 = this.handlers.prompter, { cliConfig, ...commandOptions } = options2, apiClient = getClientWrapper(
      cliConfig?.config?.api || null,
      cliConfig?.path || (cliConfig?.version === 2 ? "sanity.json" : "sanity.cli.js")
    ), context = {
      output,
      prompt: prompt2,
      apiClient,
      chalk: chalk__default.default,
      cliPackageManager,
      ...commandOptions,
      commandRunner: this,
      ...getVersionedContextParams(cliConfig)
    };
    if (isCommandGroup(command2))
      return context.output.print(generateCommandsDocumentation(this.commandGroups, command2.name));
    if (typeof command2.action != "function") {
      const cmdName = command2.name || commandOrGroup || "<unknown>";
      loadEnv.debug(`Command "${cmdName}" doesnt have a valid "action"-property, showing help`);
      const groupName = command2.group && command2.group !== "default" ? command2.group : null;
      return context.output.print(generateCommandDocumentation(command2, groupName, subCommandName));
    }
    return loadEnv.debug(`Running command "${command2.name}"`), command2.action(cmdArgs, context);
  }
  resolveCommand(commandOrGroup, subCommandName) {
    if (this.commandGroups[commandOrGroup] && subCommandName) {
      loadEnv.debug(`Found group for name "${commandOrGroup}", resolving subcommand`);
      const subCommand = this.resolveSubcommand(
        this.commandGroups[commandOrGroup],
        subCommandName,
        commandOrGroup
      );
      return loadEnv.debug(
        subCommand ? `Subcommand resolved to "${subCommand.commandName}"` : `Subcommand with name "${subCommandName}" not found`
      ), subCommand;
    }
    loadEnv.debug(`No group found with name "${commandOrGroup}", looking for command`);
    const command2 = this.commandGroups.default.find((cmd) => cmd.name === commandOrGroup);
    return command2 ? (loadEnv.debug(`Found command in default group with name "${commandOrGroup}"`), {
      command: command2,
      commandName: command2.name,
      parentName: "default",
      isGroup: !1,
      isCommand: !0
    }) : (loadEnv.debug(`No default command with name "${commandOrGroup}" found, giving up`), null);
  }
  resolveSubcommand(group, subCommandName, parentGroupName) {
    if (!subCommandName)
      return null;
    const subCommand = group.find((cmd) => cmd.name === subCommandName);
    if (!subCommand)
      throw new Error(getNoSuchCommandText(subCommandName, parentGroupName, this.commandGroups));
    return {
      command: subCommand,
      commandName: subCommandName,
      parentName: parentGroupName,
      isGroup: !1,
      isCommand: !0
    };
  }
  resolveHelpForGroup() {
    const command2 = this.commandGroups.default.find((cmd) => cmd.name === "help");
    if (!command2)
      throw new Error("Failed to find default `help` command");
    return {
      command: command2,
      commandName: "help",
      isGroup: !1,
      isCommand: !0
    };
  }
}
function getCliRunner(commands) {
  return new CommandRunner(
    {
      outputter: cliOutputter,
      prompter: prompt
    },
    commands
  );
}
function getVersionedContextParams(cliConfig) {
  return cliConfig?.version === 2 ? {
    sanityMajorVersion: 2,
    cliConfig: cliConfig?.config || void 0,
    cliConfigPath: cliConfig?.path || void 0
  } : {
    sanityMajorVersion: 3,
    cliConfig: cliConfig?.config || void 0,
    cliConfigPath: cliConfig?.path || void 0
  };
}
function detectRuntime() {
  return "Deno" in globalThis ? "deno" : "Bun" in globalThis ? "bun" : "node";
}
async function mergeCommands(baseCommands2, corePath, options2) {
  if (!corePath)
    return baseCommands2;
  const { cwd, workDir, cliVersion } = options2, coreImport = getCliConfig.dynamicRequire(corePath);
  semver__default.default.coerce(cliVersion);
  const core2 = "cliProjectCommands" in coreImport ? coreImport.cliProjectCommands : coreImport;
  return baseCommands2.concat(core2.commands).map(addDefaultGroup).reverse().reduce(
    (cmds, cmd) => {
      const group = isCommandGroup(cmd) ? void 0 : cmd.group;
      return lodashExports.find(cmds, { name: cmd.name, group }) || cmds.push(cmd), cmds;
    },
    []
  );
}
function addDefaultGroup(cmd) {
  return !isCommandGroup(cmd) && !cmd.group && (cmd.group = "default"), cmd;
}
var escapeStringRegexp, hasRequiredEscapeStringRegexp;
function requireEscapeStringRegexp() {
  return hasRequiredEscapeStringRegexp || (hasRequiredEscapeStringRegexp = 1, escapeStringRegexp = (string) => {
    if (typeof string != "string")
      throw new TypeError("Expected a string");
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }), escapeStringRegexp;
}
var cleanStack$1, hasRequiredCleanStack;
function requireCleanStack() {
  if (hasRequiredCleanStack) return cleanStack$1;
  hasRequiredCleanStack = 1;
  const os2 = require$$0__default$2.default, escapeStringRegexp2 = requireEscapeStringRegexp(), extractPathRegex = /\s+at.*[(\s](.*)\)?/, pathRegex = /^(?:(?:(?:node|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/, homeDir = typeof os2.homedir > "u" ? "" : os2.homedir();
  return cleanStack$1 = (stack2, { pretty = !1, basePath } = {}) => {
    const basePathRegex = basePath && new RegExp(`(at | \\()${escapeStringRegexp2(basePath)}`, "g");
    return stack2.replace(/\\/g, "/").split(`
`).filter((line3) => {
      const pathMatches = line3.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1])
        return !0;
      const match2 = pathMatches[1];
      return match2.includes(".app/Contents/Resources/electron.asar") || match2.includes(".app/Contents/Resources/default_app.asar") ? !1 : !pathRegex.test(match2);
    }).filter((line3) => line3.trim() !== "").map((line3) => (basePathRegex && (line3 = line3.replace(basePathRegex, "$1")), pretty && (line3 = line3.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")))), line3)).join(`
`);
  }, cleanStack$1;
}
var cleanStackExports = requireCleanStack(), cleanStack = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(cleanStackExports);
const options = { pretty: process.platform !== "win32" };
function neatStack(error2) {
  if (typeof error2 == "string")
    return chalk.red(cleanStack(error2, options));
  if (error2 === null || typeof error2 != "object" || typeof error2.stack != "string")
    return chalk.red(util$4.inspect(error2));
  const title = error2.toString(), stack2 = cleanStack(error2.stack, options);
  return stack2.startsWith(title) ? chalk.red(`${title}${chalk.dim(cleanStack(error2.stack, options).slice(title.length))}`) : chalk.red(stack2);
}
var minimistExports = requireMinimist(), minimist = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(minimistExports);
function parseArguments(argv = process.argv) {
  const {
    _,
    h,
    help: help2,
    d,
    debug: debug2,
    v,
    version: version2,
    "--": extraArguments,
    ...extOptions
  } = minimist(argv.slice(2), {
    "--": !0,
    boolean: ["h", "help", "d", "debug", "v", "version"],
    string: ["_"]
  }), [groupOrCommand, ...argsWithoutOptions] = _;
  return {
    groupOrCommand,
    argv,
    extOptions,
    argsWithoutOptions,
    extraArguments: extraArguments || [],
    // prettier-ignore
    coreOptions: {
      h,
      help: help2,
      d,
      debug: debug2,
      v,
      version: version2
    }
  };
}
var boxen$1 = { exports: {} }, stringWidth = { exports: {} }, ansiRegex, hasRequiredAnsiRegex;
function requireAnsiRegex() {
  return hasRequiredAnsiRegex || (hasRequiredAnsiRegex = 1, ansiRegex = ({ onlyFirst = !1 } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  }), ansiRegex;
}
var stripAnsi, hasRequiredStripAnsi;
function requireStripAnsi() {
  if (hasRequiredStripAnsi) return stripAnsi;
  hasRequiredStripAnsi = 1;
  const ansiRegex2 = requireAnsiRegex();
  return stripAnsi = (string) => typeof string == "string" ? string.replace(ansiRegex2(), "") : string, stripAnsi;
}
var isFullwidthCodePoint = { exports: {} }, hasRequiredIsFullwidthCodePoint;
function requireIsFullwidthCodePoint() {
  if (hasRequiredIsFullwidthCodePoint) return isFullwidthCodePoint.exports;
  hasRequiredIsFullwidthCodePoint = 1;
  const isFullwidthCodePoint$12 = (codePoint) => Number.isNaN(codePoint) ? !1 : codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
  codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
  43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
  44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
  63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
  65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
  110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
  127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= codePoint && codePoint <= 262141);
  return isFullwidthCodePoint.exports = isFullwidthCodePoint$12, isFullwidthCodePoint.exports.default = isFullwidthCodePoint$12, isFullwidthCodePoint.exports;
}
var emojiRegex, hasRequiredEmojiRegex;
function requireEmojiRegex() {
  return hasRequiredEmojiRegex || (hasRequiredEmojiRegex = 1, emojiRegex = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  }), emojiRegex;
}
var hasRequiredStringWidth;
function requireStringWidth() {
  if (hasRequiredStringWidth) return stringWidth.exports;
  hasRequiredStringWidth = 1;
  const stripAnsi2 = requireStripAnsi(), isFullwidthCodePoint2 = requireIsFullwidthCodePoint(), emojiRegex2 = requireEmojiRegex(), stringWidth$12 = (string) => {
    if (typeof string != "string" || string.length === 0 || (string = stripAnsi2(string), string.length === 0))
      return 0;
    string = string.replace(emojiRegex2(), "  ");
    let width = 0;
    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i);
      code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || (code > 65535 && i++, width += isFullwidthCodePoint2(code) ? 2 : 1);
    }
    return width;
  };
  return stringWidth.exports = stringWidth$12, stringWidth.exports.default = stringWidth$12, stringWidth.exports;
}
var widestLine = { exports: {} }, hasRequiredWidestLine;
function requireWidestLine() {
  if (hasRequiredWidestLine) return widestLine.exports;
  hasRequiredWidestLine = 1;
  const stringWidth2 = requireStringWidth(), widestLine$1 = (input2) => {
    let max2 = 0;
    for (const line3 of input2.split(`
`))
      max2 = Math.max(max2, stringWidth2(line3));
    return max2;
  };
  return widestLine.exports = widestLine$1, widestLine.exports.default = widestLine$1, widestLine.exports;
}
var cliBoxes = { exports: {} }, single = {
  topLeft: "\u250C",
  topRight: "\u2510",
  bottomRight: "\u2518",
  bottomLeft: "\u2514",
  vertical: "\u2502",
  horizontal: "\u2500"
}, double = {
  topLeft: "\u2554",
  topRight: "\u2557",
  bottomRight: "\u255D",
  bottomLeft: "\u255A",
  vertical: "\u2551",
  horizontal: "\u2550"
}, round = {
  topLeft: "\u256D",
  topRight: "\u256E",
  bottomRight: "\u256F",
  bottomLeft: "\u2570",
  vertical: "\u2502",
  horizontal: "\u2500"
}, bold = {
  topLeft: "\u250F",
  topRight: "\u2513",
  bottomRight: "\u251B",
  bottomLeft: "\u2517",
  vertical: "\u2503",
  horizontal: "\u2501"
}, singleDouble = {
  topLeft: "\u2553",
  topRight: "\u2556",
  bottomRight: "\u255C",
  bottomLeft: "\u2559",
  vertical: "\u2551",
  horizontal: "\u2500"
}, doubleSingle = {
  topLeft: "\u2552",
  topRight: "\u2555",
  bottomRight: "\u255B",
  bottomLeft: "\u2558",
  vertical: "\u2502",
  horizontal: "\u2550"
}, classic = {
  topLeft: "+",
  topRight: "+",
  bottomRight: "+",
  bottomLeft: "+",
  vertical: "|",
  horizontal: "-"
}, require$$0 = {
  single,
  double,
  round,
  bold,
  singleDouble,
  doubleSingle,
  classic
}, hasRequiredCliBoxes;
function requireCliBoxes() {
  if (hasRequiredCliBoxes) return cliBoxes.exports;
  hasRequiredCliBoxes = 1;
  const cliBoxes$1 = require$$0;
  return cliBoxes.exports = cliBoxes$1, cliBoxes.exports.default = cliBoxes$1, cliBoxes.exports;
}
var camelcase = { exports: {} }, hasRequiredCamelcase;
function requireCamelcase() {
  if (hasRequiredCamelcase) return camelcase.exports;
  hasRequiredCamelcase = 1;
  const preserveCamelCase = (string) => {
    let isLastCharLower = !1, isLastCharUpper = !1, isLastLastCharUpper = !1;
    for (let i = 0; i < string.length; i++) {
      const character = string[i];
      isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character ? (string = string.slice(0, i) + "-" + string.slice(i), isLastCharLower = !1, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !0, i++) : isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character ? (string = string.slice(0, i - 1) + "-" + string.slice(i - 1), isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !1, isLastCharLower = !0) : (isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character);
    }
    return string;
  }, camelCase = (input2, options2) => {
    if (!(typeof input2 == "string" || Array.isArray(input2)))
      throw new TypeError("Expected the input to be `string | string[]`");
    options2 = Object.assign({
      pascalCase: !1
    }, options2);
    const postProcess = (x) => options2.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
    return Array.isArray(input2) ? input2 = input2.map((x) => x.trim()).filter((x) => x.length).join("-") : input2 = input2.trim(), input2.length === 0 ? "" : input2.length === 1 ? options2.pascalCase ? input2.toUpperCase() : input2.toLowerCase() : (input2 !== input2.toLowerCase() && (input2 = preserveCamelCase(input2)), input2 = input2.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase()), postProcess(input2));
  };
  return camelcase.exports = camelCase, camelcase.exports.default = camelCase, camelcase.exports;
}
var ansiAlign_1, hasRequiredAnsiAlign;
function requireAnsiAlign() {
  if (hasRequiredAnsiAlign) return ansiAlign_1;
  hasRequiredAnsiAlign = 1;
  const stringWidth2 = requireStringWidth();
  function ansiAlign(text, opts) {
    if (!text) return text;
    opts = opts || {};
    const align = opts.align || "center";
    if (align === "left") return text;
    const split = opts.split || `
`, pad = opts.pad || " ", widthDiffFn = align !== "right" ? halfDiff : fullDiff;
    let returnString = !1;
    Array.isArray(text) || (returnString = !0, text = String(text).split(split));
    let width, maxWidth = 0;
    return text = text.map(function(str2) {
      return str2 = String(str2), width = stringWidth2(str2), maxWidth = Math.max(width, maxWidth), {
        str: str2,
        width
      };
    }).map(function(obj) {
      return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad) + obj.str;
    }), returnString ? text.join(split) : text;
  }
  ansiAlign.left = function(text) {
    return ansiAlign(text, { align: "left" });
  }, ansiAlign.center = function(text) {
    return ansiAlign(text, { align: "center" });
  }, ansiAlign.right = function(text) {
    return ansiAlign(text, { align: "right" });
  }, ansiAlign_1 = ansiAlign;
  function halfDiff(maxWidth, curWidth) {
    return Math.floor((maxWidth - curWidth) / 2);
  }
  function fullDiff(maxWidth, curWidth) {
    return maxWidth - curWidth;
  }
  return ansiAlign_1;
}
var termSize, hasRequiredTermSize;
function requireTermSize() {
  if (hasRequiredTermSize) return termSize;
  hasRequiredTermSize = 1;
  const { execFileSync } = require$$1__default$2.default, path2 = require$$0__default.default, exec = (command2, arguments_, shell) => execFileSync(command2, arguments_, { encoding: "utf8", shell }).trim(), create = (columns, rows) => ({
    columns: parseInt(columns, 10),
    rows: parseInt(rows, 10)
  });
  return termSize = () => {
    const { env, stdout, stderr } = process;
    if (stdout && stdout.columns && stdout.rows)
      return create(stdout.columns, stdout.rows);
    if (stderr && stderr.columns && stderr.rows)
      return create(stderr.columns, stderr.rows);
    if (env.COLUMNS && env.LINES)
      return create(env.COLUMNS, env.LINES);
    if (process.platform === "win32")
      try {
        const size = exec(path2.join(__dirname, "vendor/windows/term-size.exe")).split(/\r?\n/);
        if (size.length === 2)
          return create(size[0], size[1]);
      } catch {
      }
    else {
      if (process.platform === "darwin")
        try {
          const size = exec(path2.join(__dirname, "vendor/macos/term-size"), [], !0).split(/\r?\n/);
          if (size.length === 2)
            return create(size[0], size[1]);
        } catch {
        }
      try {
        const size = exec("resize", ["-u"]).match(/\d+/g);
        if (size.length === 2)
          return create(size[0], size[1]);
      } catch {
      }
      if (process.env.TERM)
        try {
          const columns = exec("tput", ["cols"]), rows = exec("tput", ["lines"]);
          if (columns && rows)
            return create(columns, rows);
        } catch {
        }
    }
    return create(80, 24);
  }, termSize;
}
var hasRequiredBoxen;
function requireBoxen() {
  if (hasRequiredBoxen) return boxen$1.exports;
  hasRequiredBoxen = 1;
  const stringWidth2 = requireStringWidth(), chalk2 = chalk__default.default, widestLine2 = requireWidestLine(), cliBoxes2 = requireCliBoxes(), camelCase = requireCamelcase(), ansiAlign = requireAnsiAlign(), termSize2 = requireTermSize(), getObject = (detail) => {
    let object;
    return typeof detail == "number" ? object = {
      top: detail,
      right: detail * 3,
      bottom: detail,
      left: detail * 3
    } : object = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...detail
    }, object;
  }, getBorderChars = (borderStyle) => {
    const sides = [
      "topLeft",
      "topRight",
      "bottomRight",
      "bottomLeft",
      "vertical",
      "horizontal"
    ];
    let chararacters;
    if (typeof borderStyle == "string") {
      if (chararacters = cliBoxes2[borderStyle], !chararacters)
        throw new TypeError(`Invalid border style: ${borderStyle}`);
    } else {
      for (const side of sides)
        if (!borderStyle[side] || typeof borderStyle[side] != "string")
          throw new TypeError(`Invalid border style: ${side}`);
      chararacters = borderStyle;
    }
    return chararacters;
  }, isHex = (color) => color.match(/^#[0-f]{3}(?:[0-f]{3})?$/i), isColorValid = (color) => typeof color == "string" && (chalk2[color] || isHex(color)), getColorFn = (color) => isHex(color) ? chalk2.hex(color) : chalk2[color], getBGColorFn = (color) => isHex(color) ? chalk2.bgHex(color) : chalk2[camelCase(["bg", color])];
  return boxen$1.exports = (text, options2) => {
    if (options2 = {
      padding: 0,
      borderStyle: "single",
      dimBorder: !1,
      align: "left",
      float: "left",
      ...options2
    }, options2.borderColor && !isColorValid(options2.borderColor))
      throw new Error(`${options2.borderColor} is not a valid borderColor`);
    if (options2.backgroundColor && !isColorValid(options2.backgroundColor))
      throw new Error(`${options2.backgroundColor} is not a valid backgroundColor`);
    const chars = getBorderChars(options2.borderStyle), padding = getObject(options2.padding), margin = getObject(options2.margin), colorizeBorder = (border) => {
      const newBorder = options2.borderColor ? getColorFn(options2.borderColor)(border) : border;
      return options2.dimBorder ? chalk2.dim(newBorder) : newBorder;
    }, colorizeContent = (content) => options2.backgroundColor ? getBGColorFn(options2.backgroundColor)(content) : content;
    text = ansiAlign(text, { align: options2.align });
    const NL = `
`, PAD = " ";
    let lines2 = text.split(NL);
    padding.top > 0 && (lines2 = new Array(padding.top).fill("").concat(lines2)), padding.bottom > 0 && (lines2 = lines2.concat(new Array(padding.bottom).fill("")));
    const contentWidth = widestLine2(text) + padding.left + padding.right, paddingLeft = PAD.repeat(padding.left), { columns } = termSize2();
    let marginLeft = PAD.repeat(margin.left);
    if (options2.float === "center") {
      const padWidth = Math.max((columns - contentWidth) / 2, 0);
      marginLeft = PAD.repeat(padWidth);
    } else if (options2.float === "right") {
      const padWidth = Math.max(columns - contentWidth - margin.right - 2, 0);
      marginLeft = PAD.repeat(padWidth);
    }
    const horizontal = chars.horizontal.repeat(contentWidth), top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + horizontal + chars.topRight), bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom)), side = colorizeBorder(chars.vertical), middle = lines2.map((line3) => {
      const paddingRight = PAD.repeat(contentWidth - stringWidth2(line3) - padding.left);
      return marginLeft + side + colorizeContent(paddingLeft + line3 + paddingRight) + side;
    }).join(NL);
    return top + NL + middle + NL + bottom;
  }, boxen$1.exports._borderStyles = cliBoxes2, boxen$1.exports;
}
var boxenExports = requireBoxen(), boxen = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(boxenExports);
const TELEMETRY_DISCLOSED_CONFIG_KEY = "telemetryDisclosed";
function telemetryDisclosure() {
  const userConfig = getUserConfig();
  if (isCi) {
    loadEnv.debug("CI environment detected, skipping telemetry disclosure");
    return;
  }
  if (userConfig.get(TELEMETRY_DISCLOSED_CONFIG_KEY)) {
    loadEnv.debug("Telemetry disclosure has already been shown");
    return;
  }
  console.error(
    boxen(
      `The Sanity CLI now collects telemetry data on general usage and errors.
This helps us improve Sanity and prioritize features.

To opt in/out, run ${chalk__default.default.cyan("npx sanity telemetry enable/disable")}.

${telemetryLearnMoreMessage("unset")}`,
      {
        padding: 1,
        margin: 1,
        borderColor: "yellow",
        // Typescript issues forcing these to any
        borderStyle: "round"
      }
    )
  ), userConfig.set(TELEMETRY_DISCLOSED_CONFIG_KEY, Date.now());
}
var pTimeout$1 = { exports: {} }, hasRequiredPTimeout;
function requirePTimeout() {
  if (hasRequiredPTimeout) return pTimeout$1.exports;
  hasRequiredPTimeout = 1;
  class TimeoutError2 extends Error {
    constructor(message) {
      super(message), this.name = "TimeoutError";
    }
  }
  const pTimeout2 = (promise2, milliseconds, fallback, options2) => {
    let timer2;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds != "number" || milliseconds < 0)
        throw new TypeError("Expected `milliseconds` to be a positive number");
      if (milliseconds === 1 / 0) {
        resolve(promise2);
        return;
      }
      options2 = {
        customTimers: { setTimeout, clearTimeout },
        ...options2
      }, timer2 = options2.customTimers.setTimeout.call(void 0, () => {
        if (typeof fallback == "function") {
          try {
            resolve(fallback());
          } catch (error2) {
            reject(error2);
          }
          return;
        }
        const message = typeof fallback == "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`, timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message);
        typeof promise2.cancel == "function" && promise2.cancel(), reject(timeoutError);
      }, milliseconds), (async () => {
        try {
          resolve(await promise2);
        } catch (error2) {
          reject(error2);
        } finally {
          options2.customTimers.clearTimeout.call(void 0, timer2);
        }
      })();
    });
    return cancelablePromise.clear = () => {
      clearTimeout(timer2), timer2 = void 0;
    }, cancelablePromise;
  };
  return pTimeout$1.exports = pTimeout2, pTimeout$1.exports.default = pTimeout2, pTimeout$1.exports.TimeoutError = TimeoutError2, pTimeout$1.exports;
}
var pTimeoutExports = requirePTimeout(), pTimeout = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(pTimeoutExports);
const MAX_BLOCKING_TIME = 300, TWELVE_HOURS = 1e3 * 60 * 60 * 12, isDisabled = isCi || // Running in CI environment
process.env.NO_UPDATE_NOTIFIER;
function runUpdateCheck(options2) {
  loadEnv.debug("CLI installed at %s", __dirname);
  const { pkg, cwd, workDir } = options2, { name, version: version2 } = pkg, userConfig = getUserConfig(), check = getLatestRemote().catch(() => !1);
  let hasPrintedResult = !1;
  return { notify };
  async function notify() {
    if (!process.stdout.isTTY)
      return;
    const result = await pTimeout(check, MAX_BLOCKING_TIME, printCachedResult);
    if (hasPrintedResult) {
      loadEnv.debug("Has already printed result through timeout check, skipping result notification");
      return;
    }
    printResult2(result);
  }
  async function printCachedResult() {
    loadEnv.debug("Max time (%dms) reached waiting for latest version info", MAX_BLOCKING_TIME), hasPrintedResult = !0;
    const cached = userConfig.get("cliHasUpdate");
    return cached ? semverCompare(cached, version2) <= 0 ? (loadEnv.debug("CLI was upgraded since last check, falling back"), userConfig.delete("cliHasUpdate"), !1) : (loadEnv.debug("Printing cached latest version result"), await printResult2(cached), !1) : (loadEnv.debug("No cached latest version result found"), !1);
  }
  async function printResult2(newVersion) {
    hasPrintedResult = !0;
    const lastUpdated = userConfig.get("cliLastUpdateNag") || 0;
    if (Date.now() - lastUpdated < TWELVE_HOURS) {
      loadEnv.debug("Less than 12 hours since last nag, skipping");
      return;
    }
    if (!newVersion || semverCompare(newVersion, version2) <= 0) {
      loadEnv.debug(`New version is ${newVersion || "unknown"}, current is ${version2}. Falling back.`);
      return;
    }
    const upgradeCommand = await getCliUpgradeCommand({ cwd, workDir }), message = [
      "Update available ",
      chalk__default.default.dim(version2),
      chalk__default.default.reset(" \u2192 "),
      chalk__default.default.green(newVersion),
      ` 
Run `,
      chalk__default.default.cyan(upgradeCommand),
      " to update"
    ].join("");
    console.error(`
${boxen(message, {
      padding: 1,
      margin: 1,
      borderColor: "yellow",
      // Typescript issues forcing these to any
      align: "center",
      borderStyle: "round"
    })}`), userConfig.set("cliLastUpdateNag", Date.now());
  }
  async function getLatestRemote() {
    if (isDisabled)
      return loadEnv.debug("Running on CI, or explicitly disabled, skipping update check"), !1;
    const lastUpdated = userConfig.get("cliLastUpdateCheck") || 0;
    if (Date.now() - lastUpdated < TWELVE_HOURS)
      return loadEnv.debug("Less than 12 hours since last check, skipping update check"), userConfig.get("cliHasUpdate") || !1;
    let latestRemote;
    try {
      loadEnv.debug("Checking for latest remote version"), latestRemote = await latestVersion(name), loadEnv.debug("Latest remote version is %s", latestRemote);
    } catch (err) {
      return loadEnv.debug(`Failed to fetch latest version of ${name} from npm:
${err.stack}`), !1;
    }
    if (!latestRemote)
      return loadEnv.debug(`Failed to fetch latest version of ${name} from npm`), !1;
    userConfig.set("cliLastUpdateCheck", Date.now());
    const diff = semverCompare(latestRemote, version2);
    return diff <= 0 ? (loadEnv.debug(diff === 0 ? "No update found" : "Remote version older than local"), userConfig.delete("cliHasUpdate"), !1) : (userConfig.set("cliHasUpdate", latestRemote), loadEnv.debug("Update is available (%s)", latestRemote), latestRemote);
  }
}
const sanityEnv = process.env.SANITY_INTERNAL_ENV || "production", knownEnvs = ["development", "staging", "production"];
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function installProcessExitHack(finalTask) {
  const originalProcessExit = process.exit;
  process.exit = (exitCode) => {
    finalTask().finally(() => originalProcessExit(exitCode));
  };
}
async function runCli(cliRoot, { cliVersion }) {
  installUnhandledRejectionsHandler();
  const pkg = { name: "@sanity/cli", version: cliVersion }, args = parseArguments(), isInit = args.groupOrCommand === "init" && args.argsWithoutOptions[0] !== "plugin", cwd = getCurrentWorkingDirectory();
  let workDir;
  try {
    workDir = isInit ? process.cwd() : loadEnv.resolveRootDir(cwd);
  } catch (err) {
    console.error(chalk__default.default.red(err.message)), process.exit(1);
  }
  loadAndSetEnvFromDotEnvFiles({ workDir, cmd: args.groupOrCommand }), maybeFixMissingWindowsEnvVar(), await runUpdateCheck({ pkg, cwd, workDir }).notify(), telemetryDisclosure(), loadEnv.debug(`Reading CLI config from "${workDir}"`);
  const cliConfig = await getCliConfig.getCliConfig(workDir, { forked: !0 });
  cliConfig || loadEnv.debug("No CLI config found");
  const { logger: telemetry2, flush: flushTelemetry } = createTelemetryStore({
    projectId: cliConfig?.config?.api?.projectId,
    env: process.env
  });
  installProcessExitHack(
    () => (
      // When process.exit() is called, flush telemetry events first, but wait no more than x amount of ms before exiting process
      Promise.race([wait(2e3), flushTelemetry()])
    )
  ), telemetry2.updateUserProperties({
    runtimeVersion: process.version,
    runtime: detectRuntime(),
    cliVersion: pkg.version,
    machinePlatform: process.platform,
    cpuArchitecture: process.arch,
    projectId: cliConfig?.config?.api?.projectId,
    dataset: cliConfig?.config?.api?.dataset
  });
  const options2 = {
    cliRoot,
    workDir,
    corePath: await getCoreModulePath(workDir, cliConfig),
    cliConfig,
    telemetry: telemetry2
  };
  warnOnNonProductionEnvironment(), warnOnInferredProjectDir(isInit, cwd, workDir);
  const core2 = args.coreOptions, commands = await mergeCommands(baseCommands, options2.corePath, { cliVersion, cwd, workDir });
  (core2.v || core2.version) && (console.log(`${pkg.name} version ${pkg.version}`), process.exit()), (core2.h || core2.help) && (args.groupOrCommand && args.argsWithoutOptions.unshift(args.groupOrCommand), args.groupOrCommand = "help"), args.groupOrCommand === "logout" && await flushTelemetry();
  const cliRunner = getCliRunner(commands), cliCommandTrace = telemetry2.trace(CliCommand, {
    groupOrCommand: args.groupOrCommand,
    extraArguments: args.extraArguments,
    commandArguments: args.argsWithoutOptions.slice(0, 10),
    coreOptions: {
      help: args.coreOptions.help || void 0,
      version: args.coreOptions.help || void 0,
      debug: args.coreOptions.help || void 0
    },
    ...!args.groupOrCommand && { emptyCommand: !0 }
    // user did not entry a command
  });
  cliCommandTrace.start(), cliRunner.runCommand(args.groupOrCommand, args, {
    ...options2,
    telemetry: cliCommandTrace.newContext(args.groupOrCommand)
  }).then(() => cliCommandTrace.complete()).catch(async (err) => {
    await flushTelemetry();
    const error2 = typeof err.details == "string" ? err.details : err;
    console.error(`
${error2.stack ? neatStack(err) : error2}`), cliCommandTrace.error(error2), process.exit(1);
  });
}
async function getCoreModulePath(workDir, cliConfig) {
  const corePath = resolveFrom.silent(workDir, "@sanity/core"), sanityPath = resolveFrom.silent(workDir, "sanity/_internal");
  if (corePath && sanityPath) {
    const closest = corePath.startsWith(workDir) ? corePath : sanityPath, assumedVersion = closest === corePath ? "v2" : "v3";
    return console.warn(
      chalk__default.default.yellow(
        `Both \`@sanity/core\` AND \`sanity\` installed - assuming Sanity ${assumedVersion} project.`
      )
    ), closest;
  }
  if (sanityPath)
    return sanityPath;
  if (corePath && cliConfig && cliConfig?.version < 3)
    return corePath;
  const isInstallCommand = process.argv.indexOf("install") === -1;
  if (cliConfig && cliConfig?.version < 3 && !corePath && !isInstallCommand) {
    const installCmd = await getInstallCommand({ workDir });
    console.warn(
      chalk__default.default.yellow(
        [
          "The `@sanity/core` module is not installed in current project",
          `Project-specific commands not available until you run \`${installCmd}\``
        ].join(`
`)
      )
    );
  }
  if (cliConfig && cliConfig.version >= 3 && !sanityPath) {
    const installCmd = await getInstallCommand({ workDir });
    console.warn(
      chalk__default.default.yellow(
        [
          "The `sanity` module is not installed in current project",
          `Project-specific commands not available until you run \`${installCmd}\``
        ].join(`
`)
      )
    );
  }
}
function getCurrentWorkingDirectory() {
  let pwd;
  try {
    pwd = process.cwd();
  } catch (err) {
    if (err.code === "ENOENT")
      console.error("[ERR] Could not resolve working directory, does the current folder exist?"), process.exit(1);
    else
      throw err;
  }
  return pwd;
}
function installUnhandledRejectionsHandler() {
  process.on("unhandledRejection", (reason) => {
    rejectionHasStack(reason) ? console.error("Unhandled rejection:", reason.stack) : console.error(`Unhandled rejection
`, reason);
  });
}
function rejectionHasStack(reason) {
  return !!(reason && typeof reason == "object" && "stack" in reason && typeof reason.stack == "string");
}
function warnOnInferredProjectDir(isInit, cwd, workDir) {
  isInit || cwd === workDir || console.log(`Not in project directory, assuming context of project at ${workDir}`);
}
function warnOnNonProductionEnvironment() {
  sanityEnv !== "production" && console.warn(
    chalk__default.default.yellow(
      knownEnvs.includes(sanityEnv) ? `[WARN] Running in ${sanityEnv} environment mode
` : `[WARN] Running in ${chalk__default.default.red("UNKNOWN")} "${sanityEnv}" environment mode
`
    )
  );
}
function loadAndSetEnvFromDotEnvFiles({ workDir, cmd }) {
  if (fs$1.existsSync(path__default.default.join(workDir, "sanity.json"))) {
    loadEnv.debug("sanity.json exists, assuming v2 project and loading .env files using old behavior");
    const env = process.env.SANITY_ACTIVE_ENV || process.env.NODE_ENV || "development";
    loadEnv.debug("Loading environment files using %s mode", env), loadEnv.dotenv.config({ path: path__default.default.join(workDir, `.env.${env}`) });
    return;
  }
  loadEnv.debug("No sanity.json exists, assuming v3 project and loading .env files using new behavior");
  const isProdCmd = ["build", "deploy"].includes(cmd);
  let mode2 = process.env.SANITY_ACTIVE_ENV;
  !mode2 && (isProdCmd || process.env.NODE_ENV === "production") ? mode2 = "production" : mode2 || (mode2 = "development"), mode2 === "production" && !isProdCmd && console.warn(chalk__default.default.yellow(`[WARN] Running in ${sanityEnv} environment mode
`)), loadEnv.debug("Loading environment files using %s mode", mode2);
  const studioEnv = loadEnv.loadEnv(mode2, workDir, ["SANITY_STUDIO_"]);
  process.env = { ...process.env, ...studioEnv };
}
function maybeFixMissingWindowsEnvVar() {
  os__default.default.platform() === "win32" && !("SYSTEMROOT" in process.env) && "SystemRoot" in process.env && (process.env.SYSTEMROOT = process.env.SystemRoot);
}
exports.getCliVersion = getCliVersion;
exports.runCli = runCli;
//# sourceMappingURL=cli.js.map
